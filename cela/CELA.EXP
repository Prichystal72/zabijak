

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_AxisJobCtrl_Cam_Gear
VAR_INPUT
	r_getriebefaktor						: LREAL;
	r_master_position					: LREAL;
	mc_activation_mode_camin			: MC_CamActivationMode;
	lr_activation_position_camin			: LREAL := 0.0;
	mc_activation_mode_scaleing		: MC_CamActivationMode;
	lr_activation_position_scaleing		: LREAL := 0.0;
	mc_buffermode_axis					: MC_BufferMode;     (*	MC_Aborting,	->sofortiger Abbruch der momentanen Bewegung, bei einem neuen Verfahrbefehl
														MC_Buffered,
														MC_BlendingLow,
														MC_BlendingPrevious,
														MC_BlendingNext,
														MC_BlendingHigh *)
	mc_cam_point_id						: MC_MotionFunctionPoint_ID; (* MC_MotionFunctionPoint_ID : UDINT; *)
	mc_motion_function_point				: MC_MotionFunctionPoint;	(*TYPE MC_MotionFunctionPoint :
																	STRUCT
																	    PointIndex        : MC_MotionFunctionPoint_ID;
																	    FunctionType      : MC_MotionFunctionType;
																	    PointType         : MC_MotionPointType;
																	    RelIndexNextPoint : MC_MotionFunctionPoint_ID;
																	    MasterPos         : LREAL; (* X *)
																	    SlavePos          : LREAL; (* Y *)
																	    SlaveVelo         : LREAL; (* Y' *)
																	    SlaveAcc          : LREAL; (* Y'' *)
																	    SlaveJerk         : LREAL; (* Y''' *)
																	END_STRUCT
																END_TYPE*)
	st_camin_options						: ST_CamInOptions_V2;
	st_camexchange_options				: ST_CamExchangeOptions ;
	mc_cam_table_id					 	: MC_CAM_ID;	(* MC_CAM_ID : UDINT; *)
	mc_reference_cam_table_id				: MC_CAM_ID;	(* MC_CAM_ID : UDINT; *)
	st_camscaling_data						: ST_CamScalingData;	(*STRUCT
																	(* scaling of the X axis of the cam (master scaling) *)
																	MasterScalingMode 	: MC_CamScalingMode;
																	MasterRelative 	: BOOL;
																	MasterOffset 	: LREAL; (* E *)
																	MasterScaling 	: LREAL := 1.0; (* E *)
																
																	(* scaling of the Y axis of the cam (slave scaling) *)
																	SlaveScalingMode 	: MC_CamScalingMode;
																	SlaveRelative 	: BOOL;
																	SlaveOffset 	: LREAL; (* E *)
																	SlaveScaling 	: LREAL := 1.0; (* E *)
																	END_STRUCT*)
END_VAR
VAR_IN_OUT
	st_masterachse						: AXIS_REF;
	st_slaveachse 						: AXIS_REF;
	st_ecd_cmd							: struct_ecd_cmd;
END_VAR
VAR
	fb_ton_cmd_timeout					: TON;
	fb_ton_vz							: TON;
	mc_gearindyn_axis 					: MC_GearInDyn;
	mc_gearout_axis						: MC_GearOut;
	mc_camin_axis						: MC_CamIn_V2;
	mc_camout_axis						: MC_CamOut;
	mc_cam_scaleing						: MC_CamScaling_V2;
	mc_read_motion_function_point			: MC_ReadMotionFunctionPoint;
	mc_write_motion_function_point			: MC_WriteMotionFunctionPoint;
	mc_read_camtable_slave_dynamics		: MC_ReadCamTableSlaveDynamics;
	st_cam_table_characteristics			: MC_TableCharacValues;
	mc_read_camtable_characteristics		: MC_ReadCamTableCharacteristics;
	err_id								: DWORD := 0;
	fb_state_entry							: ST_StateEntry;
	fb_cmd_history						: ST_CommandHistory;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_cmd_timeout(IN:= , PT:= t#5s, Q=> , ET=> );
fb_ton_vz(IN:= , PT:= , Q=> , ET=> );

(* ======================================Schrittkette Drivebefehle======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:	(* *)
		st_ecd_cmd.enu_cmd := NO_COMMAND;
		st_ecd_cmd.b_job_fehler := FALSE;
		mc_gearindyn_axis.Enable := FALSE;
		mc_gearout_axis.Execute := FALSE;
		mc_camin_axis.Execute := FALSE;
		mc_camout_axis.Execute := FALSE;
		mc_cam_scaleing.Execute := FALSE;
		mc_read_motion_function_point.Execute := FALSE;
		mc_write_motion_function_point.Execute := FALSE;
		mc_read_camtable_slave_dynamics.Execute := FALSE;
		mc_read_camtable_characteristics.Execute := FALSE;
		st_ecd_cmd.meldungen.sm_gear_in_slave := FALSE;
		st_ecd_cmd.meldungen.sm_gear_out_slave := FALSE;
		st_ecd_cmd.meldungen.sm_cam_in_slave := FALSE;
		st_ecd_cmd.meldungen.sm_cam_out_slave := FALSE;
		st_ecd_cmd.meldungen.sm_cam_scaleing_slave := FALSE;
		st_ecd_cmd.meldungen.sm_write_motion_funktion_point := FALSE;
		st_ecd_cmd.meldungen.sm_read_motion_funktion_point := FALSE;
		st_ecd_cmd.meldungen.sm_read_camtable_slave_dynamics := FALSE;
		st_ecd_cmd.meldungen.sm_read_camtable_charakteristik := FALSE;
		st_ecd_cmd.meldungen.sm_camgear_command_timeout := FALSE;

		fb_ton_cmd_timeout.IN := FALSE;
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte auf Kommando *)
		IF fb_state_entry.E THEN
			st_ecd_cmd.b_job_fehler := FALSE;
			st_ecd_cmd.enu_cmd := NO_COMMAND;
		END_IF

		IF st_ecd_cmd.enu_cmd > NO_COMMAND THEN
			(* Diese Kommandos werden mit Direktsprung ausgeführt, um Zykluszeit zu sparen *)
			IF st_ecd_cmd.enu_cmd = GEAR_IN_SLAVE THEN
				fb_state_entry.i16_next_step := 20;
			ELSIF st_ecd_cmd.enu_cmd = GEAR_OUT_SLAVE THEN
				fb_state_entry.i16_next_step := 30;
			ELSIF st_ecd_cmd.enu_cmd = CAM_IN_SLAVE THEN
				fb_state_entry.i16_next_step := 40;
			ELSIF st_ecd_cmd.enu_cmd = CAM_OUT_SLAVE THEN
				fb_state_entry.i16_next_step := 50;
			ELSIF st_ecd_cmd.enu_cmd = CAM_SCALEING_SLAVE THEN
				fb_state_entry.i16_next_step := 60;
			ELSIF st_ecd_cmd.enu_cmd = READ_MOTION_POINT THEN
				fb_state_entry.i16_next_step := 70;
			ELSIF st_ecd_cmd.enu_cmd = WRITE_MOTION_POINT THEN
				fb_state_entry.i16_next_step := 80;
			ELSIF st_ecd_cmd.enu_cmd = READ_SLAVE_DYNAMICS THEN
				fb_state_entry.i16_next_step := 90;
			ELSIF st_ecd_cmd.enu_cmd = READ_CAMTABLE_CHAR THEN
				fb_state_entry.i16_next_step := 100;
			ELSIF st_ecd_cmd.enu_cmd = RESET THEN
				fb_state_entry.i16_next_step := 999;
			ELSE
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	20:	(* Gear in *)
		fb_ton_cmd_timeout.IN := TRUE;
		mc_gearindyn_axis.Enable := TRUE;
		IF mc_gearindyn_axis.Busy THEN
			fb_state_entry.i16_next_step := 22;
		END_IF

	22:
		IF mc_gearindyn_axis.InGear THEN
			mc_gearindyn_axis.Enable := FALSE;
			fb_state_entry.i16_next_step := 999;
		ELSIF mc_gearindyn_axis.Error THEN
			st_ecd_cmd.meldungen.sm_gear_in_slave := TRUE;
			err_id := mc_gearindyn_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF

		IF st_ecd_cmd.enu_cmd = GEAR_OUT_SLAVE THEN
			mc_gearindyn_axis.Enable := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_ton_vz.IN := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	30:	(* Gear out *)
		fb_ton_cmd_timeout.IN := TRUE;
		mc_gearout_axis.Execute := TRUE;
		IF mc_gearout_axis.Busy THEN
			fb_state_entry.i16_next_step := 32;
		END_IF
	32:
		IF NOT mc_gearout_axis.Busy THEN
			mc_gearout_axis.Execute := FALSE;
			IF mc_gearout_axis.Done THEN
				fb_state_entry.i16_next_step := 999;
			ELSIF mc_gearout_axis.Error THEN
				st_ecd_cmd.meldungen.sm_gear_out_slave := TRUE;
				err_id := mc_gearout_axis.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	40:	(* Cam in *)
		fb_ton_cmd_timeout.IN := NOT st_slaveachse.Status.CamTableQueued;
		mc_camin_axis.Execute := TRUE;
		IF mc_camin_axis.Busy THEN
			fb_state_entry.i16_next_step := 42;
		END_IF
		IF st_ecd_cmd.enu_cmd = CAM_OUT_SLAVE THEN
			mc_camin_axis.Execute := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF
	42:
		fb_ton_cmd_timeout.IN := NOT st_slaveachse.Status.CamTableQueued;
		IF NOT mc_camin_axis.Busy THEN
			mc_camin_axis.Execute := FALSE;
			IF mc_camin_axis.InSync THEN
				fb_state_entry.i16_next_step := 999;
			ELSIF mc_camin_axis.Error THEN
				err_id := mc_camin_axis.ErrorID;
				mc_camin_axis.Execute := FALSE;
				st_ecd_cmd.meldungen.sm_cam_in_slave := TRUE;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

		IF st_ecd_cmd.enu_cmd = CAM_OUT_SLAVE THEN
			mc_camin_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_ton_vz.IN := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:	(* Cam out *)
		fb_ton_cmd_timeout.IN := TRUE;
		mc_camout_axis.Execute := TRUE;
		IF mc_camout_axis.Busy THEN
			fb_state_entry.i16_next_step := 52;
		END_IF
	52:
		IF NOT mc_camout_axis.Busy THEN
			mc_camout_axis.Execute := FALSE;
			IF mc_camout_axis.Done THEN
				fb_state_entry.i16_next_step := 999;
			ELSIF mc_camout_axis.Error THEN
				st_ecd_cmd.meldungen.sm_cam_out_slave := TRUE;
				err_id := mc_camout_axis.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	60:	(* Cam scaleing *)
		fb_ton_cmd_timeout.IN := NOT st_slaveachse.Status.CamScalingPending;
		mc_cam_scaleing.Execute := TRUE;
		IF mc_cam_scaleing.Busy THEN
			fb_state_entry.i16_next_step := 62;
		END_IF
	62:
		fb_ton_cmd_timeout.IN := NOT st_slaveachse.Status.CamScalingPending;
		IF NOT mc_cam_scaleing.Busy THEN
			mc_cam_scaleing.Execute := FALSE;
			IF mc_cam_scaleing.Done THEN
				fb_state_entry.i16_next_step := 999;
			ELSIF mc_cam_scaleing.Error THEN
				st_ecd_cmd.meldungen.sm_cam_scaleing_slave := TRUE;
				err_id := mc_cam_scaleing.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

		IF st_ecd_cmd.enu_cmd = CAM_OUT_SLAVE THEN
			mc_cam_scaleing.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_ton_vz.IN := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	70:	(* Lesen Motion Funktion Point *)
		fb_ton_cmd_timeout.IN := TRUE;
		mc_read_motion_function_point.Execute := TRUE;
		IF mc_read_motion_function_point.Busy THEN
			fb_state_entry.i16_next_step := 72;
		END_IF
	72:
		IF NOT mc_read_motion_function_point.Busy THEN
			mc_read_motion_function_point.Execute := FALSE;
			IF mc_read_motion_function_point.Done THEN
				fb_state_entry.i16_next_step := 999;
			ELSIF mc_read_motion_function_point.Error THEN
				st_ecd_cmd.meldungen.sm_read_motion_funktion_point := TRUE;
				err_id := mc_read_motion_function_point.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	80:	(* Schreiben Motion Funktion Point *)
		fb_ton_cmd_timeout.IN := TRUE;
		mc_write_motion_function_point.Execute := TRUE;
		IF mc_write_motion_function_point.Busy THEN
			fb_state_entry.i16_next_step := 82;
		END_IF
	82:
		IF NOT mc_write_motion_function_point.Busy THEN
			mc_write_motion_function_point.Execute := FALSE;
			IF mc_write_motion_function_point.Done THEN
				fb_state_entry.i16_next_step := 999;
			ELSIF mc_write_motion_function_point.Error THEN
				st_ecd_cmd.meldungen.sm_write_motion_funktion_point := TRUE;
				err_id := mc_write_motion_function_point.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	90:	(* Lesen der Slaveposition in einer Kurvenscheibe *)
		fb_ton_cmd_timeout.IN := TRUE;
		mc_read_camtable_slave_dynamics.Execute := TRUE;
		IF mc_read_camtable_slave_dynamics.Busy THEN
			fb_state_entry.i16_next_step := 92;
		END_IF
	92:
		IF NOT mc_read_camtable_slave_dynamics.Busy THEN
			mc_read_camtable_slave_dynamics.Execute := FALSE;
			IF mc_read_camtable_slave_dynamics.Done THEN
				fb_state_entry.i16_next_step := 999;
			ELSIF mc_read_camtable_slave_dynamics.Error THEN
				st_ecd_cmd.meldungen.sm_write_motion_funktion_point := TRUE;
				err_id := mc_read_camtable_slave_dynamics.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	100:	(* Lesen der charakteristischen Werte einer Kurvenscheibe *)
		fb_ton_cmd_timeout.IN := TRUE;
		mc_read_camtable_characteristics.Execute := TRUE;
		IF mc_read_camtable_characteristics.Busy THEN
			fb_state_entry.i16_next_step := 102;
		END_IF
	102:
		IF NOT mc_read_camtable_characteristics.Busy THEN
			mc_read_camtable_characteristics.Execute := FALSE;
			IF mc_read_camtable_characteristics.Done THEN
				fb_state_entry.i16_next_step := 999;
			ELSIF mc_read_camtable_characteristics.Error THEN
				st_ecd_cmd.meldungen.sm_read_camtable_charakteristik := TRUE;
				err_id := mc_read_camtable_slave_dynamics.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	999:	(* Ende - Befehl wurde korrekt abgearbeitet *)
		fb_ton_cmd_timeout.IN := FALSE;
		fb_ton_vz.IN := FALSE;

		mc_gearindyn_axis.Enable := FALSE;
		mc_gearout_axis.Execute := FALSE;
		mc_camin_axis.Execute := FALSE;
		mc_camout_axis.Execute := FALSE;
		mc_cam_scaleing.Execute := FALSE;
		mc_read_motion_function_point.Execute := FALSE;
		mc_write_motion_function_point.Execute := FALSE;
		mc_read_camtable_slave_dynamics.Execute := FALSE;
		mc_read_camtable_characteristics.Execute := FALSE;

		st_ecd_cmd.meldungen.sm_gear_in_slave := FALSE;
		st_ecd_cmd.meldungen.sm_gear_out_slave := FALSE;
		st_ecd_cmd.meldungen.sm_cam_in_slave := FALSE;
		st_ecd_cmd.meldungen.sm_cam_out_slave := FALSE;
		st_ecd_cmd.meldungen.sm_cam_scaleing_slave := FALSE;
		st_ecd_cmd.meldungen.sm_write_motion_funktion_point := FALSE;
		st_ecd_cmd.meldungen.sm_read_motion_funktion_point := FALSE;
		st_ecd_cmd.meldungen.sm_read_camtable_slave_dynamics := FALSE;
		st_ecd_cmd.meldungen.sm_read_camtable_charakteristik := FALSE;
		st_ecd_cmd.meldungen.sm_camgear_command_timeout := FALSE;

		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			st_ecd_cmd.enu_cmd := NO_COMMAND;
			st_ecd_cmd.b_job_fehler := TRUE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_ton_vz.IN := FALSE;

			mc_gearindyn_axis.Enable := FALSE;
			mc_gearout_axis.Execute := FALSE;
			mc_camin_axis.Execute := FALSE;
			mc_camout_axis.Execute := FALSE;
			mc_cam_scaleing.Execute := FALSE;
			mc_read_motion_function_point.Execute := FALSE;
			mc_write_motion_function_point.Execute := FALSE;
			mc_read_camtable_slave_dynamics.Execute := FALSE;
			mc_read_camtable_characteristics.Execute := FALSE;
		END_IF

		(* Fehler reseten *)
		IF st_ecd_cmd.enu_cmd > ABORT THEN
			st_ecd_cmd.b_job_fehler := FALSE;

			st_ecd_cmd.meldungen.sm_gear_in_slave := FALSE;
			st_ecd_cmd.meldungen.sm_gear_out_slave := FALSE;
			st_ecd_cmd.meldungen.sm_cam_in_slave := FALSE;
			st_ecd_cmd.meldungen.sm_cam_out_slave := FALSE;
			st_ecd_cmd.meldungen.sm_cam_scaleing_slave := FALSE;
			st_ecd_cmd.meldungen.sm_write_motion_funktion_point := FALSE;
			st_ecd_cmd.meldungen.sm_read_motion_funktion_point := FALSE;
			st_ecd_cmd.meldungen.sm_read_camtable_slave_dynamics := FALSE;
			st_ecd_cmd.meldungen.sm_read_camtable_charakteristik := FALSE;
			st_ecd_cmd.meldungen.sm_camgear_command_timeout := FALSE;

			fb_state_entry.i16_next_step := 10;
			err_id :=0;
		END_IF
END_CASE

(* Timeout-Fehler aller Drivekommandos *)
IF fb_ton_cmd_timeout.Q THEN
	fb_ton_cmd_timeout.IN := FALSE;
	st_ecd_cmd.meldungen.sm_camgear_command_timeout := TRUE;
	fb_state_entry.i16_next_step := 1000;
END_IF

(* Statehistory *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

fb_cmd_history(i16_current_cmd:= st_ecd_cmd.enu_cmd, last_cmd=> );

(*=============================================================================================*)
(* Ab hier werden alle Cam und Gear Aufträge für eine Achse abgewickelt *)

(* Getriebegleichlauf an der Slaveachse einschalten *)
(* Alternativ kann der Getriebefaktor im Zähler als Fließkommawert angegeben werden, wenn der Nenner 1 ist. *)
mc_gearindyn_axis(
	Enable:= , 
	GearRatio:= r_getriebefaktor,
	Acceleration:= , 
	Deceleration:= , 
	Jerk:= , 
	BufferMode:= mc_buffermode_axis,
	Options:= , 
	Master:= st_masterachse,
	Slave:= st_slaveachse,
	InGear=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );

(*=============================================================================================*)
(* Getriebegleichlauf ausschalten *)
mc_gearout_axis(
	Execute:= ,
	Options:= ,
	Slave:= st_slaveachse,
	Done=> ,
	Busy=> ,
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* Kurvenscheibe am Slave aktivieren *)
mc_camin_axis(
	Execute:= , 
	ActivationMode:= mc_activation_mode_camin,
	ActivationPosition:= lr_activation_position_camin,
	CamTableID:= mc_cam_table_id,
	Scaling:= st_camscaling_data,
	Options:= st_camin_options,
	Master:= st_masterachse,
	Slave:= st_slaveachse,
	InSync=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* Kurvenscheibe ausschalten *)
mc_camout_axis(
	Execute:= ,
	Slave:= st_slaveachse,
	Options:= ,
	Done=> ,
	Busy=> ,
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* Scalierung einer Kurvenscheibe *)
mc_cam_scaleing(
	Execute:= , 
	ActivationMode:= mc_activation_mode_scaleing,
	ActivationPosition:= lr_activation_position_scaleing,
	CamTableID:= mc_cam_table_id,
	Scaling:= st_camscaling_data,
	Options:= ,
	Slave:= st_slaveachse,
	Done=> , 
	Busy=> ,
	Active=> , 
	CommandAborted=> ,
	Error=> , 
	ErrorID=> );

(*=============================================================================================*)
(* Lesen eines Punktes in der Kurvenscheibe *)
mc_read_motion_function_point(
	Execute:= ,
	CamTableID:= mc_cam_table_id,
	PointID:= mc_cam_point_id,
	Point:= mc_motion_function_point,
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );

(*=============================================================================================*)
(* Verändern von einem Punkt in der Kurvenscheibe *)
mc_write_motion_function_point(
	Execute:= , 
	CamTableID:= mc_cam_table_id,
	PointID:= mc_cam_point_id,
	Point:= mc_motion_function_point,
	Done=> , 
	Busy=> , 
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* Lesen einer Slaveposition in der Kurvenscheibe *)
mc_read_camtable_slave_dynamics(
	Execute:= ,
	CamTableID:= mc_cam_table_id,
	MasterPosition:= r_master_position,
	Done=> , 
	Busy=> ,
	Error=> , 
	ErrorID=> ,
	SlavePosition=> , 
	SlaveVelocity=> , 
	SlaveAcceleration=> );

(*=============================================================================================*)
(* Lesen der charakteristischen Werte einer Kurvenscheibe *)
mc_read_camtable_characteristics(
	Execute:= , 
	CamTableID:= mc_cam_table_id,
	CamTableCharac:= st_cam_table_characteristics,
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_AxisJobCtrl_Motion
VAR_INPUT
	e_referenznocken						: BOOL;
	b_refsensor_vorhanden				: BOOL;
	b_limitsensor_positiv_vorhanden		: BOOL;
	b_limitsensor_negativ_vorhanden		: BOOL;
	i16_achstyp							: enum_ecd_typ;
	lr_override_vorgabe					: LREAL;
	st_position							: struct_ecd_positionen;
	mc_richtung_modulo					: MC_Direction;
	mc_richtung_velocity					: MC_Direction;
											(*default: MC_Positive_Direction := 1,
											MC_Shortest_Way ,
									    		MC_Negative_Direction,
									    		MC_Current_Direction *)
	mc_referenzmodus 					: MC_HomingMode; (* default: MC_DefaultHoming   default homing as defined in the SystemManager encoder parameters *)
	mc_buffermode_axis					: MC_BufferMode;     (*	MC_Aborting,	->sofortiger Abbruch der momentanen Bewegung, bei einem neuen Verfahrbefehl
														MC_Buffered,
														MC_BlendingLow,
														MC_BlendingPrevious,
														MC_BlendingNext,
														MC_BlendingHigh *)
	ui16_soeparam_write_value				: UINT;
	w_idn								: WORD;
	i16_nc_parameter_nummer				: INT;
	r_wert_nc_write_parameter				: LREAL;
	st_vorgabe_geschwindigkeiten			: struct_ecd_geschwindigkeiten;
	lr_soll_geschwindigkeit					: LREAL;
	b_bedingung_sls						: BOOL;
	st_ads_info							: struct_ads_info;
	st_eccoe_sdo						: struct_eccoe_sdo;
	b_TriggerInput						: BOOL;
	b_FallingEdge						: BOOL;
END_VAR
VAR_OUTPUT
	ui16_soeparam_read_value			: UINT;
	r_wert_nc_read_parameter				: LREAL;
	lr_RecPos							: LREAL;
END_VAR
VAR_IN_OUT
	st_masterachse						: AXIS_REF;
	st_visu_axis							: struct_ecd_visu;
	st_ecd_cmd							: struct_ecd_cmd;
END_VAR
VAR
	fb_ton_cmd_timeout					: TON;
	t_cmd_timeout						: TIME;
	t_ads_timeout							: TIME;
	fb_ton_vz							: TON;
	b_jog_vorwaerts_execute				: BOOL := FALSE;
	b_jog_rueckwaerts_execute				: BOOL := FALSE;
	e_limit_sensor_positive				AT %I* : BOOL;
	e_limit_sensor_negative				AT %I* : BOOL;
	e_referenz_sensor						AT %I* : BOOL;
	fb_f_trig_limit_sensor_positiv			: F_TRIG;
	fb_f_trig_limit_sensor_negativ			: F_TRIG;
	fb_cmd_history						: ST_CommandHistory;

	mc_power_axis 						: MC_Power;
	mc_reset_axis						: MC_Reset;
	mc_home_axis 						: MC_Home;
	mc_setposition_axis					: MC_SetPosition;
	mc_jog_axis							: MC_Jog;
	mc_moveabsolute_axis 				: MC_MoveAbsolute;
	mc_moveabsolutenext_axis 			: MC_MoveAbsolute;
	mc_moverelative_axis 					: MC_MoveRelative;
	mc_movevelocity_axis 					: MC_MoveVelocity;
	mc_movemodulo_axis					: MC_MoveModulo;
	mc_stop_axis 						: MC_Stop;
	mc_halt_axis							: MC_Halt;
	mc_touch_probe					: MC_TouchProbe;
	mc_abort_trigger						: MC_AbortTrigger;
	TriggerInput							:TRIGGER_REF;
	err_id								: DWORD := 0;
	fb_state_entry							: ST_StateEntry;
	fb_soe_reset							: FB_SoEReset;
	fb_soe_write							: FB_SoEWrite;
	fb_soe_read							: FB_SoERead;
	fb_ec_coe_sdo_write_ex				: FB_EcCoESdoWriteEx;
	fb_ec_coe_sdo_read_ex				: FB_EcCoESdoReadEx;
	mc_write_nc_parameter				: MC_WriteParameter;
	mc_read_nc_parameter				: MC_ReadParameter;
	fb_ads_write							: ADSWRITE;
	fb_ads_read							: ADSREAD;
	lr_override							: LREAL := 0.0;
	lr_override_reduziert					: LREAL := 0.0;
	lr_reduktionsfaktor						: LREAL := 5.0;
	lr_hm_master_act_velo					: LREAL := 0.0;
	lr_sollgeschwindigkeit					: LREAL := 0.0;
END_VAR
(* @END_DECLARATION := '0' *)
sub_TouchProbe();
(* Zeiten *)
fb_ton_cmd_timeout(IN:= , PT:=t_cmd_timeout, Q=> , ET=> );
fb_ton_vz(IN:= , PT:= , Q=> , ET=> );

(* Flanken *)
fb_f_trig_limit_sensor_positiv(CLK:= e_limit_sensor_positive, Q=> );
fb_f_trig_limit_sensor_negativ(CLK:= e_limit_sensor_negative, Q=> );

(* =====Beschränkung des Overrides wegen SLS bei offenen Türen===== *)
IF b_bedingung_sls THEN
	IF i16_achstyp = RUND OR  i16_achstyp = RUND_VIRTUELL THEN
		lr_hm_master_act_velo := st_masterachse.NcToPlc.ActVelo * 60 / 360;
	ELSE
		lr_hm_master_act_velo := st_masterachse.NcToPlc.ActVelo;
	END_IF
	IF ABS(lr_hm_master_act_velo) < st_vorgabe_geschwindigkeiten.lr_jog THEN
		lr_override := lr_override_reduziert := lr_override_vorgabe;
	ELSE
		lr_override_reduziert := lr_override_reduziert - lr_reduktionsfaktor;
		IF lr_override_reduziert >= 0 OR lr_override_reduziert <= 100 THEN
			lr_override := lr_override_reduziert;
		END_IF
	END_IF
ELSE
	lr_override := lr_override_vorgabe;
END_IF

(* =====Beschränkung der Achsgeschwindigkeiten===== *)
(* Verrechnet nach Rund/Linear wird weiter unten *)
lr_sollgeschwindigkeit := lr_soll_geschwindigkeit;

(* Beschränkung der Geschwindigkeit *)
IF lr_sollgeschwindigkeit > st_vorgabe_geschwindigkeiten.lr_auto_max THEN
	lr_sollgeschwindigkeit := st_vorgabe_geschwindigkeiten.lr_auto_max;
ELSIF lr_sollgeschwindigkeit < st_vorgabe_geschwindigkeiten.lr_auto_min THEN
	lr_sollgeschwindigkeit := st_vorgabe_geschwindigkeiten.lr_auto_min ;
END_IF

(* ======Ausgabe von Position und Geschwindigkeit der Achse===== *)
IF i16_achstyp = RUND OR  i16_achstyp = RUND_VIRTUELL THEN
	(* INT-Daten *)
	IF LREAL_TO_DINT(st_masterachse.NcToPlc.ModuloActPos) = 360 THEN
		st_visu_axis.i32_position_ist := 0;
	ELSE
		st_visu_axis.i32_position_ist := LREAL_TO_DINT(st_masterachse.NcToPlc.ModuloActPos);
	END_IF
	st_visu_axis.i32_geschwindigkeit_ist := LREAL_TO_DINT(st_masterachse.NcToPlc.ActVelo * 60 / 360); (* Hub = Grad/sec / 360 * 60s *)

	(* LREAL-DATEN *)
	st_visu_axis.lr_position_ist :=st_masterachse.NcToPlc.ModuloActPos;
	st_visu_axis.lr_geschwindigkeit_ist := st_masterachse.NcToPlc.ActVelo * 60 / 360; (* Hub = Grad/sec / 360 * 60s *)
ELSIF i16_achstyp = LINEAR OR i16_achstyp = LINEAR_VIRTUELL THEN
	st_visu_axis.lr_position_ist :=st_masterachse.NcToPlc.ActPos;
	st_visu_axis.lr_geschwindigkeit_ist := st_masterachse.NcToPlc.ActVelo;
ELSE
	st_visu_axis.lr_position_ist :=st_masterachse.NcToPlc.ActPos;
	st_visu_axis.lr_geschwindigkeit_ist := st_masterachse.NcToPlc.ActVelo;
END_IF

(* ======================================Schrittkette Drivebefehle======================================== *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:	(* Init *)
		st_ecd_cmd.b_job_fehler := FALSE;
		st_ecd_cmd.enu_cmd := NO_COMMAND;
		mc_buffermode_axis := MC_Aborting;
		t_cmd_timeout := T#10s;
		t_ads_timeout := t#10s;
		err_id :=0;

		b_jog_vorwaerts_execute := FALSE;
		b_jog_rueckwaerts_execute := FALSE;
		mc_power_axis.Enable := FALSE;
		mc_reset_axis.Execute := FALSE;
		mc_home_axis.Execute := FALSE;
		mc_moveabsolute_axis.Execute := FALSE;
		mc_moverelative_axis.Execute := FALSE;
		mc_movevelocity_axis.Execute := FALSE;
		mc_movemodulo_axis.Execute := FALSE;
		mc_setposition_axis.Execute := FALSE;
		mc_halt_axis.Execute := FALSE;
		mc_stop_axis.Execute := FALSE;
		mc_touch_probe.Execute := FALSE;
		fb_soe_reset.Execute := FALSE;
		fb_soe_write.Execute := FALSE;
		fb_soe_read.Execute := FALSE;
		fb_ec_coe_sdo_write_ex.bExecute := FALSE;
		fb_ec_coe_sdo_write_ex.bExecute := FALSE;
		mc_write_nc_parameter.Execute := FALSE;
		mc_read_nc_parameter.Enable := FALSE;
		fb_ads_write.WRITE := FALSE;
		fb_ads_read.READ := FALSE;

		st_ecd_cmd.meldungen.sm_power_enable := FALSE;
		st_ecd_cmd.meldungen.sm_power_disable := FALSE;
		st_ecd_cmd.meldungen.sm_reset := FALSE;
		st_ecd_cmd.meldungen.sm_home := FALSE;
		st_ecd_cmd.meldungen.sm_setposition := FALSE;
		st_ecd_cmd.meldungen.sm_jog_vorwaerts := FALSE;
		st_ecd_cmd.meldungen.sm_jog_rueckwaerts := FALSE;
		st_ecd_cmd.meldungen.sm_move_absolute := FALSE;
		st_ecd_cmd.meldungen.sm_move_relative := FALSE;
		st_ecd_cmd.meldungen.sm_move_velocity := FALSE;
		st_ecd_cmd.meldungen.sm_move_modulo := FALSE;
		st_ecd_cmd.meldungen.sm_stop_axis := FALSE;
		st_ecd_cmd.meldungen.sm_halt_axis := FALSE;
		st_ecd_cmd.meldungen.sm_motion_command_timeout := FALSE;
		st_ecd_cmd.meldungen.sm_limit_positiv_erreicht := FALSE;
		st_ecd_cmd.meldungen.sm_limit_negativ_erreicht := FALSE;
		st_ecd_cmd.meldungen.sm_write_soe_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_read_soe_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_write_nc_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_read_nc_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_write_ads_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_read_ads_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_ec_coe_sdo_write_ex := FALSE;
		st_ecd_cmd.meldungen.sm_ec_coe_sdo_read_ex := FALSE;
		st_ecd_cmd.meldungen.sm_touch_probe_defect := FALSE;
		st_ecd_cmd.meldungen.sm_touch_probe_err := FALSE;
		fb_state_entry.i16_next_step := 1;

(*=======================================================*)
	1:	(* Warte auf Kommando *)
		IF st_ecd_cmd.enu_cmd > NO_COMMAND THEN
			IF st_ecd_cmd.enu_cmd <= HALT_AXIS THEN
				(* Wichtige Kommandos werden mit Direktsprung ausgeführt, um Zykluszeit zu sparen *)
				IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
					fb_state_entry.i16_next_step := 120;
				ELSIF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
					fb_state_entry.i16_next_step := 130;
				ELSE
					fb_state_entry.i16_next_step := 10;	(* Motionbefehle *)
				END_IF
			ELSE
				fb_state_entry.i16_next_step := 500;	(* Parameter für Achsen *)
			END_IF
		END_IF

(*=======================Motionbefehle================================*)
	10:	(* Power OFF NC-Achse *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = POWER_DISABLE THEN
			mc_power_axis.Enable := FALSE;
			fb_state_entry.i16_next_step := 11;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF
	11:
		CASE i16_achstyp OF
			LINEAR, RUND:
				IF NOT mc_power_axis.Status AND NOT st_masterachse.Status.Operational THEN
					fb_state_entry.i16_next_step := 999;
				ELSIF NOT mc_power_axis.Busy AND mc_power_axis.Error THEN
					err_id := mc_power_axis.ErrorID;
					st_ecd_cmd.meldungen.sm_power_disable := TRUE;
					fb_state_entry.i16_next_step := 1000;
				END_IF
			LINEAR_VIRTUELL, RUND_VIRTUELL:
				IF NOT mc_power_axis.Busy AND mc_power_axis.Error THEN
					err_id := mc_power_axis.ErrorID;
					st_ecd_cmd.meldungen.sm_power_disable := TRUE;
					fb_state_entry.i16_next_step := 1000;
				ELSE
					fb_state_entry.i16_next_step := 999;
				END_IF
			SERVOKLEMME7201:
				IF NOT mc_power_axis.Status AND NOT st_masterachse.Status.Operational THEN
					fb_state_entry.i16_next_step := 999;
				ELSIF NOT mc_power_axis.Busy AND mc_power_axis.Error THEN
					err_id := mc_power_axis.ErrorID;
					st_ecd_cmd.meldungen.sm_power_disable := TRUE;
					fb_state_entry.i16_next_step := 1000;
				END_IF
		END_CASE

(*=======================================================*)
	20:	(* Reset NC-Achse und Servokontroller*)
		IF	st_ecd_cmd.enu_cmd = RESET OR
			st_masterachse.Status.DriveDeviceError OR
			st_masterachse.Status.Error
			 THEN
			fb_state_entry.i16_next_step := 21;
		ELSE
			fb_state_entry.i16_next_step := 30;
		END_IF
	21:	(*  Reset AX5000 Fehler  *)
		CASE i16_achstyp OF
			LINEAR, RUND:
				IF NOT st_masterachse.Status.DriveDeviceError THEN
					fb_state_entry.i16_next_step := 24;
				ELSE
					fb_ton_cmd_timeout.IN := TRUE;
					fb_soe_reset.Execute := TRUE;
					IF fb_soe_reset.Busy THEN
						fb_state_entry.i16_next_step := 22;
					END_IF
				END_IF
			LINEAR_VIRTUELL, RUND_VIRTUELL, SERVOKLEMME7201:
				fb_state_entry.i16_next_step := 24;
		END_CASE
	22:
		IF NOT fb_soe_reset.Busy THEN
			IF  fb_soe_reset.Error THEN
				st_ecd_cmd.meldungen.sm_reset := TRUE;
				fb_state_entry.i16_next_step := 1000;
			ELSE
				fb_soe_reset.Execute := FALSE;
				fb_state_entry.i16_next_step := 23;
			END_IF
		END_IF
	23:
		IF NOT st_masterachse.Status.DriveDeviceError THEN
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 24;
		END_IF
	24:	(* Reset NC-Achsfehler *)
		CASE i16_achstyp OF
			LINEAR, RUND, LINEAR_VIRTUELL, RUND_VIRTUELL:
				IF NOT st_masterachse.Status.Error THEN
					fb_state_entry.i16_next_step := 26;
				ELSE
					fb_ton_cmd_timeout.IN := TRUE;
					mc_reset_axis.Execute := TRUE;
					IF mc_reset_axis.Busy THEN
						fb_state_entry.i16_next_step := 25;
					END_IF
				END_IF
			SERVOKLEMME7201:
				IF NOT st_masterachse.Status.Error AND NOT st_masterachse.Status.DriveDeviceError THEN
					fb_state_entry.i16_next_step := 26;
				ELSE
					fb_ton_cmd_timeout.IN := TRUE;
					mc_reset_axis.Execute := TRUE;
					IF mc_reset_axis.Busy THEN
						fb_state_entry.i16_next_step := 25;
					END_IF
				END_IF
		END_CASE
	25:
		IF NOT st_masterachse.Status.Error THEN
			mc_reset_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 26;
		END_IF
	26:
		IF st_ecd_cmd.enu_cmd = RESET THEN
			fb_state_entry.i16_next_step := 999;
		ELSE
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Power ON NC-Achse *)
		CASE i16_achstyp OF
			LINEAR, RUND:
				fb_ton_cmd_timeout.IN := TRUE;
				IF	(st_ecd_cmd.enu_cmd > POWER_DISABLE AND st_ecd_cmd.enu_cmd < HALT_AXIS)  AND
					(NOT st_masterachse.Status.Operational OR
					(st_ecd_cmd.enu_cmd = POWER_ENABLE AND NOT st_masterachse.Status.Operational))
					THEN
						fb_state_entry.i16_next_step := 31;
				ELSE
					fb_ton_cmd_timeout.IN := FALSE;
					fb_state_entry.i16_next_step := 40;
				END_IF
			LINEAR_VIRTUELL, RUND_VIRTUELL, SERVOKLEMME7201:
				IF	st_ecd_cmd.enu_cmd > POWER_DISABLE AND st_ecd_cmd.enu_cmd < HALT_AXIS AND
					NOT mc_power_axis.Status
					THEN
						fb_state_entry.i16_next_step := 31;
				ELSE
					fb_ton_cmd_timeout.IN := FALSE;
					fb_state_entry.i16_next_step := 40;
				END_IF
		END_CASE
	31:
		mc_power_axis.Enable_Positive := TRUE;
		mc_power_axis.Enable_Negative := TRUE;
		mc_power_axis.Enable := TRUE;
		IF mc_power_axis.Busy THEN
			fb_ton_vz.PT := t#1s;
			fb_ton_vz.IN := TRUE;
			fb_state_entry.i16_next_step := 32;
		END_IF
	32:
		IF mc_power_axis.Status AND st_masterachse.Status.Operational  THEN
			IF st_ecd_cmd.enu_cmd = POWER_ENABLE THEN
				fb_state_entry.i16_next_step := 999;
			ELSE
				fb_ton_cmd_timeout.IN := FALSE;
				fb_state_entry.i16_next_step := 40;
			END_IF
		ELSIF mc_power_axis.Error AND fb_ton_vz.Q THEN
			st_ecd_cmd.meldungen.sm_power_enable := TRUE;
			err_id := mc_power_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF
		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			fb_ton_cmd_timeout.IN := FALSE;
			fb_ton_vz.IN := FALSE;
			fb_state_entry.i16_next_step := 121;
		END_IF
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			fb_ton_cmd_timeout.IN := FALSE;
			fb_ton_vz.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

(*=======================================================*)
	40:	(* Abfrage Referenzieren und Ref-Art *)
		IF st_ecd_cmd.enu_cmd = HOME THEN
			IF b_refsensor_vorhanden THEN
				mc_referenzmodus := MC_DefaultHoming;
			ELSE
				mc_referenzmodus := MC_Direct;
			END_IF
			st_position.r_referenz := 0.0;
			fb_state_entry.i16_next_step := 41;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF
	41:	(* Start Homing *)
		mc_home_axis.Execute := TRUE;
		mc_home_axis.Options.ClearPositionLag := TRUE;
		IF mc_home_axis.Busy THEN
			fb_state_entry.i16_next_step := 42;
		END_IF
	42:
		IF mc_home_axis.Done THEN
			mc_home_axis.Execute := FALSE;
			fb_state_entry.i16_next_step := 999;
		END_IF
		IF NOT mc_home_axis.Busy AND mc_home_axis.Error THEN
			st_ecd_cmd.meldungen.sm_home := TRUE;
			err_id := mc_home_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF
		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			mc_home_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 121;
		END_IF
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			mc_home_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

(*=======================================================*)
	50:	(* Jog vorwärts *)
		IF st_ecd_cmd.enu_cmd = JOG_VORWAERTS THEN
			fb_state_entry.i16_next_step := 51;
		ELSE
			fb_state_entry.i16_next_step := 55;
		END_IF
	51:
		b_jog_vorwaerts_execute := TRUE;
		IF mc_jog_axis.Active THEN
			fb_state_entry.i16_next_step := 52;
		ELSIF mc_jog_axis.Error THEN
			st_ecd_cmd.meldungen.sm_jog_vorwaerts := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	52:
		IF st_ecd_cmd.enu_cmd = JOG_STOP OR st_ecd_cmd.enu_cmd = JOG_RUECKWAERTS THEN
			fb_state_entry.i16_next_step := 61;
		END_IF

		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			mc_movemodulo_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 121;
		END_IF
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			mc_movemodulo_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

(*=======================================================*)
	55:	(* Jog rückwärts *)
		IF st_ecd_cmd.enu_cmd = JOG_RUECKWAERTS THEN
			fb_state_entry.i16_next_step := 56;
		ELSE
			fb_state_entry.i16_next_step := 60;
		END_IF

	56:
		b_jog_rueckwaerts_execute := TRUE;
		IF mc_jog_axis.Active THEN
			fb_state_entry.i16_next_step := 57;
		ELSIF mc_jog_axis.Error THEN
			st_ecd_cmd.meldungen.sm_jog_rueckwaerts := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	57:
		IF st_ecd_cmd.enu_cmd = JOG_STOP OR st_ecd_cmd.enu_cmd = JOG_VORWAERTS THEN
			fb_state_entry.i16_next_step := 61;
		END_IF

		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			mc_movemodulo_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 121;
		END_IF
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			mc_movemodulo_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

(*=======================================================*)
	60:	(* Jog Stop *)
		IF st_ecd_cmd.enu_cmd = JOG_STOP THEN
			fb_state_entry.i16_next_step := 61;
		ELSE
			fb_state_entry.i16_next_step := 70;
		END_IF
	61:
		b_jog_vorwaerts_execute := FALSE;
		b_jog_rueckwaerts_execute := FALSE;
		fb_state_entry.i16_next_step := 999;

(*=======================================================*)
	70:	(* Move absolute *)
		IF st_ecd_cmd.enu_cmd = MOVE_ABSOLUTE THEN
			fb_state_entry.i16_next_step := 71;
		ELSE
			fb_state_entry.i16_next_step := 80;
		END_IF
	71:
		IF ABS(st_masterachse.NcToPlc.ActPos -  st_position.r_soll ) < 0.05 THEN
			fb_state_entry.i16_next_step := 999;
		ELSE
			mc_moveabsolute_axis.Execute := TRUE;
		END_IF
		IF mc_moveabsolute_axis.Busy THEN
			fb_state_entry.i16_next_step := 72;
		END_IF
	72:
		IF mc_moveabsolute_axis.Done THEN
			mc_moveabsolute_axis.Execute := FALSE;
			fb_state_entry.i16_next_step := 999;
		END_IF
		IF NOT mc_moveabsolute_axis.Busy AND mc_moveabsolute_axis.Error THEN
			st_ecd_cmd.meldungen.sm_move_absolute := TRUE;
			err_id := mc_moveabsolute_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF
		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			mc_moveabsolute_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 121;
		END_IF
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			mc_moveabsolute_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

		(* Move-Kommando für folgende Bewegung *)
		IF st_ecd_cmd.enu_cmd = MOVE_ABSOLUTE_NEXT THEN
			fb_state_entry.i16_next_step := 74;
		END_IF
	74:
		IF ABS(st_masterachse.NcToPlc.ActPos -  st_position.r_soll ) < 0.05 THEN
			fb_state_entry.i16_next_step := 999;
		ELSE
			mc_moveabsolutenext_axis.Execute := TRUE;
		END_IF
		IF mc_moveabsolutenext_axis.Busy THEN
			fb_state_entry.i16_next_step := 75;
		END_IF
	75:
		IF mc_moveabsolutenext_axis.Done THEN
			mc_moveabsolute_axis.Execute := FALSE;
			mc_moveabsolutenext_axis.Execute := FALSE;
			fb_state_entry.i16_next_step := 999;
		END_IF
		IF NOT mc_moveabsolutenext_axis.Busy AND mc_moveabsolutenext_axis.Error THEN
			st_ecd_cmd.meldungen.sm_move_absolute := TRUE;
			err_id := mc_moveabsolutenext_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF
		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			mc_moveabsolute_axis.Execute := FALSE;
			mc_moveabsolutenext_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 121;
		END_IF
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			mc_moveabsolute_axis.Execute := FALSE;
			mc_moveabsolutenext_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

(*=======================================================*)
	80:	(* Move relative *)
		IF st_ecd_cmd.enu_cmd = MOVE_RELATIVE THEN
			fb_state_entry.i16_next_step := 81;
		ELSE
			fb_state_entry.i16_next_step := 90;
		END_IF
	81:
		mc_moverelative_axis.Execute := TRUE;
		IF mc_moverelative_axis.Busy THEN
			fb_state_entry.i16_next_step := 82;
		END_IF
	82:
		IF mc_moverelative_axis.Done THEN
			mc_moverelative_axis.Execute := FALSE;
			fb_state_entry.i16_next_step := 999;
		END_IF
		IF NOT mc_moverelative_axis.Busy AND mc_moverelative_axis.Error THEN
			st_ecd_cmd.meldungen.sm_move_relative := TRUE;
			err_id := mc_moverelative_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF
		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			mc_moverelative_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 121;
		END_IF
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			mc_moverelative_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

(*=======================================================*)
	90:	(* Move velocity *)
		IF st_ecd_cmd.enu_cmd = MOVE_VELOCITY THEN
			fb_state_entry.i16_next_step := 91;
		ELSE
			fb_state_entry.i16_next_step := 100;
		END_IF
	91:
		mc_movevelocity_axis.Execute := TRUE;
		IF mc_movevelocity_axis.Busy THEN
			fb_state_entry.i16_next_step := 92;
		END_IF
	92:
		IF mc_movevelocity_axis.InVelocity THEN
			mc_movevelocity_axis.Execute := FALSE;
			fb_state_entry.i16_next_step := 999;
		END_IF
		IF NOT mc_movevelocity_axis.Busy AND mc_movevelocity_axis.Error THEN
			st_ecd_cmd.meldungen.sm_move_velocity := TRUE;
			err_id := mc_movevelocity_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF
		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			mc_movevelocity_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 121;
		END_IF
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			mc_movevelocity_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

(*=======================================================*)
	100:	(* Move modulo *)
		IF st_ecd_cmd.enu_cmd = MOVE_MODULO THEN
			fb_state_entry.i16_next_step := 101;
		ELSE
			fb_state_entry.i16_next_step := 103;
		END_IF
	101:
		IF ABS(st_masterachse.NcToPlc.ModuloActPos -  st_position.r_soll ) < 0.3 THEN
			fb_state_entry.i16_next_step := 999;
		ELSE
			mc_movemodulo_axis.Execute := TRUE;
		END_IF
		IF mc_movemodulo_axis.Busy THEN
			fb_state_entry.i16_next_step := 102;
		END_IF
	102:
		IF mc_movemodulo_axis.Done THEN
			mc_movemodulo_axis.Execute := FALSE;
			fb_state_entry.i16_next_step := 999;
		END_IF

		IF NOT mc_movemodulo_axis.Busy AND mc_movemodulo_axis.Error THEN
			st_ecd_cmd.meldungen.sm_move_modulo := TRUE;
			err_id := mc_movemodulo_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF
		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			mc_movemodulo_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 121;
		END_IF
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			mc_movemodulo_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

(*=======================================================*)
	103:
		(*Touch Probe checken*)
		IF	fb_state_entry.E THEN
			mc_abort_trigger.Execute:=TRUE;
		END_IF

		IF st_ecd_cmd.enu_cmd = MOVE_TOUCH_PROBE THEN

			(*Touch Probe darf nicht betätigt sein*)
			IF	(b_FallingEdge AND NOT b_TriggerInput) OR
				(NOT b_FallingEdge AND b_TriggerInput)  THEN
				st_ecd_cmd.meldungen.sm_touch_probe_defect := TRUE;		(*Messtaster defekt*)
				fb_state_entry.i16_next_step := FEHLER;

			ELSIF mc_abort_trigger.Done THEN
				lr_RecPos:=0;
				fb_state_entry.i16_next_step := 104;
			END_IF

		ELSE
			fb_state_entry.i16_next_step := 110;
		END_IF

		IF	fb_state_entry.X THEN
			mc_abort_trigger.Execute:=FALSE;
		END_IF

	104:
		(* Move absolute (Position muss hinter dem Touch Probe liegen => der Restweg wird gelöscht)*)
		IF 	ABS(st_masterachse.NcToPlc.ActPos -  st_position.r_soll ) < 0.05 THEN
			fb_state_entry.i16_next_step := 999;
		ELSE
			mc_moveabsolute_axis.Execute := TRUE;
			mc_touch_probe.Execute:=TRUE;
		END_IF
		IF 	mc_moveabsolute_axis.Busy THEN
			fb_state_entry.i16_next_step := 105;
		END_IF

	105:
		(*Achsposition wurde erreicht ohne Taster Event*)
		IF 	mc_moveabsolute_axis.Done THEN
			fb_state_entry.i16_next_step := 999;
		END_IF

		(*Achse anhalten wenn Touch Probe betätigt wird*)
		IF 	mc_moveabsolute_axis.Busy AND
			(b_TriggerInput = NOT b_FallingEdge OR
			mc_touch_probe.Done) THEN
			fb_state_entry.i16_next_step := 131;
		END_IF

		(*Übergabe Rec Position*)
		IF	mc_touch_probe.Done THEN
			lr_RecPos:=mc_touch_probe.RecordedPosition;
		END_IF

		(*Fehler Achse*)
		IF 	NOT mc_moveabsolute_axis.Busy AND mc_moveabsolute_axis.Error THEN
			st_ecd_cmd.meldungen.sm_move_absolute := TRUE;
			err_id := mc_moveabsolute_axis.ErrorID;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

		(*Fehler Touch Probe*)
		IF  	mc_touch_probe.Error THEN
			st_ecd_cmd.meldungen.sm_touch_probe_err := TRUE;
			err_id := mc_touch_probe.ErrorID;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

		IF	fb_state_entry.X THEN
			fb_ton_cmd_timeout.IN := FALSE;
			mc_moveabsolute_axis.Execute := FALSE;
			mc_touch_probe.Execute:=FALSE;
		END_IF

(*=======================================================*)
	110:	(* Position *)
		IF st_ecd_cmd.enu_cmd = SET_POSITION THEN
			fb_state_entry.i16_next_step := 111;
		ELSE
			fb_state_entry.i16_next_step := 121;
		END_IF
	111:
		(* Soll- und Istposition werden auf den gleichen Wert gesetzt und somit der Schleppfehler gelöscht. *)
		mc_setposition_axis.Options.ClearPositionLag := TRUE;
		mc_setposition_axis.Options.EncoderIndex := 0;
		mc_setposition_axis.Options.SelectEncoderIndex := FALSE;
		mc_setposition_axis.Execute := TRUE;
		IF mc_setposition_axis.Busy THEN
			fb_state_entry.i16_next_step := 112;
		END_IF
	112:
		IF mc_setposition_axis.Done THEN
			mc_setposition_axis.Execute := FALSE;
			fb_state_entry.i16_next_step := 999;
		END_IF
		IF NOT mc_setposition_axis.Busy AND mc_setposition_axis.Error THEN
			st_ecd_cmd.meldungen.sm_setposition := TRUE;
			err_id := mc_setposition_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF
		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			mc_setposition_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 121;
		END_IF
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			mc_setposition_axis.Execute := FALSE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

(*=======================================================*)
	120:	(* Halt *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = HALT_AXIS THEN
			fb_state_entry.i16_next_step := 121;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF
	121:
		mc_halt_axis.Execute := TRUE;
		IF mc_halt_axis.Busy THEN
			fb_state_entry.i16_next_step := 122;
		END_IF
	122:
		IF mc_halt_axis.Done THEN
			mc_halt_axis.Execute := FALSE;
			fb_state_entry.i16_next_step := 123;
		END_IF
		IF NOT mc_halt_axis.Busy AND mc_halt_axis.Error THEN
			st_ecd_cmd.meldungen.sm_halt_axis := TRUE;
			err_id := mc_halt_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF
	123:
		IF	NOT st_masterachse.Status.ConstantVelocity AND
			NOT st_masterachse.Status.Accelerating AND
			NOT st_masterachse.Status.Decelerating
			THEN
				fb_state_entry.i16_next_step := 999;
		END_IF

(*=======================================================*)
	130: (* Stop *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = STOP_AXIS THEN
			fb_state_entry.i16_next_step := 131;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 140;
		END_IF
	131:
		mc_stop_axis.Execute := TRUE;
		IF mc_stop_axis.Busy THEN
			fb_state_entry.i16_next_step := 132;
		END_IF
	132:
		IF mc_stop_axis.Done THEN
			mc_stop_axis.Execute := FALSE;
			fb_state_entry.i16_next_step := 133;
		END_IF
		IF mc_stop_axis.Error THEN
			st_ecd_cmd.meldungen.sm_stop_axis := TRUE;
			err_id := mc_stop_axis.ErrorID;
			fb_state_entry.i16_next_step := 1000;
		END_IF
	133:
		IF 	NOT st_masterachse.Status.ConstantVelocity AND
			NOT st_masterachse.Status.Accelerating AND
			NOT st_masterachse.Status.Decelerating
			THEN
				fb_state_entry.i16_next_step := 999;
		END_IF

(*=======================================================*)
	140:	(* Frei *)
		fb_state_entry.i16_next_step := 500;

(*======================Parameterbefehle=================================*)
	500:	(* Schreibe einen Parameter an den Antrieb *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = SOE_WRITE_PARAM THEN
			fb_state_entry.i16_next_step := 501;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 510;
		END_IF
	501:
		fb_soe_write.Execute := TRUE;
		IF fb_soe_write.Busy THEN
			fb_state_entry.i16_next_step := 502;
		END_IF
	502:
		IF NOT fb_soe_write.Busy THEN
			fb_soe_write.Execute := FALSE;
			IF fb_soe_write.Error THEN
				st_ecd_cmd.meldungen.sm_write_soe_parameter := TRUE;
				fb_state_entry.i16_next_step := 1000;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	510:	(* Lesen eines Parameter vom Antrieb *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = SOE_READ_PARAM THEN
			fb_state_entry.i16_next_step := 511;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 520;
		END_IF
	511:
		fb_soe_read.Execute := TRUE;
		IF fb_soe_read.Busy THEN
			fb_state_entry.i16_next_step := 512;
		END_IF
	512:
		IF NOT fb_soe_read.Busy THEN
			fb_soe_write.Execute := FALSE;
			IF fb_soe_read.Error THEN
				st_ecd_cmd.meldungen.sm_read_soe_parameter := TRUE;
				fb_state_entry.i16_next_step := 1000;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	520:	(* Schreibe einen Parameter an die NC-Achse *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = WRITE_NC_PARAMETER THEN
			fb_state_entry.i16_next_step := 521;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 530;
		END_IF
	521:
		mc_write_nc_parameter.Execute := TRUE;
		IF mc_write_nc_parameter.Busy THEN
			fb_state_entry.i16_next_step := 522;
		END_IF
	522:
		IF NOT mc_write_nc_parameter.Busy THEN
			mc_write_nc_parameter.Execute := FALSE;
			IF mc_write_nc_parameter.Error THEN
				st_ecd_cmd.meldungen.sm_write_nc_parameter := TRUE;
				fb_state_entry.i16_next_step := 1000;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	530:	(* Lesen eines Parameter vom der NC-Achse *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = READ_NC_PARAMETER THEN
			fb_state_entry.i16_next_step := 531;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 540;
		END_IF
	531:
		mc_read_nc_parameter.Enable := TRUE;
		IF mc_read_nc_parameter.Busy THEN
			fb_state_entry.i16_next_step := 532;
		END_IF
	532:
		IF NOT mc_read_nc_parameter.Busy THEN
			mc_read_nc_parameter.Enable := FALSE;
			IF mc_read_nc_parameter.Error THEN
				st_ecd_cmd.meldungen.sm_read_nc_parameter := TRUE;
				fb_state_entry.i16_next_step := 1000;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	540:	(* Schreibe einen beliebigen ADS-Parameter an die NC-Achse *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = WRITE_ADS_PARAMETER THEN
			fb_state_entry.i16_next_step := 541;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 550;
		END_IF
	541:
		fb_ads_write.WRITE := TRUE;
		IF fb_ads_write.BUSY THEN
			fb_state_entry.i16_next_step := 542;
		END_IF
	542:
		IF NOT fb_ads_write.BUSY THEN
			fb_ads_write.WRITE := FALSE;
			IF fb_ads_write.ERR THEN
				st_ecd_cmd.meldungen.sm_write_ads_parameter := TRUE;
				fb_state_entry.i16_next_step := 1000;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	550:	(* Lesen einen beliebigenADS-Parameter vom der NC-Achse *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = READ_ADS_PARAMETER THEN
			fb_state_entry.i16_next_step := 551;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 560;
		END_IF
	551:
		fb_ads_read.READ := TRUE;
		IF fb_ads_read.BUSY THEN
			fb_state_entry.i16_next_step := 552;
		END_IF
	552:
		IF NOT fb_ads_read.BUSY THEN
			fb_ads_read.READ := FALSE;
			IF fb_ads_read.ERR THEN
				st_ecd_cmd.meldungen.sm_read_ads_parameter := TRUE;
				fb_state_entry.i16_next_step := 1000;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	560:	(* Schreibe die neuen EcSoe Parameter an den Antrieb *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = ECCOESDO_WRITE_PARAM THEN
			fb_state_entry.i16_next_step := 561;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 570;
		END_IF
	561:
		fb_ec_coe_sdo_write_ex.bExecute := TRUE;
		IF fb_ec_coe_sdo_write_ex.bBusy THEN
			fb_state_entry.i16_next_step := 562;
		END_IF
	562:
		IF NOT fb_ec_coe_sdo_write_ex.bBusy THEN
			fb_ec_coe_sdo_write_ex.bExecute := FALSE;
			IF fb_ec_coe_sdo_write_ex.bError THEN
				st_ecd_cmd.meldungen.sm_ec_coe_sdo_write_ex := TRUE;
				fb_state_entry.i16_next_step := 1000;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	570:	(* Lese die neuen EcSoe Parameter an den Antrieb *)
		fb_ton_cmd_timeout.IN := TRUE;
		IF st_ecd_cmd.enu_cmd = ECCOESDO_READ_PARAM THEN
			fb_state_entry.i16_next_step := 571;
		ELSE
			fb_ton_cmd_timeout.IN := FALSE;
			fb_state_entry.i16_next_step := 580;
		END_IF
	571:
		fb_ec_coe_sdo_read_ex.bExecute := TRUE;
		IF fb_ec_coe_sdo_read_ex.bBusy THEN
			fb_state_entry.i16_next_step := 572;
		END_IF
	572:
		IF NOT fb_ec_coe_sdo_read_ex.bBusy THEN
			fb_ec_coe_sdo_read_ex.bExecute := FALSE;
			IF fb_ec_coe_sdo_read_ex.bError THEN
				st_ecd_cmd.meldungen.sm_ec_coe_sdo_read_ex := TRUE;
				fb_state_entry.i16_next_step := 1000;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	580:	(* Frei *)
		fb_state_entry.i16_next_step := 999;

(*=======================================================*)
	999:	(* Ende - Befehl wurde korrekt abgearbeitet *)
		st_ecd_cmd.enu_cmd := NO_COMMAND;
		fb_ton_cmd_timeout.IN := FALSE;
		fb_ton_vz.IN := FALSE;

		b_jog_vorwaerts_execute := FALSE;
		b_jog_rueckwaerts_execute := FALSE;

		mc_reset_axis.Execute := FALSE;
		mc_home_axis.Execute := FALSE;
		mc_moveabsolute_axis.Execute := FALSE;
		mc_moverelative_axis.Execute := FALSE;
		mc_movevelocity_axis.Execute := FALSE;
		mc_movemodulo_axis.Execute := FALSE;
		mc_setposition_axis.Execute := FALSE;
		mc_halt_axis.Execute := FALSE;
		mc_stop_axis.Execute := FALSE;
		fb_soe_reset.Execute := FALSE;
		fb_soe_write.Execute := FALSE;
		fb_soe_read.Execute := FALSE;
		mc_write_nc_parameter.Execute := FALSE;
		mc_read_nc_parameter.Enable := FALSE;
		fb_ads_write.WRITE := FALSE;
		fb_ads_read.READ := FALSE;
		fb_ec_coe_sdo_write_ex.bExecute := FALSE;
		fb_ec_coe_sdo_read_ex.bExecute := FALSE;

		st_ecd_cmd.meldungen.sm_power_enable := FALSE;
		st_ecd_cmd.meldungen.sm_power_disable := FALSE;
		st_ecd_cmd.meldungen.sm_reset := FALSE;
		st_ecd_cmd.meldungen.sm_home := FALSE;
		st_ecd_cmd.meldungen.sm_setposition := FALSE;
		st_ecd_cmd.meldungen.sm_jog_vorwaerts := FALSE;
		st_ecd_cmd.meldungen.sm_jog_rueckwaerts := FALSE;
		st_ecd_cmd.meldungen.sm_move_absolute := FALSE;
		st_ecd_cmd.meldungen.sm_move_relative := FALSE;
		st_ecd_cmd.meldungen.sm_move_velocity := FALSE;
		st_ecd_cmd.meldungen.sm_move_modulo := FALSE;
		st_ecd_cmd.meldungen.sm_stop_axis := FALSE;
		st_ecd_cmd.meldungen.sm_halt_axis := FALSE;
		st_ecd_cmd.meldungen.sm_motion_command_timeout := FALSE;
		st_ecd_cmd.meldungen.sm_limit_positiv_erreicht := FALSE;
		st_ecd_cmd.meldungen.sm_limit_negativ_erreicht := FALSE;
		st_ecd_cmd.meldungen.sm_write_soe_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_read_soe_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_write_nc_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_read_nc_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_write_ads_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_read_ads_parameter := FALSE;
		st_ecd_cmd.meldungen.sm_ec_coe_sdo_write_ex := FALSE;
		st_ecd_cmd.meldungen.sm_ec_coe_sdo_read_ex := FALSE;

		fb_state_entry.i16_next_step := 1;

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			st_ecd_cmd.b_job_fehler := TRUE;
			fb_ton_cmd_timeout.IN := FALSE;
			fb_ton_vz.IN := FALSE;
			st_ecd_cmd.enu_cmd := NO_COMMAND;
		END_IF

		(* Fehler reseten *)
		IF st_ecd_cmd.enu_cmd >= ABORT THEN
			st_ecd_cmd.b_job_fehler := FALSE;
			b_jog_vorwaerts_execute := FALSE;
			b_jog_rueckwaerts_execute := FALSE;
			mc_reset_axis.Execute := FALSE;
			mc_home_axis.Execute := FALSE;
			mc_moveabsolute_axis.Execute := FALSE;
			mc_moverelative_axis.Execute := FALSE;
			mc_movevelocity_axis.Execute := FALSE;
			mc_movemodulo_axis.Execute := FALSE;
			mc_setposition_axis.Execute := FALSE;
			mc_halt_axis.Execute := FALSE;
			mc_stop_axis.Execute := FALSE;
			fb_soe_reset.Execute := FALSE;
			fb_soe_write.Execute := FALSE;
			fb_soe_read.Execute := FALSE;
			mc_write_nc_parameter.Execute := FALSE;
			mc_read_nc_parameter.Enable := FALSE;
			fb_ads_write.WRITE := FALSE;
			fb_ads_read.READ := FALSE;
			fb_ec_coe_sdo_write_ex.bExecute := FALSE;
			fb_ec_coe_sdo_read_ex.bExecute := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

(* Endlagenüberwachung der maximalen Verfahrwege der Achse *)
IF b_limitsensor_positiv_vorhanden AND fb_f_trig_limit_sensor_positiv.Q THEN
	mc_stop_axis.Execute := TRUE;
	st_ecd_cmd.meldungen.sm_limit_positiv_erreicht := TRUE;
	fb_state_entry.i16_next_step := 1000;
END_IF
IF b_limitsensor_negativ_vorhanden AND fb_f_trig_limit_sensor_negativ.Q THEN
	mc_stop_axis.Execute := TRUE;
	st_ecd_cmd.meldungen.sm_limit_negativ_erreicht := TRUE;
	fb_state_entry.i16_next_step := 1000;
END_IF

(* Timeout-Fehler aller Drivekommandos *)
IF fb_ton_cmd_timeout.Q THEN
	fb_ton_cmd_timeout.IN := FALSE;
	st_ecd_cmd.meldungen.sm_motion_command_timeout := TRUE;
	fb_state_entry.i16_next_step := 1000;
END_IF

(*Abbruch des aktuellen Achskommandos *)
IF st_ecd_cmd.enu_cmd = ABORT AND fb_state_entry.i16_next_step <> FEHLER THEN
	fb_state_entry.i16_next_step := 999;
END_IF

(* Statehistory *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

fb_cmd_history(i16_current_cmd:= st_ecd_cmd.enu_cmd, last_cmd=> );

(*=============================================================================================*)
(* Ab hier werden alle Verfahraufträge für eine Achse abgewickelt *)

(* Lese Zustand der Achse *)
st_masterachse.ReadStatus;

(* Für Rundachsen muss die Sollgeschwindigkeit umgerechnet werden in °/s *)
IF i16_achstyp = RUND OR i16_achstyp = RUND_VIRTUELL THEN
	lr_sollgeschwindigkeit := lr_sollgeschwindigkeit * 360 / 60;
END_IF

(*=============================================================================================*)
(* Reglerfreigabe *)
mc_power_axis(
	Enable:= ,
	Enable_Positive:= ,
	Enable_Negative:= ,
	Override:= lr_override,
	BufferMode:= mc_buffermode_axis,
	Axis:= st_masterachse,
	Status=> ,
	Busy=> ,
	Active=> ,
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* Achse aus Fehlerzustand rücksetzen *)
(* NC-Achse *)
mc_reset_axis(
	Execute:= ,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Error=> ,
	ErrorID=> );

(* AX5000 Servokontroller *)
fb_soe_reset(
	NetId:= , 
	Execute:= , 
	Timeout:= t_ads_timeout,
	Axis:= st_masterachse,
	Busy=> ,
	Error=> , 
	AdsErrId=> , 
	SercosErrId=> );

(*=============================================================================================*)
(* Achsposition setzen *)
mc_setposition_axis(
	Execute:= ,
	Position:= st_position.r_soll,
	Mode:= FALSE, (* RELATIVE=True, ABSOLUTE=False (Default) *)
	Options:= ,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* Achse referenzieren *)
mc_home_axis(
	Execute:= ,
	Position:= st_position.r_referenz,
	HomingMode:= mc_referenzmodus,
	BufferMode:= mc_buffermode_axis,
	Options:= ,
	bCalibrationCam:= e_referenznocken,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorId=> );

(*=============================================================================================*)
(* Achse tippen *)
mc_jog_axis(
	JogForward:= b_jog_vorwaerts_execute AND NOT b_jog_rueckwaerts_execute,
	JogBackwards:= b_jog_rueckwaerts_execute AND NOT b_jog_vorwaerts_execute,
	Mode:= MC_JOGMODE_CONTINOUS,  (* motion with standard jog parameters for slow motion *)
	Velocity:= lr_sollgeschwindigkeit,
	Acceleration:= st_vorgabe_geschwindigkeiten.lr_beschleunigung,
	Deceleration:= st_vorgabe_geschwindigkeiten.lr_verzoegerung,
	Jerk:= st_vorgabe_geschwindigkeiten.lr_ruck,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorId=> );

(*=============================================================================================*)
(* Fahre Achse absolut *)
mc_moveabsolute_axis(
	Execute:= ,
	Position:= st_position.r_soll,
	Velocity:= lr_sollgeschwindigkeit,
	Acceleration:= st_vorgabe_geschwindigkeiten.lr_beschleunigung,
	Deceleration:= st_vorgabe_geschwindigkeiten.lr_verzoegerung,
	Jerk:= st_vorgabe_geschwindigkeiten.lr_ruck,
	BufferMode:= mc_buffermode_axis,
	Options:= ,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );
(* Fahre Achse absolut im Falle einer Folgebewegung *)
mc_moveabsolutenext_axis(
	Execute:= ,
	Position:= st_position.r_soll,
	Velocity:= lr_sollgeschwindigkeit,
	Acceleration:= st_vorgabe_geschwindigkeiten.lr_beschleunigung,
	Deceleration:= st_vorgabe_geschwindigkeiten.lr_verzoegerung,
	Jerk:= st_vorgabe_geschwindigkeiten.lr_ruck,
	BufferMode:= mc_buffermode_axis,
	Options:= ,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* Fahre Achse relaiv *)
mc_moverelative_axis(
	Execute:= ,
	Distance:= st_position.r_soll,
	Velocity:= lr_sollgeschwindigkeit,
	Acceleration:= st_vorgabe_geschwindigkeiten.lr_beschleunigung,
	Deceleration:= st_vorgabe_geschwindigkeiten.lr_verzoegerung,
	Jerk:= st_vorgabe_geschwindigkeiten.lr_ruck,
	BufferMode:= mc_buffermode_axis,
	Options:= ,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* Gleichlaufachse starten *)
mc_movevelocity_axis(
	Execute:= ,
	Velocity:= lr_sollgeschwindigkeit,
	Acceleration:= st_vorgabe_geschwindigkeiten.lr_beschleunigung,
	Deceleration:= st_vorgabe_geschwindigkeiten.lr_verzoegerung,
	Jerk:= st_vorgabe_geschwindigkeiten.lr_ruck,
	Direction:= mc_richtung_velocity,
	BufferMode:= mc_buffermode_axis,
	Options:= ,
	Axis:= st_masterachse,
	InVelocity=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* Bewegen einer Rundachse *)
mc_movemodulo_axis(
	Execute:= ,
	Position:= st_position.r_soll,
	Velocity:= lr_sollgeschwindigkeit,
	Acceleration:= st_vorgabe_geschwindigkeiten.lr_beschleunigung,
	Deceleration:= st_vorgabe_geschwindigkeiten.lr_verzoegerung,
	Jerk:= st_vorgabe_geschwindigkeiten.lr_ruck,
	Direction:= mc_richtung_modulo,
	BufferMode:= mc_buffermode_axis,
	Options:= ,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
mc_stop_axis(
	Execute:= ,
	Deceleration:= st_vorgabe_geschwindigkeiten.lr_verzoegerung,
	Jerk:= st_vorgabe_geschwindigkeiten.lr_ruck,
	Options:= ,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* MC_Halt führt einen normalen Halt während der Bewegung aus.
Im Gegensatz dazu verriegelt MC_Stop die Achse gegen weitere Bewegungskommandos und
sollte nur in besonderen Situationen angewendet werden. *)
mc_halt_axis(
	Execute:= ,
	Deceleration:= st_vorgabe_geschwindigkeiten.lr_verzoegerung,
	Jerk:= st_vorgabe_geschwindigkeiten.lr_ruck,
	BufferMode:= mc_buffermode_axis,
	Options:= ,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*=============================================================================================*)
(* Einen Parameter auf den Antrieb schreiben *)
fb_soe_write(
	NetId:= , 
	Idn:= w_idn,	(* Idn := S_0_IDN + 33; *)
	Element:= EC_SOE_ELEMENT_VALUE,
	pSrcBuf:= ADR(ui16_soeparam_write_value),
	BufLen:= SIZEOF(ui16_soeparam_write_value),
	Execute:= , 
	Timeout:= t_ads_timeout,
	Password:= ,
	Axis:= st_masterachse,
	Busy=> ,
	Error=> ,
	AdsErrId=> ,
	SercosErrId=> );

(*=============================================================================================*)
(* Einen Parameter auf dem Antrieb lesen  *)
fb_soe_read(
	NetId:= , 
	Idn:= w_idn,	(* Idn := S_0_IDN + 33; *)
	Element:= EC_SOE_ELEMENT_VALUE,
	pDstBuf:= ADR(ui16_soeparam_read_value),
	BufLen:= SIZEOF(ui16_soeparam_read_value),
	Execute:= , 
	Timeout:= t_ads_timeout,
	Axis:= st_masterachse,
	Busy=> ,
	Error=> , 
	AdsErrId=> ,
	SercosErrId=> , 
	Attribute=> );

(*=============================================================================================*)
(* Einen Parameter auf die NC-Achse schreiben *)
mc_write_nc_parameter(
	Execute:= , 
	ParameterNumber:= i16_nc_parameter_nummer,
	Value:= r_wert_nc_write_parameter,
	Axis:= st_masterachse,
	Done=> ,
	Busy=> ,
	Error=> , 
	ErrorID=> );

(*=============================================================================================*)
(* Einen Parameter von der NC-Achse lesen *)
mc_read_nc_parameter(
	Enable:= , 
	ParameterNumber:= i16_nc_parameter_nummer,
	ReadMode:= READMODE_ONCE,
	Axis:= st_masterachse,
	Valid=> ,
	Busy=> ,
	Error=> , 
	ErrorID=> , 
	Value=> r_wert_nc_read_parameter);

(*=============================================================================================*)
(* Einen beliebigen ADS-Parameter auf die NC-Achse schreiben *)
fb_ads_write(
	NETID:= ,
	PORT:= 501,
	IDXGRP:= st_ads_info.st_symbol_info.idxGroup,
	IDXOFFS:= st_ads_info.st_symbol_info.idxOffset,
	LEN:= st_ads_info.st_symbol_info.byteSize,
	SRCADDR:= st_ads_info.dw_quelladresse_ads_write,
	WRITE:= ,
	TMOUT:= t_ads_timeout,
	BUSY=> , 
	ERR=> , 
	ERRID=> );

(*=============================================================================================*)
(* Einen beliebigen ADS-Parameter von der NC-Achse lesen *)
fb_ads_read(
	NETID:= ,
	PORT:= 501,
	IDXGRP:= st_ads_info.st_symbol_info.idxGroup,
	IDXOFFS:= st_ads_info.st_symbol_info.idxOffset,
	LEN:= st_ads_info.st_symbol_info.byteSize,
	DESTADDR:= st_ads_info.dw_zieladresse_ads_read,
	READ:= , 
	TMOUT:= t_ads_timeout,
	BUSY=> , 
	ERR=> , 
	ERRID=> );

(*=============================================================================================*)
(* Einen neuen EcCoeSdo-Parameter auf den Antrieb schreiben *)
fb_ec_coe_sdo_write_ex(
	sNetId:= st_eccoe_sdo.s_ec_slave_net_id,
	nSlaveAddr:= st_eccoe_sdo.ui16_slave_addr,
	nSubIndex:= st_eccoe_sdo.i8_sub_index,
	nIndex:= st_eccoe_sdo.w_index,
	pSrcBuf:= st_eccoe_sdo.dw_p_source_buffer,
	cbBufLen:= st_eccoe_sdo.ui32_buffer_length,
	bExecute:= ,
	tTimeout:= t_ads_timeout,
	bCompleteAccess:= FALSE,
	bBusy=> , 
	bError=> ,
	nErrId=> );

(*=============================================================================================*)
(* Einen neuen EcCoeSdo-Parameter von dem Antrieb lesen *)
fb_ec_coe_sdo_read_ex(
	sNetId:= st_eccoe_sdo.s_ec_slave_net_id,
	nSlaveAddr:= st_eccoe_sdo.ui16_slave_addr,
	nSubIndex:= st_eccoe_sdo.i8_sub_index,
	nIndex:= st_eccoe_sdo.w_index,
	pDstBuf:= st_eccoe_sdo.dw_p_destination_buffer,
	cbBufLen:= st_eccoe_sdo.ui32_buffer_length,
	bExecute:= ,
	tTimeout:= t_ads_timeout,
	bCompleteAccess:= FALSE,
	bBusy=> ,
	bError=> ,
	nErrId=> );



END_FUNCTION_BLOCK
ACTION	sub_TouchProbe:
(*======================================================
   Command: MOVE_TOUCH_PROBE
 ------------------------------------------------------
   Auth: 		Werner Friedl    						 
   Date: 		10.09.2019    						     
   Rev.: 		1.0	
   Desc:		Mit diesem Command kann die Achsposition zu eimem Tastzeitpunkt aufgezeichnet werden.

			- im Achsaufruf müssen diese Einstellungen gemacht werden
		z.B.		b_TriggerInput:=i16_DigitalInput.0		=> Verknüpfung mit den Prozessdaten der Achse an dem der Taster angeklemmt wurde				
				i16_TouchProbeInNo:=1					=> 1 wenn der Taster am Input 1 angeklemmt wurde
				b_SignalEdge:=FallingEdge				=> FallingEdge ODER RisingEdge

		- das Kommando MOVE_TOUCH_PROBE fährt die Achse auf den Taster. Wird der Taster 
			während der Fahrt betätigt , dann stoppt die Achse automatisch und 
			das Messergebniss landet in der VAR lr_RecPos
		
		- Schritt103 => Taster prüfen
		- Schritt104 => Move Absolut und start Touch Probe
		- Schritt105 => Stop Achse und Übergabe Recording Position an die VAR lr_RecPos


		Konfiguration:
		In der IE Hilfe unter "Funktion Probe Unit" findet man die Beschreibung.
		
		im tsm muss der Touch Probe konfiguriert werden.
		Parameter		Wert		
		S-0-0303		405
		S-0-0307		409
		S-0-0169		1
		S-0-0170		3

		in den Prozessdaten einfügen 
		S-0-0801		Digital inputs, sate			und mit der Var i16_DigitalInput der jeweiligen Achse verknüpfen

		im Drivemanager die Logik der Probe unit einstellen 
		- bei Mux1 den Input auswählen und negiert zuweisen
		- 1: Auto activation from SafeOp to Op auswählen

		PLC:
		im VAR_OUTPUT der Achse die Var anlegen
		lr_RecPos							: LREAL;
		
		im VAR anlegen
		i16_DigitalInput						AT %I* : INT;
	
	
		und im Aufruf fb_axis die Var hinzufügen
	
		lr_RecPos=> lr_RecPos,
		b_TriggerInput:=i16_DigitalInput.2,
		b_FallingEdge:=TRUE


 ========================================================*)
IF	mc_touch_probe.Done THEN
	lr_RecPos:=mc_touch_probe.RecordedPosition;
END_IF


(* Touch Probe Initialisierung *)
TriggerInput.EncoderID:= 	st_masterachse.NcToPlc.AxisId;		(* funktioniert so nur wenn die Encoder ID gleich ist wie die Achs ID*)
TriggerInput.TouchProbe:=	TouchProbe1;					(*bei MC_TouchProbe immer TouchProbe1*)
TriggerInput.Edge:=			RisingEdge;						(*bei MC_TouchProbe immer RisingEdge*)
TriggerInput.Mode:=			TOUCHPROBEMODE_SINGLE;



(* Touch Probe Aufruf *)
mc_touch_probe(
	Execute:= ,
	WindowOnly:= 	FALSE ,
	FirstPosition:= ,
	LastPosition:= ,
	Axis:= 			st_masterachse,
	TriggerInput:=	TriggerInput ,
	Done=> ,
	Busy=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> ,
	RecordedPosition=> );

mc_abort_trigger(
	Execute:= ,
	Axis:= 			st_masterachse,
	TriggerInput:=	TriggerInput ,
	Done=> ,
	Busy=> ,
	Error=> , 
	ErrorID=> );
END_ACTION




(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor\/Verfahrberechnungen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_MFCalcConstPhase
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;

	(* Kurvenscheibendaten *)
	udiTableId							: MC_CAM_ID;			(* Table-ID *)
	eMotionFunctionType					: MC_MotionFunctionType;	(*Bewegungsgesetz: MOTIONFUNCTYPE_POLYNOM5 etc.*)
	i16_startpunkt_edit_mf_tab				: INT;
	arr_db_mf_tab						: ARRAY[1..i_MAX_NUM_MFP] OF struct_db_motionfunctionpoint;	(* Vorgabe aus der Datenbank *)

	(* Bewegungsdaten an der Last *)
	lrVeloMax							: LREAL;	(*maximale Geschwindigkeit [mm/s] an der Last *)
	lrAccMax								: LREAL;	(*maximale Beschleunigung [mm/s²] an der Last *)
	lrDecMax							: LREAL;	(*maximale Beschleunigung [mm/s²] an der Last *)

	lrModuloValue 						: LREAL ;
END_VAR
VAR_IN_OUT
	st_AxisRefMaster						: AXIS_REF;
	st_AxisRefSlave						: AXIS_REF;
END_VAR
VAR_OUTPUT
	lrMasterVeloMax						: LREAL;	(* Maximum Master Velocity [°/s] *)
	lrMasterRotPerMinMax					: LREAL;	(* Maximum Master Rotations per Minute [1/min] *)
	st_ctrl_out							: struct_ctrl_out;
END_VAR
VAR
	st_sm						 		: struct_cameditor_meldungen;
	fb_state_entry							: ST_StateEntry;
	fb_ton_quitt							: TON;
	fb_ton_wz							: TON;

	stMotionFunctionPointDummy			: MC_MotionFunctionPoint;	(* Dummy-Punkt *)
(*	TYPE MC_MotionFunctionPoint :
		STRUCT
		    PointIndex        		: MC_MotionFunctionPoint_ID;
		    FunctionType   		: MC_MotionFunctionType;
		    PointType         		: MC_MotionPointType;
		    RelIndexNextPoint 	: MC_MotionFunctionPoint_ID;
		    MasterPos         		: LREAL; (* X *)
		    SlavePos          		: LREAL; (* Y *)
		    SlaveVelo         		: LREAL; (* Y' *)
		    SlaveAcc          		: LREAL; (* Y'' *)
		    SlaveJerk         		: LREAL; (* Y''' *)
		END_STRUCT
	END_TYPE
*)

	(*Motion Function runterschreiben an NC*)
	astWriteMotionFunction 				: ARRAY[1..i_MAX_NUM_MFP] OF MC_MotionFunctionPoint;
	stWriteMFCamTableRef				: MC_CAM_Ref;	(*Definition Zieltabelle*)
	fbCamTableSelect					: MC_CamTableSelect;
	fbWriteMF							: MC_WriteMotionFunction;
	b_cam_table_select_periodic			: BOOL := FALSE;
	b_cam_table_select_master_absolute	: BOOL := FALSE;
	b_cam_table_select_slave_absolute		: BOOL := FALSE;

	(*Motion Function hochladen von NC*)
	fbReadMF							: MC_ReadMotionFunction;
	stReadMFCamTableRef				: MC_CAM_Ref;	(*Definition Zieltabelle*)
	astReadMotionFunction 				: ARRAY[0..i_MAX_NUM_MFP] OF MC_MotionFunctionPoint;

	(*Berechnung Konstantfahrphase*)
	fbMFcalcConstVelo					: ST_MFcalcConstVelo;	(*Baustein zur Berechnung, ob eine Konstantfahphase möglich ist*)
	stDataCalcConstVelo 					: ARRAY[1..4] OF MC_MotionFunctionPoint;	(*Aus der Berechnung ermittelte Punktedaten*)

	(* Berechnung Mastergeschwindigkeit*)
	fbMFMaxMasterVelo					: ST_MFMaxMasterVelo;	(* Baustein zur Berechnung der maximalen Mastergeschwindigkeit *)

	(*Temporäre Variablen *)
	iPointCount							: INT := 0;
	iNumMfPoints							: INT := 0;
	i_point_nr							: INT := 0;
	err_id								: UDINT := 0;
	i16_anzahl_mfps						: INT;
	lrStartPointMaster						: LREAL;	(* Startpunkt Master [°] *)
	lrStartPointSlave						: LREAL;	(* Startpunkt Slave [mm] *)
	lrEndPointMaster						: LREAL;	(* Endpunkt Master [°] *)
	lrEndPointSlave						: LREAL;	(* Endpunkt Slave [mm] *)
	lr_anfang_cam_table					: LREAL := 0;	(* Anfang Darstellungsbereich MF-Tabelle *)
	lr_ende_cam_table					: LREAL := 0;	(* Ende Darstellungsbereich MF-Tabelle *)
END_VAR
VAR CONSTANT
	i_MAX_NUM_MFP						: INT := 100;
END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#50ms, Q=> , ET=> );

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:	(* Init *)
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fertig := FALSE;
		st_ctrl_out.b_fehler := FALSE;
		fbCamTableSelect.Execute := FALSE;
		fbWriteMF.Execute := FALSE;
		fbReadMF.Execute := FALSE;
		fbMFMaxMasterVelo.bExecute := FALSE;
		fbMFcalcConstVelo.bExecute := FALSE;
		err_id := 0;
		i16_anzahl_mfps := 0;
		st_sm.berechne_konstantfahrphase := FALSE;
		st_sm.berechne_max_master_geschwindigkeit := FALSE;
		st_sm.lese_camtable := FALSE;
		st_sm.lese_mfp := FALSE;
		st_sm.lesen_werte_mf_tab := FALSE;
		st_sm.schreibe_camtable := FALSE;
		st_sm.schreibe_mfp := FALSE;

		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte auf Start *)
		IF lrModuloValue > 0 THEN
			b_cam_table_select_periodic := TRUE;
			b_cam_table_select_master_absolute := TRUE;
			b_cam_table_select_slave_absolute := FALSE;
		ELSE
			b_cam_table_select_periodic := FALSE;
			b_cam_table_select_master_absolute := TRUE;
			b_cam_table_select_slave_absolute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_start THEN
			i16_anzahl_mfps := 0;
			lrMasterVeloMax := 0;
			lrMasterRotPerMinMax := 0;
			fb_state_entry.i16_next_step := 100;
		END_IF

(*=======================================================*)
	100:	(*  *)
		IF fb_state_entry.E THEN
			FOR i_point_nr := 1 TO i_MAX_NUM_MFP BY 1 DO
				(*Für Download: Initialisieren aller  MFPs im Array *)
				astWriteMotionFunction[i_point_nr] := stMotionFunctionPointDummy;
				astWriteMotionFunction[i_point_nr].RelIndexNextPoint  := 1;

				(* Übernahme der Daten aus der WKZ-Datenbank *)
				astWriteMotionFunction[i_point_nr].FunctionType := arr_db_mf_tab[i_point_nr].FunctionType;
				astWriteMotionFunction[i_point_nr].MasterPos  := arr_db_mf_tab[i_point_nr].MasterPos;
				astWriteMotionFunction[i_point_nr].SlavePos  := arr_db_mf_tab[i_point_nr].SlavePos;
				astWriteMotionFunction[i_point_nr].PointType  := arr_db_mf_tab[i_point_nr].PointType;
				astWriteMotionFunction[i_point_nr].PointIndex  := arr_db_mf_tab[i_point_nr].PointIndex;

				IF astWriteMotionFunction[i_point_nr].FunctionType > MOTIONFUNCTYPE_NOTDEF THEN
					i16_anzahl_mfps := i16_anzahl_mfps + 1;
				END_IF
			END_FOR

			(* Beim Letzen Punkt in der Tabelle immer den RelIndexNextPoint auf 0 setzen *)
			astWriteMotionFunction[i16_anzahl_mfps].RelIndexNextPoint := 0;

			(* Darstellungsbereich der MF-Tabelle (wird benötigt für die Funktion "MC_ReadMotionFunctionValues") *)
			IF lrModuloValue > 0 THEN
				lr_anfang_cam_table := 0;
				lr_ende_cam_table := lrModuloValue;
			ELSE
				lr_anfang_cam_table := arr_db_mf_tab[1].MasterPos;
				lr_ende_cam_table := arr_db_mf_tab[i16_anzahl_mfps].MasterPos;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 110;


(*=======================================================*)
	110:	(* Starte Berechnung der Konstantfahrphase *)
		IF fb_state_entry.E THEN
			fbMFcalcConstVelo.bExecute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbMFcalcConstVelo.bBusy THEN
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120:	(* Starte Berechnung der Konstantfahrphase *)
		IF NOT fbMFcalcConstVelo.bBusy THEN
			IF fbMFcalcConstVelo.bDone THEN
				fbMFcalcConstVelo.bExecute := FALSE;
				IF fbMFcalcConstVelo.bConstantVelo THEN
					iNumMfPoints := i16_anzahl_mfps + 2;
					fb_state_entry.i16_next_step := 130;
				ELSE
					iNumMfPoints := i16_anzahl_mfps;
					fb_state_entry.i16_next_step := 140;
				END_IF
			ELSIF fbMFcalcConstVelo.bError THEN
				st_sm.berechne_konstantfahrphase := TRUE;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	130:	(* Auswertung ob Konstantfahrphase *)
		IF fb_state_entry.E THEN
			(* Verschieben aller weiteren Punkte um 2 Positionen nach hinten *)
			FOR i_point_nr := iNumMfPoints TO (i16_startpunkt_edit_mf_tab + 1) BY -1 DO
				astWriteMotionFunction[i_point_nr] := astWriteMotionFunction[i_point_nr - 2];
				astWriteMotionFunction[i_point_nr].PointIndex := i_point_nr;
			END_FOR

			iPointCount := i16_startpunkt_edit_mf_tab;

			(*Startpunkt: spezifische Daten anpassen*)
			astWriteMotionFunction[iPointCount].MasterPos := stDataCalcConstVelo[1].MasterPos;
			astWriteMotionFunction[iPointCount].SlavePos := stDataCalcConstVelo[1].SlavePos;
			astWriteMotionFunction[iPointCount].SlaveVelo := stDataCalcConstVelo[1].SlaveVelo;
			astWriteMotionFunction[iPointCount].SlaveJerk := stDataCalcConstVelo[1].SlaveJerk;
			(*Punktetyp eintragen*)
			astWriteMotionFunction[iPointCount].RelIndexNextPoint := 1;
			astWriteMotionFunction[iPointCount].FunctionType := stDataCalcConstVelo[1].FunctionType;
			astWriteMotionFunction[iPointCount].PointIndex := iPointCount;
			astWriteMotionFunction[iPointCount].PointType := stDataCalcConstVelo[1].PointType;

			iPointCount := iPointCount + 1;

			(*Zwischenpunkt 1: Konstantfahrphase eintragen*)
			astWriteMotionFunction[iPointCount].MasterPos := stDataCalcConstVelo[2].MasterPos;
			astWriteMotionFunction[iPointCount].SlavePos := stDataCalcConstVelo[2].SlavePos;
			astWriteMotionFunction[iPointCount].SlaveVelo := stDataCalcConstVelo[2].SlaveVelo;
			astWriteMotionFunction[iPointCount].SlaveJerk := stDataCalcConstVelo[2].SlaveJerk;
			(*Punktetyp eintragen*)
			astWriteMotionFunction[iPointCount].RelIndexNextPoint := 1;
			astWriteMotionFunction[iPointCount].FunctionType := stDataCalcConstVelo[2].FunctionType;
			astWriteMotionFunction[iPointCount].PointIndex := iPointCount;
			astWriteMotionFunction[iPointCount].PointType := stDataCalcConstVelo[2].PointType;
	
			iPointCount := iPointCount + 1;
	
			(*Zwischenpunkt 2: Konstantfahrphase eintragen*)
			astWriteMotionFunction[iPointCount].MasterPos := stDataCalcConstVelo[3].MasterPos;
			astWriteMotionFunction[iPointCount].SlavePos := stDataCalcConstVelo[3].SlavePos;
			astWriteMotionFunction[iPointCount].SlaveVelo := stDataCalcConstVelo[3].SlaveVelo;
			astWriteMotionFunction[iPointCount].SlaveJerk := stDataCalcConstVelo[3].SlaveJerk;
			(*Punktetyp eintragen*)
			astWriteMotionFunction[iPointCount].RelIndexNextPoint := 1;
			astWriteMotionFunction[iPointCount].FunctionType := stDataCalcConstVelo[3].FunctionType;
			astWriteMotionFunction[iPointCount].PointIndex := iPointCount;
			astWriteMotionFunction[iPointCount].PointType := stDataCalcConstVelo[3].PointType;

			iPointCount := iPointCount + 1;

			(* Beim Letzen Punkt in der Tabelle immer den RelIndexNextPoint auf 0 setzen *)
			astWriteMotionFunction[i16_anzahl_mfps + 2].RelIndexNextPoint := 0;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 140;

(*=======================================================*)
	140:	(* Alle Punkte der MF-Tabelle werden an die NC runter geschrieben  *)
		IF fb_state_entry.E THEN
			(*Tabelle initialisieren *)
			stWriteMFCamTableRef.pArray := ADR(astWriteMotionFunction[1]);	(* Adresse des ersten eindimensionalen Arrays vom Typ MC_MotionFunctionPoint. Jedes Array-Element enthält eine Beschreibung einer Stützstelle der Kurvenscheibe. *)
			stWriteMFCamTableRef.ArraySize := SIZEOF(astWriteMotionFunction[1]) * iNumMfPoints;
			stWriteMFCamTableRef.TableType := MC_TABLETYPE_MOTIONFUNCTION;
			stWriteMFCamTableRef.NoOfColumns := 1;	(* Bei Table Type "MC_TABLETYPE_MOTIONFUNCTION" ist NoOfColumns immer 1 *)
			stWriteMFCamTableRef.NoOfRows := iNumMfPoints;

			fbCamTableSelect.Execute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbCamTableSelect.Busy THEN
			fb_state_entry.i16_next_step := 150;
		END_IF

(*=======================================================*)
	150:	(* Alle Punkte der MF-Tabelle werden an die NC runter geschrieben  *)
		IF NOT fbCamTableSelect.Busy THEN
			IF fbCamTableSelect.Done THEN
				fbCamTableSelect.Execute := FALSE;
				fb_state_entry.i16_next_step := 200;
			ELSIF fbCamTableSelect.Error THEN
				st_sm.schreibe_camtable := TRUE;
				err_id := fbCamTableSelect.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	200:	(* Lesen der MF-Tabelle von der NC  *)
		IF fb_state_entry.E THEN
			stReadMFCamTableRef.pArray := ADR(astReadMotionFunction[0]);
			stReadMFCamTableRef.ArraySize := SIZEOF(astReadMotionFunction[0]) * (iNumMfPoints + 1) ;
			stReadMFCamTableRef.NoOfColumns := 2;		(* Master und Slave Spalte*)
			stReadMFCamTableRef.NoOfRows := iNumMfPoints;
			stReadMFCamTableRef.TableType := MC_TABLETYPE_MOTIONFUNCTION;
			
			(* Für Upload initialisieren *)
			FOR iPointCount := 1 TO i_MAX_NUM_MFP DO
				astReadMotionFunction[iPointCount] := stMotionFunctionPointDummy;
			END_FOR

			fbReadMF.Execute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbReadMF.Busy THEN
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* Die gesamte MF-Tabelle hochladen  *)
		IF NOT fbReadMF.Busy THEN
			IF fbReadMF.Done THEN
				fbReadMF.Execute := FALSE;
				fb_state_entry.i16_next_step := 220;
			ELSIF fbReadMF.Error THEN
				st_sm.lese_camtable := TRUE;
				err_id := fbReadMF.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	220:	(* Grenzhubzahlberechung  *)
		IF fb_state_entry.E THEN
			fbMFMaxMasterVelo.bExecute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbMFMaxMasterVelo.bBusy THEN
			fb_state_entry.i16_next_step := 230;
		END_IF

(*=======================================================*)
	230:	(* Berechnung fertig  *)
		IF NOT fbMFMaxMasterVelo.bBusy THEN
			IF fbMFMaxMasterVelo.bDone THEN
				fbMFMaxMasterVelo.bExecute := FALSE;
				fb_state_entry.i16_next_step := 240;
			ELSIF fbMFMaxMasterVelo.bError THEN
				st_sm.berechne_max_master_geschwindigkeit := TRUE;
				err_id := fbMFMaxMasterVelo.udiErrorId;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	240:	(* Zuweisung der maximalen Mastergeschwindigkeit *)
		IF fb_state_entry.E THEN
			lrMasterVeloMax := fbMFMaxMasterVelo.lrMasterVeloMax;
			IF lrModuloValue > 0 THEN
				lrMasterRotPerMinMax := 60.0 * lrMasterVeloMax / lrModuloValue;
			ELSE
				lrMasterRotPerMinMax := 0;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 250;

(*=======================================================*)
	250:	(* Fertig  *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT st_ctrl_in.b_start THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := 10;
		END_IF

(*=======================================================*)
	FEHLER: (* Fehler *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

(* Erstellen einer neuen MF-Tabelle mit anschliessendem Füllen der Punktdaten: *)
(* Es wird eine neue Tabelle in der NC angelegt zudem werden  Master und Slave Achsen zugeordnet. *)
(* Die Länge der Tabelle mit ihren Punktdaten wird gleichzeitig mit reingeschrieben. *)
fbCamTableSelect(
	Execute:= , 
	Periodic:= b_cam_table_select_periodic,
	MasterAbsolute:= b_cam_table_select_master_absolute,
	SlaveAbsolute:= b_cam_table_select_slave_absolute,
	CamTableID:= udiTableId,
	Master := st_AxisRefMaster,
	Slave := st_AxisRefSlave,
	CamTable:= stWriteMFCamTableRef,
	Done=> ,
	Busy=> , 
	Error=> , 
	ErrorID=> );

(* Die gesamte Tabelle einlesen aus der NC *)
fbReadMF(
	Execute:= ,
	CamTableID:= udiTableId,
	PointID:= 1,
	NumPoints:= stReadMFCamTableRef.NoOfRows,
	CamTable:= stReadMFCamTableRef,
	Done=> ,
	Busy=> ,
	Error=> ,
	ErrorID=> ,
	NumPointsRead=> );

(* Die ganze oder einen Teil der MF-Tabelle schreiben *)
fbWriteMF(
	Execute:= ,
	CamTableID:= udiTableId,
	PointID:= i16_startpunkt_edit_mf_tab,
	NumPoints:= i16_anzahl_mfps,
	CamTable:= stWriteMFCamTableRef,
	Done=> ,
	Busy=> , 
	Error=> , 
	ErrorID=> );

(* Berechnen ob Konstantfahrphase möglich *)
fbMFcalcConstVelo(
	bExecute:= ,
	eMotionFunctionType:= eMotionFunctionType,
	lrStartPointMaster:= arr_db_mf_tab[i16_startpunkt_edit_mf_tab].MasterPos,
	lrStartPointSlave:= arr_db_mf_tab[i16_startpunkt_edit_mf_tab].SlavePos,
	lrEndPointMaster:= arr_db_mf_tab[i16_startpunkt_edit_mf_tab + 1].MasterPos,
	lrEndPointSlave:= arr_db_mf_tab[i16_startpunkt_edit_mf_tab + 1].SlavePos,
	lrVeloLimit:= lrVeloMax,
	lrAccLimit:= lrAccMax,
	lrDecLimit:= lrDecMax,
	lrModuloValue:= lrModuloValue,
	stData:= stDataCalcConstVelo,
	bDone=> ,
	bError=> ,
	szErrText=> ,
	bConstantVelo=> ,
	lrVeloRef=> ,	(* Momentan nicht verwendet *)
	lrAccRef=> );	(* Momentan nicht verwendet *)

(* Berechne maximal mögliche Mastergeschwindigkeit *)
fbMFMaxMasterVelo(
	bExecute:= ,
	bEvCamTableChar:= eMotionFunctionType = MOTIONFUNCTYPE_POLYNOM7_MM,
	udiSlaveTableId:= udiTableId,
	lrVeloMax:= lrVeloMax,
	lrAccMax:= lrAccMax,
	lrDecMax:= lrDecMax,
	i16_anzahl_mfps:= iNumMfPoints,
	lr_anfang_cam_table:= lr_anfang_cam_table,
	lr_ende_cam_table:= lr_ende_cam_table,
	bDone=> ,
	bError=> , 
	udiErrorId=> ,
	szErrText=> ,
	lrMasterVeloMax=> );

IF st_config.b_config_fertig THEN
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := st_sm.lese_mfp;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := st_sm.lese_camtable;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := st_sm.lesen_werte_mf_tab;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := st_sm.schreibe_mfp;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := st_sm.schreibe_camtable;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := st_sm.berechne_konstantfahrphase;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := st_sm.berechne_max_master_geschwindigkeit;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor\/Verfahrberechnungen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_MFcalcConstVelo
VAR_INPUT
	bExecute			: BOOL;
	eMotionFunctionType	: MC_MotionFunctionType;(*Bewegungsgesetz*)
	lrStartPointMaster		: LREAL;	(* Start Point Master [°] oder [mm] *)
	lrStartPointSlave		: LREAL;	(* Start Point Slave [mm] *)
	lrEndPointMaster		: LREAL;	(* End Point Master [°] oder [mm] *)
	lrEndPointSlave		: LREAL;	(* End Point Slave [mm] *)
	lrVeloLimit			: LREAL;	(*Slave Geschwindigkeitsgrenzwert [EINH/s]*)
	lrAccLimit			: LREAL;	(*Slave Beschleunigungsgrenzwert [EINH/s²]*)
	lrDecLimit			: LREAL;	(*Slave Bremsbeschleunigungsgrenzwert [EINH/s²]*)
	lrModuloValue		: LREAL;	(*Modulo-Periode des Master-Zyklus*)
END_VAR
VAR_OUTPUT
	bBusy				: BOOL;
	bDone 				: BOOL;
	bError 				: BOOL;

	bConstantVelo		: BOOL;	(* Ergebnis aus der Berechnung der Konstantfahrphase *)

	lrVeloRef			: LREAL;	(* referenced velocity *)
	lrAccRef				: LREAL;	(* referenced acceleration *)
END_VAR
VAR_IN_OUT
	stData 				: ARRAY[1..4] OF MC_MotionFunctionPoint; (*Berechnete Punktedaten*)
END_VAR
VAR
	szErrText			: STRING;		(*Error text*)
	lrVMax				: LREAL;			(*Slave Geschwindigkeit [m/s]*)
	lrAMax				: LREAL;			(*Slave Beschleunigung [m/s²]*)
	lrDMax				: LREAL;			(*Slave Verzögerung [m/s²] *)
	lrCvOrig				: LREAL;			(*Original Bewegungsgesetz*)
	lrCaOrig				: LREAL;			(*Original Bewegungsgesetz*)
	lrCv					: LREAL;			(*Polynom 5*)
	lrCa					: LREAL;			(*Polynom 5*)
	eMfType				: MC_MotionFunctionType;	(*Polynom 5*)
	lrPhiAcc				: LREAL;			(*Beschleunigungsphase*)
	lrPhiVelo				: LREAL;			(*Bewegungsphase v=const.*)
	lrPhi					: LREAL;			(*Gesamtbewegungsphase*)
	lrTAcc				: LREAL;			(*Beschleunigungszeit*)
	lrTVelo_to_TAcc		: LREAL;			(*Quotient Konstantfahrt / Beschleunigungsfahrt*)
	lrXAccOrig			: LREAL;			(*Original Beschleunigungsweg*)
	lrXAcc				: LREAL;			(*Beschleunigungsweg*)

	lrTDec				: LREAL;			(*Bremsszeit*)
	lrXDecOrig			: LREAL;			(*Original Bremssweg*)
	lrXDec				: LREAL;			(*Bremssweg*)

	lrXVelo				: LREAL;			(*Konstantfahrweg*)
	lrX					: LREAL;			(*Gesamtweg / Hub*)
	lrV					: LREAL;			(*Geschwindigkeit*)

	fb_state_entry			: ST_StateEntry;
END_VAR
(* @END_DECLARATION := '0' *)
(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0 :	(* Init*)
		bBusy := FALSE;
		bDone := FALSE;
		bError := FALSE;
		bConstantVelo := FALSE;
		szErrText := '';
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte Execute *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bExecute THEN
			bBusy := TRUE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:
		IF fb_state_entry.E THEN
			(* Die Variable lrPhi wird für lineare und runde(modulo) Master verwendet *)
 			IF lrModuloValue = 0 THEN
				(*Linearachse: Einheiten umrechnen*)
				lrX := lrEndPointSlave - lrStartPointSlave;
				lrPhi := ABS(lrEndPointMaster - lrStartPointMaster);
			ELSE
				(*Rundachse: Einheiten umrechnen*)
				lrX := lrEndPointSlave - lrStartPointSlave;
				lrPhi := MODABS(lrEndPointMaster - lrStartPointMaster, lrModuloValue);
				(* Sonderfall: phi4 - phi1 = modulowert *)
				IF (lrEndPointMaster - lrStartPointMaster = lrModuloValue) THEN
					lrPhi := lrModuloValue;
				END_IF
			END_IF

			lrVMax := lrVeloLimit;
			lrAMax := lrAccLimit;
			lrDMax := lrDecLimit;
			
			(*Bewegungsgesetz auswaehlen -> Charakteristische Werte Cv, Ca*)
			IF eMotionFunctionType = MOTIONFUNCTYPE_POLYNOM7_MM THEN
			(*Polynom 7*)
				lrCvOrig :=1.9;
				lrCaOrig :=7.51;
				eMfType := MOTIONFUNCTYPE_POLYNOM7_MM;
				lrCv :=1.9;
				lrCa :=7.51;
			
			ELSE
			(*Polynom 5*)
				lrCvOrig :=1.88;
				lrCaOrig :=5.78;
				eMfType := MOTIONFUNCTYPE_POLYNOM5_MM;
				lrCv :=1.88;
				lrCa :=5.78;
			END_IF

			(*Plausibilitaetsprüfung*)
			IF lrAMax <= 0 THEN
				fb_state_entry.i16_next_step := FEHLER;
				szErrText := 'Amax <= 0';
			ELSIF lrDMax <= 0 THEN
				fb_state_entry.i16_next_step := FEHLER;
				szErrText := 'Dmax <= 0';
			ELSIF lrVMax <= 0 THEN
				fb_state_entry.i16_next_step := FEHLER;
				szErrText := 'Vmax <= 0';
			ELSIF lrCv <= 0 THEN
				fb_state_entry.i16_next_step := FEHLER;
				szErrText := 'Cv <= 0';
			ELSIF lrCa <= 0 THEN
				fb_state_entry.i16_next_step := FEHLER;
				szErrText := 'Ca <= 0';
			ELSIF lrX = 0 THEN
				fb_state_entry.i16_next_step := FEHLER;
				szErrText := 'x = 0';
			ELSIF lrPhi <= 0 THEN
				fb_state_entry.i16_next_step := FEHLER;
				szErrText := 'phi <= 0';
			ELSE
				fb_state_entry.i16_next_step := 30;
			END_IF
		END_IF

(*=======================================================*)
	30:
		IF fb_state_entry.E THEN
			(*Berechnung: Weg, ab dem sich das Einfuegen einer Konstantfahrphase lohnt*)
			(*
			Bewegungsgesetzt der Translation: s = 0.5 * v * t = 0.5 * v^2 / a
			----------------------------------
			xAcc = 0.5 * (vmax² * Ca) / (Cv² * amax)
			xDec = 0.5 * (vmax² * Ca) / (Cv² * dmax)
			----------------------------------
			
			x		:	Gesamtweg (Hub)
			xAcc	:	Weg beim Fahren mit max. Beschleunigung, so dass die max. Geschwind. gerade erreicht wird
			xDec	:	Weg beim Fahren mit max. Verzögerung, so dass die max. Geschwind. gerade erreicht wird
			vmax	:	max. zulaessige Geschwindigkeit
			amax	:	max. zulaessige Beschleunigung
			dmax	:	max. zulaessige Verzoegerung
			Cv		:	Geschwindigkeitskennwert des Bewegungsgesetzes
			Ca		:	Beschleunigungskennwert des Bewegungsgesetzes
			*)
			
			lrXAcc := 0.5 * (lrVMax * lrVMax * lrCa) / (lrCv * lrCv * lrAMax);
			lrXAcc := F_rSign(lrX) * lrXAcc;
			lrXAccOrig := 0.5 * (lrVMax * lrVMax * lrCaOrig) / (lrCvOrig * lrCvOrig * lrAMax);
			
			lrXDec := 0.5 * (lrVMax * lrVMax * lrCa) / (lrCv * lrCv * lrDMax);
			lrXDec := F_rSign(lrX) * lrXDec;
			lrXDecOrig := 0.5 * (lrVMax * lrVMax * lrCaOrig) / (lrCvOrig * lrCvOrig * lrDMax);
			
			IF (lrXAccOrig + lrXDecOrig) < ABS(lrX) THEN
				bConstantVelo := TRUE;

				(*Berechnung Wertebereich fuer Beschleunigungsphase ohne Konstantfahrtanteil*)
				(*
				t = v / a
				--------------------------------
				tAcc = (vmax * Ca) / (Cv * amax)
				--------------------------------
				*)
				lrTAcc := (lrVMax * lrCa) / (lrAMax * lrCv);
				lrTDec := (lrVMax * lrCa) / (lrDMax * lrCv);
				(*
				---------------------------------------
				tVelo/tAcc = (x - xAcc) / (vmax * tAcc)
				---------------------------------------
				*)
				lrTVelo_to_TAcc := ABS(lrX - lrXAcc - lrXDec) / (lrVMax * (lrTAcc + lrTDec)/2);
				(*
				---------------------------------------
				tAcc = phi / {[(x - xAcc)/(vmax * tAcc)] + 1}
				---------------------------------------
				*)
				lrPhiAcc := lrPhi / (lrTVelo_to_TAcc + 1);
				lrPhiVelo := lrPhi - lrPhiAcc;

				lrXVelo := lrX - lrXAcc - lrXDec;
				lrV := lrXVelo / lrPhiVelo;

				(*Berechnete MFP Daten*)
				stData[1].FunctionType := eMfType;
				stData[1].PointType := MOTIONPOINTTYPE_VELOCITY;
				stData[1].MasterPos := lrStartPointMaster;
				stData[1].SlavePos := lrStartPointSlave;
				stData[1].SlaveVelo := lrV;
				
				stData[2].FunctionType := MOTIONFUNCTYPE_POLYNOM1;
				stData[2].PointType := MOTIONPOINTTYPE_VELOCITY;
				stData[2].MasterPos := lrStartPointMaster + (lrPhiAcc *  lrDecLimit / (lrAccLimit + lrDecLimit));
				stData[2].SlavePos := lrStartPointSlave + lrXAcc;
				stData[2].SlaveVelo := lrV;
				
				stData[3].FunctionType := eMfType;
				stData[3].PointType := MOTIONPOINTTYPE_VELOCITY;
				stData[3].MasterPos := lrEndPointMaster - (lrPhiAcc * lrAccLimit  / (lrAccLimit + lrDecLimit));
				stData[3].SlavePos := lrEndPointSlave - lrXDec;
				stData[3].SlaveVelo := lrV;
				
				stData[4].FunctionType := eMfType;
				stData[4].PointType := MOTIONPOINTTYPE_REST;
				stData[4].MasterPos := lrEndPointMaster;
				stData[4].SlavePos := lrEndPointSlave;
				stData[4].SlaveVelo := 0;
				
				lrVeloRef := ABS(lrV);
				lrAccRef := MAX(lrAccLimit,lrDecLimit) * (EXPT(lrVeloRef /lrVeloLimit,2));

			ELSE
				bConstantVelo := FALSE;
			END_IF
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40: (* Fertig *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
			bDone := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT bExecute AND NOT fb_state_entry.E THEN
			 bDone := FALSE;
			fb_state_entry.i16_next_step := 10;
		END_IF

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			bError := TRUE;
			bBusy := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT bExecute THEN
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor\/Verfahrberechnungen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_MFMaxMasterVelo
VAR_INPUT
	bExecute 						: BOOL;
	enu_mastertyp					: enum_ecd_typ;	(* Master ist Rund- oder Linearachse *)
	bEvCamTableChar				: BOOL;
	udiSlaveTableId					: MC_CAM_ID;	(* Slave Table-ID *)

	(* Bewegungsdaten Slave *)
	lrVeloMax						: LREAL;	(*maximale Geschwindigkeit [mm/s] an der Last/Slave *)
	lrAccMax							: LREAL;	(*maximale Beschleunigung [mm/s²] an der Last/Slave *)
	lrDecMax						: LREAL;	(*maximale Beschleunigung [mm/s²] an der Last/Slave *)

	i16_anzahl_mfps					: INT;
	lr_anfang_cam_table				: LREAL;
	lr_ende_cam_table				: LREAL;
END_VAR
VAR_OUTPUT
	bBusy							: BOOL;
	bDone							: BOOL;
	bError							: BOOL;
	udiErrorId						: UDINT;
	szErrText						: STRING;

	lrMasterVeloMax					: LREAL;
END_VAR
VAR
	stCamChar						: MC_TableCharacValues;	(*Charakteristika der Bewegungskurve*)
	fbReadCamTableCharacteristics	: MC_ReadCamTableCharacteristics;
	lrIncrement						: LREAL := 1;					(*Schrittweite Wertetabelle ACC / Integrationsschrittweite*)

	stVeloAccTable					: MC_CAM_Ref;
	aLrVeloAccData					: ARRAY[0..i_ANZAHL_PUNKTEMENGE,1..3] OF LREAL;	(*1..3  ->  MasterPos, SlaveVelo, SlaveAcc*)
	fbReadMotionFunctionValues		: MC_ReadMotionFunctionValues;
	(*===== INFO zu MotionFunktionValues: =====
	TYPE MC_ValueSelectType :
	(
	    (* a bitmask can be created by adding the following values *)
	    MC_VALUETYPE_POSITION     := 1,
	    MC_VALUETYPE_VELOCITY     := 2,
	    MC_VALUETYPE_ACCELERATION := 4,
	    MC_VALUETYPE_JERK         := 8
	);
	END_TYPE

	Mit der Auswahlmaske kann festgelegt werden, welche Daten interpoliert und zurückgeliefert werden soll.
	Der Wert entsteht durch Addition von Einzelwerten des Datentyps MC_ValueSelectType.
	Die Spaltenzahl der durch CamTable beschriebenen Datenstruktur muss der Anzahl der durch ValueSelectMask bestimmten Spaltenzahl entsprechen.
	Wenn zum Beispiel nur Positionsdaten gelesen werden, ist die Spaltenzahl 2 (Master- und Slave-Position).
	Mit jeder weiteren Ableitung (Geschwindigkeit, Beschleunigung, Ruck) kommt eine Spalte hinzu. *)

	lrMasterVelo1						: LREAL;	(*1.Mastergeschwindigkeit normiert aufgrund der max.Achsgeschwindigkeit*)
	lrMasterVelo2						: LREAL;	(*2.Reserve*)
	lrMasterVelo3						: LREAL;	(*3.Mastergeschwindigkeit normiert aufgrund der max.Achsbeschleunigung*)
	lrMasterVelo4						: LREAL;	(*4.Mastergeschwindigkeit normiert aufgrund der min.Achsbeschleunigung*)

	i								: INT;
	fb_state_entry						: ST_StateEntry;
END_VAR
VAR CONSTANT
	i_ANZAHL_PUNKTEMENGE		: INT := 360;
END_VAR
(* @END_DECLARATION := '0' *)
(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0 :	(* Init*)
		bBusy := FALSE;
		bDone := FALSE;
		bError := FALSE;
		udiErrorId := 0;
		szErrText := '';
		fbReadCamTableCharacteristics.Execute := FALSE;
		fbReadMotionFunctionValues.Execute := FALSE;
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte Execute *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bExecute THEN
			bBusy := TRUE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Prüfe Punktearray zur Anzeige der Punktewolke *)
		IF i16_anzahl_mfps > i_ANZAHL_PUNKTEMENGE THEN
			szErrText := 'Anzahl MFPs > Punktearray für Anzeige MF';
			fb_state_entry.i16_next_step := 1000;
		ELSE
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(*Einlesen der Cam Table Characteristics*)
		IF fb_state_entry.E THEN
			fbReadCamTableCharacteristics.Execute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbReadCamTableCharacteristics.Busy THEN
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:	(* Einlesen fertig  *)
		IF NOT fbReadCamTableCharacteristics.Busy THEN
			IF fbReadCamTableCharacteristics.Done THEN
				fbReadCamTableCharacteristics.Execute := FALSE;
				fb_state_entry.i16_next_step := 50;
			ELSIF fbReadCamTableCharacteristics.Error THEN
				udiErrorId := fbReadCamTableCharacteristics.ErrorID;
				szErrText := 'Fehler Einlesen charakteristische Daten';
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	50:	(*Geschwindigkeitsfunktion und Beschleunigungsfunktion lesen*)
		(*Upload der anzuzeigenden Punktewolke: masterPos, slaveVelo, slaveAcc mit MC_ReadMotionFunctionValues*)
		IF fb_state_entry.E THEN
			stVeloAccTable.ArraySize := SIZEOF(aLrVeloAccData);
			stVeloAccTable.pArray := ADR(aLrVeloAccData);
			stVeloAccTable.NoOfColumns := 3;	(*MasterPos, SlaveVelo, SlaveAcc*)
			stVeloAccTable.NoOfRows := i_ANZAHL_PUNKTEMENGE + 1;
			stVeloAccTable.TableType := MC_TABLETYPE_EQUIDISTANT;

			fbReadMotionFunctionValues.Execute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbReadMotionFunctionValues.Busy THEN
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60:	(* Einlesen fertig  *)
		IF NOT fbReadMotionFunctionValues.Busy THEN
			IF fbReadMotionFunctionValues.Done THEN
				fbReadMotionFunctionValues.Execute := FALSE;
				fb_state_entry.i16_next_step := 70;
			ELSIF fbReadMotionFunctionValues.Error THEN
				udiErrorId := fbReadMotionFunctionValues.ErrorID;
				szErrText := 'Beschleunigungsfunktion ungültig';
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	70:	(*  Berechnung der maximalen Mastergeschwindigkeit auf der Basis *)
		(*  der antriebsbedingten maximalen Geschwindigkeit des Slaves und der Tabelle.*)
		IF fb_state_entry.E THEN
			IF bEvCamTableChar THEN
				stCamChar.fSlaveVeloMin := 0;
				stCamChar.fSlaveVeloMax := 0;
				stCamChar.fSlaveAccMin := 0;
				stCamChar.fSlaveAccMax := 0;
				(* Ermittle Min- und Max-Werte für SlaveVelo und Slave Acc aus den interpolierten Daten in der Tabelle *)
				FOR i := 1 TO i_ANZAHL_PUNKTEMENGE DO
					IF aLrVeloAccData[i,2] > stCamChar.fSlaveVeloMax THEN
						stCamChar.fSlaveVeloMax := aLrVeloAccData[i,2];	(* an Position 2 -> SlaveVeloMax *)
					END_IF
					IF aLrVeloAccData[i,2] < stCamChar.fSlaveVeloMin THEN
						stCamChar.fSlaveVeloMin := aLrVeloAccData[i,2];	(* an Position 2 -> SlaveVeloMin *)
					END_IF
					IF aLrVeloAccData[i,3] > stCamChar.fSlaveAccMax THEN
						stCamChar.fSlaveAccMax := aLrVeloAccData[i,3];	(* an Position 3 -> SlaveAccMax *)
					END_IF
					IF aLrVeloAccData[i,3] < stCamChar.fSlaveAccMin THEN
						stCamChar.fSlaveAccMin := aLrVeloAccData[i,3];	(* an Position 3 -> SlaveAccMin *)
					END_IF
				END_FOR
			END_IF
		END_IF
		(*Fehlerbehandlung: Charakteristische Daten nicht konsistent*)
		(*Slave-Maximal- und Minimalgeschwindigkeit = 0*)
		IF stCamChar.fSlaveVeloMax = 0 AND stCamChar.fSlaveVeloMin = 0 THEN
			szErrText := 'Slave-Maximalgeschwindigkeit = 0';
			fb_state_entry.i16_next_step := 1000;
		(*Slave-Maximalbeschleunigung = 0*)
		ELSIF stCamChar.fSlaveAccMax = 0 THEN
			FOR i := 1 TO i_ANZAHL_PUNKTEMENGE DO
				IF aLrVeloAccData[i,3] > stCamChar.fSlaveAccMax THEN
					stCamChar.fSlaveAccMax := aLrVeloAccData[i,3];
				END_IF
			END_FOR
			IF stCamChar.fSlaveAccMax = 0 THEN
				szErrText := 'Slave-Maximalbeschleunigung = 0';
				fb_state_entry.i16_next_step := 1000;
			END_IF
		(*Slave-Minimalbeschleunigung = 0*)
		ELSIF stCamChar.fSlaveAccMin = 0 THEN
			FOR i := 1 TO i_ANZAHL_PUNKTEMENGE DO
				IF aLrVeloAccData[i,3] < stCamChar.fSlaveAccMin THEN
					stCamChar.fSlaveAccMin := aLrVeloAccData[i,3];
				END_IF
			END_FOR
			IF stCamChar.fSlaveAccMin = 0 THEN
				szErrText := 'Slave-Minimalbeschleunigung = 0';
				fb_state_entry.i16_next_step := 1000;
			END_IF
		(* Alles o.k. *)
		ELSE
			fb_state_entry.i16_next_step := 80;
		END_IF

	(*=======================================================*)
	80:	(*  Berechnung der maximalen Mastergeschwindigkeit  *)
		IF fb_state_entry.E THEN
			(* Im Kurvenscheibeneditor des Systemmanagers kann die "Normierte Darstellung" angehakt werden. *)
			(* Damit wird die Darstellung auf die maximale Achsgeschwindigkeit normiert. *)
			(*1.Mastergeschwindigkeit normiert aufgrund der max.Achsgeschwindigkeit*)
			(*Vs = Vm * Vf *)
			lrMasterVelo1 := ABS(lrVeloMax) / MAX(ABS(stCamChar.fSlaveVeloMin), ABS(stCamChar.fSlaveVeloMax));
			(*2.Reserve*)
			lrMasterVelo2 := lrMasterVelo1;
			(*3.Mastergeschwindigkeit normiert aufgrund der positiven Achsbeschleunigung*)
			(*As = Af(Sm)*Vm² + Vf(Sm)*Am *)
			lrMasterVelo3 := SQRT(ABS(MAX(lrAccMax,lrDecMax)) / ABS(stCamChar.fSlaveAccMax));
			(*4.Mastergeschwindigkeit normiert aufgrund der negativen Achsbeschleunigung*)
			(*As = Af(Sm)*Vm² + Vf(Sm)*Am *)
			lrMasterVelo4 := SQRT(ABS(MAX(lrAccMax,lrDecMax)) / ABS(stCamChar.fSlaveAccMin));
	
			lrMasterVeloMax := MIN(lrMasterVelo1, lrMasterVelo2);
			lrMasterVeloMax := MIN(lrMasterVeloMax, lrMasterVelo3);
			lrMasterVeloMax := MIN(lrMasterVeloMax, lrMasterVelo4);
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF lrMasterVeloMax > 0 THEN
			fb_state_entry.i16_next_step := 90;
		ELSE
			szErrText := 'Master-Maximalbeschleunigung <= 0';
			fb_state_entry.i16_next_step := 1000;
		END_IF

(*=======================================================*)
	90: (* Fertig *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
			bDone := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT bExecute AND NOT fb_state_entry.E THEN
			 bDone := FALSE;
			fb_state_entry.i16_next_step := 10;
		END_IF

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			bError := TRUE;
			bBusy := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT bExecute THEN
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

fbReadCamTableCharacteristics(
	Execute:= ,
	CamTableID:=udiSlaveTableId,
	CamTableCharac:=stCamChar,
	Done=> ,
	Busy=> ,
	Error=> , 
	ErrorID=> );

fbReadMotionFunctionValues(
	Execute:= , 
	CamTableID:= udiSlaveTableId,
	ValueSelectMask:= MC_VALUETYPE_VELOCITY + MC_VALUETYPE_ACCELERATION,
	StartPosMaster:= lr_anfang_cam_table,
	EndPosMaster:= lr_ende_cam_table,
	Increment:= lrIncrement,
	CamTable:= stVeloAccTable,
	Done=> ,
	Busy=> , 
	Error=> ,
	ErrorID=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Camtable_Maker
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;

	(* Kurvenscheibendaten *)
	udiTableId							: MC_CAM_ID;			(* Table-ID *)
	arr_db_mf_tab						: ARRAY[1..i_MAX_NUM_MFP] OF struct_db_motionfunctionpoint;	(* Vorgabe aus der Datenbank *)

	lrModuloValue 						: LREAL ;
END_VAR
VAR_IN_OUT
	st_AxisRefMaster						: AXIS_REF;
	st_AxisRefSlave						: AXIS_REF;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
END_VAR
VAR
	st_sm						 		: struct_cameditor_meldungen;
	fb_state_entry							: ST_StateEntry;
	fb_ton_quitt							: TON;
	fb_ton_wz							: TON;

	stMotionFunctionPointDummy			: MC_MotionFunctionPoint;	(* Dummy-Punkt *)
(*	TYPE MC_MotionFunctionPoint :
		STRUCT
		    PointIndex        		: MC_MotionFunctionPoint_ID;
		    FunctionType   		: MC_MotionFunctionType;
		    PointType         		: MC_MotionPointType;
		    RelIndexNextPoint 	: MC_MotionFunctionPoint_ID;
		    MasterPos         		: LREAL; (* X *)
		    SlavePos          		: LREAL; (* Y *)
		    SlaveVelo         		: LREAL; (* Y' *)
		    SlaveAcc          		: LREAL; (* Y'' *)
		    SlaveJerk         		: LREAL; (* Y''' *)
		END_STRUCT
	END_TYPE
*)

	(*Motion Function runterschreiben an NC*)
	astWriteMotionFunction 				: ARRAY[1..i_MAX_NUM_MFP] OF MC_MotionFunctionPoint;
	stWriteMFCamTableRef				: MC_CAM_Ref;	(*Definition Zieltabelle*)
	fbCamTableSelect					: MC_CamTableSelect;
	fbWriteMF							: MC_WriteMotionFunction;
	b_cam_table_select_periodic			: BOOL := FALSE;
	b_cam_table_select_master_absolute	: BOOL := FALSE;
	b_cam_table_select_slave_absolute		: BOOL := FALSE;

	(*Motion Function hochladen von NC*)
	fbReadMF							: MC_ReadMotionFunction;
	stReadMFCamTableRef				: MC_CAM_Ref;	(*Definition Zieltabelle*)
	astReadMotionFunction 				: ARRAY[0..i_MAX_NUM_MFP] OF MC_MotionFunctionPoint;

	(*Temporäre Variablen *)
	iPointCount							: INT := 0;
	iNumMfPoints							: INT := 0;
	i_point_nr							: INT := 0;
	err_id								: UDINT := 0;
	i16_anzahl_mfps						: INT;
	lrStartPointMaster						: LREAL;	(* Startpunkt Master [°] *)
	lrStartPointSlave						: LREAL;	(* Startpunkt Slave [mm] *)
	lrEndPointMaster						: LREAL;	(* Endpunkt Master [°] *)
	lrEndPointSlave						: LREAL;	(* Endpunkt Slave [mm] *)
	lr_anfang_cam_table					: LREAL := 0;	(* Anfang Darstellungsbereich MF-Tabelle *)
	lr_ende_cam_table					: LREAL := 0;	(* Ende Darstellungsbereich MF-Tabelle *)
END_VAR
VAR CONSTANT
	i_MAX_NUM_MFP						: INT := 100;
END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#50ms, Q=> , ET=> );

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:	(* Init *)
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fertig := FALSE;
		st_ctrl_out.b_fehler := FALSE;
		fbCamTableSelect.Execute := FALSE;
		fbWriteMF.Execute := FALSE;
		fbReadMF.Execute := FALSE;
		err_id := 0;
		i16_anzahl_mfps := 0;
		st_sm.lese_camtable := FALSE;
		st_sm.lese_mfp := FALSE;
		st_sm.lesen_werte_mf_tab := FALSE;
		st_sm.schreibe_camtable := FALSE;
		st_sm.schreibe_mfp := FALSE;

		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte auf Start *)
		IF lrModuloValue > 0 THEN
			b_cam_table_select_periodic := TRUE;
			b_cam_table_select_master_absolute := TRUE;
			b_cam_table_select_slave_absolute := FALSE;
		ELSE
			b_cam_table_select_periodic := FALSE;
			b_cam_table_select_master_absolute := TRUE;
			b_cam_table_select_slave_absolute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_start THEN
			i16_anzahl_mfps := 0;
			fb_state_entry.i16_next_step := 100;
		END_IF

(*=======================================================*)
	100:	(*  *)
		IF fb_state_entry.E THEN
			FOR i_point_nr := 1 TO i_MAX_NUM_MFP BY 1 DO
				(*Für Download: Initialisieren aller  MFPs im Array *)
				astWriteMotionFunction[i_point_nr] := stMotionFunctionPointDummy;
				astWriteMotionFunction[i_point_nr].RelIndexNextPoint  := 1;

				(* Übernahme der Daten aus der WKZ-Datenbank *)
				astWriteMotionFunction[i_point_nr].FunctionType := arr_db_mf_tab[i_point_nr].FunctionType;
				astWriteMotionFunction[i_point_nr].MasterPos  := arr_db_mf_tab[i_point_nr].MasterPos;
				astWriteMotionFunction[i_point_nr].SlavePos  := arr_db_mf_tab[i_point_nr].SlavePos;
				astWriteMotionFunction[i_point_nr].PointType  := arr_db_mf_tab[i_point_nr].PointType;
				astWriteMotionFunction[i_point_nr].PointIndex  := arr_db_mf_tab[i_point_nr].PointIndex;

				IF astWriteMotionFunction[i_point_nr].FunctionType > MOTIONFUNCTYPE_NOTDEF THEN
					i16_anzahl_mfps := i16_anzahl_mfps + 1;
				END_IF
			END_FOR

			(* Beim Letzen Punkt in der Tabelle immer den RelIndexNextPoint auf 0 setzen *)
			astWriteMotionFunction[i16_anzahl_mfps].RelIndexNextPoint := 0;

			(* Darstellungsbereich der MF-Tabelle (wird benötigt für die Funktion "MC_ReadMotionFunctionValues") *)
			IF lrModuloValue > 0 THEN
				lr_anfang_cam_table := 0;
				lr_ende_cam_table := lrModuloValue;
			ELSE
				lr_anfang_cam_table := arr_db_mf_tab[1].MasterPos;
				lr_ende_cam_table := arr_db_mf_tab[i16_anzahl_mfps].MasterPos;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 110;

(*=======================================================*)
	110:	(* Alle Punkte der MF-Tabelle werden an die NC runter geschrieben  *)
		IF fb_state_entry.E THEN
			iNumMfPoints := i16_anzahl_mfps;
			(*Tabelle initialisieren *)
			stWriteMFCamTableRef.pArray := ADR(astWriteMotionFunction[1]);	(* Adresse des ersten eindimensionalen Arrays vom Typ MC_MotionFunctionPoint. Jedes Array-Element enthält eine Beschreibung einer Stützstelle der Kurvenscheibe. *)
			stWriteMFCamTableRef.ArraySize := SIZEOF(astWriteMotionFunction[1]) * iNumMfPoints;
			stWriteMFCamTableRef.TableType := MC_TABLETYPE_MOTIONFUNCTION;
			stWriteMFCamTableRef.NoOfColumns := 1;	(* Bei Table Type "MC_TABLETYPE_MOTIONFUNCTION" ist NoOfColumns immer 1 *)
			stWriteMFCamTableRef.NoOfRows := iNumMfPoints;

			fbCamTableSelect.Execute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbCamTableSelect.Busy THEN
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120:	(* Alle Punkte der MF-Tabelle werden an die NC runter geschrieben  *)
		IF NOT fbCamTableSelect.Busy THEN
			IF fbCamTableSelect.Done THEN
				fbCamTableSelect.Execute := FALSE;
				fb_state_entry.i16_next_step := 200;
			ELSIF fbCamTableSelect.Error THEN
				st_sm.schreibe_camtable := TRUE;
				err_id := fbCamTableSelect.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	200:	(* Lesen der MF-Tabelle von der NC  *)
		IF fb_state_entry.E THEN
			stReadMFCamTableRef.pArray := ADR(astReadMotionFunction[0]);
			stReadMFCamTableRef.ArraySize := SIZEOF(astReadMotionFunction[0]) * (iNumMfPoints + 1) ;
			stReadMFCamTableRef.NoOfColumns := 2;		(* Master und Slave Spalte*)
			stReadMFCamTableRef.NoOfRows := iNumMfPoints;
			stReadMFCamTableRef.TableType := MC_TABLETYPE_MOTIONFUNCTION;
			
			(* Für Upload initialisieren *)
			FOR iPointCount := 1 TO i_MAX_NUM_MFP DO
				astReadMotionFunction[iPointCount] := stMotionFunctionPointDummy;
			END_FOR

			fbReadMF.Execute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbReadMF.Busy THEN
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* Die gesamte MF-Tabelle hochladen  *)
		IF NOT fbReadMF.Busy THEN
			IF fbReadMF.Done THEN
				fbReadMF.Execute := FALSE;
				fb_state_entry.i16_next_step := 220;
			ELSIF fbReadMF.Error THEN
				st_sm.lese_camtable := TRUE;
				err_id := fbReadMF.ErrorID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	220:	(* Fertig  *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT st_ctrl_in.b_start THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := 10;
		END_IF

(*=======================================================*)
	FEHLER: (* Fehler *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

(* Erstellen einer neuen MF-Tabelle mit anschliessendem Füllen der Punktdaten: *)
(* Es wird eine neue Tabelle in der NC angelegt zudem werden  Master und Slave Achsen zugeordnet. *)
(* Die Länge der Tabelle mit ihren Punktdaten wird gleichzeitig mit reingeschrieben. *)
fbCamTableSelect(
	Execute:= , 
	Periodic:= b_cam_table_select_periodic,
	MasterAbsolute:= b_cam_table_select_master_absolute,
	SlaveAbsolute:= b_cam_table_select_slave_absolute,
	CamTableID:= udiTableId,
	Master := st_AxisRefMaster,
	Slave := st_AxisRefSlave,
	CamTable:= stWriteMFCamTableRef,
	Done=> ,
	Busy=> , 
	Error=> , 
	ErrorID=> );

(* Die gesamte Tabelle einlesen aus der NC *)
fbReadMF(
	Execute:= ,
	CamTableID:= udiTableId,
	PointID:= 1,
	NumPoints:= stReadMFCamTableRef.NoOfRows,
	CamTable:= stReadMFCamTableRef,
	Done=> ,
	Busy=> ,
	Error=> ,
	ErrorID=> ,
	NumPointsRead=> );

(* Die ganze MF-Tabelle schreiben *)
fbWriteMF(
	Execute:= ,
	CamTableID:= udiTableId,
	PointID:= 1,
	NumPoints:= i16_anzahl_mfps,
	CamTable:= stWriteMFCamTableRef,
	Done=> ,
	Busy=> , 
	Error=> , 
	ErrorID=> );

IF st_config.b_config_fertig THEN
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := st_sm.lese_mfp;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := st_sm.lese_camtable;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := st_sm.lesen_werte_mf_tab;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := st_sm.schreibe_mfp;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := st_sm.schreibe_camtable;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Kurvenscheibeneditor
VAR_INPUT
 	udint_camtable_id						: UDINT;
	i16_laenge_mfp_tabelle				: UINT;
	arr_db_mfps							: ARRAY[1..ui_MAX_NUM_MFP] OF struct_db_motionfunctionpoint;	(* Vorgabe aus der Datenbank *)
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	i16_auftrag							: enum_auftrag_cameditor;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
END_VAR
VAR
	mc_point_id							: MC_MotionFunctionPoint_ID;
	mc_read_motion_function_point			: MC_ReadMotionFunctionPoint;
	mc_write_motion_function_point			: MC_WriteMotionFunctionPoint;
	arr_motion_function_points				: ARRAY[1..ui_MAX_NUM_MFP] OF MC_MotionFunctionPoint;	(* Eingelesene Kurvenscheibentabelle aus dem Systemmanager oder geschriebene MFPs an den Systemmanager *)
	udint_write_error_id 					: UDINT := 0;
	udint_read_error_id					: UDINT := 0;
	fb_state_entry							: ST_StateEntry;
	fb_ton_quitt							: TON;
	fb_ton_wz							: TON;
	fb_r_trig_ibn_lesen					: R_TRIG;
	fb_r_trig_ibn_schreiben					: R_TRIG;
	fb_ton_ibn_lesen						: TON;
	fb_ton_ibn_schreiben					: TON;
	b_ibn_lesen							: BOOL := FALSE;
	b_ibn_schreiben						: BOOL := FALSE;
	sm_fehler_schreibe_mfp 				: BOOL := FALSE;
	sm_fehler_lese_mfp					: BOOL := FALSE;
END_VAR
VAR CONSTANT
	ui_MAX_NUM_MFP					:UINT := 100;
END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

fb_r_trig_ibn_lesen(CLK:= b_ibn_lesen, Q=> );
fb_r_trig_ibn_schreiben(CLK:= b_ibn_schreiben, Q=> );
fb_ton_ibn_lesen(IN:= , PT:= t#1s, Q=> , ET=> );
fb_ton_ibn_schreiben(IN:= , PT:= t#1s, Q=> , ET=> );


IF fb_r_trig_ibn_lesen.Q THEN
	fb_ton_ibn_lesen.IN := TRUE;
ELSE
	IF fb_ton_ibn_lesen.Q THEN
		b_ibn_lesen := FALSE;
	 	fb_ton_ibn_lesen.IN := FALSE;
	END_IF
END_IF

IF fb_r_trig_ibn_schreiben.Q THEN
	fb_ton_ibn_schreiben.IN := TRUE;
ELSE
	IF fb_ton_ibn_schreiben.Q THEN
		b_ibn_schreiben := FALSE;
	 	fb_ton_ibn_schreiben.IN := FALSE;
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:	(* Init *)
		fb_ton_quitt.IN := FALSE;
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fehler := FALSE;
		i16_auftrag := MFP_KEIN_AUFTRAG;
		mc_point_id := 1;
		mc_read_motion_function_point.Execute := FALSE;
		mc_write_motion_function_point.Execute := FALSE;
		sm_fehler_schreibe_mfp := FALSE;
		sm_fehler_lese_mfp := FALSE;
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10: (* Warte auf Auftrag *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(* Motion Function Points aus der Kurvenscheibentabelle des Systemmanagers lesen *)
		IF i16_auftrag = MFP_LESEN OR fb_r_trig_ibn_lesen.Q THEN
			fb_state_entry.i16_next_step := 100;
		(* Motion Function Points von der Datenbankvorgabe in die Kurvenscheibentabelle des Systemmanagers schreiben *)
		ELSIF i16_auftrag = MFP_SCHREIBEN OR fb_r_trig_ibn_schreiben.Q THEN
			fb_state_entry.i16_next_step := 200;
		END_IF

(*=======================================================*)
	100:
		mc_point_id := 1;
		fb_state_entry.i16_next_step := 110;

(*=======================================================*)
	110:	(* Lese die einzelnen MFPs aus der Kurvenscheibentabelle des Systemmanagers *)
		IF fb_state_entry.E THEN
			mc_read_motion_function_point.Execute := TRUE;
		END_IF

		IF mc_read_motion_function_point.Busy THEN
			mc_read_motion_function_point.Execute := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120:	(* MFP wurde gelesen *)
		IF  NOT mc_read_motion_function_point.Busy THEN
			IF NOT mc_read_motion_function_point.Error THEN
				fb_state_entry.i16_next_step := 130;
			ELSE
				sm_fehler_schreibe_mfp := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	130:	(* Zum nächsten MFP *)
		IF fb_state_entry.E THEN
			mc_point_id := mc_point_id + 1;
		END_IF

		IF mc_point_id > i16_laenge_mfp_tabelle THEN
			(* Alle Punkte wurden gelesen *)
			fb_state_entry.i16_next_step := 140;
		ELSE
			(* Weitere Punkte lesen *)
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	140:	(* Lesevorgang beendet *)
		fb_state_entry.i16_next_step := 0;

(*=======================================================*)
	200:	(* Einlesen der Vorgabepunktetabelle *)
		IF fb_state_entry.E THEN
			FOR mc_point_id := 1  TO 32 BY 1DO
				arr_motion_function_points[mc_point_id].PointIndex := arr_db_mfps[mc_point_id].PointIndex;
				arr_motion_function_points[mc_point_id].FunctionType := arr_db_mfps[mc_point_id].FunctionType;
				arr_motion_function_points[mc_point_id].PointType := arr_db_mfps[mc_point_id].PointType;
				arr_motion_function_points[mc_point_id].RelIndexNextPoint := 1;
				arr_motion_function_points[mc_point_id].MasterPos := arr_db_mfps[mc_point_id].MasterPos;
				arr_motion_function_points[mc_point_id].SlavePos := arr_db_mfps[mc_point_id].SlavePos;
			END_FOR
		END_IF
		mc_point_id := 1;
		fb_state_entry.i16_next_step := 210;

(*=======================================================*)
	210:	(* Schreibe die einzelnen MFPs *)
		IF fb_state_entry.E THEN
			mc_write_motion_function_point.Execute := TRUE;
		END_IF

		IF mc_write_motion_function_point.Busy THEN
			mc_write_motion_function_point.Execute := FALSE;
			fb_state_entry.i16_next_step := 220;
		END_IF

(*=======================================================*)
	220:	(* MFP wurde geschrieben *)
		IF  NOT mc_write_motion_function_point.Busy THEN
			IF NOT  mc_write_motion_function_point.Error THEN
				fb_state_entry.i16_next_step := 230;
			ELSE
				sm_fehler_schreibe_mfp := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	230:	(* Zum nächsten MFP *)
		IF fb_state_entry.E THEN
			mc_point_id := mc_point_id + 1;
		END_IF

		IF mc_point_id > i16_laenge_mfp_tabelle THEN
			(* Alle Punkte wurden gelesen *)
			fb_state_entry.i16_next_step := 240;
		ELSE
			(* Weitere Punkte lesen *)
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	240:	(* Schreibevorgang beendet *)
		fb_state_entry.i16_next_step := 0;

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

mc_read_motion_function_point(
	Execute:= ,
	CamTableID:= udint_camtable_id,
	PointID:= mc_point_id,
	Point:= arr_motion_function_points[mc_point_id],
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );

mc_write_motion_function_point(
	Execute:= , 
	CamTableID:= udint_camtable_id,
	PointID:= mc_point_id,
	Point:= arr_motion_function_points[mc_point_id],
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );

IF st_config.b_config_fertig THEN
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_lese_mfp;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_fehler_schreibe_mfp;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Daten' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_ExporString
VAR_INPUT
	Start				:BOOL;
	Reset			:BOOL;
	ExportStr			:STRING(255);
	FileName		:STRING(255);
	Path				:STRING(255);
	Mode			:DWORD;
END_VAR
VAR_OUTPUT
	Ready				:BOOL;
	Busy				:BOOL;
	Done				:BOOL;
	Error				:BOOL;
	ErrorMsg			:STRING(255);

END_VAR
VAR
	fb_state_entry		:ST_StateEntry;
	nErrId				:UDINT;
	i					:UINT;

	fbFileOpen			:FB_FileOpen;
	fbFilePuts			:FB_FilePuts;
	fbFileClose			:FB_FileClose;

	hFile				:UINT;

	ProductionDate		:STRING;

END_VAR

VAR CONSTANT
	Zeilenumbruch		:STRING:='$R$N';
END_VAR


(* @END_DECLARATION := '0' *)
(*======================================================
   PRG: FB_ExportString
 ------------------------------------------------------
   Auth: 		Werner Friedl    						 
   Date: 		30.10.2014    						     
   Rev.: 		1.0	
   Desc:		
		
   Historie:   1.0

 ========================================================*)
fb_state_entry(i16_pos:= 1);

CASE fb_state_entry.i16_step OF

0:	(*Objekt initialisieren*)
	fb_state_entry.i16_next_step:=INIT;

10:	(*initialisieren*)
	fb_state_entry.i16_next_step:=BEREIT;

BEREIT:(*Start*)

	IF	Start THEN  (*initialisieren*)
		Start:=FALSE;
		Busy:=TRUE;
		Error:=FALSE;
		Done:=FALSE;
		nErrId:=0;
		ErrorMsg:='';
		fb_state_entry.i16_next_step:=110;

	END_IF

110: (*Datei erstellen*)

	FileName:=CONCAT(Path,FileName);

	fbFileOpen.sPathName:=FileName;
 	fbFileOpen.bExecute:=TRUE;

	IF 	NOT fbFileOpen.bBusy   THEN
		fb_state_entry.i16_next_step:=120;
	END_IF

120: (*Datei erstellen*)

	IF 	NOT fbFileOpen.bBusy THEN
		fbFileOpen.bExecute:=FALSE;
		IF 	fbFileOpen.bError THEN
			nErrId:=fbFileOpen.nErrId;
			fb_state_entry.i16_next_step:=FEHLER;
			ErrorMsg:='Fehler beim Öffnen der Datei';
		ELSE
			fb_state_entry.i16_next_step:=130;
		END_IF
	END_IF

130: (*String in Datei eintragen*)
	IF fb_state_entry.E THEN
		;
	END_IF

	fbFilePuts.sLine:=CONCAT(ExportStr,Zeilenumbruch);
	fbFilePuts.bExecute:=TRUE;

	IF  fbFilePuts.bBusy THEN
		fb_state_entry.i16_next_step:=140;
	END_IF

140: (*String in Datei eintragen*)

	IF 	NOT fbFilePuts.bBusy THEN
		fbFilePuts.bExecute:=FALSE;
		IF 	fbFilePuts.bError THEN
			nErrId:=fbFilePuts.nErrId;
			fb_state_entry.i16_next_step:=150;
			ErrorMsg:='Fehler beim String Eintragen in der Datei';
			Error:=TRUE;
		ELSE
			fb_state_entry.i16_next_step:=150;
		END_IF
	END_IF

150:(*Datei schließen*)

	fbFileClose.bExecute:=TRUE;
	IF 	fbFileClose.bBusy THEN
		fb_state_entry.i16_next_step:=160;
	END_IF

160:(*Datei schließen*)

	IF NOT fbFileClose.bBusy THEN
		fbFileClose.bExecute:=FALSE;
		IF 	fbFileClose.bError THEN
			nErrId:=fbFileClose.nErrId;
			ErrorMsg:='Fehler beim Schließen der Datei';
			Error:=TRUE;
		ELSE
			fb_state_entry.i16_next_step:=170;
		END_IF
	END_IF

	IF	Error THEN
		fb_state_entry.i16_next_step:=FEHLER;
	END_IF

170: (*fertig*)
	Busy:=FALSE;
	Done:=TRUE;
	fb_state_entry.i16_next_step:=10;

FEHLER: (*Fehler*)
	fb_state_entry.i16_next_step:=10;
	Busy:=FALSE;
	Error:=TRUE;
END_CASE

fb_state_entry(i16_pos:= 2 );

fbFileOpen(
	sNetId:='',
	sPathName:= ,
	nMode:=mode,
	ePath:=PATH_GENERIC,
	bExecute:= ,
	tTimeout:=T#1s,
	hFile=> hFile);

fbFilePuts(
	sNetId:='',
	hFile:=hFile,
	sLine:= ,
	bExecute:= ,
	tTimeout:=t#1s);

fbFileClose(
	sNetId:='',
	hFile:=hFile,
	bExecute:= ,
	tTimeout:=t#1s);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Daten' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_StartWinProcess
VAR_INPUT
	st_ctrl_in			:struct_ctrl_in;
	st_config			: struct_config;
	s_path				:STRING(255);		(*Pfad der Bat- oder vbs- Datei*)
	s_info_file			:STRING(255);		(*Pfad + Dateiname der Statusdatei*)
	s_script				:STRING;
	i16_Timeout			:INT;			(*in sec*)
	b_Start				:BOOL;
END_VAR
VAR_OUTPUT
	st_ctrl_out				:struct_ctrl_out;
	ErrId					:UDINT;
	ErrTyp					:STRING(5);
	ErrorMsg				:STRING(255);
	MsgString				:STRING(255);
END_VAR
VAR
	b_init					:BOOL;
	fb_state_entry			:ST_StateEntry;

	NT_StartProcess 		:NT_StartProcess;
	fbFileOpen				:FB_FileOpen;
	fbFileRead				:FB_FileRead;
	fbFileClose				:FB_FileClose;
	fbFileDelete				:FB_FileDelete;
	hFile					:UINT;

	fb_ton_wz				:TON;
	fb_ton_quitt				:TON;
	pos						:INT;
	FileString				:STRING(255);
	i16_Time				:INT;	(*in sec*)
	i						:INT;
	b_sm					:ARRAY[0..9] OF BOOL;	(*Störmeldungen aus der bat oder vbs Datei*)
	b_bm					:ARRAY[0..9] OF BOOL;	(*Bertiebsmeldungen aus der bat oder vbs Datei*)
	(*sonstige Meldungen*)
	sm_DateiNichtVorhanden				:BOOL;
	sm_FehlerBeimOeffnenDerDatei		:BOOL;
	sm_FehlerBeimAuslesenDerDatei		:BOOL;
	sm_FehlerBeimSchliessenDerDatei		:BOOL;
	sm_FehlerBeimLoeschenDerDatei		:BOOL;
	sm_KeineImportdateiVorhanden		:BOOL;
	sm_KeineErrIdGefunden				:BOOL;
END_VAR

(* @END_DECLARATION := '0' *)
(*======================================================
   FB: Start eines Win Prozess mit Prüfung 
 ------------------------------------------------------
   Auth: 		Werner Friedl   						 
   Date: 		19.02.2019   						     
   Rev.: 		1.0	
   Desc:		Eine Bat- oder vbs- Datei kann gestartet weden und der Status kommt über die ErrId wieder zurück.
			Die "ErrId" wird dann b_sm[ErrId] oder b_bm[ErrId], Damit können Betriebs und Störmeldungen von der bat angezeigt werden. 
			alle Meldungen quittieren sich selbst
			b_bm[0] =	'OK',
			b_sm[1] =	Netzwerk nicht verbunden!
			b_sm[2] =	User nicht vorhanden oder Passwort falsch!
			b_sm[3] =	Verzeichnis nicht vorhanden!
			b_sm[4] =	Datei nicht vorhanden!

   Historie:   1.0

   Aufruf Beispiel:
	s_instanz_name:='test',
	s_path:= 		s_tools_path,			(*Verzeichnis der Bat- und Prüf- Datei*)
	s_info_file:=	CONCAT(s_tools_path,'Test.txt') ,	(*Datei in der die Prüfung landet (sollte so heißen wie die Bat-Datei)*)
	s_script:=		'Test.bat' ,				(*auszuführende Datei bat oder vbs eintragen*)
	i16_Timeout:= 100);					(*in sec*)

 ========================================================*)
IF	NOT b_init THEN
	b_Init:=TRUE;
END_IF
(* ========================================================*)
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

fb_state_entry(i16_pos:= 1);
CASE fb_state_entry.i16_step OF
(*=======================================================*)
INIT_OBJ:
		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
INIT:	(*initialisieren*)
	IF fb_state_entry.E THEN
		fb_ton_quitt.IN := FALSE;
		st_ctrl_out.b_fehler := FALSE;
		st_ctrl_out.b_gestoppt := FALSE;
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fertig := FALSE;
		st_ctrl_out.b_busy := FALSE;

		sm_DateiNichtVorhanden:=FALSE;
		sm_FehlerBeimOeffnenDerDatei:=FALSE;
		sm_FehlerBeimAuslesenDerDatei:=FALSE;
		sm_FehlerBeimSchliessenDerDatei:=FALSE;
		sm_FehlerBeimLoeschenDerDatei:=FALSE;
		sm_KeineImportdateiVorhanden:=FALSE;
		sm_KeineErrIdGefunden:=FALSE;
		FOR i:=0 TO 9 DO
			b_sm[i]:=FALSE;
			b_bm[i]:=FALSE;
		END_FOR
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	fb_state_entry.i16_next_step:=BEREIT;

(*=======================================================*)
BEREIT: fb_state_entry.s_debugtext:='warte auf start';

	IF fb_state_entry.E THEN
		st_ctrl_out.b_bereit:=TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	st_ctrl_in.b_start THEN
		NT_StartProcess.START:=TRUE;
		fb_state_entry.i16_next_step:=110;
	END_IF

	IF fb_state_entry.X THEN
		i16_Time:=0;
		st_ctrl_out.b_busy:=TRUE;
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fertig := FALSE;
		ErrId:=99;
		ErrorMsg:='';
		FileString:='';
		MsgString:='';
	END_IF

	IF 	fb_state_entry.X THEN
		NT_StartProcess.START:=FALSE;
	END_IF

(*=======================================================*)
110:  fb_state_entry.s_debugtext:='start Datei öffnen';

	IF	fb_state_entry.fb_ton_Step.ET > t#1s THEN
		fbFileOpen.sPathName:=s_info_file;
   		fbFileOpen.bExecute:=TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	fbFileOpen.bBusy THEN
		fb_state_entry.i16_next_step:=120;
	END_IF

	IF 	fb_state_entry.X THEN
		ErrorMsg:='';
		st_ctrl_out.b_fehler:=FALSE;
	END_IF

(*=======================================================*)
120:  fb_state_entry.s_debugtext:='warte auf fertig Datei öffnen';

	IF 	NOT fbFileOpen.bBusy AND fb_state_entry.i16_next_step=120 THEN
		fbFileOpen.bExecute:=FALSE;
		IF	NOT fbFileOpen.bError THEN
			fb_state_entry.i16_next_step:=130;
		ELSIF
			fb_state_entry.fb_ton_Step.ET > t#1000ms THEN

			IF	i16_Time<=i16_Timeout THEN (*Datei nicht vorhanden*)
				fb_state_entry.i16_next_step:=110;
				i16_Time:=i16_Time+1;
			ELSE
				ErrId:=fbFileOpen.nErrId;
				fb_state_entry.i16_next_step:=FEHLER;

				IF 	fbFileOpen.nErrId =1804 THEN (*Datei nicht vorhanden*)
					sm_DateiNichtVorhanden:=TRUE;
					ErrorMsg:='Info Datei nicht vorhanden';
				ELSE
					sm_FehlerBeimOeffnenDerDatei:=TRUE;
					ErrorMsg:='Fehler beim Öffnen der Datei.';
				END_IF

			END_IF

		END_IF
	END_IF

(*=======================================================*)
130:  fb_state_entry.s_debugtext:='Start String aus Datei auslesen';

	fbFileRead.bExecute:=TRUE;
	IF 	fbFileRead.bBusy THEN
		fb_state_entry.i16_next_step:=140;
	END_IF

(*=======================================================*)
140:  fb_state_entry.s_debugtext:='warte auf fertig String aus Datei auslesen';

	IF 	NOT fbFileRead.bBusy THEN
		fbFileRead.bExecute:=FALSE;
		IF 	fbFileRead.bError THEN
			ErrId:=fbFileRead.nErrId;
			fb_state_entry.i16_next_step:=FEHLER;
			sm_FehlerBeimAuslesenDerDatei:=TRUE;
			ErrorMsg:='Fehler beim Auslesen der Datei.';
		ELSE
			fb_state_entry.i16_next_step:=150;
		END_IF
	END_IF

(*=======================================================*)
150: fb_state_entry.s_debugtext:='start Datei schließen';

	fbFileClose.bExecute:=TRUE;
	IF 	fbFileClose.bBusy THEN
		fb_state_entry.i16_next_step:=160;
	END_IF

(*=======================================================*)
160: fb_state_entry.s_debugtext:='warte auf fertig Datei schließen';

	IF 	NOT fbFileClose.bBusy THEN
		fbFileClose.bExecute:=FALSE;
		IF 	fbFileClose.bError THEN
			ErrId:=fbFileClose.nErrId;
			fb_state_entry.i16_next_step:=FEHLER;
			sm_FehlerBeimSchliessenDerDatei:=TRUE;
			ErrorMsg:='Fehler beim Schließen der Datei.';
		ELSE
			fb_state_entry.i16_next_step:=190;
		END_IF
	END_IF

(*=======================================================*)
170: fb_state_entry.s_debugtext:='start Datei löschen';

	fbFileDelete.bExecute:=TRUE;
	fbFileDelete.sPathName:=s_info_file;
	IF 	fbFileDelete.bBusy THEN
		fb_state_entry.i16_next_step:=180;
	END_IF

(*=======================================================*)
180: fb_state_entry.s_debugtext:='warte auf fertig Datei löschen';

	IF 	NOT fbFileDelete.bBusy THEN
		fbFileDelete.bExecute:=FALSE;
		IF 	fbFileDelete.bError THEN
			ErrId:=fbFileDelete.nErrId;
			fb_state_entry.i16_next_step:=FEHLER;
			sm_FehlerBeimLoeschenDerDatei:=TRUE;
			ErrorMsg:='Fehler beim löschen der Datei.';
		ELSE
			fb_state_entry.i16_next_step:=190;
		END_IF
	END_IF

(*=======================================================*)
190: fb_state_entry.s_debugtext:='Auswertung';

	IF 	fb_state_entry.E THEN
		MsgString:=FileString;

		(*falls noch ein Text mitkommt*)
		pos:=0;
		pos:=FIND (MsgString,'$N');
		IF 	pos >0 THEN
			ErrTyp:=LEFT(MsgString,pos-1);
			ErrId:=STRING_TO_INT(DELETE(ErrTyp,2,1));
			MsgString:=DELETE(MsgString,LEN(MsgString)-pos+2,pos);
		END_IF

		pos:=0;
		pos:=FIND (MSGString,'$T');
		IF 	pos >0 THEN
			MsgString:=DELETE(MsgString,1,pos);
		END_IF

	END_IF

	IF	LEN(FileString) = 0 THEN
		fb_state_entry.i16_next_step:=FEHLER;
		sm_KeineImportdateiVorhanden:=TRUE;
		ErrorMsg:='Kein Importstring vorhanden.';
	ELSE
		IF	ErrId <>99 THEN
			IF	FIND(ErrTyp,'BM') > 0 THEN
				b_bm[ErrId]:=TRUE;
			ELSIF	FIND(ErrTyp,'SM') > 0 THEN
				b_sm[ErrId]:=TRUE;
			END_IF
			fb_state_entry.i16_next_step:=200;
		ELSE
			sm_KeineErrIdGefunden:=TRUE;
			ErrorMsg:='**Error Id not found**';
			fb_state_entry.i16_next_step:=FEHLER;
		END_IF
	END_IF

(*=======================================================*)
200: fb_state_entry.s_debugtext:='Fertig';

	IF	fb_state_entry.fb_ton_Step.ET >t#5s THEN
		IF	FIND(ErrTyp,'BM') > 0 THEN
			fb_state_entry.i16_next_step:=INIT;
			st_ctrl_out.b_fertig:=TRUE;
		ELSE
			fb_state_entry.i16_next_step:=FEHLER;
		END_IF

	END_IF

	IF fb_state_entry.X THEN
		st_ctrl_out.b_busy:=FALSE;
	END_IF

(*=======================================================*)
STOP, FEHLER:

	IF fb_state_entry.E THEN
		st_ctrl_out.b_fehler := fb_state_entry.i16_step = FEHLER;
		st_ctrl_out.b_gestoppt := fb_state_entry.i16_step = STOP;
		st_ctrl_out.b_busy:=FALSE;
		fb_ton_wz.IN:=TRUE;
	END_IF

	IF	fb_state_entry.fb_ton_Step.ET >t#5s THEN   (*Quittiert sich selbst*)
		fb_state_entry.i16_next_step:=INIT;
	END_IF

	IF fb_state_entry.X THEN
		fb_ton_wz.IN:=FALSE;
	END_IF

END_CASE
(*=======================================================*)
fb_state_entry(i16_pos:= 2);
st_ctrl_in:=st_ctrl_in_empty;

(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die Meldungsarrays des fb_Fehlermeldung schreiben *)
garr_stoermeldungen[st_config.i16_meld_startindex +0] := b_sm[0];
garr_stoermeldungen[st_config.i16_meld_startindex +1] := b_sm[1];		(*Netzwerk nicht verbunden*)
garr_stoermeldungen[st_config.i16_meld_startindex +2] := b_sm[2];		(*User nicht vorhanden oder Passwort falsch*)
garr_stoermeldungen[st_config.i16_meld_startindex +3] := b_sm[3];		(*Verzeichnis nicht vorhanden!*)
garr_stoermeldungen[st_config.i16_meld_startindex +4] := b_sm[4];		(*Datei nicht vorhanden!*)
garr_stoermeldungen[st_config.i16_meld_startindex +5] := b_sm[5];
garr_stoermeldungen[st_config.i16_meld_startindex +6] := b_sm[6];
garr_stoermeldungen[st_config.i16_meld_startindex +7] := b_sm[7];
garr_stoermeldungen[st_config.i16_meld_startindex +8] := b_sm[8];
garr_stoermeldungen[st_config.i16_meld_startindex +9] := b_sm[9];
garr_stoermeldungen[st_config.i16_meld_startindex +10] := sm_DateiNichtVorhanden;
garr_stoermeldungen[st_config.i16_meld_startindex +11] := sm_FehlerBeimOeffnenDerDatei;
garr_stoermeldungen[st_config.i16_meld_startindex +12] := sm_FehlerBeimAuslesenDerDatei;
garr_stoermeldungen[st_config.i16_meld_startindex +13] := sm_FehlerBeimSchliessenDerDatei;
garr_stoermeldungen[st_config.i16_meld_startindex +14] := sm_FehlerBeimLoeschenDerDatei;
garr_stoermeldungen[st_config.i16_meld_startindex +15] := sm_KeineImportdateiVorhanden;
garr_stoermeldungen[st_config.i16_meld_startindex +16] := sm_KeineErrIdGefunden;
garr_stoermeldungen[st_config.i16_meld_startindex +17] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex +18] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex +19] := FALSE;

garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := b_bm[0];		(*OK*)
garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := b_bm[1];		(*keinen Unterschied gefunden*)
garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := b_bm[2];
garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := b_bm[3];
garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := b_bm[4];
garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := b_bm[5];
garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := b_bm[6];
garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := b_bm[7];
garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := b_bm[8];
garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := b_bm[9];


CallPrg();
END_FUNCTION_BLOCK
ACTION	CallPrg:
IF 	FIND(s_script,'.bat') > 0 THEN


	NT_StartProcess(
		NETID:='',
		PATHSTR		:='C:\Windows\System32\cmd.exe',
		DIRNAME		:=s_path,
		COMNDLINE	:=CONCAT('/C start /b ', s_script),
		START			:=,
		TMOUT			:=DEFAULT_ADS_TIMEOUT);

ELSE
	NT_StartProcess(
		NETID:='',
		PATHSTR	:='C:\Windows\System32\wscript.exe',
		DIRNAME	:=s_path,
		COMNDLINE	:=s_script,
		START		:=,
		TMOUT		:=DEFAULT_ADS_TIMEOUT);
END_IF

fbFileOpen(
	sNetId:='',
	sPathName:= ,
	nMode:=FOPEN_MODEREAD,
	ePath:=PATH_GENERIC,
	bExecute:= ,
	tTimeout:=T#1s,
	hFile=> hFile);

fbFileRead(
	sNetId:='' ,
	hFile:=hFile,
	pReadBuff:= ADR(FileString)  ,
	cbReadLen:=SIZEOF(FileString)  ,
	tTimeout:=t#2s );

fbFileClose(
	sNetId:='',
	hFile:=hFile,
	bExecute:= ,
	tTimeout:=t#1s);

fbFileDelete(
	sNetId:= ,
	sPathName:= , 
	ePath:= PATH_GENERIC,
	bExecute:= ,
	tTimeout:= t#1s );
END_ACTION




(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Daten' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_AutoCheckIn
VAR_INPUT
	st_ctrl_in				: struct_ctrl_in;
	fb_AutocheckinDaten	: FB_StartWinProcess;
	i_IntervalDay				: INT;		(*all  X Tagen, 0 = jeden Tag*)
END_VAR
VAR_OUTPUT
	st_ctrl_out				: struct_ctrl_out;
END_VAR
VAR
	fb_state_entry			:ST_StateEntry;
	fb_ton_quitt				:TON;

	str_uhrzeit				:STRING;
	i_DayOfYear			:DINT;
	s_infoFile				:STRING;
	s_ScriptFile				:STRING;

END_VAR

VAR CONSTANT
		s_AutoCheckInMDtxt				:STRING:=		'AutoCheckInMD.txt';
		s_AutoCheckInMDBat				:STRING:=		'AutoCheckInMD.bat';

END_VAR

(* @END_DECLARATION := '0' *)
(*======================================================
   FB: Start eines Win Prozess mit Prüfung 
 ------------------------------------------------------
   Auth: 		Werner Friedl   						 
   Date: 		19.02.2019   						     
   Rev.: 		1.0	
   Desc:		Mit diesem Programm Können Komponenten im Versdog automatisch eingecheckt werden.
			Für den Check in benötigt man einen Bat- Datei. Diese liegt im Projektverzeichniss "Tools" und 
			muss für jede Komponente erstellt werden.
			Wenn mehrere Komponeten Eingecheckt werden sollen muss der Schritt 110 bis 120 mehrfach
			ausgefühtr werden.

			- die Input Variable "i16_Intervall" legt den Seicherintervall in x Tagen fest.
			Wenn das Speichern nicht klappt, dann wird einen Tag später der nächste Versuch gemacht.

   Historie:   1.0

=======================================================*)

(* Zeiten *)
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Tag im Jahr *)
i_DayOfYear:=F_GetDOYOfYearMonthDay( gst_system_time.wYear, gst_system_time.wMonth, gst_system_time.wDay );

fb_state_entry(i16_pos:= 1);

CASE fb_state_entry.i16_step OF

(*=======================================================*)
INIT_OBJ:

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	gst_datensatz.st_md.i16_typ_zelle <> KEINE_ZELLE AND
		gstr_uhrzeit <> '00:00:00' AND gstr_uhrzeit <> ''  THEN
		IF	gst_PersDaten.i_DayOfYearAutoCheckIn > i_DayOfYear THEN
			gst_PersDaten.i_DayOfYearAutoCheckIn:= i_DayOfYear;
		END_IF
			fb_state_entry.i16_next_step := 5;
	END_IF

(*=======================================================*)
5:
	IF fb_state_entry.E THEN
		str_uhrzeit:=gstr_uhrzeit;
		(*str_uhrzeit:=REPLACE (str_uhrzeit,'00',2,1);*)	(*nur in der Nacht sichern*)
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	fb_state_entry.fb_ton_Step.ET > t#59s THEN
		IF	gst_PersDaten.i_DayOfYearAutoCheckIn + i_IntervalDay < i_DayOfYear  THEN
			fb_state_entry.i16_next_step:=110;		(*gleich sicher, da das letzte Sichern zu lange her ist*)
		ELSE
			fb_state_entry.i16_next_step:=INIT;
		END_IF
	END_IF

(*=======================================================*)
INIT:
	IF fb_state_entry.E THEN
		fb_ton_quitt.IN := FALSE;
		st_ctrl_out.b_fehler := FALSE;
		st_ctrl_out.b_gestoppt := FALSE;
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fertig := FALSE;
		st_ctrl_out.b_busy := FALSE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	fb_state_entry.i16_next_step := BEREIT;

(*=======================================================*)
BEREIT: fb_state_entry.s_debugtext:='warte auf Start';

	IF fb_state_entry.E THEN
		st_ctrl_out.b_bereit:=TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	str_uhrzeit=gstr_uhrzeit AND
		(gst_PersDaten.i_DayOfYearAutoCheckIn + i_IntervalDay) <= i_DayOfYear THEN
		fb_state_entry.i16_next_step:=110;
	END_IF

	IF fb_state_entry.X THEN
		st_ctrl_out.b_busy:=TRUE;
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fertig := FALSE;
	END_IF

(*=======================================================*)
110:  fb_state_entry.s_debugtext:='Start Autocheckin';

	IF fb_state_entry.E THEN
		s_infoFile:=s_AutoCheckInMDtxt;
		s_ScriptFile:=s_AutoCheckInMDBat;
		fb_AutocheckinDaten.st_ctrl_in.b_start:=TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	fb_AutocheckinDaten.st_ctrl_out.b_busy THEN
		fb_state_entry.i16_next_step:=120;
	ELSIF	fb_state_entry.fb_ton_Step.ET > t#15s THEN
		fb_state_entry.i16_next_step:=FEHLER;
	END_IF

(*=======================================================*)
120:  fb_state_entry.s_debugtext:='Warte auf fertig Autocheckin';

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	fb_AutocheckinDaten.st_ctrl_out.b_fertig THEN
		fb_state_entry.i16_next_step:=200;
	ELSIF
		fb_state_entry.fb_ton_Step.ET > t#59s OR
		fb_AutocheckinDaten.st_ctrl_out.b_fehler THEN
		fb_state_entry.i16_next_step:=FEHLER;
		gst_PersDaten.i_DayOfYearAutoCheckIn:=i_DayOfYear - i_IntervalDay+1; (*bei einem Fehler wird die nächst Sicherung einen Tag später nochmal gemacht*)
	END_IF

(*=======================================================*)
200:  fb_state_entry.s_debugtext:='Ende';

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	fb_state_entry.i16_next_step:=BEREIT;
	gst_PersDaten.i_DayOfYearAutoCheckIn:=i_DayOfYear;
	IF fb_state_entry.X THEN
		st_ctrl_out.b_busy:=FALSE;
		st_ctrl_out.b_fertig := TRUE;
	END_IF

(*=======================================================*)
STOP, FEHLER:
	IF fb_state_entry.E THEN
		st_ctrl_out.b_fehler := fb_state_entry.i16_step = FEHLER;
		st_ctrl_out.b_gestoppt := fb_state_entry.i16_step = STOP;
		fb_ton_quitt.IN := FALSE;
		st_ctrl_out.b_busy:=FALSE;
		st_ctrl_out.b_fertig:=FALSE;
		fb_ton_quitt.IN := TRUE;				(*quttiert sich selbst*)
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	st_ctrl_in.b_quitt THEN
		fb_ton_quitt.IN := TRUE;
	END_IF

	IF fb_ton_quitt.Q THEN
		fb_ton_quitt.IN := FALSE;
		st_ctrl_out.b_fehler := FALSE;
		fb_state_entry.i16_next_step := INIT;
	END_IF

END_CASE

fb_state_entry(i16_pos:= 2 );
st_ctrl_in:=st_ctrl_in_empty;


(*Aufrufe======================================================*)
fb_AutocheckinDaten(
	s_path:= 			s_tools_path,								(*Verzeichnis der bat,vbs und Prüf- Datei*)
	s_info_file:=			CONCAT(s_tools_path,s_infoFile) ,			(*Datei in der die Prüfung landet*)
	s_script:=			s_ScriptFile ,								(*auszuführende Datei bat oder vbs eintragen*)
	i16_Timeout:= 	100);											(*in sec*)
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Daten' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_SaveAndLoad
VAR_INPUT
	st_ctrl_in			: struct_ctrl_in;
	st_config			: struct_config;

END_VAR
VAR_OUTPUT
	st_ctrl_out			:struct_ctrl_out;
END_VAR
VAR
	b_init				:BOOL;
	fb_state_entry		:ST_StateEntry;
	fb_ton_quitt			:TON;

	NT_StartProcess 	: NT_StartProcess;
	fbFileDelete			: FB_FileDelete;

	s_script				: STRING;
	sm_FehlerBeimStartenDerBat				:BOOL;
	sm_FehlerBeimLoeschenDerDatei		:BOOL;

END_VAR
VAR CONSTANT
		s_bbgenMachineToSrv				:STRING:=		'_bbgen_aktuelles_wz_und_band_von_zelle_nach_server.bat';

		s_bbgenSrvToMachine				:STRING:=		'_bbgen_von_server_nach_zelle.bat';
		s_bbgenSrvToMachineHalbauto		:STRING:=		'_bbgen_von_server_nach_zelle_halbauto.bat';
		s_bbgenSrvToMachineManuell		:STRING:=		'_bbgen_von_server_nach_zelle_manuell.bat';

		s_fbwf_info							:STRING:=		'fbwf_info.bat';
		s_fbwf_disable						:STRING:=		'fbwf_disable.bat';
		s_fbwf_enable						:STRING:=		'fbwf_enable.bat';
END_VAR


(* @END_DECLARATION := '0' *)
(*======================================================
   ST_SaveAndLoad
 ------------------------------------------------------
   Auth: 		Werner Friedl   						 
   Date: 		06.10.2020   						     
   Rev.: 		1.0	
   Desc:		Die bat Datein zum laden und speichern der BBgen Dateien werden hier ausgeführt.
			mit der Constante b_wkzBereinigen kann bestimmt werden, ob die Werkzeugdateu forher gelöscht wird.

 ========================================================*)
IF	NOT b_init THEN
	b_Init:=TRUE;
END_IF
CallPrg();
(* ========================================================*)
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );



fb_state_entry(i16_pos:= 1);
CASE fb_state_entry.i16_step OF
(*=======================================================*)
INIT_OBJ:
		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
INIT:
	IF	fb_state_entry.E THEN
		sm_FehlerBeimStartenDerBat:=FALSE;
		sm_FehlerBeimLoeschenDerDatei:=FALSE;
	END_IF

		fb_state_entry.i16_next_step := BEREIT;


(*=======================================================*)
BEREIT:	fb_state_entry.s_debugtext:='warte auf Taster Save oder Load';

	IF fb_state_entry.E THEN
		st_ctrl_out.b_bereit:=TRUE;
		NT_StartProcess.START:=FALSE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	visu.b_load THEN
		fb_state_entry.i16_next_step:=110;
	ELSIF
		visu.b_save THEN
		IF 	gst_datensatz.st_md.b_wkzBereinigen THEN
			fb_state_entry.i16_next_step:=210;
		ELSE
			fb_state_entry.i16_next_step:=240;
		END_IF
	ELSIF
		visu.b_fbwf_info THEN
		s_script:=s_fbwf_info;
		fb_state_entry.i16_next_step:=120;
	ELSIF
		visu.b_fbwf_disable THEN
		s_script:=s_fbwf_disable;
		fb_state_entry.i16_next_step:=120;
	ELSIF
		visu.b_fbwf_enable THEN
		s_script:=s_fbwf_enable;
		fb_state_entry.i16_next_step:=120;
	END_IF

	IF fb_state_entry.X THEN
		st_ctrl_out.b_busy:=TRUE;
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fertig := FALSE;
	END_IF

(*=======================================================*)
110:fb_state_entry.s_debugtext:='erstelle s_script';

	IF fb_state_entry.E THEN

 		CASE gst_datensatz.st_md.i16_typ_bestueckmodus OF

			BESTUECKUNG_MANUAL:
				s_script:=CONCAT(visu.s_akt_sprache,s_bbgenSrvToMachineManuell);

			BESTUECKUNG_HALBAUTO:
				s_script:=CONCAT(visu.s_akt_sprache,s_bbgenSrvToMachineHalbauto);

			BESTUECKUNG_AUTO:
				s_script:=CONCAT(visu.s_akt_sprache,s_bbgenSrvToMachine);
		END_CASE

		fb_state_entry.i16_next_step:=120;
	END_IF

(*=======================================================*)
120:fb_state_entry.s_debugtext:='start bat Script "Laden der Dateien vom Server"';

	IF 	fb_state_entry.E THEN
		NT_StartProcess.START:=TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	NT_StartProcess.BUSY THEN
		fb_state_entry.i16_next_step:=130;
	END_IF

	IF 	fb_state_entry.X THEN
		NT_StartProcess.START:=FALSE;
	END_IF

(*=======================================================*)
130:fb_state_entry.s_debugtext:='Warten auf fertig';

	IF 	NT_StartProcess.ERR THEN
		fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,' ERRID => ');
		fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,UDINT_TO_STRING(NT_StartProcess.ERRID));
		sm_FehlerBeimStartenDerBat:=TRUE;
		fb_state_entry.i16_next_step:=FEHLER;
	ELSIF
		NOT NT_StartProcess.BUSY AND
		NOT NT_StartProcess.ERR AND
		fb_state_entry.fb_ton_Step.ET>t#3000ms THEN
		st_ctrl_out.b_busy:=FALSE;
		st_ctrl_out.b_fertig := TRUE;
		fb_state_entry.i16_next_step:=BEREIT;
	END_IF

	IF 	fb_state_entry.X THEN
		visu.b_fbwf_info:=FALSE;
		visu.b_fbwf_disable:=FALSE;
		visu.b_fbwf_enable:=FALSE;
		visu.b_load:=FALSE;
	END_IF

(*=======================================================*)
(*=======================================================*)
210:	fb_state_entry.s_debugtext:='Löschen der Werkzeug Datei';

	IF 	fb_state_entry.E THEN
		fbFileDelete.sPathName:=CONCAT(CONCAT(ST_BBGen.s_wkz_path,gst_datensatz.st_md.s_aktuelles_wkz),'.xml');
		fbFileDelete.bExecute:=TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	fbFileDelete.bBusy THEN
		fb_state_entry.i16_next_step:=220;
	END_IF

	IF 	fb_state_entry.X THEN
		fbFileDelete.bExecute:=FALSE;
	END_IF

(*=======================================================*)
220: fb_state_entry.s_debugtext:='warte auf fertig';

	IF 	NOT fbFileDelete.bBusy THEN
		IF 	fbFileDelete.bError THEN
			fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,' ERRID => ');
			fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,UDINT_TO_STRING(fbFileDelete.nErrId));
			fb_state_entry.i16_next_step:=FEHLER;
			sm_FehlerBeimLoeschenDerDatei:=TRUE;
		ELSE
			fb_state_entry.i16_next_step:=230;
		END_IF
	END_IF

(*=======================================================*)
230: fb_state_entry.s_debugtext:='Werkzeugdatei neu erstellen';

	IF 	fb_state_entry.E THEN
		gi16_bbgen_auftrag:=SCHREIBE_WKZ;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	gi16_bbgen_auftrag = KEIN_BB_AUFTRAG THEN
		fb_state_entry.i16_next_step:=240;
	END_IF

(*=======================================================*)
240:	fb_state_entry.s_debugtext:='Speichern auf Server';

	IF 	fb_state_entry.E THEN
		s_script:=CONCAT(visu.s_akt_sprache,s_bbgenMachineToSrv);
		NT_StartProcess.START:=TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	NT_StartProcess.BUSY THEN
		fb_state_entry.i16_next_step:=250;
	END_IF

	IF 	fb_state_entry.X THEN
		NT_StartProcess.START:=FALSE;
	END_IF

(*=======================================================*)
250:fb_state_entry.s_debugtext:='Warten auf fertig';

	IF 	NT_StartProcess.ERR THEN
		fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,' ERRID => ');
		fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,UDINT_TO_STRING(NT_StartProcess.ERRID));
		sm_FehlerBeimStartenDerBat:=TRUE;
		fb_state_entry.i16_next_step:=FEHLER;
	ELSIF
		NOT NT_StartProcess.BUSY AND
		NOT NT_StartProcess.ERR AND
		fb_state_entry.fb_ton_Step.ET>t#3000ms THEN
		st_ctrl_out.b_busy:=FALSE;
		st_ctrl_out.b_fertig := TRUE;
		fb_state_entry.i16_next_step:=BEREIT;
	END_IF

	IF 	fb_state_entry.X THEN
		visu.b_save:=FALSE;
	END_IF

(*=======================================================*)
STOP, FEHLER:

	IF fb_state_entry.E THEN
		st_ctrl_out.b_fehler := fb_state_entry.i16_step = FEHLER;
		st_ctrl_out.b_gestoppt := fb_state_entry.i16_step = STOP;
		st_ctrl_out.b_busy:=FALSE;
	END_IF

	IF	fb_state_entry.fb_ton_Step.ET > t#1000ms THEN   (*Quittiert sich selbst*)
		fb_state_entry.i16_next_step:=INIT;
	END_IF

END_CASE

fb_state_entry(i16_pos:= 2 );
st_ctrl_in:=st_ctrl_in_empty;


garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_FehlerBeimStartenDerBat;
garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_FehlerBeimLoeschenDerDatei;
garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;

garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;

END_PROGRAM
ACTION	CallPrg:
NT_StartProcess(
	NETID:='',
	PATHSTR		:='C:\Windows\System32\cmd.exe',
	DIRNAME		:=s_tools_path,
	COMNDLINE	:=CONCAT('/C start /b ', s_script),
	START			:=,
	TMOUT			:=DEFAULT_ADS_TIMEOUT);


fbFileDelete(
	sNetId:= ,
	sPathName:= , 
	ePath:= PATH_GENERIC,
	bExecute:= ,
	tTimeout:= t#1s );
END_ACTION




(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Ethercat Diagnose' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_EtherCatDiag
VAR_INPUT
	st_config					: struct_config;
	st_ctrl_in					: struct_ctrl_in;
END_VAR
VAR_OUTPUT
	st_ctrl_out						: struct_ctrl_out;
END_VAR
VAR
	fb_state_entry					: ST_StateEntry;
	visu_Data						: struct_EthercatDiagnose;
	fb_ton_start						: TON;
	fb_ton_quitt						: TON;
	FB_EcGetAllSlaveStates			: FB_EcGetAllSlaveStates;
	by_AmsNetId					AT %I* : T_AmsNetIdArr;			(*Muss verknüpft werden*)
	s_AmsNetId					: T_AmsNetId := '0.0.0.0.0.0';	(* Master ID*)
	st_EcSlaveStateData			: ARRAY[1..MaxNoOfSlaves] OF ST_EcSlaveState;
	i_Slaves						: INT; 						(* Anzahl konfigurierter Slaves*)
	i								: INT;
	nErrId							: UDINT;

	sm_FehlerEthercat				: BOOL;

	FB_EcGetConfSlaves			: FB_EcGetConfSlaves;
	st_EcGetConfSlavesData		: ARRAY[1..MaxNoOfSlaves] OF ST_EcSlaveConfigData;


	fb_EcMasterFrameStatistic		: FB_EcMasterFrameStatistic;
END_VAR
(* @END_DECLARATION := '0' *)
(*======================================================
   ST: Fb_EtherCatDiag
 ------------------------------------------------------
   Auth: 	Thomas Vilgis, Werner Friedl    						 
   Date: 	25.01.2019    						     
   Rev.: 		1.1	
   Desc:		1.0	
				Der Baustein liest alle Zustände der Slaves aus.
   				Es muss nur die Variable "by_AmsNetId" mit dem EtherCAT Master verknüpt werden.
				Die maximale Anzahl an Slaves wird durch die globale Konstante "MaxNoOfSlaves" begrenzt.
				In der Visu werden die ausgelesenen Daten wie im Systemmanager angezeigt.
				Es wird eine Fehlermeldung ausgegeben, dass mindestens ein Teilnehmer nicht OP ist.
				Dies wird aber nur gemacht, wenn "st_config.b_station_aktiv" TRUE ist.
			1.1 
				UP und Down Button entfernt
				Var visu_Data.st_Slave[1].b_Err hinzugefüt => damit werden in der Visu Zeilen im Fehler farbig dargestellt.
			
   Historie: 	1.0

 ========================================================*)

(* Zeiten *)
fb_ton_start(IN:= NOT fb_ton_start.Q, PT:= T#2s, Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
(* Flanken *)

(* ======================================Schrittkette======================================== *)
fb_state_entry(i16_pos:= 1);

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:	(*initialisieren*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step:=INIT;
		END_IF
		
(*=======================================================*)
	INIT:	(*initialisieren*)
		IF fb_state_entry.E THEN
			fb_EcGetAllSlaveStates.bExecute := FALSE;
			fb_EcGetConfSlaves.bExecute := FALSE;
			fb_EcMasterFrameStatistic.bExecute := FALSE;
			sm_FehlerEthercat := FALSE;

			(*Umwandeln in einen String*)
			s_AmsNetId := F_CreateAmsNetId(by_AmsNetId);
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF s_AmsNetId <> '0.0.0.0.0.0' THEN
			fb_state_entry.i16_next_step:=20;
		END_IF

(*=======================================================*)
	20:(* Baustein zum Abfragen der Configuration starten*)
		IF fb_state_entry.E THEN
			fb_EcGetConfSlaves.bExecute:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	fb_EcGetConfSlaves.bBusy THEN
			fb_state_entry.i16_next_step:=30;
		END_IF

(*=======================================================*)
	30:(* Warte auf Baustein *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_EcGetConfSlaves.bBusy THEN
			fb_EcGetConfSlaves.bExecute:=FALSE;
			IF 	fb_EcGetConfSlaves.bError THEN
				nErrId:=fb_EcGetConfSlaves.nErrorId;
				fb_state_entry.i16_next_step:=FEHLER;
			ELSE
				fb_state_entry.i16_next_step:=BEREIT;
			END_IF
		END_IF
		
(*=======================================================*)
	BEREIT:	(*  *)
		IF fb_state_entry.E THEN
			LeseDaten();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_start.Q THEN
			fb_state_entry.i16_next_step:=110;
		END_IF

(*=======================================================*)
	110:(* Baustein zum Abfragen des Status starten*)
		IF fb_state_entry.E THEN
			fb_EcGetAllSlaveStates.bExecute:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	fb_EcGetAllSlaveStates.bBusy THEN
			fb_state_entry.i16_next_step:=120;
		END_IF

(*=======================================================*)
	120:(* Warte auf Baustein *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_EcGetAllSlaveStates.bBusy THEN
			fb_EcGetAllSlaveStates.bExecute:=FALSE;
			IF 	fb_EcGetAllSlaveStates.bError THEN
				nErrId:=fb_EcGetAllSlaveStates.nErrId;
				fb_state_entry.i16_next_step:=FEHLER;
			ELSE
				i_Slaves := UINT_TO_INT(fb_EcGetAllSlaveStates.nSlaves);
				fb_state_entry.i16_next_step:=130;
			END_IF
		END_IF

(*=======================================================*)
	130:(* Prüfe, ob ein Slave einen Fehler hat *)
		IF fb_state_entry.E THEN
			sm_FehlerEthercat := FALSE;
			(*Fehlermeldung nur ausgeben, wenn Sation aktiv ist*)
			IF st_config.b_station_aktiv THEN
				FOR i:= 1 TO i_Slaves DO
					IF st_EcSlaveStateData[i].deviceState <> EC_DEVICE_STATE_OP THEN
						visu_Data.st_Slave[i].b_Err:=TRUE;
						sm_FehlerEthercat := TRUE;
						(*-----------------------Weiterschaltbedingungen----------------------------*)
						fb_state_entry.i16_next_step:=FEHLER;
					ELSE
						visu_Data.st_Slave[i].b_Err:=FALSE;
						(*-----------------------Weiterschaltbedingungen----------------------------*)
						fb_state_entry.i16_next_step:=140;
					END_IF
				END_FOR
			END_IF
		END_IF

(*=======================================================*)
	140:(* Baustein zum Abfragen der Lost Frames starten*)
		IF fb_state_entry.E THEN
			fb_EcMasterFrameStatistic.bExecute:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	fb_EcMasterFrameStatistic.bBusy THEN
			fb_state_entry.i16_next_step:=150;
		END_IF

(*=======================================================*)
	150:(* Warte auf Baustein *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_EcMasterFrameStatistic.bBusy THEN
			fb_EcMasterFrameStatistic.bExecute:=FALSE;
			IF 	fb_EcMasterFrameStatistic.bError THEN
				nErrId:=fb_EcMasterFrameStatistic.nErrId;
				fb_state_entry.i16_next_step:=FEHLER;
			ELSE
				fb_state_entry.i16_next_step:=BEREIT;
			END_IF
		END_IF



(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

END_CASE


fb_state_entry(i16_pos:= 2);


(*Aufruf*)
fb_EcGetAllSlaveStates(
	sNetId:= s_AmsNetId, 
	pStateBuf:= ADR(st_EcSlaveStateData),
	cbBufLen:= SIZEOF(st_EcSlaveStateData));

fb_EcGetConfSlaves(
	sNetId:= s_AmsNetId,
	pArrEcConfSlaveInfo:= ADR(st_EcGetConfSlavesData),
	cbBufLen:= SIZEOF(st_EcGetConfSlavesData) );

fb_EcMasterFrameStatistic(
	sNetId:= s_AmsNetId);
	


IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_FehlerEthercat;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;

	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
END_IF

END_FUNCTION_BLOCK
ACTION	LeseDaten:
(*Master Daten übergeben*)
visu_Data.ST_Master.s_Name := st_config.str_instanz_name;
visu_Data.st_Master.s_AmsNetId := s_AmsNetId;
visu_Data.st_Master.i_Slaves := i_Slaves;
visu_Data.st_Master.f_FramesPerSeconed := fb_EcMasterFrameStatistic.fFramesPerSecond;
visu_Data.st_Master.i_LostFrames := fb_EcMasterFrameStatistic.nLostFrames;

(*Slave Daten übergeben*)
FOR i:=1 TO MaxNoOfSlaves DO
	visu_Data.st_Slave[i].i_Number := i;
	IF st_EcGetConfSlavesData[i].nAddr <> 0 THEN
		visu_Data.st_Slave[i].s_Adress := WORD_TO_STRING(st_EcGetConfSlavesData[i].nAddr);
	END_IF
	visu_Data.st_Slave[i].s_Name := st_EcGetConfSlavesData[i].sName;
	visu_Data.st_Slave[i].s_Type := st_EcGetConfSlavesData[i].sType;

	visu_Data.st_Slave[i].s_DeviceState := F_ConvStateToString(st_EcSlaveStateData[i].deviceState);

	(*Link State wird von TwinCAT aus Status und Port-Nummer zusammengebaut*)
	CASE st_EcSlaveStateData[i].linkState OF
		0:
			;	(*alles OK*)
		1:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' NO_COMM');
			
		18:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' LINK_WITHOUT_COMM A');
		34:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' LINK_WITHOUT_COMM B');
		66:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' LINK_WITHOUT_COMM C');
		130:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' LINK_WITHOUT_COMM D');
			
		20:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' MISSING_LINK A');
		36:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' MISSING_LINK B');
		68:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' MISSING_LINK C');
		132:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' MISSING_LINK D');
			
		24:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' ADDITIONAL_LINK A');
		40:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' ADDITIONAL_LINK B');
		72:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' ADDITIONAL_LINK C');
		136:
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' ADDITIONAL_LINK D');
		
		ELSE
			visu_Data.st_Slave[i].s_DeviceState := CONCAT(visu_Data.st_Slave[i].s_DeviceState, ' undefined');
	END_CASE
END_FOR
END_ACTION




(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Ethercat Diagnose' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_EthercatDiag
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_ton_quitt					: TON;
	fb_ton_wz					: TON;
	fb_state_entry					: ST_StateEntry;
	fb_get_local_ams_netid		: ST_GetLocalAMSNetID;
	id							:  INT := 0;
	s_ec_slave_net_id			: ARRAY[0..8] OF  T_AmsNetId;
	arr_ec_slave_net_id			AT %I* : ARRAY[0..8] OF  T_AmsNetIdArr;

	sm_fehler_netid				: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_wz(IN:= , PT:= t#10s , Q=> , ET=> );

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:	(* Initialisierung *)
		st_ctrl_out.b_fehler := FALSE;
		st_ctrl_out.b_fertig := FALSE;
		st_ctrl_out.b_bereit := FALSE;
		fb_get_local_ams_netid.bExecute := FALSE;
		fb_get_local_ams_netid.bQuit := FALSE;
		sm_fehler_netid := FALSE;

		FOR id := 0  TO (SIZEOF (arr_ec_slave_net_id) / SIZEOF (arr_ec_slave_net_id[0]))-1 BY 1DO
			s_ec_slave_net_id[id] := '';
		END_FOR

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_get_local_ams_netid.bReady THEN
			fb_state_entry.i16_next_step := 10;
		END_IF

(*=======================================================*)
	10:	(* Die AMS-NetID des lokalen PC ermitteln *)
		IF fb_state_entry.E THEN
			fb_get_local_ams_netid.bExecute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_get_local_ams_netid.bBusy THEN
			fb_get_local_ams_netid.bExecute := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_get_local_ams_netid.bBusy  AND fb_get_local_ams_netid.bReady THEN
			IF NOT fb_get_local_ams_netid.bError THEN
				fb_state_entry.i16_next_step := 30;
			ELSE	(* Fehler *)
				sm_fehler_netid := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	30:	(* Umwandeln der Slave NetId von der Arrayform in die Stringform *)
		IF fb_state_entry.E THEN
			FOR id := 0  TO (SIZEOF (arr_ec_slave_net_id) / SIZEOF (arr_ec_slave_net_id[0]))-1 BY 1DO
				s_ec_slave_net_id[id] := F_CreateAmsNetId(nIds := arr_ec_slave_net_id[id]);
			END_FOR
		END_IF

		st_ctrl_out.b_fertig := TRUE;

(*=======================================================*)
	FEHLER: (* Fehler *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			fb_get_local_ams_netid.bExecute := FALSE;
			fb_get_local_ams_netid.bQuit := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_get_local_ams_netid .bQuit := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

fb_get_local_ams_netid(
	bExecute:= , 
	bQuit:= , 
	bBusy=> , 
	bReady=> , 
	bError=> , 
	nErrId=> , 
	s_ams_netid=> );

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen\/Checks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION CheckBounds : DINT
VAR_INPUT
	index, lower, upper 	: DINT;
END_VAR
VAR
END_VAR

(* @END_DECLARATION := '0' *)
IF index<lower THEN
	CheckBounds_ErrCnt := CheckBounds_ErrCnt + 1;
	CheckBounds := lower;
ELSIF index>upper THEN
	CheckBounds_ErrCnt := CheckBounds_ErrCnt + 1;
	CheckBounds := upper;
ELSE
	CheckBounds := index;
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen\/Checks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION CheckDivByte : BYTE
VAR_INPUT
	divisor			 	: BYTE;
END_VAR
VAR
END_VAR

(* @END_DECLARATION := '0' *)
IF divisor = 0 THEN
	CheckByteZeroDiv_ErrCnt := CheckByteZeroDiv_ErrCnt + 1;
	CheckDivByte := 1;
ELSE
	CheckDivByte := divisor;
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen\/Checks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION CheckDivDWord : DWORD
VAR_INPUT
	divisor				: DWORD;
END_VAR
VAR
END_VAR

(* @END_DECLARATION := '0' *)
IF divisor = 0 THEN
	CheckDWordZeroDiv_ErrCnt := CheckDWordZeroDiv_ErrCnt + 1;
	CheckDivDWord := 1;
ELSE
	CheckDivDWord := divisor;
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen\/Checks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION CheckDivReal : REAL
VAR_INPUT
	divisor		 		: REAL;
END_VAR
VAR
END_VAR

(* @END_DECLARATION := '0' *)
IF divisor = 0 THEN
	CheckRealZeroDiv_ErrCnt := CheckRealZeroDiv_ErrCnt + 1;
	CheckDivReal := 1;
ELSE
	CheckDivReal := divisor;
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen\/Checks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION CheckDivWord : WORD
VAR_INPUT
	divisor				: WORD;
END_VAR
VAR
END_VAR

(* @END_DECLARATION := '0' *)
IF divisor = 0 THEN
	CheckWordZeroDiv_ErrCnt:= CheckWordZeroDiv_ErrCnt + 1;
	CheckDivWord := 1;
ELSE
	CheckDivWord := divisor;
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen\/Checks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION CheckRangeSigned : DINT
VAR_INPUT
    value, lower, upper: DINT;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
IF (value < lower) THEN
	CheckRangeSigned_ErrCnt := CheckRangeSigned_ErrCnt + 1;
	CheckRangeSigned := lower;
ELSIF(value > upper) THEN
	CheckRangeSigned_ErrCnt := CheckRangeSigned_ErrCnt + 1;
	CheckRangeSigned := upper;
ELSE
	CheckRangeSigned := value;
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen\/Checks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION CheckRangeUnsigned : UDINT
VAR_INPUT
    value, lower, upper: UDINT;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
IF (value < lower) THEN
	CheckRangeUnSigned_ErrCnt := CheckRangeUnsigned_ErrCnt + 1;
	CheckRangeUnsigned := lower;
ELSIF(value > upper) THEN
	CheckRangeUnsigned_ErrCnt := CheckRangeUnsigned_ErrCnt + 1;
	CheckRangeUnsigned := upper;
ELSE
	CheckRangeUnsigned := value;
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION BOOLARRAY_TO_BYTE : BYTE
VAR_INPUT
	p_adr_buffer			: POINTER TO ARRAY[0..7] OF BOOL;
END_VAR
VAR
	tmp_buffer			: ARRAY[0..7] OF BOOL;
	tmp_byte				: BYTE;
	i16_index			: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* Aus einem Boolarray, soll ein Byte entstehen *)
tmp_buffer := p_adr_buffer^;

tmp_byte := 2#0;

FOR i16_index := 7 TO 0 BY -1 DO
	tmp_byte := tmp_byte OR BOOL_TO_BYTE(tmp_buffer[i16_index]);
	IF i16_index > 0 THEN
		tmp_byte := SHL(tmp_byte, 1);
	END_IF
END_FOR;

BOOLARRAY_TO_BYTE := tmp_byte; (* Rückgabewert der Funktion *)
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION BOOLARRAY_TO_DWORD : DWORD
VAR_INPUT
	p_adr_buffer			: POINTER TO ARRAY[0..31] OF BOOL;
END_VAR
VAR
	tmp_buffer			: ARRAY[0..31] OF BOOL;
	tmp_dword			: DWORD;
	i16_index			: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* Aus einem Boolarray, soll ein Doppelword entstehen *)
tmp_buffer := p_adr_buffer^;

tmp_dword := 2#0;

FOR i16_index := 31 TO 0 BY -1 DO
	tmp_dword := tmp_dword OR BOOL_TO_DWORD(tmp_buffer[i16_index]);
	IF i16_index > 0 THEN
		tmp_dword := SHL(tmp_dword, 1);
	END_IF
END_FOR;

BOOLARRAY_TO_DWORD := tmp_dword; (* Rückgabewert der Funktion *)
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION BOOLARRAY_TO_WORD : WORD
VAR_INPUT
	p_adr_buffer			: POINTER TO ARRAY[0..15] OF BOOL;
END_VAR
VAR
	tmp_buffer			: ARRAY[0..15] OF BOOL;
	tmp_word			: WORD;
	i16_index			: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* Aus einem Boolarray, soll ein Word entstehen *)
tmp_buffer := p_adr_buffer^;

tmp_word := 2#0;

FOR i16_index := 15 TO 0 BY -1 DO
	tmp_word := tmp_word OR BOOL_TO_WORD(tmp_buffer[i16_index]);
	IF i16_index > 0 THEN
		tmp_word := SHL(tmp_word, 1);
	END_IF
END_FOR;

BOOLARRAY_TO_WORD := tmp_word; (* Rückgabewert der Funktion *)
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION BYTEARRAY_TO_STRING_WITH_DELIMITER : STRING
VAR_INPUT
	p_adr_buffer			: POINTER TO ARRAY[0..100] OF BYTE;
	i16_buffer_laenge		: INT;
	str_delimiter			: STRING; (* Punkt zum trennen der einzelnen Zahlen in der Net-Adresse *)
END_VAR
VAR
	tmp_buffer			: ARRAY[0..100] OF BYTE;
	tmp_string			: STRING;
	i16_index			: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* Aus einem Bytearray, welches die einzelnen Zahlen der Net-Adresse beinhaltet wird ein String erzeugt, welcher die Zahlen getrennt durch Punkte enthält *)
tmp_buffer := p_adr_buffer^;

tmp_string := ''; (* leerer String *)
FOR i16_index := 0 TO i16_buffer_laenge - 1 DO
	tmp_string :=CONCAT(tmp_string ,BYTE_TO_STRING(tmp_buffer[i16_index]));
	IF i16_index < i16_buffer_laenge - 1 THEN
		tmp_string := CONCAT(tmp_string,str_delimiter); (* "Punkt" einfügen in den String *)
	END_IF;
END_FOR;

BYTEARRAY_TO_STRING_WITH_DELIMITER := tmp_string; (* Rückgabewert der Funktion *)
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION DT_TO_SPECIALSTRING_YYYY_MM : STRING
VAR_INPUT
	inDT					:	DT;
END_VAR
VAR

	TempString		:	STRING;
	SysTime				:	TIMESTRUCT;


	wYear					: WORD;
	wMonth				: WORD;
	wDay					: WORD;
	wHour					: WORD;
	wMin					: WORD;
	wSec					: WORD;
END_VAR
(* @END_DECLARATION := '0' *)
(*gVarStrSystemTime:=SYSTEMTIME_TO_STRING(gFB_GETLOCALSYSTEMTIME.systemTime);
gVarDTSystemtime:=SYSTEMTIME_TO_DT(gFB_GETLOCALSYSTEMTIME.SystemTime);
gVarSystemtime:=gFB_GETLOCALSYSTEMTIME.systemTime;
*)

SysTime:=DT_TO_SYSTEMTIME(inDT);

wYear:=SysTime.wYear;
wMonth:=SysTime.wMonth;
wDay:=SysTime.wDay;
wHour:=SysTime.wHour;
wMin:=SysTime.wMinute;
wSec:=SysTime.wSecond;
TempString:='';

TempString:=CONCAT(TempString ,WORD_TO_STRING(wYear));
TempString:=CONCAT(TempString ,'_');

IF wMonth<10 THEN	TempString:=CONCAT(TempString ,WORD_TO_STRING(0)); END_IF;
TempString:=CONCAT(TempString ,WORD_TO_STRING(wMonth));


DT_TO_SPECIALSTRING_YYYY_MM:=TempString;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION ET_TO_STRING :STRING
VAR_INPUT
	et		:TIME;
END_VAR

VAR
	i16_LEN	:INT;
END_VAR

(* @END_DECLARATION := '0' *)
ET_TO_STRING:=TIME_TO_STRING(et);
ET_TO_STRING:=DELETE(ET_TO_STRING,2,1);

IF 	et> t#60s THEN
	ET_TO_STRING:=LEFT(ET_TO_STRING,FIND(ET_TO_STRING,'s'));
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION F_rSign : LREAL
VAR_INPUT
	rValue		:LREAL;	(*Zahl*)
END_VAR


(* @END_DECLARATION := '0' *)
IF rValue >= 0 THEN
	F_rSign := 1;
ELSE
	F_rSign := -1;
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION F_Vergleich_LReal : BOOL
VAR_INPUT
	lr_wert			: LREAL;
	lr_vergleichswert	: LREAL;
END_VAR
VAR
	lr_toleranz		: LREAL := 0.02;
END_VAR
(* @END_DECLARATION := '0' *)
IF ABS(lr_wert - lr_vergleichswert) < lr_toleranz THEN
	F_Vergleich_LReal := TRUE;
ELSE
	F_Vergleich_LReal := FALSE;
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION F_Vergleich_Real : BOOL
VAR_INPUT
	r_wert			: REAL;
	r_vergleichswert	: REAL;
END_VAR
VAR
	r_toleranz		: REAL := 0.001;
END_VAR
(* @END_DECLARATION := '0' *)
IF ABS(r_wert - r_vergleichswert) < r_toleranz THEN
	F_Vergleich_Real := TRUE;
ELSE
	F_Vergleich_Real := FALSE;
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION Scale : REAL
VAR_INPUT
	i16Messwert : INT;
	i16MessbereichUnten : INT;
	i16MessbereichOben : INT;
	rSkaleUnten : REAL;
	rSkaleOben : REAL;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(* Überwachung auf Division durch Null*)
IF i16MessbereichOben <> i16MessbereichUnten THEN

Scale := ( rSkaleOben - rSkaleUnten ) * i16Messwert / ( i16MessbereichOben - i16MessbereichUnten );

END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION WORD_TO_BOOLARRAY : ARRAY[0..15] OF BOOL
VAR_INPUT
	p_inputword			: WORD;
END_VAR
VAR
	tmp_bytearray		: ARRAY[0..15] OF BOOL;
	tmp_word			: WORD;
	i16_index			: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* Aus einem Word, soll ein Boolarray entstehen *)
tmp_word := p_inputword;

FOR i16_index := 15 TO 0 BY -1 DO
	tmp_bytearray[i16_index] := WORD_TO_BOOL(tmp_word AND 16#8000);
	tmp_word := SHL(tmp_word, 1);
END_FOR;

WORD_TO_BOOLARRAY := tmp_bytearray; (* Rückgabewert der Funktion *)
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION WORD_TO_STR_LEN :STRING(255)
VAR_INPUT
	w_In		:WORD;
	i_Len		:INT:=1;
END_VAR

VAR
	i			:INT;
	i_LenIn		:INT;
	s_Help		:STRING(255);

END_VAR




(* @END_DECLARATION := '0' *)
(*
der INT Wert wird in einen String umgewandelt und mit 0 aufgefüllt oder 
abgeschnitten auf die deffinierte Länge *)

s_Help:=WORD_TO_STRING(w_In);
i_LenIn:=LEN(s_Help);

IF	i_LenIn < i_Len THEN
	FOR i := 1 TO i_Len - i_LenIn DO
		s_Help:=CONCAT('0',s_Help);
	END_FOR

ELSIF
	i_LenIn > i_Len THEN
	s_Help:=RIGHT(s_Help,i_Len);
END_IF

WORD_TO_STR_LEN:=s_Help;

END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine\/Nockenschaltwerke\/NSW_INT' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Nockenschaltwerk_int
VAR_INPUT
	i16_achsposition							: INT;
	i16_achsgeschwindigkeit					: INT;
	st_config									: struct_config;
END_VAR
VAR_IN_OUT
	st_visu									: struct_visu;
	arr_nocken								: ARRAY [0..15] OF struct_nocken_int;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	b_first_cycle 								: BOOL := TRUE;
	i16_aktuelle_pos 							: INT := 0;
	i16_alte_pos	 							: INT := 0;
	r_zeit_fuer_1einheit						: REAL := 0.0;
	i16_anfangspos_mit_tzk 					: ARRAY [0..15] OF INT := 0;
	i16_endpos_mit_tzk 						: ARRAY [0..15] OF INT := 0;
	i16_vorsteuerpos_max						: INT := 0;
	b_verfahrrichtung_positiv 					: BOOL := FALSE;
	b_verfahrrichtung_negativ					: BOOL := FALSE;
	sm_positionseingabe						: BOOL := FALSE;
	sm_vorsteuerung							: BOOL := FALSE;
	sp, no									: UINT := 0;
	arr_spur									: ARRAY [0..15] OF BOOL;
	b_setzustand_anfang_kleiner_ende			: ARRAY [0..15] OF BOOL;
	b_setzustand_anfang_groesser_ende		: ARRAY [0..15] OF BOOL;
	b_resetzustand_anfang_kleiner_ende		: ARRAY [0..15] OF BOOL;
	b_resetzustand_anfang_groesser_ende		: ARRAY [0..15] OF BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Funktionsbaustein Nockenschaltwerk *)
IF b_first_cycle THEN
	b_first_cycle := FALSE;
	i16_vorsteuerpos_max := 60;
	b_verfahrrichtung_positiv := TRUE;
	b_verfahrrichtung_negativ := FALSE;
	i16_alte_pos := i16_aktuelle_pos;
END_IF

(* Aktuelle Position für weitere Komponenten zur Verfügung stellen *)
i16_aktuelle_pos := i16_achsposition;

(* Verfahrrichtung überwachen *)
IF i16_aktuelle_pos > i16_alte_pos THEN
	b_verfahrrichtung_positiv := TRUE;
	b_verfahrrichtung_negativ := FALSE;
	i16_alte_pos := i16_aktuelle_pos;
ELSIF i16_aktuelle_pos < i16_alte_pos THEN
	b_verfahrrichtung_positiv := FALSE;
	b_verfahrrichtung_negativ := TRUE;
	i16_alte_pos := i16_aktuelle_pos;
END_IF

IF i16_achsgeschwindigkeit >= 1 THEN
	(* 0.006 = 360Grad / (60sec * 1000ms) *)
	r_zeit_fuer_1einheit := 0.006 * INT_TO_REAL(i16_achsgeschwindigkeit);	(* REAL-Zahl in ms *)
ELSE
	r_zeit_fuer_1einheit := 0.0;
END_IF

(* Erst alle Spuren reset *)
FOR sp := 0  TO SIZEOF (arr_spur)/SIZEOF(arr_spur[0]) - 1BY 1 DO
	arr_spur[sp] :=FALSE;
END_FOR

(* Totzeitkompensation durch Vorsteuerung *)
FOR no := 0  TO SIZEOF (arr_nocken)/SIZEOF(arr_nocken[0]) - 1 BY 1DO
	(* Berechnung des Vorsteuerwinkels *)
	arr_nocken[no].i16_vorsteuerpos :=  REAL_TO_INT((TIME_TO_REAL(arr_nocken[no].t_vorsteuerzeit)) * r_zeit_fuer_1einheit);
	IF  arr_nocken[no].i16_vorsteuerpos >=i16_vorsteuerpos_max THEN
		 arr_nocken[no].i16_vorsteuerpos := 0;
		sm_vorsteuerung := TRUE;
	ELSE
		sm_vorsteuerung := FALSE;
	END_IF

	(* Nockentoleranz mit Berücksichtigung der Vorsteuerzeit für Anfangswinkel*)
	i16_anfangspos_mit_tzk[no] := arr_nocken[no].i16_cam_begin -  arr_nocken[no].i16_vorsteuerpos;
	IF i16_anfangspos_mit_tzk[no] > 360 THEN
		i16_anfangspos_mit_tzk[no] := i16_anfangspos_mit_tzk[no] - 360;
	ELSIF i16_anfangspos_mit_tzk[no] < 0 THEN
		i16_anfangspos_mit_tzk[no] := i16_anfangspos_mit_tzk[no] + 360;
	END_IF
	(* Nockentoleranz mit Berücksichtigung der Vorsteuerzeit für Endwinkel*)
	i16_endpos_mit_tzk[no] := arr_nocken[no].i16_cam_end -  arr_nocken[no].i16_vorsteuerpos;
	IF i16_endpos_mit_tzk[no] > 360 THEN
		i16_endpos_mit_tzk[no] := i16_endpos_mit_tzk[no] - 360;
	ELSIF i16_endpos_mit_tzk[no] < 0 THEN
		i16_endpos_mit_tzk[no] := i16_endpos_mit_tzk[no] + 360;
	END_IF

	IF i16_anfangspos_mit_tzk[no] < 0 OR i16_endpos_mit_tzk[no] < 0 OR i16_anfangspos_mit_tzk[no] >= 360 OR i16_endpos_mit_tzk[no] >= 360 THEN
		 (* Fehlerfälle  mit Abbruch*)
		sm_positionseingabe := TRUE;
		EXIT; (* Schleifenabbruch *)
	ELSE (* Winkel sind o.k. und der Nocken wird bearbeitet -> ON/OFF *)
		sm_positionseingabe := FALSE;
		IF i16_anfangspos_mit_tzk[no] <> i16_endpos_mit_tzk[no] THEN
			(* Nocken setzen *)
			(* Anfangswinkel ist kleiner Endwinkel *)
			b_setzustand_anfang_kleiner_ende[no] := i16_anfangspos_mit_tzk[no] < i16_endpos_mit_tzk[no] AND
												i16_aktuelle_pos >= i16_anfangspos_mit_tzk[no] AND
												i16_aktuelle_pos <= i16_endpos_mit_tzk[no];
			(* Anfangswinkel ist grösser Endwinkel *)
			b_setzustand_anfang_groesser_ende[no] := i16_anfangspos_mit_tzk[no] > i16_endpos_mit_tzk[no] AND
												(i16_aktuelle_pos >= i16_anfangspos_mit_tzk[no] OR
												i16_aktuelle_pos <= i16_endpos_mit_tzk[no]);

			(* Nocken ist gültig, d.h. wurde von der Maschine oder Bediener aktiviert *)
			IF	arr_nocken[no].b_camvalid AND
				(b_setzustand_anfang_kleiner_ende[no] OR b_setzustand_anfang_groesser_ende[no]) AND
				((b_verfahrrichtung_positiv AND arr_nocken[no].b_eff_direction_pos) OR	(* positive Drehrichtung und positive Wirkrichtung ist freigegeben *)
				(b_verfahrrichtung_negativ AND arr_nocken[no].b_eff_direction_neg)) 		(* negative Drehrichtung und negative Wirkrichtung ist freigegeben *)
				THEN
					arr_nocken[no].b_nockenzustand := TRUE;
			END_IF

			(* Nocken zurücksetzen *)
			(* Anfangswinkel ist kleiner Endwinkel *)
			b_resetzustand_anfang_kleiner_ende[no] := i16_anfangspos_mit_tzk[no] < i16_endpos_mit_tzk[no] AND
													(i16_aktuelle_pos < i16_anfangspos_mit_tzk[no] OR
													i16_aktuelle_pos  > i16_endpos_mit_tzk[no]);
			(* Anfangswinkel ist grösser Endwinkel *)
			b_resetzustand_anfang_groesser_ende[no] := i16_anfangspos_mit_tzk[no] > i16_endpos_mit_tzk[no] AND
													i16_aktuelle_pos < i16_anfangspos_mit_tzk[no] AND
													i16_aktuelle_pos > i16_endpos_mit_tzk[no];

			(* Nocken ist ungültig, d.h. wurde von der Maschine oder Bediener deaktiviert *)
			IF	NOT arr_nocken[no].b_camvalid OR
				(b_resetzustand_anfang_kleiner_ende[no] OR b_resetzustand_anfang_groesser_ende[no])
				THEN
					arr_nocken[no].b_nockenzustand := FALSE;
			END_IF
		ELSE
			(* Anfang = Ende -> Nocken ist false *)
			arr_nocken[no].b_nockenzustand := FALSE;
		END_IF
	END_IF

	(* Aktive Nocken auf ihre Spuren setzen *)
	IF arr_nocken[no].b_camvalid AND arr_nocken[no].b_nockenzustand THEN
		arr_spur[arr_nocken[no].i16_track_no] := TRUE;
	END_IF
END_FOR

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_positionseingabe;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_vorsteuerung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine\/Nockenschaltwerke\/NSW_LREAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Nockenschaltwerk_lreal
VAR_INPUT
	r_achsposition							: LREAL;
	r_achsgeschwindigkeit						: LREAL;
	i16_verfahrrichtung_achse_extern			: INT;
	b_verfahrrichtungsauswertung_extern			: BOOL;
	i16_art_der_achse							: enum_ecd_typ;
	st_config									: struct_config;
END_VAR
VAR_IN_OUT
	st_visu									: struct_visu;
	arr_nocken								: ARRAY [0..MAX_NOCKENGERUEST] OF struct_nocken_lreal;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	b_first_cycle 								: BOOL := TRUE;
	r_aktuelle_pos 							: T_FIX16;
	r_alte_pos	 							: T_FIX16;
	b_verfahrrichtung_positiv 					: BOOL := FALSE;
	b_verfahrrichtung_negativ					: BOOL := FALSE;
	r_zeit_fuer_1einheit						: LREAL := 0.0;
	r_anfangspos_mit_tzk 						: ARRAY [0..MAX_NOCKENGERUEST] OF LREAL := 0.0;
	r_endpos_mit_tzk 							: ARRAY [0..MAX_NOCKENGERUEST] OF LREAL := 0.0;
	r_vorsteuerpos_max						: LREAL := 0.0;
	i16_verfahrrichtung_achse_intern				: INT := 0;
	sm_positionseingabe						: BOOL := FALSE;
	sm_vorsteuerung							: BOOL := FALSE;
	sp, no									: UINT := 0;
	arr_spur									: ARRAY [0..MAX_NOCKENGERUEST] OF BOOL;
	b_setzustand_anfang_kleiner_ende			: ARRAY [0..MAX_NOCKENGERUEST] OF BOOL;
	b_setzustand_anfang_groesser_ende		: ARRAY [0..MAX_NOCKENGERUEST] OF BOOL;
	b_resetzustand_anfang_kleiner_ende		: ARRAY [0..MAX_NOCKENGERUEST] OF BOOL;
	b_resetzustand_anfang_groesser_ende		: ARRAY [0..MAX_NOCKENGERUEST] OF BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Funktionsbaustein Nockenschaltwerk *)
(* Funktion für lineare und rotatorische Achsen *)
CASE i16_art_der_achse  OF
1:	(* Linearachse *)
	IF b_first_cycle THEN
		b_first_cycle := FALSE;

		(* Setze Drehrichtung Positiv. Da wenn beide Drehrichtungen nicht gesetzt sind, keine Nocke aktiv wird *)
		r_vorsteuerpos_max := 100.0;
		b_verfahrrichtung_positiv := TRUE;
		b_verfahrrichtung_negativ := FALSE;
		r_alte_pos := r_aktuelle_pos;
	END_IF

	(* Aktuelle Position für weitere Komponenten zur Verfügung stellen *)
	r_aktuelle_pos := LREAL_TO_FIX16(r_achsposition,2);

	(* Verfahrrichtung überwachen *)
	IF FIX16_TO_LREAL(r_aktuelle_pos) > FIX16_TO_LREAL(r_alte_pos) THEN
		i16_verfahrrichtung_achse_intern := 1;
		r_alte_pos := r_aktuelle_pos;
	ELSIF FIX16_TO_LREAL(r_aktuelle_pos) < FIX16_TO_LREAL(r_alte_pos) THEN
		i16_verfahrrichtung_achse_intern := -1;
		r_alte_pos := r_aktuelle_pos;
	END_IF

	IF b_verfahrrichtungsauswertung_extern THEN
		IF i16_verfahrrichtung_achse_extern = 1 THEN
			b_verfahrrichtung_positiv := TRUE;
			b_verfahrrichtung_negativ := FALSE;
		ELSIF i16_verfahrrichtung_achse_extern = -1 THEN
			b_verfahrrichtung_positiv := FALSE;
			b_verfahrrichtung_negativ := TRUE;
		END_IF
	ELSE
		IF i16_verfahrrichtung_achse_intern = 1 THEN
			b_verfahrrichtung_positiv := TRUE;
			b_verfahrrichtung_negativ := FALSE;
		ELSIF i16_verfahrrichtung_achse_intern = -1 THEN
			b_verfahrrichtung_positiv := FALSE;
			b_verfahrrichtung_negativ := TRUE;
		END_IF
	END_IF

	IF r_achsgeschwindigkeit >= 1.0 THEN
		r_zeit_fuer_1einheit := 0.001 * r_achsgeschwindigkeit;		(* REAL-Zahl in ms *)
	ELSE
		r_zeit_fuer_1einheit := 0.0;
	END_IF

	(* Totzeitkompensation durch Vorsteuerung *)
	FOR no := 0  TO SIZEOF (arr_nocken)/SIZEOF(arr_nocken[0]) -1 DO
		(* Berechnung der Vorsteuerposition *)
		 arr_nocken[no].r_vorsteuerpos :=  (TIME_TO_LREAL(arr_nocken[no].t_vorsteuerzeit)) * r_zeit_fuer_1einheit;
		IF  arr_nocken[no].r_vorsteuerpos >= r_vorsteuerpos_max THEN
			 arr_nocken[no].r_vorsteuerpos := 0.0;
			sm_vorsteuerung := TRUE;
		ELSE
			sm_vorsteuerung := FALSE;
		END_IF

		(* Nockentoleranz mit Berücksichtigung der Vorsteuerzeit für Anfangswinkel*)
		r_anfangspos_mit_tzk[no] := arr_nocken[no].r_cam_begin - arr_nocken[no].r_vorsteuerpos;
		(* Nockentoleranz mit Berücksichtigung der Vorsteuerzeit für Endwinkel*)
		r_endpos_mit_tzk[no] := arr_nocken[no].r_cam_end - arr_nocken[no].r_vorsteuerpos;

		IF r_anfangspos_mit_tzk[no] <> r_endpos_mit_tzk[no] THEN
			(* Nocken setzen *)
			(* Anfangsposition ist kleiner Endposition *)
			b_setzustand_anfang_kleiner_ende[no] := r_anfangspos_mit_tzk[no] < r_endpos_mit_tzk[no] AND
													FIX16_TO_LREAL(r_aktuelle_pos) >= r_anfangspos_mit_tzk[no] AND
													FIX16_TO_LREAL(r_aktuelle_pos) <= r_endpos_mit_tzk[no];
			(* Anfangsposition ist grösser Endposition *)
			b_setzustand_anfang_groesser_ende[no] := r_anfangspos_mit_tzk[no] > r_endpos_mit_tzk[no] AND
													FIX16_TO_LREAL(r_aktuelle_pos) <= r_anfangspos_mit_tzk[no] AND
													FIX16_TO_LREAL(r_aktuelle_pos) >= r_endpos_mit_tzk[no];
	
			(* Nocken ist gültig, d.h. wurde von der Maschine oder Bediener aktiviert *)
			IF	arr_nocken[no].b_camvalid AND
				(b_setzustand_anfang_kleiner_ende[no] OR b_setzustand_anfang_groesser_ende[no]) AND
				((b_verfahrrichtung_positiv AND arr_nocken[no].b_eff_direction_pos) OR	(* positive Drehrichtung und positive Wirkrichtung ist freigegeben *)
				(b_verfahrrichtung_negativ AND arr_nocken[no].b_eff_direction_neg)) 		(* negative Drehrichtung und negative Wirkrichtung ist freigegeben *)
				THEN
					arr_nocken[no].b_nockenzustand := TRUE;
			END_IF
	
			(* Nocken zurücksetzen *)
			(* Anfangswinkel ist kleiner Endwinkel *)
			b_resetzustand_anfang_kleiner_ende[no] := r_anfangspos_mit_tzk[no] < r_endpos_mit_tzk[no] AND
													(FIX16_TO_LREAL(r_aktuelle_pos) < r_anfangspos_mit_tzk[no] OR
													FIX16_TO_LREAL(r_aktuelle_pos)  > r_endpos_mit_tzk[no]);
			(* Anfangswinkel ist grösser Endwinkel *)
			b_resetzustand_anfang_groesser_ende[no] := r_anfangspos_mit_tzk[no] > r_endpos_mit_tzk[no] AND
													(FIX16_TO_LREAL(r_aktuelle_pos) > r_anfangspos_mit_tzk[no] OR
													FIX16_TO_LREAL(r_aktuelle_pos) < r_endpos_mit_tzk[no]);
	
			(* Nocken ist ungültig, d.h. wurde von der Maschine oder Bediener deaktiviert *)
			IF	NOT arr_nocken[no].b_camvalid OR
				b_resetzustand_anfang_kleiner_ende[no] OR
				b_resetzustand_anfang_groesser_ende[no] OR
				(* Zusatzbedingung für Nockenzustand rücksetzen ist nur bei Linearachsen sinnvoll *)
				(b_verfahrrichtung_positiv AND NOT arr_nocken[no].b_eff_direction_pos AND arr_nocken[no].b_eff_direction_neg) OR	(* positive Drehrichtung und positive Wirkrichtung ist freigegeben *)
				(b_verfahrrichtung_negativ AND NOT arr_nocken[no].b_eff_direction_neg AND arr_nocken[no].b_eff_direction_pos)		(* negative Drehrichtung und negative Wirkrichtung ist freigegeben *)
				THEN
					arr_nocken[no].b_nockenzustand := FALSE;
			END_IF
		ELSE
			(* Anfang = Ende -> Nocken ist false *)
			arr_nocken[no].b_nockenzustand := FALSE;
		END_IF
	END_FOR

	(* Erst alle Spuren reset *)
	FOR sp := 0  TO SIZEOF (arr_spur)-1 DO
		arr_spur[sp] :=FALSE;
	END_FOR
	
	(* Dann aktive Nocken auf ihre Spuren setzen *)
	FOR no := 0  TO SIZEOF (arr_nocken)/SIZEOF(arr_nocken[0])-1 DO
		IF arr_nocken[no].b_camvalid AND arr_nocken[no].b_nockenzustand THEN
			arr_spur[arr_nocken[no].i16_track_no] := TRUE;
		END_IF
	END_FOR

2:	(* Rotatorische Achse *)
	IF b_first_cycle THEN
		b_first_cycle := FALSE;

		(* Setze Drehrichtung Positiv. Da wenn beide Drehrichtungen nicht gesetzt sind, keine Nocke aktiv wird *)
		r_vorsteuerpos_max := 60.0;
		b_verfahrrichtung_positiv := TRUE;
		b_verfahrrichtung_negativ := FALSE;
		r_alte_pos := r_aktuelle_pos;
	END_IF

	(* Aktuelle Position für weitere Komponenten zur Verfügung stellen *)
	r_aktuelle_pos := LREAL_TO_FIX16(r_achsposition,2);

	(* Verfahrrichtung überwachen *)
	IF FIX16_TO_LREAL(r_aktuelle_pos) > FIX16_TO_LREAL(r_alte_pos) THEN
		i16_verfahrrichtung_achse_intern := 1;
		r_alte_pos := r_aktuelle_pos;
	ELSIF FIX16_TO_LREAL(r_aktuelle_pos) < FIX16_TO_LREAL(r_alte_pos) THEN
		i16_verfahrrichtung_achse_intern := -1;
		r_alte_pos := r_aktuelle_pos;
	END_IF

	IF b_verfahrrichtungsauswertung_extern THEN
		IF i16_verfahrrichtung_achse_extern = 1 THEN
			b_verfahrrichtung_positiv := TRUE;
			b_verfahrrichtung_negativ := FALSE;
		ELSIF i16_verfahrrichtung_achse_extern = -1 THEN
			b_verfahrrichtung_positiv := FALSE;
			b_verfahrrichtung_negativ := TRUE;
		END_IF
	ELSE
		IF i16_verfahrrichtung_achse_intern = 1 THEN
			b_verfahrrichtung_positiv := TRUE;
			b_verfahrrichtung_negativ := FALSE;
		ELSIF i16_verfahrrichtung_achse_intern = -1 THEN
			b_verfahrrichtung_positiv := FALSE;
			b_verfahrrichtung_negativ := TRUE;
		END_IF
	END_IF

	IF r_achsgeschwindigkeit >= 1.0 THEN
		(* 0.006 = 360Grad / (60sec * 1000ms) *)
		r_zeit_fuer_1einheit := 0.006 * r_achsgeschwindigkeit;	(* REAL-Zahl in ms *)
	ELSE
		r_zeit_fuer_1einheit := 0.0;
	END_IF

	(* Totzeitkompensation durch Vorsteuerung *)
	FOR no := 0  TO SIZEOF (arr_nocken)/SIZEOF(arr_nocken[0]) -1 DO
		(* Berechnung des Vorsteuerwinkels *)
		arr_nocken[no].r_vorsteuerpos :=  (TIME_TO_LREAL(arr_nocken[no].t_vorsteuerzeit)) * r_zeit_fuer_1einheit;
		IF  arr_nocken[no].r_vorsteuerpos >= r_vorsteuerpos_max THEN
			 arr_nocken[no].r_vorsteuerpos := 0.0;
			sm_vorsteuerung := TRUE;
		ELSE
			sm_vorsteuerung := FALSE;
		END_IF

		(* Nockentoleranz mit Berücksichtigung der Vorsteuerzeit für Anfangswinkel*)
		r_anfangspos_mit_tzk[no] := arr_nocken[no].r_cam_begin -  arr_nocken[no].r_vorsteuerpos;
		IF r_anfangspos_mit_tzk[no] > 360.0 THEN
			r_anfangspos_mit_tzk[no] := r_anfangspos_mit_tzk[no] - 360.0;
		ELSIF r_anfangspos_mit_tzk[no] < 0.0 THEN
			r_anfangspos_mit_tzk[no] := r_anfangspos_mit_tzk[no] + 360.0;
		END_IF
		(* Nockentoleranz mit Berücksichtigung der Vorsteuerzeit für Endwinkel*)
		r_endpos_mit_tzk[no] := arr_nocken[no].r_cam_end -  arr_nocken[no].r_vorsteuerpos;
		IF r_endpos_mit_tzk[no] > 360.0 THEN
			r_endpos_mit_tzk[no] := r_endpos_mit_tzk[no] - 360.0;
		ELSIF r_endpos_mit_tzk[no] < 0.0 THEN
			r_endpos_mit_tzk[no] := r_endpos_mit_tzk[no] + 360.0;
		END_IF
	
		IF r_anfangspos_mit_tzk[no] < 0.0 OR r_endpos_mit_tzk[no] < 0.0 OR r_anfangspos_mit_tzk[no] >= 360.0 OR r_endpos_mit_tzk[no] >= 360.0 THEN
			 (* Fehlerfälle  mit Abbruch*)
			sm_positionseingabe := TRUE;
			EXIT; (* Schleifenabbruch *)
		ELSE (* Winkel sind o.k. und der Nocken wird bearbeitet -> ON/OFF *)
			sm_positionseingabe := FALSE;
			IF r_anfangspos_mit_tzk[no] <> r_endpos_mit_tzk[no] THEN
				(* Nocken setzen *)
				(* Anfangswinkel ist kleiner Endwinkel *)
				b_setzustand_anfang_kleiner_ende[no] := r_anfangspos_mit_tzk[no] < r_endpos_mit_tzk[no] AND
													FIX16_TO_LREAL(r_aktuelle_pos) >= r_anfangspos_mit_tzk[no] AND
													FIX16_TO_LREAL(r_aktuelle_pos) <= r_endpos_mit_tzk[no];
				(* Anfangswinkel ist grösser Endwinkel *)
				b_setzustand_anfang_groesser_ende[no] := r_anfangspos_mit_tzk[no] > r_endpos_mit_tzk[no] AND
													(FIX16_TO_LREAL(r_aktuelle_pos) >= r_anfangspos_mit_tzk[no] OR
													FIX16_TO_LREAL(r_aktuelle_pos) <= r_endpos_mit_tzk[no]);

				(* Nocken ist gültig, d.h. wurde von der Maschine oder Bediener aktiviert *)
				IF	arr_nocken[no].b_camvalid AND
					(b_setzustand_anfang_kleiner_ende[no] OR b_setzustand_anfang_groesser_ende[no]) AND
					((b_verfahrrichtung_positiv AND arr_nocken[no].b_eff_direction_pos) OR	(* positive Drehrichtung und positive Wirkrichtung ist freigegeben *)
					(b_verfahrrichtung_negativ AND arr_nocken[no].b_eff_direction_neg)) 		(* negative Drehrichtung und negative Wirkrichtung ist freigegeben *)
					THEN
						arr_nocken[no].b_nockenzustand := TRUE;
				END_IF

				(* Nocken zurücksetzen *)
				(* Anfangswinkel ist kleiner Endwinkel *)
				b_resetzustand_anfang_kleiner_ende[no] := r_anfangspos_mit_tzk[no] < r_endpos_mit_tzk[no] AND
														(FIX16_TO_LREAL(r_aktuelle_pos) < r_anfangspos_mit_tzk[no] OR
														FIX16_TO_LREAL(r_aktuelle_pos)  > r_endpos_mit_tzk[no]);
				(* Anfangswinkel ist grösser Endwinkel *)
				b_resetzustand_anfang_groesser_ende[no] := r_anfangspos_mit_tzk[no] > r_endpos_mit_tzk[no] AND
														FIX16_TO_LREAL(r_aktuelle_pos) < r_anfangspos_mit_tzk[no] AND
														FIX16_TO_LREAL(r_aktuelle_pos) > r_endpos_mit_tzk[no];

				(* Nocken ist ungültig, d.h. wurde von der Maschine oder Bediener deaktiviert *)
				IF	NOT arr_nocken[no].b_camvalid OR
					(b_resetzustand_anfang_kleiner_ende[no] OR b_resetzustand_anfang_groesser_ende[no])
					THEN
						arr_nocken[no].b_nockenzustand := FALSE;
				END_IF
			ELSE
				(* Anfang = Ende -> Nocken ist false *)
				arr_nocken[no].b_nockenzustand := FALSE;
			END_IF
		END_IF
	END_FOR

	(* Erst alle Spuren reset *)
	FOR sp := 0  TO SIZEOF (arr_spur)-1 DO
		arr_spur[sp] :=FALSE;
	END_FOR

	(* Dann aktive Nocken auf ihre Spuren setzen *)
	FOR no := 0  TO SIZEOF (arr_nocken)/SIZEOF(arr_nocken[0])-1 DO
		IF arr_nocken[no].b_camvalid AND arr_nocken[no].b_nockenzustand THEN
			arr_spur[arr_nocken[no].i16_track_no] := TRUE;
		END_IF
	END_FOR
END_CASE

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_positionseingabe;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_vorsteuerung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine\/Nockenschaltwerke\/NZW' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Nockenzaehlwerk
VAR_INPUT
	i16_wkz_vorbesetzwert		: INT;
	b_zustand_spur			: BOOL;
	b_externer_zaehler_reset	: BOOL;
END_VAR
VAR_OUTPUT
	b_aktionsnocken			: BOOL;
END_VAR
VAR
	fb_ctu_hubzaehler			: CTU;
	fb_r_trig_zaehler			: R_TRIG;
	fb_r_trig_ot_nocken		: R_TRIG;
	b_interner_zaehler_reset	: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zählwerk für Aktionen, die OT-Nocken abhängig sind
Anwendung: Nacheiner bestimmten Anzahl von Umdrehungen soll eine Aktion ausgelöst werden.
Der Ausgang ist für eine Umdrehung aktiv, bevor er wieder zurückgesetzt wird. *)
fb_ctu_hubzaehler(
	CU:=  b_zustand_spur,
	RESET:= b_interner_zaehler_reset OR b_externer_zaehler_reset,
	PV:= i16_wkz_vorbesetzwert,
	Q=> ,
	CV=> );

fb_r_trig_zaehler(CLK:= fb_ctu_hubzaehler.Q, Q=> );

(* Abfrage des Zählerstatus und daraus resultierende Aktionen *)
IF fb_r_trig_zaehler.Q THEN (* Bei Zählerstand erreicht, Ausgang für eine Umdrehung setzen *)
	b_aktionsnocken := TRUE;
END_IF
IF NOT fb_ctu_hubzaehler.Q AND fb_r_trig_ot_nocken.Q THEN
	b_aktionsnocken := FALSE; (* Nach einer Umdrehung wird der Ausgang wieder rückgesetzt *)
END_IF

fb_r_trig_ot_nocken(CLK:= b_zustand_spur, Q=> );

IF NOT  b_zustand_spur AND fb_ctu_hubzaehler.Q THEN
	b_interner_zaehler_reset := TRUE; (* Wenn Zählerstand erreicht, dann Zähler nullen *)
ELSIF b_interner_zaehler_reset AND fb_ctu_hubzaehler.CV = 0 THEN
	b_interner_zaehler_reset := FALSE; (* Wenn Zähler genullt, dann wieder freigeben für erneutes Zählen *)
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_AnalogIn
VAR_INPUT
	t_verzoegerung				: TIME;
	st_config						: struct_config;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	b_error						: BOOL := FALSE;
	e_i16_sensor_delayed_value	: INT := 0;
	i16_anzeigewert_max			: INT := 16#7FFF;
	i16_anzeigewert_min			: INT := 16#0000;
	r_offset_skalierung			: INT := 16#0000;
	r_gain_skalierung				: INT := 16#0000;
	fb_abfragetakt				: ST_Blinker;
	fb_r_trig_abfragetakt			: R_TRIG;
	sm_overrange				: BOOL := FALSE;
	sm_underrange				: BOOL := FALSE;
	sm_limit1						: BOOL := FALSE;
	sm_limit2						: BOOL := FALSE;
	sm_error						: BOOL := FALSE;
	st_sensor					AT %I* :struct_analog_in;
END_VAR
(* @END_DECLARATION := '0' *)
(* Aufbereitung und Skalierung eines analogen Sensorwertes *)
i16_anzeigewert_max := 16#7FFF;

(* Verzögerte Abfrage des Analogwertes *)
fb_abfragetakt(
	b_start:= TRUE,
	 t_taktzeit_on:= t_verzoegerung,
	 t_taktzeit_off:= t_verzoegerung,
	b_blinker_out=> );

fb_r_trig_abfragetakt(CLK:= fb_abfragetakt.b_blinker_out, Q=> );

IF fb_r_trig_abfragetakt.Q THEN
	e_i16_sensor_delayed_value := st_sensor.e_i16_value;
END_IF

(* Fehlermeldungen der Analogkarte *)
sm_overrange := st_sensor.e_b_status_overrange;
sm_underrange := st_sensor.e_b_status_underrange;
sm_limit1	:= BYTE_TO_BOOL (st_sensor.e_by_status_limit1);
sm_limit2	 := BYTE_TO_BOOL (st_sensor.e_by_status_limit2);
sm_error	:= st_sensor.e_b_status_error;

b_error := sm_overrange OR sm_underrange OR sm_limit1 OR sm_limit2 OR sm_error;

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_overrange;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_underrange;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_limit1;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_limit2;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_error;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_AnalogOut
VAR_INPUT
	r_digital_in					: REAL;
	st_config						: struct_config;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	b_error						: BOOL := FALSE;
	i16_ausgabewert_max			: INT := 16#7FFF;
	i16_ausgabewert_min			: INT := 16#0;
	i16_offset_skalierung			: INT := 16#0;
	i16_gain_skalierung			: INT := 16#CCC;
	i16_analogwert				: INT := 0;
	sm_error						: BOOL := FALSE;
	i16_analog_out				AT %Q* : INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* ===Ausgabe eines analogen Sollwertes an einen Aktor=== *)
(* Die Kalibrierung der Geraden sollte hier nicht geändert werden!
Der Ausgabe wert ist vom Format INT, somit wurde kalibriert auf den maximalen Endwert von 7FFF mit der Steigung CCC.
Der Offset dient zum Verschieben der Geraden, wenn bei Eingangswert 0 kein Analogwert von 0 erreicht wird. *)

IF st_config.b_station_aktiv THEN
	(* Skalieren des Analogwertes und Ausgabe an die Karte: y = gain*wert + offset *)
	i16_analogwert := REAL_TO_INT(INT_TO_REAL(i16_gain_skalierung) * r_digital_in + INT_TO_REAL(i16_offset_skalierung));
	
	IF i16_analogwert < i16_ausgabewert_min THEN
		i16_analog_out := i16_ausgabewert_min;
		b_error := TRUE;
	ELSIF i16_analogwert > i16_ausgabewert_max THEN
		i16_analog_out := i16_ausgabewert_max;
		b_error := TRUE;
	ELSE
		i16_analog_out := i16_analogwert;
		b_error := FALSE;
	END_IF
ELSE
	i16_analog_out := 0;
	b_error := FALSE;
END_IF

(* Fehlermeldung Bereich *)
sm_error := b_error;

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_error;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_BerechnungOverride
VAR_INPUT
	i16_betriebsart				: enum_betriebsarten;
	lr_skalierung_slave_achse1		: LREAL;
	lr_skalierung_slave_achse2		: LREAL;
	lr_override_vorgabe			: LREAL;
	lr_faktor						: LREAL;

	lr_FaktorHub				: LREAL;
	lr_HubAuto					: LREAL;
END_VAR
VAR_OUTPUT
	lr_override					: LREAL := 0.0;
END_VAR
VAR
	lr_offset						: LREAL := 100.0;
	tmp_lr_override_slave1		: LREAL := 0.0;
	tmp_lr_override_slave2		: LREAL := 0.0;

	lr_ProzentDerRichtdrehzahl	: LREAL;
	lr_Reduzierung				: LREAL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Funktion zur Berechnung des Override der  Masterachse: y = - faktor * x^2 + offset *)
(* Die Funktion besteht aus einer auf dem Kopf stehenden Parabel, welche um den faktor nach oben verschoben ist *)
(* Aufpassen bei den Nullstellen der Funktion, wenn faktor und offset verändert werden *)

(* Die Anpassung der maximalen Mastergeschwindigkeit an die Verfahrlänge des Slaves wird hier einfach über eine empirisch ermittelte Funktion realisiert *)
(* Eine verbesserte Anpassung stellt die Berechnung der maximalen Mastergeschwindigkeit (ST_MFMaxMasterVelo) im CamEditor dar. *)

tmp_lr_override_slave1 := - lr_faktor * (lr_skalierung_slave_achse1 * lr_skalierung_slave_achse1)  + lr_offset;
tmp_lr_override_slave2 := - lr_faktor * (lr_skalierung_slave_achse2 * lr_skalierung_slave_achse2)  + lr_offset;

IF tmp_lr_override_slave1 < 0.0 THEN
	 tmp_lr_override_slave1 := 0.0;
ELSIF tmp_lr_override_slave1 >= 100.0 THEN
	 tmp_lr_override_slave1 := 100.0;
END_IF
IF tmp_lr_override_slave2 < 0.0 THEN
	 tmp_lr_override_slave2 := 0.0;
ELSIF tmp_lr_override_slave2 >= 100.0 THEN
	 tmp_lr_override_slave2 := 100.0;
END_IF

IF i16_betriebsart = AUTO THEN
	(* Nur wenn der mit der Funktion berechnete Override kleiner ist, als die Vorgabe, dann wird der Funktionswert übernommen *)
	IF 	tmp_lr_override_slave1 < lr_override_vorgabe OR
		tmp_lr_override_slave2 < lr_override_vorgabe THEN

		IF tmp_lr_override_slave1 <= tmp_lr_override_slave2 THEN
			lr_override := tmp_lr_override_slave1;
		ELSIF tmp_lr_override_slave2 < tmp_lr_override_slave1 THEN
			lr_override := tmp_lr_override_slave2;
		ELSE
			lr_override := lr_override_vorgabe;
		END_IF

	ELSE
		lr_override := lr_override_vorgabe;
	END_IF
ELSE
	lr_override := lr_override_vorgabe;
END_IF


(*neue Berechnung==========================================================================*)
(*Reduzierung abhängig von der Nenndrehzahl*)
lr_ProzentDerRichtdrehzahl:=(lr_HubAuto *100)/250;
IF	lr_HubAuto >250 AND
	lr_override_vorgabe > lr_override THEN
	lr_override := 100-((lr_override_vorgabe - lr_override) * (lr_ProzentDerRichtdrehzahl /100)) ;
END_IF

(*nur Reduzieren wenn das Ergebniss kleiner ist als bei der Reduzierung durch die Pin Anzahl*)
lr_Reduzierung:= (lr_override_vorgabe - lr_override)/100;
IF	(1 - lr_Reduzierung) < lr_FaktorHub THEN
	lr_override := lr_override;
ELSE
	lr_override:= 100 * lr_FaktorHub;
END_IF

IF	lr_override > lr_override_vorgabe OR
	lr_override < 0 THEN
	lr_override:= lr_override_vorgabe;
END_IF

(*Beim Einfädeln wird der Override vom Bausstein ST_TippTasten einfach durchgeschleust*)
IF	ST_TippTasten.b_einfaedeln_aktiv OR
	ST_TippTasten.b_initialisierungsphase THEN
	lr_override := lr_override_vorgabe;
END_IF

(*bei Prüfteilen Override fest auf 30% *)
IF	lr_override_vorgabe > 30 AND
	(FIND( gst_datensatz.st_md.s_aktuelle_artikelnummer,'ruef') <> 0 OR FIND( gst_datensatz.st_md.s_aktuelle_artikelnummer,'erth') <> 0)THEN
	lr_override := 30;
END_IF

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Betriebsartenwechsel
VAR_INPUT
	i16_akt_betriebsart		: enum_betriebsarten;
END_VAR
VAR_OUTPUT
	b_wechsel_auto			: BOOL;
	b_wechsel_tippen			: BOOL;
	b_wechsel_hand			: BOOL;
	b_wechsel_dummy		: BOOL;
	b_wechsel_pseudo		: BOOL;
	b_wechsel_allgemein		: BOOL;
END_VAR
VAR
	fb_r_trig_ba_auto			: R_TRIG;
	fb_r_trig_ba_tippen		: R_TRIG;
	fb_r_trig_ba_hand			: R_TRIG;
	fb_r_trig_ba_dummy		: R_TRIG;
	fb_r_trig_ba_pseudo		: R_TRIG;
	i16_betriebsart_alt			: enum_betriebsarten := KEINE;
	i16_betriebsart_neu		: enum_betriebsarten := KEINE;
	b_merker_ba_auto		: BOOL := FALSE;
	b_merker_ba_tippen		: BOOL := FALSE;
	b_merker_ba_hand		: BOOL := FALSE;
	b_merker_ba_dummy		: BOOL := FALSE;
	b_merker_ba_pseudo		: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
(* Funktionsbaustein zum Erfassen der verschiedenen Betriebsartenflanken *)
fb_r_trig_ba_auto(CLK:= b_merker_ba_auto, Q=> b_wechsel_auto);
fb_r_trig_ba_tippen(CLK:= b_merker_ba_tippen, Q=> b_wechsel_tippen);
fb_r_trig_ba_hand(CLK:=b_merker_ba_hand , Q=> b_wechsel_hand);
fb_r_trig_ba_dummy(CLK:=b_merker_ba_dummy , Q=> b_wechsel_dummy);
fb_r_trig_ba_pseudo(CLK:=b_merker_ba_pseudo , Q=> b_wechsel_pseudo);

b_wechsel_allgemein := b_wechsel_auto OR b_wechsel_tippen OR b_wechsel_hand OR b_wechsel_dummy OR b_wechsel_pseudo;

i16_betriebsart_neu := i16_akt_betriebsart;

IF i16_betriebsart_neu <> i16_betriebsart_alt THEN
	CASE gi16_betriebsart OF
		KEINE:
			b_merker_ba_auto := FALSE;
			b_merker_ba_tippen := FALSE;
			b_merker_ba_hand := FALSE;
			b_merker_ba_dummy := FALSE;
			b_merker_ba_pseudo := FALSE;

		AUTO:
			b_merker_ba_auto := TRUE;
			b_merker_ba_tippen := FALSE;
			b_merker_ba_hand := FALSE;
			b_merker_ba_dummy := FALSE;
			b_merker_ba_pseudo := FALSE;

		TIPPEN:
			b_merker_ba_auto := FALSE;
			b_merker_ba_tippen := TRUE;
			b_merker_ba_hand := FALSE;
			b_merker_ba_dummy := FALSE;
			b_merker_ba_pseudo := FALSE;

		HAND:
			b_merker_ba_auto := FALSE;
			b_merker_ba_tippen := FALSE;
			b_merker_ba_hand := TRUE;
			b_merker_ba_dummy := FALSE;
			b_merker_ba_pseudo := FALSE;

		DUMMY:
			b_merker_ba_auto := FALSE;
			b_merker_ba_tippen := FALSE;
			b_merker_ba_hand := FALSE;
			b_merker_ba_dummy := TRUE;
			b_merker_ba_pseudo := FALSE;

		PSEUDO:
			b_merker_ba_auto := FALSE;
			b_merker_ba_tippen := FALSE;
			b_merker_ba_hand := FALSE;
			b_merker_ba_dummy := FALSE;
			b_merker_ba_pseudo := TRUE;
	END_CASE

	i16_betriebsart_alt := i16_betriebsart_neu;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Blinker
VAR_INPUT
	b_start 		: BOOL;
	t_taktzeit_on	: TIME;
	t_taktzeit_off	: TIME;
END_VAR
VAR_OUTPUT
	b_blinker_out : BOOL;
END_VAR
VAR
	ton_on		: TON;
	ton_off		: TON;
END_VAR
(* @END_DECLARATION := '0' *)
ton_on(IN:=b_start AND NOT ton_off.Q , PT:=t_taktzeit_on , Q=>b_blinker_out , ET=> );
ton_off(IN:= ton_on.Q  , PT:=t_taktzeit_off , Q=> , ET=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION ST_Check_Modulopos : BOOL
VAR_INPUT
	akt_pos		: LREAL;
	ziel_pos		: LREAL;
END_VAR
VAR
	lr_rest		: LREAL;
	lr_pos		: LREAL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Funktion zum Überprüfen des MC_MoveModulo-Befehls wegen seltsamen Fahrens bei der Anzahl der Modulo Umdrehungen *)

		(* !!!nicht getestet !!! *)

lr_rest := LTRUNC(ziel_pos / 360);

IF lr_rest < 1 THEN
	ST_Check_Modulopos := TRUE;
ELSE
	lr_pos := ziel_pos - (lr_rest * 360);
	
	IF lr_pos >= akt_pos THEN
		ST_Check_Modulopos := TRUE;
	ELSE
		ST_Check_Modulopos := FALSE;
	END_IF
END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_CommandHistory
VAR_INPUT
	i16_current_cmd 		: enum_ecd_cmd;
END_VAR
VAR_OUTPUT
	last_cmd 			: enum_ecd_cmd;
END_VAR
VAR
	arr_last_cmd_history 	: ARRAY[0..31] OF enum_ecd_cmd;
	i					: INT;
END_VAR
(* @END_DECLARATION := '0' *)
IF (last_cmd <> i16_current_cmd) THEN
	last_cmd := i16_current_cmd;

	FOR i:= 30 TO 0 BY -1DO
		arr_last_cmd_history[i+1] := arr_last_cmd_history[i];
	END_FOR
	arr_last_cmd_history[0] := last_cmd;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Export_String
VAR_INPUT
	Start				:BOOL;
	ExportStr			:STRING(255);
	FileName			:STRING;
	Path				:STRING;
	Mode				:DWORD;
END_VAR
VAR
	fb_state_entry		:ST_StateEntry;
	fb_file_open			:FB_FileOpen;
	fb_file_puts			:FB_FilePuts;
	fb_file_close			:FB_FileClose;
	nErrId					:UDINT;
	ErrorMsg			:STRING(255);
	hFile				:UINT;
END_VAR
VAR_OUTPUT
	Ready				:BOOL;
	Busy				:BOOL;
	Done				:BOOL;
	Error				:BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
fb_state_entry(i16_pos:= 1);

CASE fb_state_entry.i16_step OF

(*=======================================================*)
	0:	(*Objekt initialisieren*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step:=INIT;

(*=======================================================*)
	10:	(*initialisieren*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step:=BEREIT;

(*=======================================================*)
	BEREIT:(*Start*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF Start THEN
			Start:=FALSE;
			Busy:=TRUE;
			Error:=FALSE;
			Done:=FALSE;
			nErrId:=0;
			ErrorMsg:='';
			fb_state_entry.i16_next_step:=105;
		END_IF

(*=======================================================*)
	105: (*Datei erstellen*)
		IF fb_state_entry.E THEN
			fb_file_open.sPathName:=CONCAT (Path, FileName);
			fb_file_open.bExecute:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_file_open.bBusy THEN
			fb_state_entry.i16_next_step:=110;
		END_IF

(*=======================================================*)
	110: (*Datei erstellen*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	NOT fb_file_open.bBusy THEN
			fb_file_open.bExecute:=FALSE;
			IF 	fb_file_open.bError THEN
				nErrId:=fb_file_open.nErrId;
				fb_state_entry.i16_next_step:=FEHLER;
				ErrorMsg:='Fehler beim Öffnen der Datei';
			ELSE
				fb_state_entry.i16_next_step:=120;
			END_IF
		END_IF

(*=======================================================*)
	120: (*String in Datei eintragen*)
		IF fb_state_entry.E THEN
			fb_file_puts.sLine:=ExportStr;
			fb_file_puts.bExecute:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_file_puts.bBusy THEN
			fb_state_entry.i16_next_step:=130;
		END_IF

(*=======================================================*)
	130: (*String in Datei eintragen*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	NOT fb_file_puts.bBusy THEN
			fb_file_puts.bExecute:=FALSE;
			IF 	fb_file_puts.bError THEN
				nErrId:=fb_file_puts.nErrId;
				fb_state_entry.i16_next_step:=FEHLER;
			ELSE
				fb_state_entry.i16_next_step:=140;
			END_IF
		END_IF
	
(*=======================================================*)
	140:(*Datei schließen*)
		IF fb_state_entry.E THEN
		fb_file_close.bExecute:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	fb_file_close.bBusy THEN
			fb_state_entry.i16_next_step:=150;
		END_IF
	
(*=======================================================*)
	150:(*Datei schließen*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_file_close.bBusy THEN
			fb_file_close.bExecute:=FALSE;
			IF 	fb_file_close.bError THEN
				nErrId:=fb_file_close.nErrId;
				fb_state_entry.i16_next_step:=FEHLER;
				ErrorMsg:='Fehler beim Schließen der Datei';
			ELSE
				Busy:=FALSE;
				Done:=TRUE;
				fb_state_entry.i16_next_step:=BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	FEHLER:	(*bei Fehler einfach weiter*)

		Busy:=FALSE;
		Error:=TRUE;
		fb_state_entry.i16_next_step := INIT;

END_CASE

fb_state_entry(i16_pos:= 2);


fb_file_open(
	sNetId:='',
	sPathName:= ,
	nMode:=Mode,
	ePath:=PATH_GENERIC,
	bExecute:= ,
	tTimeout:=T#1s,
	hFile=> hFile);

fb_file_puts(
	sNetId:='',
	hFile:=hFile,
	sLine:= ,
	bExecute:= ,
	tTimeout:=t#1s);

fb_file_close(
	sNetId:='',
	hFile:=hFile,
	bExecute:= ,
	tTimeout:=t#1s);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Flasher
VAR_INPUT
	b_start 			: BOOL;
	t_taktzeit_aus 		: TIME;
END_VAR
VAR_OUTPUT
	b_flasher_out 		: BOOL;
END_VAR
VAR
	ton_on			: TON;
	ton_off			: TON;
END_VAR
(* @END_DECLARATION := '0' *)
ton_on(IN:=b_start AND NOT ton_off.Q , PT:=  t_taktzeit_aus, Q=>b_flasher_out , ET=> );
ton_off(IN:= ton_on.Q  , PT:= t#250ms, Q=> , ET=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_OT_UT_Ueberwachung
VAR_INPUT
	lr_achsposition				 : LREAL;
END_VAR
VAR_OUTPUT
	b_error						: BOOL;
END_VAR
VAR
	i32_anfang_ot					: DINT := 0;
	i32_ende_ot					: DINT := 5;
	i32_anfang_ut					: DINT := 180;
	i32_ende_ut					: DINT := 185;
	arr_eintrag					: ARRAY[0..99] OF BOOL := 1,0,1;	(* Länge dient nur zum Nachverfolgen *)
	b_ot							: BOOL := FALSE;
	b_ut							: BOOL := FALSE;
	fb_r_trig_ot					: R_TRIG;
	fb_r_trig_ut					: R_TRIG;
	fb_f_trig_ot					: F_TRIG;
	fb_f_trig_ut					: F_TRIG;
	i							: INT := 0;
END_VAR
(* @END_DECLARATION := '0' *)
(* Kontrollfunktion zum Prüfen, ob auf OT auch immer UT kommt. *)
(* Die Fehlerausgabe erfolgt mittels temporärer Fehlermeldung, welche im Errorlog der Visu mitgeschrieben wird. *)
(* Dies dient der Kontrolle auf fehlbedienung durch das Anlagenpersonal. *)

(* Flanken *)
fb_r_trig_ot(CLK:= b_ot, Q=> );
fb_r_trig_ut(CLK:= b_ut, Q=> );
fb_f_trig_ot(CLK:= b_ot, Q=> );
fb_f_trig_ut(CLK:= b_ut, Q=> );

(* Erstellen der Bereichsnocken *)
IF LREAL_TO_DINT(lr_achsposition) > i32_anfang_ot AND LREAL_TO_DINT(lr_achsposition) < i32_ende_ot THEN
	b_ot := TRUE;
	b_error := FALSE;
ELSE
	b_ot := FALSE;
END_IF

IF LREAL_TO_DINT(lr_achsposition) > i32_anfang_ut AND LREAL_TO_DINT(lr_achsposition) < i32_ende_ut THEN
	b_ut := TRUE;
	b_error := FALSE;
ELSE
	b_ut := FALSE;
END_IF

(* Eintragen von OT bzw. UT in das Register *)
IF fb_r_trig_ot.Q THEN
	FOR i := 99  TO 1 BY -1 DO
		arr_eintrag [i] := arr_eintrag[i - 1];
	END_FOR
	arr_eintrag[0] := 2#0;	(* Eintrag für OT = 0 *)
END_IF

IF fb_r_trig_ut.Q THEN
	FOR i := 99  TO 1 BY -1 DO
		arr_eintrag[i] := arr_eintrag[i - 1];
	END_FOR
	arr_eintrag[0] := 2#1;	(* Eintrag für UT = 1 *)
END_IF

(* Auswertung und Fehler *)
IF fb_f_trig_ot.Q OR fb_f_trig_ut.Q THEN
	b_error := NOT (arr_eintrag[0]  XOR arr_eintrag[1]);
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_StateEntry
VAR
	arr_last_step_history	: ARRAY[0..31] OF STRING(110);
	i 					: INT := 0;
	last_pos 				: INT := 0;
	interner_step			: INT := 0;
	s_stepTime 			: STRING;
END_VAR
VAR_OUTPUT
	i16_last_step 			: enum_step_nr := INIT_OBJ;	(* Der Schritt vor diesem Schritt *)
	i16_step 				: enum_step_nr := INIT_OBJ;	(* Diese variable soll vom "case step of" verwendet werden *)
	E					: BOOL;					(* Aktiv bei betreten des Steps *)
	X					: BOOL;					(* Aktiv beim verlassen des Steps *)
	b_error 				: BOOL := FALSE;			(* Ablauf Pos 1,2,1,2,1,2,... nicht richtig *)
	fb_ton_Step			: TON;
END_VAR
VAR_INPUT
	i16_next_step 		: enum_step_nr := INIT_OBJ;	(* Nächster schritt *)
	i16_pos 				: INT;					(* Pos = 1: Aufruf vor dem Case step of ---  Pos = 2: Aufruf nach dem Case step of*)
	s_debugtext			: STRING(100);
END_VAR
VAR CONSTANT
	t_MaxStepTime		: TIME := T#60S;
END_VAR


(* @END_DECLARATION := '0' *)
(*stepTime ermitteln*)
fb_ton_Step(IN:= , PT:=t_MaxStepTime , Q=>  , ET=> );
IF	i16_step = i16_next_step THEN
	fb_ton_Step.IN:=TRUE;
END_IF

IF NOT b_error THEN
	CASE interner_step OF
		0:
			(* Mitten im Schritt drin *)
			X := FALSE;
			E := FALSE;


			(* Schritt wird verlassen *)
			IF i16_step <> i16_next_step AND i16_pos = 1 THEN
				subrDebugtext();
				interner_step := 10;
				X := TRUE;
				E := FALSE;
				fb_ton_Step.IN:=FALSE;
			END_IF

		10:
			(* Eintritt in neuen Schritt *)
			IF i16_pos = 1 THEN
				X := FALSE;
				E := TRUE;

				(* Schalte Schritt weiter *)
				i16_last_step := i16_step;
				i16_step := i16_next_step;
				(* Baue Statehistory *)

				IF  E THEN
					FOR i:= 31 TO 1 BY -1 DO
						arr_last_step_history[i] := arr_last_step_history[i-1];
					END_FOR
					arr_last_step_history[0] := '';
					s_stepTime:='';
					s_debugtext:='';
				END_IF

				interner_step := 0;

			END_IF
	END_CASE
END_IF

IF 	(fb_ton_Step.ET >= T#200ms AND arr_last_step_history[0] = '') OR	(* Am Anfang Debugtext schreiben, damit etwas drin steht *)
	(fb_ton_Step.Q AND s_stepTime <> '>1m') THEN	(* Debugtext schreiben, wenn t_MaxStepTime erreicht wird *)
	subrDebugtext();
END_IF

(* Prüfe Baustein *)
IF 	i16_pos = last_pos THEN
	b_error := TRUE;
END_IF

last_pos := i16_pos;
END_FUNCTION_BLOCK
ACTION	subrDebugtext:
s_stepTime:=ET_TO_STRING(fb_ton_Step.ET);
IF 	fb_ton_Step.ET >= t_MaxStepTime THEN
	s_stepTime:=CONCAT('>',s_StepTime);
END_IF

(* history zusammenbauen aus StepNr, StepTime und debugtext*)
CASE i16_step OF
	INIT_OBJ :			arr_last_step_history[0]:='INIT_OBJ';
	INIT :				arr_last_step_history[0]:='INIT';
	BEREIT :				arr_last_step_history[0]:='BEREIT';
	FEHLER :			arr_last_step_history[0]:='FEHLER';
	STOP :				arr_last_step_history[0]:='STOP';
	STILLSTAND :		arr_last_step_history[0]:='STILLSTAND';
	HALT :				arr_last_step_history[0]:='HALT';
	HANDRAD :			arr_last_step_history[0]:='HANDRAD';
	MOTORBREMSE_AUF :	arr_last_step_history[0]:='MOTORBREMSE_AUF';
	MOTORBREMSE_ZU :	arr_last_step_history[0]:='MOTORBREMSE_ZU';
	LUEFTEN :			arr_last_step_history[0]:='LUEFTEN';
	REGELN :			arr_last_step_history[0]:='REGELN';
	INBETRIEBNAHME :		arr_last_step_history[0]:='INBETRIEBNAHME';
	(* Zylinder *)
	ZYL_INIT :			arr_last_step_history[0]:='ZYL_INIT';
	GESTOPPT :			arr_last_step_history[0]:='GESTOPPT';
	EINGEFAHREN :		arr_last_step_history[0]:='EINGEFAHREN';
	BEWEGUNG_AUSFAHREN :		arr_last_step_history[0]:='BEWEGUNG_AUSFAHREN';
	AUSGEFAHREN :		arr_last_step_history[0]:='AUSGEFAHREN';
	BEWEGUNG_EINFAHREN :		arr_last_step_history[0]:='BEWEGUNG_EINFAHREN';
	MITTEGEFAHREN :		arr_last_step_history[0]:='MITTEGEFAHREN';
	BEWEGUNG_MITTE  :	arr_last_step_history[0]:='BEWEGUNG_MITTE';
	LUFTLOS :			arr_last_step_history[0]:='LUFTLOS';
	ZYL_FEHLER :		arr_last_step_history[0]:='ZYL_FEHLER';
	DIREKT_EINFAHREN :	arr_last_step_history[0]:='DIREKT_EINFAHREN';
	DIREKT_AUSFAHREN :	arr_last_step_history[0]:='DIREKT_AUSFAHREN';
ELSE
	arr_last_step_history[0] := INT_TO_STRING(i16_step);
END_CASE

IF 	s_stepTime ='0ms' OR s_stepTime =''THEN
	s_stepTime:='3ms';		(*damit nicht 0 drin steht*)
END_IF
arr_last_step_history[0] := CONCAT(arr_last_step_history[0],':  ');
arr_last_step_history[0] := CONCAT(arr_last_step_history[0],s_stepTime);
arr_last_step_history[0] := CONCAT(arr_last_step_history[0],': ');
arr_last_step_history[0] := CONCAT(arr_last_step_history[0],s_debugtext);
END_ACTION




(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Taktzeit
VAR_INPUT
	b_start			: BOOL;
END_VAR
VAR_OUTPUT
	t_zeit			: TIME;
END_VAR
VAR
	fb_f_trig_stop		: F_TRIG;
	fb_ton			: TON;
END_VAR
(* @END_DECLARATION := '0' *)
fb_f_trig_stop(CLK:= b_start, Q=> );

IF fb_f_trig_stop.Q THEN
	t_zeit := fb_ton.ET;
END_IF

fb_ton(IN:= b_start, PT:= t#20h, Q=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Funktionsbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Winkeltrigger
VAR_INPUT
	IN							: DINT;
	PT							: TIME;
END_VAR
VAR_OUTPUT
	Q							: BOOL;
END_VAR
VAR
	i32_alter_winkel				: DINT := 0;
	i32_neuer_winkel				: DINT := 0;
	b_triggersignal_start			: BOOL := FALSE;
	fb_tof_triggersignal			: TOF;
	t_zeit						: TIME := t#0ms;
END_VAR
(* @END_DECLARATION := '0' *)
(* Sobald sich der Hauptantrieb dreht, wird ein Triggersignal von mindestens 200ms erzeugt um Aktionen auszulösen *)
i32_neuer_winkel := IN;

IF PT < t#200ms THEN
	t_zeit := t#200ms;
ELSE
	t_zeit := PT;
END_IF

IF i32_neuer_winkel <> 360 THEN
	IF i32_neuer_winkel > i32_alter_winkel OR i32_neuer_winkel < i32_alter_winkel THEN
		b_triggersignal_start := TRUE;
	ELSE
		b_triggersignal_start := FALSE;
	END_IF
	i32_alter_winkel := i32_neuer_winkel;
ELSE
	b_triggersignal_start := FALSE;
END_IF

fb_tof_triggersignal(IN:= b_triggersignal_start, PT:= t_zeit, Q=> Q, ET=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine\/Routing\/ADS-Kommunikation' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ReadAdsStruct
VAR_INPUT
	b_Execute				: BOOL;
	b_Reset					: BOOL;
	AmsNetId				: STRING;
	Port						: UINT;
	s_SymbolName			: STRING;
	dw_DestAdr				: DWORD;
END_VAR
VAR_OUTPUT
	b_Busy					: BOOL;
	b_Done					: BOOL;
	b_Error					: BOOL;
	b_ErrorID				: UDINT;
END_VAR
VAR
	s_SymbolNameOld		: STRING;
	str_SymInfo				: SYMINFOSTRUCT;

	fb_read_symbolinfo		: PLC_ReadSymInfoByName;
	fb_ads_read				: ADSREAD;

	Done					: BOOL;
	fb_ton_quitt				: TON;
	fb_state_entry				: ST_StateEntry;
END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_quitt(IN:= , PT:= t#1s, Q=> , ET=> );

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:
		IF b_Execute THEN
			fb_state_entry.i16_next_step := 10;
		END_IF

(*=======================================================*)
	10:	(* Get Symbolinfo if necessary *)
		b_Busy := TRUE;
		IF str_SymInfo.idxGroup <> 0 AND s_SymbolName = s_SymbolNameOld THEN
			fb_state_entry.i16_next_step := 100;
		ELSE
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Read Symbolinfo *)
		fb_read_symbolinfo.START := TRUE;
		IF fb_read_symbolinfo.BUSY THEN
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Done or Error *)
		IF NOT fb_read_symbolinfo.BUSY THEN
			IF NOT fb_read_symbolinfo.ERR THEN
				fb_read_symbolinfo.START := FALSE;
				s_SymbolNameOld := s_SymbolName;
				fb_state_entry.i16_next_step := 100;
			ELSE
				b_Error := TRUE;
				b_ErrorID := fb_read_symbolinfo.ERRID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	100:	(* Read Symbol-Data *)
			fb_ads_read.READ := TRUE;
			IF fb_ads_read.BUSY THEN
				fb_state_entry.i16_next_step := 110;
			END_IF

(*=======================================================*)
	110:	(* Read is Busy *)
		IF NOT fb_ads_read.BUSY THEN
			IF NOT fb_ads_read.ERR THEN
				fb_ads_read.READ := FALSE;
				b_Done := TRUE;
				b_Busy := FALSE;
				fb_state_entry.i16_next_step := 120;
			ELSE
				b_Error := TRUE;
				b_ErrorID := fb_ads_read.ERRID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	120:	(* Read erfolgreich abgeschlossen *)
		IF NOT b_Execute THEN
			b_Done := FALSE;
			b_Busy := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF;

(*=======================================================*)
	1000:	(* Fehler *)
		fb_read_symbolinfo.START := FALSE;
		fb_ads_read.READ := FALSE;

		IF b_Reset THEN
			fb_state_entry.i16_next_step := 0;
			b_Done := FALSE;
			b_Busy := FALSE;
			b_Error := FALSE;
			b_ErrorID := 0;
		END_IF

END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> ,
	i16_step=> ,
	i16_last_step=> );

fb_read_symbolinfo(
	NETID:= AmsNetId,
	PORT:= Port,
	SYMNAME:= s_SymbolName,
	START:= , 
	TMOUT:= DEFAULT_ADS_TIMEOUT,
	BUSY=> , 
	ERR=> , 
	ERRID=> , 
	SYMINFO=> str_SymInfo);

fb_ads_read(
	NETID:= AmsNetId,
	PORT:= Port,
	IDXGRP:= str_SymInfo.idxGroup,
	IDXOFFS:= str_SymInfo.idxOffset,
	LEN:= str_SymInfo.byteSize,
	DESTADDR:= dw_DestAdr,
	READ:= , 
	TMOUT:= DEFAULT_ADS_TIMEOUT,
	BUSY=> , 
	ERR=> , 
	ERRID=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine\/Routing\/ADS-Kommunikation' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_ADS_Kommunikation
VAR_INPUT
	s_read_symbol_name			: STRING;
	s_write_symbol_name			: STRING;
	dw_read_source_adr_vorher	: struct_station_vorher_out;
	dw_write_source_adr_vorher	: struct_station_vorher_in;
	dw_read_source_adr_nachher	: struct_station_nachher_out;
	dw_write_source_adr_nachher	: struct_station_nachher_in;
END_VAR
VAR
	fb_read_ads					: ReadAdsStruct;
	fb_write_ads					: WriteAdsStruct;

	fb_ton_wz					: TON;
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	b_ibn_start					: BOOL := FALSE;
	fb_r_trig_ibn_start				: R_TRIG;
	fb_ton_ibn_start				: TON;
	s_AMSNetId					: STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#3s, Q=> , ET=> );

fb_r_trig_ibn_start(CLK:= b_ibn_start, Q=> );
fb_ton_ibn_start(IN:= , PT:= t#1s, Q=> , ET=> );

IF fb_r_trig_ibn_start.Q THEN
	fb_ton_ibn_start.IN := TRUE;
ELSE
	IF fb_ton_ibn_start.Q THEN
		b_ibn_start := FALSE;
	 	fb_ton_ibn_start.IN := FALSE;
	END_IF
END_IF

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:	(* Initialisierung *)
		fb_read_ads.b_Execute := FALSE;
		fb_write_ads.b_Execute := FALSE;
		fb_read_ads.b_Reset := FALSE;
		fb_write_ads.b_Reset := FALSE;
		fb_ton_wz.IN := FALSE;
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte bis Routing-Verbindung zum Front-PC wurde angelegt wurde *)
		IF fb_state_entry.E THEN
			;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_RoutingBackpanel.fb_state_entry.i16_step = 999 THEN
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Lese NetId von angeschlossenen Remote-PCs *)
		IF fb_state_entry.E THEN
			s_AMSNetId :=  ST_RoutingBackpanel.s_backpanel_netid;
		END_IF

		fb_state_entry.i16_next_step := 100;

(*==========================LESEN=============================*)
	100:	(* Lesen der Symbole über ADS *)
		IF fb_state_entry.E THEN
			fb_read_ads.b_Execute := TRUE;
		END_IF

		IF fb_read_ads.b_Busy THEN
			fb_read_ads.b_Execute := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110:	(* Lesen abgeschlossen *)
		IF NOT fb_read_ads.b_Busy AND fb_read_ads.b_Done THEN
			fb_state_entry.i16_next_step := 200;
		ELSIF fb_read_ads.b_Error THEN
			fb_state_entry.i16_next_step := 1000;
		END_IF

(*===========================SCHREIBEN============================*)
	200:	(* Schreiben der Symbole über ADS *)
		IF fb_state_entry.E THEN
			fb_write_ads.b_Execute := TRUE;
		END_IF

		IF fb_write_ads.b_Busy THEN
			fb_write_ads.b_Execute := FALSE;
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* Schreiben abgeschlossen *)
		IF NOT fb_write_ads.b_Busy AND fb_write_ads.b_Done THEN
			fb_state_entry.i16_next_step := 999;
		ELSIF fb_write_ads.b_Error THEN
			fb_state_entry.i16_next_step := 1000;
		END_IF

(*=======================================================*)
	999:	(* Ende *)
		fb_state_entry.i16_next_step := 100;

(*=======================================================*)
	1000:	(* Fehler *)
		IF fb_state_entry.E THEN
			fb_read_ads.b_Execute := FALSE;
			fb_write_ads.b_Execute := FALSE;
			fb_ton_wz.IN := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF  fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_read_ads.b_Reset := TRUE;
			fb_write_ads.b_Reset := TRUE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> ,
	i16_step=> ,
	i16_last_step=> );

fb_read_ads(
	b_Execute:= ,
	b_Reset:= ,
	AmsNetId:= s_AMSNetId ,
	Port:= 801,
	s_SymbolName:=s_read_symbol_name ,
	dw_DestAdr:= ADR(dw_read_source_adr_vorher),
	b_Busy=> ,
	b_Done=> ,
	b_Error=> ,
	b_ErrorID=> );

fb_write_ads(
	b_Execute:= ,
	b_Reset:= ,
	AmsNetId:= s_AMSNetId,
	Port:= 801 ,
	s_SymbolName:=  s_write_symbol_name,
	dw_SourceAdr:= ADR(dw_write_source_adr_vorher) ,
	b_Busy=> ,
	b_Done=> ,
	b_Error=> ,
	b_ErrorID=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine\/Routing\/ADS-Kommunikation' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK WriteAdsStruct
VAR_INPUT
	b_Execute				: BOOL;
	b_Reset					: BOOL;
	AmsNetId				: STRING;
	Port						: UINT;
	s_SymbolName			: STRING;
	dw_SourceAdr			: DWORD;
END_VAR
VAR_OUTPUT
	b_Busy					: BOOL;
	b_Done					: BOOL;
	b_Error					: BOOL;
	b_ErrorID				: UDINT;
END_VAR
VAR
	s_SymbolNameOld		: STRING;
	str_SymInfo				: SYMINFOSTRUCT;

	fb_read_symbolinfo		: PLC_ReadSymInfoByName;
	fb_ads_write				: ADSWRITE;

	Done					: BOOL;
	fb_ton_quitt				: TON;
	fb_state_entry				: ST_StateEntry;
END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_quitt(IN:= , PT:= t#1s, Q=> , ET=> );

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_next_step OF
(*=======================================================*)
	0:
		IF b_Execute THEN
			fb_state_entry.i16_next_step := 10;
		END_IF

(*=======================================================*)
	10:	(* Get Symbolinfo if necessary *)
		b_Busy := TRUE;
		IF str_SymInfo.idxGroup <> 0 AND s_SymbolName = s_SymbolNameOld THEN
			fb_state_entry.i16_next_step := 100;
		ELSE
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Read Symbolinfo *)
		fb_read_symbolinfo.START := TRUE;
		IF fb_read_symbolinfo.BUSY THEN
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Done or Error *)
		IF NOT fb_read_symbolinfo.BUSY THEN
			IF NOT fb_read_symbolinfo.ERR THEN
				fb_read_symbolinfo.START := FALSE;
				s_SymbolNameOld := s_SymbolName;
				fb_state_entry.i16_next_step := 100;
			ELSE
				b_Error := TRUE;
				b_ErrorID := fb_read_symbolinfo.ERRID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	100:	(* Read Symbol-Data *)
			fb_ads_write.WRITE := TRUE;
			IF fb_ads_write.BUSY THEN
				fb_state_entry.i16_next_step := 110;
			END_IF

(*=======================================================*)
	110:	(* Read is Busy *)
		IF NOT fb_ads_write.BUSY THEN
			IF NOT fb_ads_write.ERR THEN
				fb_ads_write.WRITE := FALSE;
				b_Done := TRUE;
				b_Busy := FALSE;
				fb_state_entry.i16_next_step := 120;
			ELSE
				b_Error := TRUE;
				b_ErrorID := fb_ads_write.ERRID;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	120:	(* Read erfolgreich abgeschlossen *)
		IF NOT b_Execute THEN
			b_Done := FALSE;
			b_Busy := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF;

(*=======================================================*)
	1000:	(* Fehler *)
		fb_read_symbolinfo.START := FALSE;
		fb_ads_write.WRITE := FALSE;

		IF b_Reset THEN
			fb_state_entry.i16_next_step := 0;
			b_Done := FALSE;
			b_Busy := FALSE;
			b_Error := FALSE;
			b_ErrorID := 0;
		END_IF

END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> ,
	i16_step=> ,
	i16_last_step=> );

fb_read_symbolinfo(
	NETID:= AmsNetId,
	PORT:= Port,
	SYMNAME:= s_SymbolName,
	START:= , 
	TMOUT:= DEFAULT_ADS_TIMEOUT,
	BUSY=> , 
	ERR=> , 
	ERRID=> , 
	SYMINFO=> str_SymInfo);

fb_ads_write(
	NETID:= AmsNetId,
	PORT:= Port,
	IDXGRP:= str_SymInfo.idxGroup,
	IDXOFFS:= str_SymInfo.idxOffset,
	LEN:= str_SymInfo.byteSize,
	SRCADDR:= dw_SourceAdr,
	WRITE:= ,
	TMOUT:= DEFAULT_ADS_TIMEOUT,
	BUSY=> , 
	ERR=> , 
	ERRID=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine\/Routing\/PC-Suche' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_RoutingBackpanel
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz					: TON;
	arr_read_routing_info			: ARRAY [0..31] OF ST_AmsRouteEntry;
	b_routing_station_gefunden		: BOOL;
	fb_add_route_entry			: FB_AddRouteEntry;
	fb_enum_route_entry			: FB_EnumRouteEntry;
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	i16_eintrag					: INT := 0;
	b_ibn_start_routing			: BOOL := FALSE;
	fb_r_trig_ibn_start_routing		: R_TRIG;
	fb_ton_ibn_start_routing		: TON;
	s_backpanel_adresse			: STRING[255] := '';
	s_backpanel_netid			: STRING[255] := '';
	s_backpanel_name			: STRING[255] := '';
	s_temp_net_string				: STRING[255] := '';
	i16_temp_net_int				: INT := 0;
	s_temp_ip_string				: STRING[255] := '';
	i16_temp_ip_int				: INT := 0;
	s_temp_string_p11			: STRING[255] := '';
	s_temp_string_p12			: STRING[255] := '';
	s_temp_string_p13			: STRING[255] := '';
	fb_get_local_ams_netid		: ST_GetLocalAMSNetID;
	fb_get_adapters_info			: ST_GetAdaptersInfo;
	fb_get_host_name				: FB_GetHostName;
	fb_get_host_addr_by_name		: FB_GetHostAddrByName;
	st_pc_adapter_info			: ST_IpAdapterInfo;
	st_backpanel_adapter_info		: ST_IpAdapterInfo;
	sm_fehler_netid				: BOOL := FALSE;
	sm_fehler_adapter_info		: BOOL := FALSE;
	sm_fehler_host_name			: BOOL := FALSE;
	sm_fehler_host_addr			: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_wz(IN:= , PT:= t#10s , Q=> , ET=> );

fb_r_trig_ibn_start_routing(CLK:= b_ibn_start_routing, Q=> );
fb_ton_ibn_start_routing(IN:= , PT:= t#1s, Q=> , ET=> );

IF fb_r_trig_ibn_start_routing.Q THEN
	fb_ton_ibn_start_routing.IN := TRUE;
ELSE
	IF fb_ton_ibn_start_routing.Q THEN
		b_ibn_start_routing := FALSE;
	 	fb_ton_ibn_start_routing.IN := FALSE;
	END_IF
END_IF

(* =======================================Toplevel========================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	 IF fb_get_adapters_info.bError OR fb_get_local_ams_netid.bError THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:
		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
	INIT:	(* Initialisierung *)
		st_ctrl_out.b_fehler := FALSE;
		st_ctrl_out.b_fertig := FALSE;
		st_ctrl_out.b_bereit := FALSE;
		fb_add_route_entry.bExecute := FALSE;
		fb_enum_route_entry.bExecute := FALSE;
		fb_enum_route_entry.eCmd := eEnumCmd_First;
		b_routing_station_gefunden := TRUE;
		i16_eintrag := 0;
		fb_get_local_ams_netid.bExecute := FALSE;
		fb_get_local_ams_netid.bQuit := FALSE;
		fb_get_adapters_info.bExecute := FALSE;
		fb_get_adapters_info.bQuit := FALSE;
		fb_get_host_name.bExecute := FALSE;
		fb_get_host_addr_by_name.bExecute := FALSE;
		sm_fehler_netid := FALSE;
		sm_fehler_adapter_info := FALSE;
		sm_fehler_host_name := FALSE;
		sm_fehler_host_addr := FALSE;

		FOR i16_eintrag := 0  TO (SIZEOF (arr_read_routing_info) / SIZEOF (arr_read_routing_info[0])) BY 1DO
			IF	i16_eintrag <32 THEN
				arr_read_routing_info[i16_eintrag].sName := '';
				arr_read_routing_info[i16_eintrag].sNetID := '';
				arr_read_routing_info[i16_eintrag].sAddress := '';
				arr_read_routing_info[i16_eintrag].eTransport := eRouteTransport_TCP_IP;
			END_IF
		END_FOR

		IF fb_get_local_ams_netid.bReady AND fb_get_adapters_info.bReady THEN
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Die AMS-NetID des lokalen PC ermitteln *)
		IF fb_state_entry.E THEN
			fb_get_local_ams_netid.bExecute := TRUE;
		END_IF

		IF fb_get_local_ams_netid.bBusy THEN
			fb_get_local_ams_netid.bExecute := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	30:
		IF NOT fb_get_local_ams_netid.bBusy  AND fb_get_local_ams_netid.bReady THEN
			IF NOT fb_get_local_ams_netid.bError THEN
				fb_state_entry.i16_next_step := 40;
			ELSE	(* Fehler *)
				sm_fehler_netid := TRUE;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	40:	(* Ersten Routing Eintrag im Routingtable lesen *)
		IF fb_state_entry.E THEN
			s_temp_string_p11 := MID(fb_get_local_ams_netid.local_ams_netid, 1, 11);
			s_temp_string_p12 := MID(fb_get_local_ams_netid.local_ams_netid, 1, 12);
			s_temp_string_p13 := MID(fb_get_local_ams_netid.local_ams_netid, 1, 13);
			IF s_temp_string_p11 = '.' THEN
				(* Die vierte Zahl ist einstellig *)
				i16_temp_net_int := STRING_TO_INT(MID(fb_get_local_ams_netid.local_ams_netid, 1, 10));
			ELSIF s_temp_string_p12 = '.' THEN
				(* Die vierte Zahl ist zweistellig *)
				i16_temp_net_int := STRING_TO_INT(MID(fb_get_local_ams_netid.local_ams_netid, 2, 10));
			ELSIF s_temp_string_p13 = '.' THEN
				(* Die vierte Zahl ist dreistellig *)
				i16_temp_net_int := STRING_TO_INT(MID(fb_get_local_ams_netid.local_ams_netid, 3, 10));
			END_IF
			i16_temp_net_int := i16_temp_net_int  + 1;	(* Die NetID des Remote-Panel ist um 1 höher, als diejenige des PCs *)
			s_temp_net_string := INT_TO_STRING (i16_temp_net_int);
			s_backpanel_netid := CONCAT((CONCAT(MID(fb_get_local_ams_netid.s_ams_netid, 9, 1), s_temp_net_string)), '.1.1');
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:	(* Die Adapter-Info des lokalen PC ermitteln *)
		IF fb_state_entry.E THEN
			fb_get_adapters_info.sNet_ID := fb_get_local_ams_netid.local_ams_netid;
			fb_get_adapters_info.bExecute := TRUE;
		END_IF

		IF fb_get_adapters_info.bBusy THEN
			fb_get_adapters_info.bExecute := FALSE;
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60:	(* Info steht zur Verfügung *)
		IF NOT fb_get_adapters_info.bBusy THEN
			IF NOT fb_get_adapters_info.bError THEN
				IF fb_get_adapters_info.bReady THEN
					st_pc_adapter_info := fb_get_adapters_info.st_ip_adapter_info;
					fb_state_entry.i16_next_step := 70;
				END_IF
			ELSE	(* Fehler *)
				sm_fehler_adapter_info := TRUE;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	70:	(* Die Adapter-Info des Backpanel ermitteln *)
		IF fb_state_entry.E THEN
			fb_get_adapters_info.sNet_ID := s_backpanel_netid;
			fb_get_adapters_info.bExecute := TRUE;
		END_IF

		IF fb_get_adapters_info.bBusy THEN
			fb_get_adapters_info.bExecute := FALSE;
			fb_state_entry.i16_next_step := 80;
		END_IF

(*=======================================================*)
	80:	(* Info steht zur Verfügung *)
		IF NOT fb_get_adapters_info.bBusy THEN
			IF NOT fb_get_adapters_info.bError THEN
				IF fb_get_adapters_info.bReady THEN
					st_pc_adapter_info := fb_get_adapters_info.st_ip_adapter_info;
					s_backpanel_adresse := st_pc_adapter_info.sIpAddr;
					fb_state_entry.i16_next_step := 90;
				END_IF
			ELSE	(* Fehler *)
				sm_fehler_adapter_info := TRUE;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	90:	(* Den Namen des Backpanels ermitteln *)
		IF fb_state_entry.E THEN
			fb_get_host_name.sNetID := s_backpanel_netid;
			fb_get_host_name.bExecute := TRUE;
		END_IF

		IF fb_get_host_name.bBusy THEN
			fb_get_host_name.bExecute := FALSE;
			fb_state_entry.i16_next_step := 100;
		END_IF

(*=======================================================*)
	100:	(* Info steht zur Verfügung *)
		IF NOT fb_get_host_name.bBusy THEN
			IF NOT fb_get_host_name.bError THEN
				s_backpanel_name := fb_get_host_name.sHostName;
				fb_state_entry.i16_next_step := 110;
			ELSE	(* Fehler *)
				sm_fehler_host_name := TRUE;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	110:	(* Ersten Routing Eintrag im Routingtable lesen *)
		IF fb_state_entry.E THEN
			fb_enum_route_entry.bExecute := TRUE;
		END_IF

		IF fb_enum_route_entry.bBusy THEN
			fb_enum_route_entry.bExecute := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120:	(* Routinginformation ist vorhanden *)
		IF NOT fb_enum_route_entry.bBusy  THEN
			IF NOT fb_enum_route_entry.bError THEN
				IF NOT fb_enum_route_entry.bEOE THEN
					arr_read_routing_info[i16_eintrag] := fb_enum_route_entry.stRoute;
					fb_enum_route_entry.eCmd := eEnumCmd_Next;
					i16_eintrag := i16_eintrag + 1;
					fb_state_entry.i16_next_step := 110;
				ELSE	(* Alle vorhandenen Routingeinträge  wurden eingelesen*)
					fb_state_entry.i16_next_step := 130;
				END_IF
			ELSE	(* Fehler *)
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	130:	(* Alle Einträge sind gelesen *)
		IF fb_state_entry.E THEN
			(* Suche nach dem zugehörigen Backpanel *)
			FOR i16_eintrag := 0  TO (SIZEOF (arr_read_routing_info) / SIZEOF (arr_read_routing_info[0])) BY 1DO
				IF arr_read_routing_info[i16_eintrag].sNetID = s_backpanel_netid AND arr_read_routing_info[i16_eintrag].sAddress = s_backpanel_adresse THEN
					b_routing_station_gefunden := TRUE;
					fb_state_entry.i16_next_step :=  999;	(* Ende *)
					EXIT;
				ELSE
					b_routing_station_gefunden := FALSE;
				END_IF
			END_FOR
			IF NOT b_routing_station_gefunden THEN
				(* Station nicht in Liste -> eintragen *)
				fb_state_entry.i16_next_step := 140;
			END_IF
		END_IF

(*=======================================================*)
	140:	(* Routingtable mit Backpaneladresse füllen *)
		IF fb_state_entry.E THEN
			(* Initialisierung der Routingverbindung zum Backpanel *)
			fb_add_route_entry.stRoute.sName := s_backpanel_name;
			fb_add_route_entry.stRoute.sNetID := s_backpanel_netid;
			fb_add_route_entry.stRoute.sAddress := s_backpanel_adresse;
			fb_add_route_entry.stRoute.eTransport := eRouteTransport_TCP_IP;
			fb_add_route_entry.bExecute :=TRUE;
		END_IF

		IF fb_add_route_entry.bBusy THEN
			fb_add_route_entry.bExecute := FALSE;
			fb_state_entry.i16_next_step := 150;
		END_IF

(*=======================================================*)
	150:	(* Routingtable füllen läuft *)
		IF NOT fb_add_route_entry.bBusy THEN
			IF NOT fb_add_route_entry.bError THEN	(* Route wurde erfolgreich hinzugefügt *)
				fb_state_entry.i16_next_step := 999;
			ELSE	(* Fehler *)
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	999: (* Ende: Alle Stationen wurden im Routingtable eingetragen *)
		IF fb_r_trig_ibn_start_routing.Q THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			fb_add_route_entry.bExecute := FALSE;
			fb_enum_route_entry.bExecute := FALSE;
			fb_get_local_ams_netid.bExecute := FALSE;
			fb_get_local_ams_netid.bQuit := FALSE;
			fb_get_adapters_info.bExecute := FALSE;
			fb_get_adapters_info.bQuit := FALSE;
			fb_get_host_name.bExecute := FALSE;
			fb_get_host_addr_by_name.bExecute := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_get_local_ams_netid .bQuit := TRUE;
			fb_get_adapters_info .bQuit := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q OR  fb_r_trig_ibn_start_routing.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

fb_get_local_ams_netid(
	bExecute:= , 
	bQuit:= , 
	bBusy=> , 
	bReady=> , 
	bError=> , 
	nErrId=> , 
	s_ams_netid=> );

fb_add_route_entry(
	sNetID:= '',
	stRoute:= ,
	bExecute:= ,
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> ,
	bError=> ,
	nErrID=> );

fb_enum_route_entry(
	sNetID:= '',
	eCmd:= , 
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> ,
	bError=> , 
	nErrID=> , 
	bEOE=> , 
	stRoute=> );

fb_get_adapters_info(
	sNet_ID:= , 
	bExecute:= , 
	bQuit:= , 
	bBusy=> ,
	bReady=> , 
	bError=> ,
	nErrId=> , 
	st_ip_adapter_info=> );

fb_get_host_name(
	sNetID:= ,
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> ,
	nErrID=> , 
	sHostName=> );

fb_get_host_addr_by_name(
	sNetID:= '',
	sHostName:= ,
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> , 
	nErrID=> , 
	sAddr=> , 
	arrAddr=> );

IF st_config.b_config_fertig THEN
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_netid;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_fehler_adapter_info;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_fehler_host_addr;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine\/Routing\/PC-Suche' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_RoutingNachbarPC
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	arr_read_routing_info			: ARRAY [0..31] OF ST_AmsRouteEntry;
	fb_add_route_entry			: FB_AddRouteEntry;
	fb_enum_route_entry			: FB_EnumRouteEntry;
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	i16_geschriebene_eintraege	: INT := 0;
	i16_vorhandene_eintraege		: INT := 0;
	b_ibn_start_routing			: BOOL := FALSE;
	fb_r_trig_ibn_start_routing		: R_TRIG;
	fb_ton_ibn_start_routing		: TON;
	sm_fehler_remotesuche		: BOOL := FALSE;
	sm_fehler_netid				: BOOL := FALSE;
	fb_suche_remote_pc			: ST_SucheRemotePC;
	fb_get_local_ams_netid		: ST_GetLocalAMSNetID;
	i16_eintrag					: INT := 0;
END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_r_trig_ibn_start_routing(CLK:= b_ibn_start_routing, Q=> );
fb_ton_ibn_start_routing(IN:= , PT:= t#1s, Q=> , ET=> );

IF fb_r_trig_ibn_start_routing.Q THEN
	fb_ton_ibn_start_routing.IN := TRUE;
ELSE
	IF fb_ton_ibn_start_routing.Q THEN
		b_ibn_start_routing := FALSE;
	 	fb_ton_ibn_start_routing.IN := FALSE;
	END_IF
END_IF

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:	(* Initialisierung *)
		st_ctrl_out.b_fehler := TRUE;
		st_ctrl_out.b_bereit := TRUE;
		st_ctrl_out.b_fertig := TRUE;
		fb_add_route_entry.bExecute := FALSE;
		fb_enum_route_entry.bExecute := FALSE;
		fb_suche_remote_pc.bQuit := FALSE;
		fb_suche_remote_pc.bExecute := FALSE;
		fb_get_local_ams_netid .bQuit := FALSE;
		fb_get_local_ams_netid.bExecute := FALSE;
		fb_enum_route_entry.eCmd := eEnumCmd_First;
		i16_geschriebene_eintraege := 0;
		i16_vorhandene_eintraege := 0;
		sm_fehler_remotesuche := FALSE;
		sm_fehler_netid := FALSE;

		FOR i16_eintrag := 0  TO (SIZEOF (arr_read_routing_info) / SIZEOF (arr_read_routing_info[0])) BY 1DO
			arr_read_routing_info[i16_eintrag].sName := '';
			arr_read_routing_info[i16_eintrag].sNetID := '';
			arr_read_routing_info[i16_eintrag].sAddress := '';
			arr_read_routing_info[i16_eintrag].eTransport := eRouteTransport_TCP_IP;
		END_FOR

		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Die AMS-NetID des lokalen PC ermitteln *)
		IF fb_state_entry.E THEN
			fb_get_local_ams_netid.bExecute := TRUE;
		END_IF

		IF fb_get_local_ams_netid.bBusy THEN
			fb_get_local_ams_netid.bExecute := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:
		IF NOT fb_get_local_ams_netid.bBusy  THEN
			IF NOT fb_get_local_ams_netid.bError THEN
				fb_state_entry.i16_next_step := 100;
			ELSE	(* Fehler *)
				sm_fehler_netid := TRUE;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	100:	(* Ersten Routing Eintrag im Routingtable lesen *)
		IF fb_state_entry.E THEN
			fb_enum_route_entry.bExecute := TRUE;
		END_IF

		IF fb_enum_route_entry.bBusy THEN
			fb_enum_route_entry.bExecute := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110:	(* Routinginformation ist vorhanden *)
		IF NOT fb_enum_route_entry.bBusy  THEN
			IF NOT fb_enum_route_entry.bError THEN
				IF NOT fb_enum_route_entry.bEOE THEN
					arr_read_routing_info[i16_vorhandene_eintraege] := fb_enum_route_entry.stRoute;
					fb_enum_route_entry.eCmd := eEnumCmd_Next;
					fb_state_entry.i16_next_step := 120;
				ELSE	(* Alle vorhandenen Routingeinträge  wurden eingelesen*)
					fb_state_entry.i16_next_step := 130;
				END_IF
			ELSE	(* Fehler *)
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	120:	(* Zähler erhöhen *)
		IF fb_state_entry.E THEN
			i16_vorhandene_eintraege := i16_vorhandene_eintraege + 1;
		END_IF

		fb_state_entry.i16_next_step := 100;

(*=======================================================*)
	130:	(* Suche Nachbar-PCs im Maschinennetz *)
		IF fb_state_entry.E THEN
			fb_suche_remote_pc.bExecute := TRUE;
		END_IF

		IF fb_suche_remote_pc.bBusy THEN
			fb_suche_remote_pc.bExecute := FALSE;
			fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	140:	(* Suchvorgang und beendet *)
		IF NOT fb_suche_remote_pc.bBusy  THEN
			IF NOT fb_suche_remote_pc.bError THEN
				fb_state_entry.i16_next_step := 150;
			ELSE	(* Fehler *)
				sm_fehler_remotesuche := TRUE;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	150:	(* Die Route der gefundenen Nachbar-PCs eintragen *)
		IF fb_state_entry.E THEN
			fb_add_route_entry.stRoute.sName := fb_suche_remote_pc.st_remote_pcinfo_struct[i16_geschriebene_eintraege].Name;
			fb_add_route_entry.stRoute.sNetID := fb_suche_remote_pc.st_remote_pcinfo_struct[i16_geschriebene_eintraege].NetId;
			fb_add_route_entry.stRoute.sAddress := DELETE(fb_add_route_entry.stRoute.sNetID, 4, 12);
			fb_add_route_entry.stRoute.eTransport := eRouteTransport_TCP_IP;
			fb_add_route_entry.bExecute :=TRUE;
			i16_geschriebene_eintraege := i16_geschriebene_eintraege + 1;
		END_IF

		IF fb_add_route_entry.bBusy THEN
			fb_add_route_entry.bExecute := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160:	(* Routingtable füllen läuft *)
		IF NOT fb_add_route_entry.bBusy THEN
			IF NOT fb_add_route_entry.bError THEN	(* Route wurde erfolgreich hinzugefügt *)
				(* Routingtable mit fehlenden Stationsadressen füllen wenn notwendig *)
				IF i16_geschriebene_eintraege < i16_vorhandene_eintraege THEN
					fb_state_entry.i16_next_step := 150;
				ELSE
					fb_state_entry.i16_next_step := 999;
				END_IF
			ELSE	(* Fehler *)
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	999: (* Ende: Alle Stationen wurden im Routingtable eingetragen *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig := TRUE;
		END_IF

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			fb_add_route_entry.bExecute := FALSE;
			fb_enum_route_entry.bExecute := FALSE;
			fb_suche_remote_pc.bExecute := FALSE;
			fb_suche_remote_pc.bQuit := FALSE;
			fb_get_local_ams_netid.bExecute := FALSE;
			fb_get_local_ams_netid.bQuit := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
			fb_suche_remote_pc.bQuit := TRUE;
			fb_get_local_ams_netid .bQuit := TRUE;
		END_IF

		IF fb_ton_quitt.Q OR  fb_r_trig_ibn_start_routing.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

fb_get_local_ams_netid(
	bExecute:= , 
	bQuit:= , 
	bBusy=> , 
	bReady=> , 
	bError=> , 
	nErrId=> , 
	s_ams_netid=> );

fb_suche_remote_pc(
	bExecute:= ,
	bQuit:= , 
	bBusy=> , 
	bError=> , 
	nErrId=> );

fb_add_route_entry(
	sNetID:= ,
	stRoute:= ,
	bExecute:= ,
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> , 
	nErrID=> );

fb_enum_route_entry(
	sNetID:= ,
	eCmd:= , 
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> , 
	nErrID=> , 
	bEOE=> , 
	stRoute=> );

IF st_config.b_config_fertig THEN
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_remotesuche;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_fehler_netid;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine\/Routing\/PC-Suche' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_SucheRemotePC
VAR_INPUT
	bExecute			: BOOL;
	bQuit				: BOOL;
END_VAR
VAR_OUTPUT
	bBusy				: BOOL;
	bError				: BOOL;
	nErrId				: UDINT;
END_VAR
VAR
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	fb_r_trig_execute				: R_TRIG;
	i							: INT := 0;
	b_ibn_start					: BOOL := FALSE;
	fb_r_trig_ibn_start				: R_TRIG;
	fb_ton_ibn_start				: TON;
	fb_get_remote_pcinfo			:GetRemotePCInfo;
	st_remote_pcinfo_struct		:REMOTEPCINFOSTRUCT;
							       (*TYPE REMOTEPCINFOSTRUCT
									ARRAY[0..99] OF REMOTEPC;
								END_TYPE*)
							      (*TYPE REMOTEPC
								STRUCT
									NetId 	: T_AmsNetId;
									Name 	: STRING(31);
								END_STRUCT
								END_TYPE*)
END_VAR
(* @END_DECLARATION := '0' *)
fb_r_trig_execute(CLK:= bExecute, Q=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

fb_r_trig_ibn_start(CLK:= b_ibn_start, Q=> );
fb_ton_ibn_start(IN:= , PT:= t#1s, Q=> , ET=> );

IF fb_r_trig_ibn_start.Q THEN
	fb_ton_ibn_start.IN := TRUE;
ELSE
	IF fb_ton_ibn_start.Q THEN
		b_ibn_start := FALSE;
	 	fb_ton_ibn_start.IN := FALSE;
	END_IF
END_IF

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:(* INIT *)
		bBusy := FALSE;
		bError := FALSE;
		nErrId := 0;
		fb_get_remote_pcinfo.START := FALSE;
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte auf Execute-Befehl *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
		END_IF

		IF fb_r_trig_execute.Q OR fb_r_trig_ibn_start.Q THEN
			bBusy := TRUE;
			fb_state_entry.i16_next_step := 100;
		END_IF

(*=======================================================*)
	100:	(* Starte mit Auslesen der über ADS verbundenen Nachbar-PCs *)
		IF fb_state_entry.E THEN
			fb_get_remote_pcinfo.START := TRUE;
		END_IF

		IF fb_get_remote_pcinfo.BUSY THEN
			fb_get_remote_pcinfo.START := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110:	(* Routinginformation über die Nachbar-PCs ist vorhanden *)
		IF NOT fb_get_remote_pcinfo.BUSY  THEN
			IF NOT fb_get_remote_pcinfo.ERR THEN
				fb_state_entry.i16_next_step := 999;
			ELSE	(* Fehler *)
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	999:	(* Kontrollschritt: Nachbar-PC ist gefunden *)
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
			bError := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bQuit AND NOT fb_state_entry.E THEN
			bError := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

fb_get_remote_pcinfo(
	NETID:= , 
	START:= , 
	TMOUT:= , 
	BUSY=> , 
	ERR=> , 
	ERRID=> , 
	RemotePCInfo=> st_remote_pcinfo_struct);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine\/Routing' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_GetAdaptersInfo
VAR_INPUT
	sNet_ID						: T_AmsNetId;
	bExecute					: BOOL;
	bQuit						: BOOL;
END_VAR
VAR_OUTPUT
	bBusy						: BOOL;
	bReady						: BOOL;
	bError						: BOOL;
	nErrId						: UDINT;
	st_ip_adapter_info				: ST_IpAdapterInfo;
END_VAR
VAR
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	fb_r_trig_execute				: R_TRIG;
	fb_get_adapters_info			: FB_GetAdaptersInfo;
	arr_adapters 					: ARRAY[0..MAX_LOCAL_ADAPTERS] OF ST_IpAdapterInfo;
END_VAR
(* @END_DECLARATION := '0' *)
(* Auslesen von IP-Adresse usw. des lokalen PCs *)
fb_r_trig_execute(CLK:= bExecute, Q=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* =======================================Toplevel========================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	 IF fb_get_adapters_info.bError THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:
		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
	INIT:(* INIT *)
		bBusy := FALSE;
		bReady := FALSE;
		bError := FALSE;
		nErrId := 0;
		fb_get_adapters_info.bExecute := FALSE;
		fb_state_entry.i16_next_step := 20;

(*=======================================================*)
	20:	(* Warte auf Execute-Befehl *)
		IF fb_state_entry.E THEN
			bReady := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_execute.Q THEN
			bReady := FALSE;
			bBusy := TRUE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Starte mit Auslesen der Adapter-Info des lokalen PC *)
		IF fb_state_entry.E THEN
			fb_get_adapters_info.bExecute := TRUE;
		END_IF

		IF fb_get_adapters_info.bBusy THEN
			fb_get_adapters_info.bExecute := FALSE;
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:	(* Adapter-Info wurde ausgelesen *)
		IF NOT fb_get_adapters_info.bBusy THEN
			IF NOT fb_get_adapters_info.bError THEN
				bBusy := FALSE;
				fb_state_entry.i16_next_step := 999;
			ELSE	(* Fehler *)
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	999:	(* Fertig *)
		st_ip_adapter_info := arr_adapters[1];
		fb_state_entry.i16_next_step := 20;

(*=======================================================*)
	FEHLER: (* Fehler *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
			bReady := FALSE;
			bError := TRUE;
			fb_get_adapters_info.bExecute := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bQuit AND NOT fb_state_entry.E THEN
			bError := FALSE;
			fb_ton_quitt.IN := TRUE;
			(* Quittierflanke für FB *)
			fb_get_adapters_info.bExecute := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

fb_get_adapters_info(
	sNetID:= sNet_ID,
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> ,
	bError=> , 
	nErrID=> nErrId,
	arrAdapters=> arr_adapters,
	nCount=> , 
	nGet=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine\/Routing' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_GetLocalAMSNetID
VAR_INPUT
	bExecute			: BOOL;
	bQuit				: BOOL;
END_VAR
VAR_OUTPUT
	bBusy				: BOOL;
	bReady				: BOOL;
	bError				: BOOL;
	nErrId				: UDINT;
	s_ams_netid			: T_AmsNetId;
END_VAR
VAR
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	fb_r_trig_execute				: R_TRIG;
	fb_get_local_ams_netId		: FB_GetLocalAmsNetId;
	local_ams_netid				: T_AmsNetId := '0.0.0.0.0.0';
	ams_netid_arr				: T_AmsNetIdArr ;
END_VAR
(* @END_DECLARATION := '0' *)
fb_r_trig_execute(CLK:= bExecute, Q=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* =======================================Toplevel========================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	 IF fb_get_local_ams_netId.bError THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:
		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
	10:(* INIT *)
		bBusy := FALSE;
		bReady := FALSE;
		bError := FALSE;
		nErrId := 0;
		s_ams_netid :=  '0.0.0.0.0.0';
		fb_get_local_ams_netId.bExecute := FALSE;
		fb_state_entry.i16_next_step := 20;

(*=======================================================*)
	20:	(* Warte auf Execute-Befehl *)
		IF fb_state_entry.E THEN
			bReady := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_execute.Q THEN
			bReady := FALSE;
			bBusy := TRUE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Starte mit Auslesen der NetID des lokalen PC *)
		IF fb_state_entry.E THEN
			fb_get_local_ams_netId.bExecute := TRUE;
		END_IF

		IF fb_get_local_ams_netId.bBusy THEN
			fb_get_local_ams_netId.bExecute := FALSE;
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:	(* NetID wurde ausgelesen *)
		IF NOT fb_get_local_ams_netId.bBusy THEN
			IF NOT fb_get_local_ams_netId.bError THEN
				bBusy := FALSE;
				fb_state_entry.i16_next_step := 50;
			ELSE	(* Fehler *)
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	50:	(* Prüfe NetID  *)
		IF local_ams_netid <> '0.0.0.0.0.0' THEN
			s_ams_netid := local_ams_netid;
			fb_state_entry.i16_next_step := 999;
		ELSE	(* Fehler *)
			fb_state_entry.i16_next_step := 1000;
		END_IF

(*=======================================================*)
	999:	(* Kontrollschritt: NetID ist korrekt *)
		fb_state_entry.i16_next_step := 20;

(*=======================================================*)
	FEHLER: (* Fehler *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
			bReady := FALSE;
			bError := TRUE;
			fb_get_local_ams_netId.bExecute := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bQuit AND NOT fb_state_entry.E THEN
			bError := FALSE;
			fb_ton_quitt.IN := TRUE;
			(* Quittierflanke für FB *)
			fb_get_local_ams_netId.bExecute := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

fb_get_local_ams_netId(
	bExecute:= ,
	tTimeOut:= DEFAULT_ADS_TIMEOUT,
	bBusy=> ,
	bError=> , 
	nErrId=> nErrId,
	AddrString=> local_ams_netid,
	AddrBytes=> ams_netid_arr);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Start_Batchscript
VAR_INPUT
	bExecute			: BOOL;
	bQuit				: BOOL;
	st_pfad				: STRING;
END_VAR
VAR_OUTPUT
	bBusy				: BOOL;
	bReady				: BOOL;
	bError				: BOOL;
	nErrId				: UDINT;
END_VAR
VAR
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	fb_r_trig_execute				: R_TRIG;
	fb_nt_start_process			: NT_StartProcess;
END_VAR
(* @END_DECLARATION := '0' *)
(* Starten eines Batchscriptes auf dem lokalen PC *)
fb_r_trig_execute(CLK:= bExecute, Q=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:(* INIT *)
		bBusy := FALSE;
		bReady := FALSE;
		bError := FALSE;
		nErrId := 0;
		fb_nt_start_process.START := FALSE;
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte auf Execute-Befehl *)

		IF fb_r_trig_execute.Q THEN
			bReady := FALSE;
			bBusy := TRUE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Starte mit Ausführen des Batchscriptes *)
		IF fb_state_entry.E THEN
			fb_nt_start_process.START := TRUE;
		END_IF

		IF fb_nt_start_process.BUSY THEN
			fb_nt_start_process.START := FALSE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Script wurde erfolgreich ausgeführt *)
		IF NOT fb_nt_start_process.BUSY THEN
			IF NOT fb_nt_start_process.ERR THEN
				bBusy := FALSE;
				fb_state_entry.i16_next_step := 999;
			ELSE	(* Fehler *)
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	999:	(* Fertig *)
		bReady := TRUE;
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
			bReady := FALSE;
			bError := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bQuit AND NOT fb_state_entry.E THEN
			bError := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

fb_nt_start_process(
	NETID:= '',
	PATHSTR:= st_pfad,
	DIRNAME:= , 
	COMNDLINE:= ,
	START:= ,
	TMOUT:= DEFAULT_ADS_TIMEOUT,
	BUSY=> ,
	ERR=> , 
	ERRID=> nErrId);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_start_OSK
VAR_INPUT
	bExecute			: BOOL;
END_VAR
VAR
	NT_StartProcess 		:NT_StartProcess;
	b_Start				:BOOL;

	fb_ton_start			:TON;
	fb_r_trig_start			: R_TRIG;

END_VAR

(* @END_DECLARATION := '0' *)
(*Windows Tastatur starten mit der Quttiertaste*)
fb_ton_start(
	IN:=bExecute,
	PT:= t#2s,);

fb_r_trig_start(
	CLK:=fb_ton_start.Q ,
	Q=> b_Start);

NT_StartProcess(
	NETID:='',
	PATHSTR	:='C:\Windows\System32\cmd.exe',
	DIRNAME	:= ,
	COMNDLINE	:='/C C:\WINDOWS\system32\taskkill /f /im osk.exe /t & start /b osk /MAX',
	START		:=b_Start,
	TMOUT		:=T#10s);

IF	NOT NT_StartProcess.BUSY AND b_Start THEN
	b_Start:=FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_System_DateAndTime
VAR
	w_year					: WORD := 16#0000;
	w_month					: WORD := 16#0000;
	w_day					: WORD := 16#0000;
	w_hour					: WORD := 16#0000;
	w_min					: WORD := 16#0000;
	w_sec					: WORD := 16#0000;
	fb_get_system_time 		: FB_LocalSystemTime;
END_VAR
(* @END_DECLARATION := '0' *)
(* =====Erzeugen der Systemzeit für die ganze Maschine======== *)
(* Die Umstellung von Sommer auf Winterzeit und umgekehrt erfolgt automatisch über die PC-Zeit *)
fb_get_system_time ( sNetID := '',
					bEnable 	:= TRUE,
					dwCycle 	:= 1,
					dwOpt	:= 1,
					tTimeout 	:= DEFAULT_ADS_TIMEOUT,
					bValid => b_system_time_valid,
					systemTime => gst_system_time, (* Systemzeit *)
					tzID 	=> );
(*=======================================================*)
gdt_system_time := SYSTEMTIME_TO_DT(fb_get_system_time.systemTime);

w_year:=gst_system_time.wYear;
w_month:=gst_system_time.wMonth;
w_day:=gst_system_time.wDay;
w_hour:=gst_system_time.wHour;
w_min:=gst_system_time.wMinute;
w_sec:=gst_system_time.wSecond;

gstr_system_time := '';
gstr_datum := '';
IF w_day < 10 THEN
	gstr_datum := CONCAT(gstr_datum ,WORD_TO_STRING(0));
END_IF;
gstr_datum := CONCAT(gstr_datum ,WORD_TO_STRING(w_day));
gstr_datum := CONCAT(gstr_datum , '.');

IF w_month < 10 THEN
	gstr_datum := CONCAT(gstr_datum ,WORD_TO_STRING(0));
END_IF;
gstr_datum := CONCAT(gstr_datum ,WORD_TO_STRING(w_month));
gstr_datum := CONCAT(gstr_datum , '.');
gstr_datum := CONCAT(gstr_datum ,WORD_TO_STRING(w_year));	(* Datum steht zur Verfügung *)

gstr_uhrzeit := '';
IF w_hour < 10 THEN
	gstr_uhrzeit := CONCAT(gstr_uhrzeit ,WORD_TO_STRING(0));
END_IF;
gstr_uhrzeit := CONCAT(gstr_uhrzeit ,WORD_TO_STRING(w_hour));
gstr_uhrzeit := CONCAT(gstr_uhrzeit , ':');

IF w_min < 10 THEN
	gstr_uhrzeit := CONCAT(gstr_uhrzeit ,WORD_TO_STRING(0));
END_IF;
gstr_uhrzeit := CONCAT(gstr_uhrzeit ,WORD_TO_STRING(w_min));
gstr_uhrzeit := CONCAT(gstr_uhrzeit , ':');

IF w_sec < 10 THEN
	gstr_uhrzeit := CONCAT(gstr_uhrzeit ,WORD_TO_STRING(0));
END_IF;
gstr_uhrzeit := CONCAT(gstr_uhrzeit ,WORD_TO_STRING(w_sec));	(* Uhrzeit steht zur Verfügung *)

gstr_system_time := CONCAT(gstr_system_time, gstr_datum );
gstr_system_time := CONCAT(gstr_system_time , ' ');
gstr_system_time := CONCAT(gstr_system_time , gstr_uhrzeit);	(* Ausgabe von Datum und Uhrzeit als String für z.B . die Visu *)
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Programmbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_UPS
VAR_INPUT
	st_config				: struct_config;
	st_ctrl_in				: struct_ctrl_in;
	b_Ups					: BOOL;
END_VAR
VAR_IN_OUT

END_VAR
VAR_OUTPUT
	st_ctrl_out			: struct_ctrl_out;
END_VAR
VAR
	fb_ton_quitt			: TON;
	fb_ton_uez			: TON;
	fb_state_entry			: ST_StateEntry;

	nLastErrID			:UDINT;

	fbGetUpsStatus		: FB_GetUPSStatus;

	bm_ReplaceBattery 	: BOOL;
	bm_NoPower 		: BOOL;
	bm_StatusNotValid 	: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(*======================================================
   ST: ST_UPS
 ------------------------------------------------------
   Auth: 	Thomas Vilgis    						 
   Date: 	21.06.2018    						     
   Rev.: 		1.0	
   Desc:		Der Baustein liest den Status des Akkupacks aus.
			Die restliche Akkulaufzeit in Minuten kann abgefragt werden.
			Wenn der Akkupack getauscht werden muss wird angezeigt.
			Wenn sich der PC im Netzbetrieb befindet wird angezeigt.
   Historie: 	1.0

 ========================================================*)

(* Zeiten *)
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_uez(IN:= , PT:= t#20s, Q=> , ET=> );

(* Flanken *)


(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER  THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(	i16_pos:= 1);

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_busy := FALSE;

			bm_ReplaceBattery := FALSE;
			bm_NoPower := FALSE;
			bm_StatusNotValid := FALSE;

			fbGetUpsStatus.bEnable := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := BEREIT;

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		fbGetUpsStatus.bEnable := b_Ups;
		fb_ton_uez.IN := b_Ups;

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF b_Ups THEN
			IF fbGetUpsStatus.bValid THEN
				fb_state_entry.i16_next_step := 110;
			ELSIF fb_ton_uez.Q THEN
				bm_StatusNotValid := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_busy := TRUE;
		END_IF

(*=======================================================*)
	110:	(* Evaluation *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbGetUpsStatus.bValid THEN
			IF NOT fbGetUpsStatus.bError THEN
				CASE fbGetUpsStatus.stStatus.eBatteryStatus OF
					BatteryUnknownStatus:	(*Der Akkustatus ist unbekannt*)
						;
					BatteryOk:			(*Der Akku ist in Ordnung*)
						bm_ReplaceBattery := FALSE;
					BatteryReplace:		(*Der Akku sollte gewechselt werden*)
						bm_ReplaceBattery := TRUE;
				END_CASE

				CASE fbGetUpsStatus.stStatus.eCommStatus OF
					UpsCommUnknownStatus:	(*Kommunikationsstatus zur USV-Hardware ist unbekannt*)
						;
					UpsCommOk:		(*Kommunikation zur USV-Hardware ist hergestellt*)
						;
					UpsCommFailed:	(*Kommunikation zur USV wurde unterbrochen*)
						;
				END_CASE

				CASE fbGetUpsStatus.stStatus.ePowerStatus OF
					PowerUnknownStatus:	(*Der Status der Stromversorgung ist unbekannt*)
						;
					PowerOnLine:		(*Das Gerät befindet sich im Netzbetrieb*)
						bm_NoPower := FALSE;
					PowerOnBattery:	(*Stromausfall ist aufgetreten und das Gerät befindet sich im Akkubetrieb*)
						bm_NoPower := TRUE;
				END_CASE
			ELSE
				nLastErrID := fbGetUpsStatus.nErrId;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		ELSE
			bm_StatusNotValid := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	STOP, FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := fb_state_entry.i16_step = FEHLER;
			st_ctrl_out.b_gestoppt := fb_state_entry.i16_step = STOP;
			fb_ton_quitt.IN := FALSE;
			fbGetUpsStatus.bEnable := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF
	
		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

END_CASE

fb_state_entry(i16_pos:= 2 );

fbGetUpsStatus(
	sNetId:= ,	(* wenn in AmsNetId nichts drin steht, wird immer die lokale genommen*)
	nPort:= 0,
	bEnable:= ,
	bValid=> , 
	bError=> , 
	nErrId=> ,
	stStatus=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;

	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_ReplaceBattery;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := bm_NoPower;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := bm_StatusNotValid;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
END_IF


END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Serielle Kommunikation' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_BalluffTagReader
VAR_INPUT
	st_config						: struct_config;
	i16_addresse					: INT := 0;
	i16_anzahl_byte				: INT := 0;
	s_schreib_daten				: ARRAY [0..100] OF BYTE;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_OUTPUT
	s_lese_daten					: ARRAY [0..100] OF BYTE;
	s_transp_serial_number		: STRING;
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz					: TON;
	fb_ton_uez					: TON;
	fb_ton_quitt					: TON;
	fb_r_trig_lesen				: R_TRIG;
	fb_r_trig_schreiben			: R_TRIG;
	t_wz							: TIME := t#0ms;
	fb_state_entry					: ST_StateEntry;
	fb_r_trig_ibn_lesen			: R_TRIG;
	fb_r_trig_ibn_schreiben			: R_TRIG;
	fb_ton_ibn_lesen				: TON;
	fb_ton_ibn_schreiben			: TON;
	b_ibn_lesen					: BOOL := FALSE;
	b_ibn_schreiben				: BOOL := FALSE;
	sm_fehler_rfid_reader			: BOOL := FALSE;
	sm_kein_tag_erkannt			: BOOL := FALSE;

	(* Puffer für RS232*)
	RxBuffer						:ComBuffer;
	TxBuffer						:ComBuffer;
	EL6ComInData AT %I* 			:EL6inData22B;
	EL6ComOutData AT %Q*  		:EL6outData22B;
	fb_serial_line					: SerialLineControl ;

	(* RFID *)
	fb_RFID_Reader				: FB_RFIDReader;
	st_access_data				: ST_RFID_AccessData;
	eErrCodeRcv					: E_RFID_ErrCodeRcv_Balluff;

	e_tag_im_aktionsfeld			AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_r_trig_lesen(CLK:= st_ctrl_in.b_start_lesen, Q=> );
fb_r_trig_schreiben(CLK:= st_ctrl_in.b_start_schreiben, Q=> );

(* Inbetriebnahme *)
fb_r_trig_ibn_lesen(CLK:= b_ibn_lesen, Q=> );
fb_r_trig_ibn_schreiben(CLK:= b_ibn_schreiben, Q=> );
fb_ton_ibn_lesen(IN:= , PT:= t#1s, Q=> , ET=> );
fb_ton_ibn_schreiben(IN:= , PT:= t#1s, Q=> , ET=> );

IF fb_r_trig_ibn_lesen.Q THEN
	fb_ton_ibn_lesen.IN := TRUE;
ELSE
	IF fb_ton_ibn_lesen.Q THEN
		b_ibn_lesen := FALSE;
	 	fb_ton_ibn_lesen.IN := FALSE;
	END_IF
END_IF

IF fb_r_trig_ibn_schreiben.Q THEN
	fb_ton_ibn_schreiben.IN := TRUE;
ELSE
	IF fb_ton_ibn_schreiben.Q THEN
		b_ibn_schreiben := FALSE;
	 	fb_ton_ibn_schreiben.IN := FALSE;
	END_IF
END_IF


(* Toplevel *)(*
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
END_IF*)

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			sm_fehler_rfid_reader := FALSE;
			sm_kein_tag_erkannt := FALSE;
			fb_RFID_Reader.bExecute := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
(*		IF st_ctrl_in.b_init THEN*)
			fb_state_entry.i16_next_step := 20;
(*		END_IF*)

(*=======================================================*)
	20:	(* Reset Reader *)
		IF fb_state_entry.E THEN
			fb_RFID_Reader.bExecute := TRUE;
			fb_RFID_Reader.eCommand := eRFC_ResetReader;
		END_IF
	
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_RFID_Reader.bBusy THEN
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_RFID_Reader.bBusy THEN
			fb_RFID_Reader.bExecute := FALSE;
			IF fb_RFID_Reader.bResponseRcv THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSIF  fb_RFID_Reader.bError THEN
				eErrCodeRcv := fb_RFID_Reader.iErrorID;
				sm_fehler_rfid_reader := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
		END_IF

		IF fb_r_trig_lesen.Q OR fb_r_trig_ibn_lesen.Q THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := 200;
		ELSIF fb_r_trig_schreiben.Q OR fb_r_trig_ibn_schreiben.Q THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := 300;
		END_IF

(*=======================================================*)
	200: (* Abfrage, ob sich ein Tag im Aktionsfeld befindet, damit gelesen werden kann. *)
		IF fb_state_entry.E THEN
			fb_ton_uez.PT := t#1s;
			fb_ton_uez.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_tag_im_aktionsfeld THEN
			fb_ton_uez.IN := FALSE;
			fb_state_entry.i16_next_step := 210;
		ELSIF fb_ton_uez.Q THEN
			sm_kein_tag_erkannt := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	210: (* Start Lesen *)
		(* Vorbereiten Lesen *)
		IF fb_state_entry.E THEN
			fb_RFID_Reader.bExecute := TRUE;
			fb_RFID_Reader.eCommand := eRFC_ReadBlock;

			(* Datasize = blockCount * BlockSize *)
			st_access_data.iDataSize := i16_anzahl_byte;
			st_access_data.iBlockCount := i16_anzahl_byte;
			st_access_data.iBlockSize := 1;
			st_access_data.iStartBlock := i16_addresse;

			MEMSET(ADR(s_lese_daten), 0 , SIZEOF(s_lese_daten) );
			st_access_data.pData := ADR(s_lese_daten);
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_RFID_Reader.bBusy THEN
			fb_state_entry.i16_next_step := 220;
		END_IF

(*=======================================================*)
	220:	(* Fertig Lesen *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_RFID_Reader.bBusy THEN
			fb_RFID_Reader.bExecute := FALSE;
			IF fb_RFID_Reader.bResponseRcv THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSIF  fb_RFID_Reader.bError THEN
				eErrCodeRcv := fb_RFID_Reader.iErrorID;
				sm_fehler_rfid_reader := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	300: (* Abfrage, ob sich ein Tag im Aktionsfeld befindet, damit geschrieben werden kann. *)
		IF fb_state_entry.E THEN
			fb_ton_uez.PT := t#1s;
			fb_ton_uez.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_tag_im_aktionsfeld THEN
			fb_ton_uez.IN := FALSE;
			fb_state_entry.i16_next_step := 310;
		ELSIF fb_ton_uez.Q THEN
			sm_kein_tag_erkannt := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	310: (* Start Schreiben *)
		(* Vorbereiten Schreiben *)
		IF fb_state_entry.E THEN
			fb_RFID_Reader.bExecute := TRUE;
			fb_RFID_Reader.eCommand := eRFC_WriteBlock;

			(* Datasize = blockCount * BlockSize *)
			st_access_data.iDataSize := i16_anzahl_byte;
			st_access_data.iBlockCount := i16_anzahl_byte;
			st_access_data.iBlockSize := 1;
			st_access_data.iStartBlock := i16_addresse;

			st_access_data.pData := ADR(s_schreib_daten);
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_RFID_Reader.bBusy THEN
			fb_state_entry.i16_next_step := 320;
		END_IF

(*=======================================================*)
	320:	(* Fertig Schreiben *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_RFID_Reader.bBusy THEN
			fb_RFID_Reader.bExecute := FALSE;
			IF fb_RFID_Reader.bResponseRcv THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSIF  fb_RFID_Reader.bError THEN
				eErrCodeRcv := fb_RFID_Reader.iErrorID;
				sm_fehler_rfid_reader := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			fb_RFID_Reader.bExecute := FALSE;
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

(* RFID FBs *)
fb_serial_line(
	Mode		:= SERIALLINEMODE_EL6_22B,
	pComIn		:= ADR(EL6ComInData),
	pComOut	:= ADR(EL6ComOutData),
	SizeComIn	:= SIZEOF(EL6ComInData),
	TxBuffer		:= TxBuffer,
	RxBuffer		:= RxBuffer
);

fb_RFID_Reader(
	bExecute:= , 
	eCommand:= ,
	stAccessData:= st_access_data ,
	stCtrl:= , 
	stCfg:= , 
	eManufacturer:= eRFRM_Balluff,
	tTimeOut:= , 
	RxBuffer:= RxBuffer,
	TxBuffer:= TxBuffer,
	bBusy=> , 
	bResponseRcv=> ,
	eResponse=> , 
	bError=> ,
	iErrorID=> , 
	iErrCodeRcv=> ,
	stReaderCfg=> , 
	stReaderInfo=> , 
	stTranspInfo=> , 
	stRawData=> );

s_transp_serial_number := fb_RFID_Reader.stTranspInfo.sSerialNumber;

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_rfid_reader;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_kein_tag_erkannt;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	(* Betriebsmeldungen *)
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Serielle Kommunikation' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_BarcodeReader
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
	s_last_barcode				: STRING;
END_VAR
VAR
	fb_ton_wz					: TON;
	fb_ton_uez					: TON;
	fb_ton_quitt					: TON;
	t_wz							: TIME := t#0ms;
	fb_state_entry					: ST_StateEntry;

	(* RS232-Schnittstelle *)
	(* Hinweis: Datenpuffer vom Typ ComBuffer werden vom Anwender niemals direkt beschrieben oder gelesen,
	sondern dienen nur als Zwischenspeicher für die Kommunikationsbausteine. *)
	RxBuffer						: ComBuffer;
	TxBuffer						: ComBuffer;
	COM_in_data AT %I* 			: PcComInData; (*EL6inData22B;*)
	COM_out_data AT %Q*  		: PcComOutData; (*EL6outData22B;*)
	fb_com_port_control			: SerialLineControl;
	com_port_control_error			: BOOL := FALSE;
	com_port_control_error_id		: ComError_t;

	(* ReceiveString empfängt eine Zeichenkette von der mit der Eingangsvariablen RxBuffer korrespondierenden Schnittstelle
	und speichert sie in der Ausgangsvariablen ReceivedString. *)
	fb_receive					: ReceiveString;
	s_tmp_string					: STRING := '';
	s_barcode					: STRING := '';
	i16_receive_string_len			: INT := 0;
	i16_suffix_len					: INT := 0;
	receive_error_id				: ComError_t;
	b_receive_timeout				: BOOL := FALSE;
	t_receive_timeout				: TIME := t#0s;

	fb_trig_new_string				: R_TRIG;

	sm_fehler_seriel				: BOOL := FALSE;
	sm_fehler_string				: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= t#1000ms, Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#50ms, Q=> , ET=> );

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
(*
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
*)
	IF com_port_control_error OR receive_error_id > 0 THEN
		sm_fehler_seriel := TRUE;
		fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			sm_fehler_seriel := FALSE;
			sm_fehler_string := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;

			t_receive_timeout := t#1s;
			i16_suffix_len := 2;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Reset Schnittstelle *)
		IF fb_state_entry.E THEN
			fb_receive.Reset := TRUE;
			fb_ton_wz.PT := t#100ms;
			fb_ton_wz.IN := TRUE;
		END_IF
	
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_receive.Reset := FALSE;
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:	(* Warte auf neuen Barcode *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_receive.Busy THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110: (* Barcode wurde eingelesen *)
		IF NOT fb_receive.Busy  THEN
			IF fb_receive.Error = COMERROR_NOERROR THEN
				s_last_barcode := s_barcode;
				fb_state_entry.i16_next_step := BEREIT;
			ELSE	(* Fehler *)
				sm_fehler_seriel := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> ,
	i16_step=> ,
	i16_last_step=> );

(* Aufruf Baustein für serielle Kommunikation *)
fb_com_port_control(
	Mode:= SERIALLINEMODE_PC_COM_PORT,
	pComIn:= ADR(COM_in_data),			(* I/O data; see global variables *)
	pComOut:= ADR(COM_out_data),		(* I/O data; see global variables *)
	SizeComIn:= SIZEOF(COM_in_data),		(* I/O data; see global variables *)
	TxBuffer:= TxBuffer,					(* transmit buffer; see global variables *)
	RxBuffer:= RxBuffer,					(* receive buffer; see global variables *)
	Error=> com_port_control_error,
	ErrorID=> com_port_control_error_id);
(* =================================== *)

(* Routine für Strings empfangen *)
fb_receive(
	Prefix:= '',
	Suffix:= '$R$N',		(* RETURN*)
	Timeout:= t_receive_timeout,
	ReceivedString:= s_tmp_string,
	RXbuffer:= RxBuffer,
	StringReceived=> ,
	Busy=> ,
	Error=> receive_error_id,
	RxTimeout=> b_receive_timeout );

fb_trig_new_string(CLK  := fb_receive.StringReceived, Q=> );

IF fb_trig_new_string.Q THEN
	i16_receive_string_len:=LEN(s_tmp_string);
	s_barcode:=LEFT(s_tmp_string, i16_receive_string_len - i16_suffix_len); (* Delete Suffix *)
END_IF
(* ========================== *)

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_seriel;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_fehler_string;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	(* Betriebsmeldungen *)
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Zylinder12V012346E
VAR_INPUT
	st_config							: struct_zylinder_config;
	bw_nocken_zylinder_einfahren		: BOOL;
	bw_nocken_zylinder_ausfahren		: BOOL;
	uw_nocken_zylinder_einfahren		: BOOL;
	uw_nocken_zylinder_ausfahren		: BOOL;
	b_direkttaste_ausfahren			: BOOL;
	b_direkttaste_mittefahren			: BOOL;
	b_direkttaste_einfahren				: BOOL;
	st_ctrl_in							: struct_zylinder_ctrl_in;
	e_druckwaechter					: BOOL;
	i16_betriebsart					: enum_betriebsarten;
	b_no_gesteuert_im_norm_betrieb	: BOOL;
	b_masterachse_hand_dialog_aktiv	: BOOL;
END_VAR
VAR_IN_OUT
	st_visu							: struct_zylinder_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out						: struct_zylinder_ctrl_out;
	a_ventil_einfahren					AT %Q* : BOOL;
	a_ventil_ausfahren				AT %Q* : BOOL;
END_VAR
VAR
	b_first_cycle 						: BOOL := TRUE;
	i16_anzahl_sensoren				: INT := 0;
	i16_anzahl_spulen					: INT := 0;
	b_sensor_eingefahren_vorhanden	: BOOL := FALSE;
	b_sensor_ausgefahren_vorhanden	: BOOL := FALSE;
	b_mit_tzk							: BOOL := FALSE;
	b_nockengesteuert				: BOOL := FALSE;
	b_zustand_uw_nocken_einfahren	: BOOL := FALSE;
	b_zustand_uw_nocken_ausfahren	: BOOL := FALSE;
	st_tzk							: struct_totzeitkompensation;
	fb_ton_uz_fahren					: TON;
	fb_ton_uz_endlage1				: TON;
	fb_ton_uz_endlage2				: TON;
	fb_ton_uz_endlage3				: TON;
	fb_ton_uz_sensor1					: TON;
	fb_ton_uz_sensor2					: TON;
	fb_ton_uz_sensor3					: TON;
	fb_ton_einausfahren				: TON;
	fb_r_trig_ibn_ausfahren				: R_TRIG;
	fb_r_trig_ibn_einfahren				: R_TRIG;
	fb_r_trig_ibn_quit					: R_TRIG;
	fb_ton_ibn_ausfahren				: TON;
	fb_ton_ibn_einfahren				: TON;
	fb_ton_ibn_quit					: TON;
	fb_ton_quitt						: TON;
	st_sm							: struct_zylinder_meldungen;
	fb_state_entry						: ST_StateEntry;
	b_ibn_zylinder_ausfahren			: BOOL := FALSE;
	b_ibn_zylinder_einfahren			: BOOL := FALSE;
	b_ibn_zylinderfehler_quit			: BOOL := FALSE;

	e_sensor1_eingefahren			AT %I* : BOOL;
	e_sensor1_ausgefahren			AT %I* : BOOL;
	e_sensor2_eingefahren			AT %I* : BOOL;
	e_sensor2_ausgefahren			AT %I* : BOOL;
	e_sensor3_eingefahren			AT %I* : BOOL;
	e_sensor3_ausgefahren			AT %I* : BOOL;
	e_sensor_mittegefahren			AT %I* : BOOL;
	e_taste_einfahren					AT %I* : BOOL;
	e_taste_ausfahren					AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
IF b_first_cycle THEN
	b_first_cycle := FALSE;
	st_ctrl_out.b_fehler := FALSE;
	st_ctrl_out.b_eingefahren := FALSE;
	st_ctrl_out.b_ausgefahren := FALSE;
	st_ctrl_out.b_gestoppt := FALSE;
	st_sm.b_zeit_ausfahren1:= FALSE;
	st_sm.b_zeit_einfahren1:= FALSE;
	st_sm.b_endlage1	:= FALSE;
	st_sm.b_sensor1:= FALSE;
	st_sm.b_zeit_ausfahren2 := FALSE;
	st_sm.b_zeit_einfahren2 := FALSE;
	st_sm.b_endlage2	:= FALSE;
	st_sm.b_sensor2 := FALSE;
	st_sm.b_zeit_ausfahren3 := FALSE;
	st_sm.b_zeit_einfahren3 := FALSE;
	st_sm.b_endlage3	:= FALSE;
	st_sm.b_sensor3 := FALSE;
	st_sm.b_winkel_ausfahren1:= FALSE;
	st_sm.b_winkel_einfahren1:= FALSE;
	st_sm.b_winkel_ausfahren2 := FALSE;
	st_sm.b_winkel_einfahren2 := FALSE;
	st_sm.b_winkel_ausfahren3 := FALSE;
	st_sm.b_winkel_einfahren3 := FALSE;
	st_sm.b_zyltyp_nicht_definiert := FALSE;
	st_sm.b_reserve1:= FALSE;
END_IF

(* Inbetriebnahme *)
fb_r_trig_ibn_ausfahren(CLK:= b_ibn_zylinder_ausfahren, Q=> );
fb_r_trig_ibn_einfahren(CLK:= b_ibn_zylinder_einfahren, Q=> );
fb_r_trig_ibn_quit(CLK:= b_ibn_zylinderfehler_quit, Q=> );
fb_ton_ibn_ausfahren(IN:= , PT:= t#1s, Q=> , ET=> );
fb_ton_ibn_einfahren(IN:= , PT:= t#1s, Q=> , ET=> );
fb_ton_ibn_quit(IN:= , PT:= t#1s, Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#50ms, Q=> , ET=> );

IF fb_r_trig_ibn_ausfahren.Q THEN
	fb_ton_ibn_ausfahren.IN := TRUE;
ELSE
	IF fb_ton_ibn_ausfahren.Q THEN
		b_ibn_zylinder_ausfahren := FALSE;
	 	fb_ton_ibn_ausfahren.IN := FALSE;
	END_IF
END_IF

IF fb_r_trig_ibn_einfahren.Q THEN
	fb_ton_ibn_einfahren.IN := TRUE;
ELSE
	IF fb_ton_ibn_einfahren.Q THEN
		b_ibn_zylinder_einfahren := FALSE;
	 	fb_ton_ibn_einfahren.IN := FALSE;
	END_IF
END_IF

IF fb_r_trig_ibn_quit.Q THEN
	fb_ton_ibn_quit.IN := TRUE;
ELSE
	IF fb_ton_ibn_quit.Q THEN
		b_ibn_zylinderfehler_quit := FALSE;
	 	fb_ton_ibn_quit.IN := FALSE;
	END_IF
END_IF

(* Simulationssensoren für den Zylinderhandbetrieb *)
IF  	gi16_betriebsart = HAND AND
	st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND
	fb_state_entry.i16_step > INIT_OBJ
	THEN
		CASE i16_anzahl_sensoren OF
			0:
				st_visu.b_sensor_mittegefahren := e_sensor_mittegefahren;
				st_visu.enu_zustand := fb_state_entry.i16_step;
			1:
				st_visu.b_sensor_ausgefahren := e_sensor1_ausgefahren;
				st_visu.b_sensor_eingefahren := e_sensor1_eingefahren;
				st_visu.enu_zustand := fb_state_entry.i16_step;
			2:
				IF b_sensor_eingefahren_vorhanden AND b_sensor_ausgefahren_vorhanden THEN
					st_visu.b_sensor_ausgefahren := e_sensor1_ausgefahren;
					st_visu.b_sensor_eingefahren := e_sensor1_eingefahren;
					st_visu.b_sensor_mittegefahren := e_sensor_mittegefahren;
				ELSIF b_sensor_ausgefahren_vorhanden THEN
					st_visu.b_sensor_ausgefahren := e_sensor1_ausgefahren OR e_sensor2_ausgefahren;
				ELSIF b_sensor_eingefahren_vorhanden THEN
					st_visu.b_sensor_eingefahren := e_sensor1_eingefahren OR e_sensor2_eingefahren;
				END_IF
				st_visu.enu_zustand := fb_state_entry.i16_step;
			4:
				st_visu.b_sensor_ausgefahren := e_sensor1_ausgefahren AND e_sensor2_ausgefahren;
				st_visu.b_sensor_eingefahren := e_sensor1_eingefahren AND e_sensor2_eingefahren;
				st_visu.b_sensor_mittegefahren := e_sensor_mittegefahren;
				st_visu.enu_zustand := fb_state_entry.i16_step;
			6:
				st_visu.b_sensor_ausgefahren := e_sensor1_ausgefahren AND e_sensor2_ausgefahren AND e_sensor3_ausgefahren;
				st_visu.b_sensor_eingefahren := e_sensor1_eingefahren AND e_sensor2_eingefahren AND e_sensor3_eingefahren;
				st_visu.b_sensor_mittegefahren := e_sensor_mittegefahren;
				st_visu.enu_zustand := fb_state_entry.i16_step;
		END_CASE
END_IF

(* Überwachungszeiten *)
fb_ton_uz_fahren(IN:= , PT:= st_config.t_ueberwachungszeit, Q=>  , ET=> );
fb_ton_uz_endlage1(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_uz_endlage2(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_uz_endlage3(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_uz_sensor1(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_uz_sensor2(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_uz_sensor3(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Aus- und Einfahrzeit *)
fb_ton_einausfahren(IN:= , PT:= st_config.t_ein_aus_fahrzeit, Q=> , ET=> );

(* Totzeitkompensationszeit *)
st_tzk.fb_ton_tzk(IN:= , PT:= st_tzk.t_kompensationszeit, Q=> , ET=> );

IF fb_state_entry.i16_step > ZYL_INIT AND fb_state_entry.i16_step < ZYL_FEHLER THEN
	IF 	st_ctrl_in.b_stop AND
		(st_visu.i16_nr_zyl_im_handbetrieb <> st_config.i16_identnummer OR gi16_betriebsart <> HAND)
		THEN
			fb_state_entry.i16_next_step := GESTOPPT;
	END_IF
END_IF

(* Zylinder bewegen über Direkttasten von der hinteren Bedienoberfläche und Hardwaretaster *)
IF (b_direkttaste_ausfahren AND NOT b_direkttaste_einfahren) OR (e_taste_ausfahren AND NOT e_taste_einfahren) THEN
	fb_state_entry.i16_next_step := DIREKT_AUSFAHREN;
ELSIF (b_direkttaste_einfahren AND NOT b_direkttaste_ausfahren) OR (NOT e_taste_ausfahren AND e_taste_einfahren) THEN
	fb_state_entry.i16_next_step := DIREKT_EINFAHREN;
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
	INIT_OBJ:	(* Zylindertyp feststellen *)
		IF st_config.b_config_fertig THEN
			(* Anzahl Spulen *)
			i16_anzahl_spulen := STRING_TO_INT(MID(st_config.str_zylinder_typ, 1, 1));
			(* Anzahl Sensoren *)
			i16_anzahl_sensoren := STRING_TO_INT(MID(st_config.str_zylinder_typ, 1, 3));
			(* Zylinder ist nockengesteuert *)
			IF FIND(st_config.str_zylinder_typ, 'NO') = 0 THEN
				b_nockengesteuert := FALSE;
			ELSE
				b_nockengesteuert := TRUE;
			END_IF
			(* Zylinder ist mit Totzeitkompensation *)
			IF FIND(st_config.str_zylinder_typ, 'TZK') = 0 THEN
				b_mit_tzk := FALSE;
			ELSE
				b_mit_tzk := TRUE;
			END_IF
			(* Vorhandene Sensoren *)
			IF FIND(st_config.str_zylinder_typ, 'AUS') >= 5 THEN
				b_sensor_ausgefahren_vorhanden := TRUE;
			ELSE
				b_sensor_ausgefahren_vorhanden := FALSE;
			END_IF
			IF FIND(st_config.str_zylinder_typ, 'EIN') >= 5 THEN
				b_sensor_eingefahren_vorhanden := TRUE;
			ELSE
				b_sensor_eingefahren_vorhanden := FALSE;
			END_IF
			fb_state_entry.i16_next_step := ZYL_INIT;
		END_IF

(*=======================================================*)
	ZYL_INIT:
		IF fb_state_entry.E THEN
			fb_ton_uz_fahren.IN := FALSE;
			fb_ton_uz_endlage1.IN := FALSE;
			fb_ton_uz_endlage2.IN := FALSE;
			fb_ton_uz_endlage3.IN := FALSE;
			fb_ton_uz_sensor1.IN := FALSE;
			fb_ton_uz_sensor2.IN := FALSE;
			fb_ton_uz_sensor3.IN := FALSE;
			st_tzk.fb_ton_tzk.IN	 := FALSE;
			fb_ton_einausfahren.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			a_ventil_ausfahren := FALSE;
			a_ventil_einfahren	:= FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_eingefahren := FALSE;
			st_ctrl_out.b_ausgefahren := FALSE;
			st_ctrl_out.b_gestoppt := FALSE;
			st_ctrl_out.b_ohne_luft := FALSE;
			st_sm.b_zeit_ausfahren1:= FALSE;
			st_sm.b_zeit_einfahren1:= FALSE;
			st_sm.b_endlage1	:= FALSE;
			st_sm.b_sensor1:= FALSE;
			st_sm.b_zeit_ausfahren2 := FALSE;
			st_sm.b_zeit_einfahren2 := FALSE;
			st_sm.b_endlage2	:= FALSE;
			st_sm.b_sensor2 := FALSE;
			st_sm.b_zeit_ausfahren3 := FALSE;
			st_sm.b_zeit_einfahren3 := FALSE;
			st_sm.b_endlage3	:= FALSE;
			st_sm.b_sensor3 := FALSE;
			st_sm.b_winkel_ausfahren1:= FALSE;
			st_sm.b_winkel_einfahren1:= FALSE;
			st_sm.b_winkel_ausfahren2 := FALSE;
			st_sm.b_winkel_einfahren2 := FALSE;
			st_sm.b_winkel_ausfahren3 := FALSE;
			st_sm.b_winkel_einfahren3 := FALSE;
			st_sm.b_zyltyp_nicht_definiert := FALSE;
			st_sm.b_reserve1:= FALSE;
			b_direkttaste_ausfahren := FALSE;
			b_direkttaste_mittefahren := FALSE;
			b_direkttaste_einfahren	 := FALSE;
			b_zustand_uw_nocken_einfahren := FALSE;
			b_zustand_uw_nocken_ausfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_druckwaechter THEN
			CASE i16_anzahl_sensoren OF
			0:
				fb_state_entry.i16_next_step := GESTOPPT;

			1:
				IF b_nockengesteuert THEN
					IF bw_nocken_zylinder_einfahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
					ELSIF bw_nocken_zylinder_ausfahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
					ELSE
						fb_state_entry.i16_next_step := GESTOPPT;
					END_IF
				ELSE
					IF  b_sensor_ausgefahren_vorhanden THEN
						IF NOT e_sensor1_ausgefahren THEN
							fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
						ELSIF e_sensor1_ausgefahren THEN
							fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
						ELSE
							fb_state_entry.i16_next_step := GESTOPPT;
						END_IF
					ELSIF  b_sensor_eingefahren_vorhanden THEN
						IF e_sensor1_eingefahren THEN
							fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
						ELSIF NOT e_sensor1_eingefahren THEN
							fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
						ELSE
							fb_state_entry.i16_next_step := GESTOPPT;
						END_IF
					END_IF
				END_IF

			2:
				IF b_nockengesteuert THEN
					IF bw_nocken_zylinder_einfahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
					ELSIF bw_nocken_zylinder_ausfahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
					ELSE
						fb_state_entry.i16_next_step := GESTOPPT;
					END_IF
				ELSE
					IF b_sensor_eingefahren_vorhanden AND b_sensor_ausgefahren_vorhanden THEN
						IF e_sensor1_eingefahren THEN
							fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
						ELSIF e_sensor1_ausgefahren THEN
							fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
						ELSE
							fb_state_entry.i16_next_step := GESTOPPT;
						END_IF
					ELSIF b_sensor_ausgefahren_vorhanden THEN
						IF NOT e_sensor1_ausgefahren AND NOT  e_sensor2_ausgefahren THEN
							fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
						ELSIF e_sensor1_ausgefahren OR e_sensor2_ausgefahren THEN
							fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
						ELSE
							fb_state_entry.i16_next_step := GESTOPPT;
						END_IF
					ELSIF b_sensor_eingefahren_vorhanden THEN
						IF e_sensor1_eingefahren OR  e_sensor2_eingefahren THEN
							fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
						ELSIF NOT e_sensor1_eingefahren AND NOT e_sensor2_eingefahren THEN
							fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
						ELSE
							fb_state_entry.i16_next_step := GESTOPPT;
						END_IF
					END_IF
				END_IF

			3:
				IF b_nockengesteuert THEN
					IF bw_nocken_zylinder_einfahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
					ELSIF bw_nocken_zylinder_ausfahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
					ELSE
						fb_state_entry.i16_next_step := GESTOPPT;
					END_IF
				ELSE
					IF e_sensor1_eingefahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
					ELSIF e_sensor1_ausgefahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
					ELSE
						fb_state_entry.i16_next_step := GESTOPPT;
					END_IF
				END_IF

			4:
				IF b_nockengesteuert THEN
					IF bw_nocken_zylinder_einfahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
					ELSIF bw_nocken_zylinder_ausfahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
					ELSE
						fb_state_entry.i16_next_step := GESTOPPT;
					END_IF
				ELSE
					IF e_sensor1_eingefahren AND e_sensor2_eingefahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
					ELSIF e_sensor1_ausgefahren AND e_sensor2_ausgefahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
					ELSE
						fb_state_entry.i16_next_step := GESTOPPT;
					END_IF
				END_IF

			6:
				IF b_nockengesteuert THEN
					IF bw_nocken_zylinder_einfahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
					ELSIF bw_nocken_zylinder_ausfahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
					ELSE
						fb_state_entry.i16_next_step := GESTOPPT;
					END_IF
				ELSE
					IF e_sensor1_eingefahren AND e_sensor2_eingefahren AND e_sensor3_eingefahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
					ELSIF e_sensor1_ausgefahren AND e_sensor2_ausgefahren AND e_sensor3_ausgefahren THEN
						fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
					ELSE
						fb_state_entry.i16_next_step := GESTOPPT;
					END_IF
				END_IF
			END_CASE
		END_IF

(*=======================================================*)
	GESTOPPT:
		IF fb_state_entry.E THEN
			a_ventil_ausfahren := FALSE;
			a_ventil_einfahren	:= FALSE;
			st_ctrl_out.b_gestoppt := TRUE;
			st_ctrl_out.b_eingefahren := FALSE;
			st_ctrl_out.b_ausgefahren := FALSE;
			st_ctrl_out.b_ohne_luft := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			b_zustand_uw_nocken_einfahren := FALSE;
			b_zustand_uw_nocken_ausfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE i16_betriebsart OF
		KEINE:
			;
		AUTO, TIPPEN, DUMMY, PSEUDO:
			IF 	(st_ctrl_in.b_ausfahren AND
				NOT bw_nocken_zylinder_ausfahren AND
				NOT b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren) OR
				(NOT st_ctrl_in.b_ausfahren AND
				bw_nocken_zylinder_ausfahren AND
				NOT b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren) OR
				(NOT st_ctrl_in.b_ausfahren AND
				NOT bw_nocken_zylinder_ausfahren AND
				b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren)
				THEN
					fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;

			ELSIF	(st_ctrl_in.b_einfahren AND
					NOT bw_nocken_zylinder_einfahren AND
					NOT b_ibn_zylinder_einfahren AND
					NOT b_direkttaste_einfahren AND
					NOT e_taste_einfahren) OR
					(NOT st_ctrl_in.b_einfahren AND
					bw_nocken_zylinder_einfahren AND
					NOT b_ibn_zylinder_einfahren AND
					NOT b_direkttaste_einfahren AND
					NOT e_taste_einfahren) OR
					(NOT st_ctrl_in.b_einfahren AND
					NOT bw_nocken_zylinder_einfahren AND
					b_ibn_zylinder_einfahren AND
					NOT b_direkttaste_einfahren AND
					NOT e_taste_einfahren)
					THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;

			ELSIF	st_ctrl_in.b_luftlos AND
					NOT bw_nocken_zylinder_einfahren AND
					NOT b_ibn_zylinder_einfahren AND
					NOT b_direkttaste_einfahren AND
					NOT e_taste_einfahren AND
					NOT bw_nocken_zylinder_ausfahren AND
					NOT b_ibn_zylinder_ausfahren AND
					NOT b_direkttaste_ausfahren AND
					NOT e_taste_ausfahren
					THEN
						fb_state_entry.i16_next_step := LUFTLOS;
			END_IF
		HAND:
			IF	(st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND (st_visu.b_taste_ausfahren OR e_taste_ausfahren)) OR
				(bw_nocken_zylinder_ausfahren AND b_nockengesteuert AND b_masterachse_hand_dialog_aktiv)
				THEN
					fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;

			ELSIF	(st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND (st_visu.b_taste_einfahren OR e_taste_einfahren)) OR
					(bw_nocken_zylinder_einfahren AND b_nockengesteuert AND b_masterachse_hand_dialog_aktiv)
					THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
			END_IF
		END_CASE

(*=======================================================*)
	EINGEFAHREN:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_gestoppt := FALSE;
			st_ctrl_out.b_ausgefahren := FALSE;
			st_ctrl_out.b_ohne_luft := FALSE;
			fb_ton_einausfahren.IN := FALSE;
			fb_ton_uz_fahren.IN := FALSE;
			fb_ton_uz_sensor1.IN := FALSE;
			fb_ton_uz_sensor2.IN := FALSE;
			fb_ton_uz_sensor3.IN := FALSE;
			st_tzk.fb_ton_tzk.IN := FALSE;
			a_ventil_einfahren := TRUE;
			b_zustand_uw_nocken_einfahren := FALSE;
			IF NOT b_mit_tzk THEN
				st_ctrl_out.b_eingefahren := TRUE;
			END_IF
		END_IF

		IF st_ctrl_in.b_einfahren THEN	(* Messagewiederholung wenn der Zylinder sich schon im gewünschten Zustand befindet*)
			st_ctrl_out.b_eingefahren := TRUE;
		END_IF
	
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE i16_betriebsart OF
		KEINE:
			;
		AUTO, TIPPEN, DUMMY, PSEUDO:
			IF 	(st_ctrl_in.b_ausfahren AND
				NOT bw_nocken_zylinder_ausfahren AND
				NOT b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren) OR
				(NOT st_ctrl_in.b_ausfahren AND
				bw_nocken_zylinder_ausfahren  AND
				NOT b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren) OR
				(NOT st_ctrl_in.b_ausfahren AND
				NOT bw_nocken_zylinder_ausfahren AND
				b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren)
				THEN
					IF i16_anzahl_sensoren >= 1AND b_sensor_ausgefahren_vorhanden AND b_mit_tzk THEN
						st_tzk.t_ausfahrzeit_kompensiert := (st_tzk.t_ausfahrzeit * st_config.i16_tzk_faktor_ausfahren) / 100;
					END_IF
					fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;

			ELSIF	st_ctrl_in.b_luftlos AND
					NOT bw_nocken_zylinder_einfahren AND
					NOT b_ibn_zylinder_einfahren AND
					NOT b_direkttaste_einfahren AND
					NOT e_taste_einfahren AND
					NOT bw_nocken_zylinder_ausfahren AND
					NOT b_ibn_zylinder_ausfahren AND
					NOT b_direkttaste_ausfahren AND
					NOT e_taste_ausfahren
					THEN
						fb_state_entry.i16_next_step := LUFTLOS;
			END_IF
		HAND:
			IF	(st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND (st_visu.b_taste_ausfahren OR e_taste_ausfahren)) OR
				(bw_nocken_zylinder_ausfahren AND b_nockengesteuert AND b_masterachse_hand_dialog_aktiv)
				THEN
					IF i16_anzahl_sensoren >= 1AND b_sensor_ausgefahren_vorhanden AND b_mit_tzk THEN
						st_tzk.t_ausfahrzeit_kompensiert := (st_tzk.t_ausfahrzeit * st_config.i16_tzk_faktor_ausfahren) / 100;
					END_IF
					fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
			END_IF
		END_CASE

		(* Überwachung auf Endlagenfehler *)
		IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
			CASE i16_anzahl_sensoren OF
				1,2,3:	(* Alle Zylinder mit mindestens einem Sensor für EINGEFAHREN *)
					IF b_sensor_eingefahren_vorhanden AND	st_config.b_endlage1_aktiv AND NOT e_sensor1_eingefahren THEN
						fb_ton_uz_endlage1.IN := TRUE;
						IF fb_ton_uz_endlage1.Q THEN
							st_sm.b_endlage1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage1.IN := FALSE;
					END_IF
	
				4:	(* Alle Zylinder mit 2 Sensoren für EINGEFAHREN *)
					IF b_sensor_eingefahren_vorhanden AND st_config.b_endlage1_aktiv AND NOT e_sensor1_eingefahren THEN
						fb_ton_uz_endlage1.IN := TRUE;
						IF fb_ton_uz_endlage1.Q THEN
							st_sm.b_endlage1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage1.IN := FALSE;
					END_IF
					IF b_sensor_eingefahren_vorhanden AND st_config.b_endlage2_aktiv AND NOT e_sensor2_eingefahren THEN
						fb_ton_uz_endlage2.IN := TRUE;
						IF fb_ton_uz_endlage2.Q THEN
							st_sm.b_endlage2 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage2.IN := FALSE;
					END_IF
	
				6:	(* Alle Zylinder mit 3 Sensoren für EINGEFAHREN *)
					IF b_sensor_eingefahren_vorhanden AND st_config.b_endlage1_aktiv AND NOT e_sensor1_eingefahren THEN
						fb_ton_uz_endlage1.IN := TRUE;
						IF fb_ton_uz_endlage1.Q THEN
							st_sm.b_endlage1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage1.IN := FALSE;
					END_IF
					IF b_sensor_eingefahren_vorhanden AND st_config.b_endlage2_aktiv AND NOT e_sensor2_eingefahren THEN
						fb_ton_uz_endlage2.IN := TRUE;
						IF fb_ton_uz_endlage2.Q THEN
							st_sm.b_endlage2 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage2.IN := FALSE;
					END_IF
					IF b_sensor_eingefahren_vorhanden AND st_config.b_endlage3_aktiv AND NOT e_sensor3_eingefahren THEN
						fb_ton_uz_endlage3.IN := TRUE;
						IF fb_ton_uz_endlage3.Q THEN
							st_sm.b_endlage3 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage3.IN := FALSE;
					END_IF
			END_CASE
		END_IF

(*=======================================================*)
	BEWEGUNG_AUSFAHREN:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_gestoppt := FALSE;
			st_ctrl_out.b_eingefahren := FALSE;
			st_ctrl_out.b_ausgefahren := FALSE;
			st_ctrl_out.b_ohne_luft := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			a_ventil_einfahren := FALSE;
			a_ventil_ausfahren := TRUE;
			fb_ton_uz_fahren.IN := TRUE;
			fb_ton_einausfahren.IN := TRUE;
			fb_ton_uz_endlage1.IN := FALSE;
			fb_ton_uz_endlage2.IN := FALSE;
			fb_ton_uz_endlage3.IN := FALSE;
			st_sm.b_zeit_ausfahren1:= FALSE;
			st_sm.b_zeit_einfahren1:= FALSE;
			st_sm.b_endlage1	:= FALSE;
			st_sm.b_sensor1:= FALSE;
			st_sm.b_zeit_ausfahren2 := FALSE;
			st_sm.b_zeit_einfahren2 := FALSE;
			st_sm.b_endlage2	:= FALSE;
			st_sm.b_sensor2 := FALSE;
			st_sm.b_zeit_ausfahren3 := FALSE;
			st_sm.b_zeit_einfahren3 := FALSE;
			st_sm.b_endlage3	:= FALSE;
			st_sm.b_sensor3 := FALSE;
			st_sm.b_winkel_ausfahren1:= FALSE;
			st_sm.b_winkel_einfahren1:= FALSE;
			st_sm.b_winkel_ausfahren2 := FALSE;
			st_sm.b_winkel_einfahren2 := FALSE;
			st_sm.b_winkel_ausfahren3 := FALSE;
			st_sm.b_winkel_einfahren3 := FALSE;
			st_sm.b_zyltyp_nicht_definiert := FALSE;
			st_sm.b_reserve1:= FALSE;
			(* Verhindere die sofortige Fehlerauslösung, wenn Überwachungsnocken bei Stateentry schon vorhanden ist *)
			IF uw_nocken_zylinder_ausfahren THEN
				b_zustand_uw_nocken_ausfahren := TRUE;
			END_IF
		END_IF

		(* Fehlermeldung für nockengesteuerte Zylinder wieder freischalten *)
		IF fb_ton_uz_fahren.Q THEN
			b_zustand_uw_nocken_ausfahren := FALSE;
		END_IF

		CASE i16_betriebsart OF
		KEINE:
			;
		AUTO, TIPPEN, DUMMY, PSEUDO:
			IF	(st_ctrl_in.b_einfahren AND
				NOT bw_nocken_zylinder_einfahren AND
				NOT b_ibn_zylinder_einfahren AND
				NOT b_direkttaste_einfahren AND
				NOT e_taste_einfahren) OR
				(NOT st_ctrl_in.b_einfahren AND
				bw_nocken_zylinder_einfahren AND
				NOT b_ibn_zylinder_einfahren AND
				NOT b_direkttaste_einfahren AND
				NOT e_taste_einfahren) OR
				(NOT st_ctrl_in.b_einfahren AND
				NOT bw_nocken_zylinder_einfahren AND
				b_ibn_zylinder_einfahren AND
				NOT b_direkttaste_einfahren AND
				NOT e_taste_einfahren)
				THEN
					IF i16_anzahl_sensoren >= 1AND b_sensor_eingefahren_vorhanden AND b_mit_tzk THEN
						st_tzk.t_einfahrzeit_kompensiert := (st_tzk.t_einfahrzeit * st_config.i16_tzk_faktor_einfahren) / 100;
					END_IF
					fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
			END_IF
		HAND:
			IF	(st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND (st_visu.b_taste_einfahren OR e_taste_einfahren)) OR
				(bw_nocken_zylinder_einfahren AND b_nockengesteuert AND b_masterachse_hand_dialog_aktiv)
				THEN
					IF i16_anzahl_sensoren >= 1AND b_sensor_eingefahren_vorhanden AND b_mit_tzk THEN
						st_tzk.t_einfahrzeit_kompensiert := (st_tzk.t_einfahrzeit * st_config.i16_tzk_faktor_einfahren) / 100;
					END_IF
					fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
			END_IF
		END_CASE

		(* Totzeitkompensation mit Plausibilitätscheck der ermittelten Kompensationszeit *)
		IF	i16_anzahl_sensoren >= 1AND
			b_mit_tzk AND
			b_sensor_ausgefahren_vorhanden AND
			st_tzk.t_ausfahrzeit_kompensiert < st_tzk.t_ausfahrzeit
			THEN
				st_tzk.fb_ton_tzk.PT := st_tzk.t_ausfahrzeit_kompensiert ;
				st_tzk.fb_ton_tzk.IN := TRUE;
				(* Totzeit ist abgelaufen -> vorzeitig "ausgefahren" melden*)
				IF st_tzk.fb_ton_tzk.Q THEN
					st_ctrl_out.b_ausgefahren := TRUE;
				END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Bedingungen für Zylinder ist ausgefahren und Fehlervorkommen*)
		(* Die Sensorkonfiguration "vorhanden" ist nur für die Fälle 1, 2 von Bedeutung wegen Sonderzylinder *)
		CASE i16_anzahl_sensoren OF
			0:
				IF fb_ton_einausfahren.Q THEN
					fb_state_entry.i16_next_step := AUSGEFAHREN;
				END_IF

			1:
				IF b_sensor_ausgefahren_vorhanden THEN
					IF e_sensor1_ausgefahren THEN
						fb_state_entry.i16_next_step := AUSGEFAHREN;
					ELSE
						IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb) THEN
								st_sm.b_zeit_ausfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_ausfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_ausfahren THEN
								st_sm.b_winkel_ausfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				ELSIF b_sensor_eingefahren_vorhanden THEN
					IF  NOT e_sensor1_eingefahren THEN
						fb_state_entry.i16_next_step := AUSGEFAHREN;
					ELSE
						IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb) THEN
								st_sm.b_zeit_ausfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_ausfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_ausfahren THEN
								st_sm.b_winkel_ausfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				END_IF

			2:
				IF b_sensor_eingefahren_vorhanden AND b_sensor_ausgefahren_vorhanden THEN
					IF e_sensor1_ausgefahren AND NOT e_sensor1_eingefahren THEN
						fb_state_entry.i16_next_step := AUSGEFAHREN;
					ELSE
						IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb) THEN
								st_sm.b_zeit_ausfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_ausfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_ausfahren THEN
								st_sm.b_winkel_ausfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				ELSIF b_sensor_eingefahren_vorhanden THEN
					IF NOT e_sensor1_eingefahren AND NOT e_sensor2_eingefahren THEN
						fb_state_entry.i16_next_step := AUSGEFAHREN;
					ELSE
						IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb) THEN
								IF e_sensor1_eingefahren THEN
									st_sm.b_zeit_ausfahren1 := TRUE;
								END_IF
								IF e_sensor2_eingefahren THEN
									st_sm.b_zeit_ausfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_ausfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_ausfahren THEN
								IF e_sensor1_eingefahren THEN
									st_sm.b_winkel_ausfahren1 := TRUE;
								END_IF
								IF e_sensor2_eingefahren THEN
									st_sm.b_winkel_ausfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				ELSIF  b_sensor_ausgefahren_vorhanden THEN
					IF e_sensor1_ausgefahren AND e_sensor2_ausgefahren THEN
						fb_state_entry.i16_next_step := AUSGEFAHREN;
					ELSE
						IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb) THEN
								IF NOT e_sensor1_ausgefahren THEN
									st_sm.b_zeit_ausfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_ausgefahren THEN
									st_sm.b_zeit_ausfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_ausfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_ausfahren THEN
								IF NOT e_sensor1_ausgefahren THEN
									st_sm.b_winkel_ausfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_ausgefahren THEN
									st_sm.b_winkel_ausfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				END_IF
				IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
					(* Überwachung auf Sensorfehler *)
					IF e_sensor1_ausgefahren  AND e_sensor1_eingefahren  AND st_config.b_sensor1_aktiv THEN
						fb_ton_uz_sensor1.IN := TRUE;
						IF fb_ton_uz_sensor1.Q THEN
							st_sm.b_sensor1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor1.IN := FALSE;
					END_IF
				END_IF

			3:
				IF	(* Zylinder ist ausgefahren *)
					(e_sensor1_ausgefahren AND NOT e_sensor1_eingefahren AND NOT e_sensor_mittegefahren) OR
					(* Zylinder steht in Mittelstellung *)
					(e_sensor_mittegefahren AND NOT e_sensor1_eingefahren AND NOT e_sensor1_ausgefahren)
					THEN
						fb_state_entry.i16_next_step := AUSGEFAHREN;
				ELSE
					IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
						(* Zeitüberwachung *)
						IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb) THEN
							st_sm.b_zeit_ausfahren1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						(* Winkelüberwachung *)
						ELSIF uw_nocken_zylinder_ausfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_ausfahren THEN
							st_sm.b_winkel_ausfahren1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					END_IF
				END_IF
				IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
					(* Überwachung auf Sensorfehler *)
					IF e_sensor1_ausgefahren  AND e_sensor1_eingefahren  AND st_config.b_sensor1_aktiv THEN
						fb_ton_uz_sensor1.IN := TRUE;
						IF fb_ton_uz_sensor1.Q THEN
							st_sm.b_sensor1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor1.IN := FALSE;
					END_IF
				END_IF

			4:
				IF e_sensor1_ausgefahren AND e_sensor2_ausgefahren AND NOT e_sensor1_eingefahren AND NOT e_sensor2_eingefahren	THEN
					fb_state_entry.i16_next_step := AUSGEFAHREN;
				ELSE
					IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
						IF NOT e_sensor1_ausgefahren OR NOT e_sensor2_ausgefahren THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb) THEN
								IF NOT e_sensor1_ausgefahren THEN
									st_sm.b_zeit_ausfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_ausgefahren THEN
									st_sm.b_zeit_ausfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_ausfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_ausfahren THEN
								IF NOT e_sensor1_ausgefahren THEN
									st_sm.b_winkel_ausfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_ausgefahren THEN
									st_sm.b_winkel_ausfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				END_IF

				IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
					(* Überwachung auf Sensorfehler *)
					IF e_sensor1_ausgefahren  AND e_sensor1_eingefahren  AND st_config.b_sensor1_aktiv THEN
						fb_ton_uz_sensor1.IN := TRUE;
						IF fb_ton_uz_sensor1.Q THEN
							st_sm.b_sensor1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor1.IN := FALSE;
					END_IF
					IF e_sensor2_ausgefahren  AND e_sensor2_eingefahren  AND st_config.b_sensor2_aktiv THEN
						fb_ton_uz_sensor2.IN := TRUE;
						IF fb_ton_uz_sensor2.Q THEN
							st_sm.b_sensor2 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor2.IN := FALSE;
					END_IF
				END_IF

			6:
				IF 	e_sensor1_ausgefahren AND
					e_sensor2_ausgefahren AND
					e_sensor3_ausgefahren AND
					NOT e_sensor1_eingefahren AND
					NOT e_sensor2_eingefahren AND
					NOT e_sensor3_eingefahren
					THEN
						fb_state_entry.i16_next_step := AUSGEFAHREN;
				ELSE
					IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
						IF NOT e_sensor1_ausgefahren OR NOT e_sensor2_ausgefahren OR NOT e_sensor3_ausgefahren THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb) THEN
								IF NOT e_sensor1_ausgefahren THEN
									st_sm.b_zeit_ausfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_ausgefahren THEN
									st_sm.b_zeit_ausfahren2 := TRUE;
								END_IF
								IF NOT e_sensor3_ausgefahren THEN
									st_sm.b_zeit_ausfahren3 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_ausfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_ausfahren THEN
								IF NOT e_sensor1_ausgefahren THEN
									st_sm.b_winkel_ausfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_ausgefahren THEN
									st_sm.b_winkel_ausfahren2 := TRUE;
								END_IF
								IF NOT e_sensor3_ausgefahren THEN
									st_sm.b_winkel_ausfahren3 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				END_IF

				IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
					(* Überwachung auf Sensorfehler *)
					IF e_sensor1_ausgefahren  AND e_sensor1_eingefahren  AND st_config.b_sensor1_aktiv THEN
						fb_ton_uz_sensor1.IN := TRUE;
						IF fb_ton_uz_sensor1.Q THEN
							st_sm.b_sensor1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor1.IN := FALSE;
					END_IF
					IF e_sensor2_ausgefahren  AND e_sensor2_eingefahren  AND st_config.b_sensor2_aktiv THEN
						fb_ton_uz_sensor2.IN := TRUE;
						IF fb_ton_uz_sensor2.Q THEN
							st_sm.b_sensor2 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor2.IN := FALSE;
					END_IF
					IF e_sensor3_ausgefahren  AND e_sensor3_eingefahren  AND st_config.b_sensor3_aktiv THEN
						fb_ton_uz_sensor3.IN := TRUE;
						IF fb_ton_uz_sensor3.Q THEN
							st_sm.b_sensor3 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor3.IN := FALSE;
					END_IF
				END_IF
		END_CASE

(*=======================================================*)
	AUSGEFAHREN:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_gestoppt := FALSE;
			st_ctrl_out.b_eingefahren := FALSE;
			st_ctrl_out.b_ohne_luft := FALSE;
			fb_ton_einausfahren.IN := FALSE;
			fb_ton_uz_fahren.IN := FALSE;
			fb_ton_uz_sensor1.IN := FALSE;
			fb_ton_uz_sensor2.IN := FALSE;
			fb_ton_uz_sensor3.IN := FALSE;
			st_tzk.fb_ton_tzk.IN := FALSE;
			a_ventil_ausfahren := TRUE;
			b_zustand_uw_nocken_ausfahren := FALSE;
			IF NOT b_mit_tzk THEN
				st_ctrl_out.b_ausgefahren := TRUE;
			END_IF
		END_IF

		IF st_ctrl_in.b_ausfahren THEN	(* Messagewiederholung wenn der Zylinder sich schon im gewünschten Zustand befindet*)
			st_ctrl_out.b_ausgefahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE i16_betriebsart OF
		KEINE:
			;
		AUTO, TIPPEN, DUMMY, PSEUDO:
			IF	(st_ctrl_in.b_einfahren AND
				NOT bw_nocken_zylinder_einfahren AND
				NOT b_ibn_zylinder_einfahren AND
				NOT b_direkttaste_einfahren AND
				NOT e_taste_einfahren) OR
				(NOT st_ctrl_in.b_einfahren AND
				bw_nocken_zylinder_einfahren AND
				NOT b_ibn_zylinder_einfahren AND
				NOT b_direkttaste_einfahren AND
				NOT e_taste_einfahren) OR
				(NOT st_ctrl_in.b_einfahren AND
				NOT bw_nocken_zylinder_einfahren AND
				b_ibn_zylinder_einfahren AND
				NOT b_direkttaste_einfahren AND
				NOT e_taste_einfahren)
				THEN
					IF i16_anzahl_sensoren >= 1AND b_sensor_eingefahren_vorhanden AND b_mit_tzk THEN
						st_tzk.t_einfahrzeit_kompensiert := (st_tzk.t_einfahrzeit * st_config.i16_tzk_faktor_einfahren) / 100;
					END_IF
					fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;

			ELSIF	st_ctrl_in.b_luftlos AND
					NOT bw_nocken_zylinder_einfahren AND
					NOT b_ibn_zylinder_einfahren AND
					NOT b_direkttaste_einfahren AND
					NOT e_taste_einfahren AND
					NOT bw_nocken_zylinder_ausfahren AND
					NOT b_ibn_zylinder_ausfahren AND
					NOT b_direkttaste_ausfahren AND
					NOT e_taste_ausfahren
					THEN
						fb_state_entry.i16_next_step := LUFTLOS;
			END_IF
		HAND:
			IF	(st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND (st_visu.b_taste_einfahren OR e_taste_einfahren)) OR
				(bw_nocken_zylinder_einfahren AND b_nockengesteuert AND b_masterachse_hand_dialog_aktiv)
				THEN
					IF i16_anzahl_sensoren >= 1AND b_sensor_eingefahren_vorhanden AND b_mit_tzk THEN
						st_tzk.t_einfahrzeit_kompensiert := (st_tzk.t_einfahrzeit * st_config.i16_tzk_faktor_einfahren) / 100;
					END_IF
					fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
			END_IF
		END_CASE

		(* Überwachung auf Endlagenfehler *)
		IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
			CASE i16_anzahl_sensoren OF
				1,2,3:	(* Alle Zylinder mit mindestens einem Sensor für EINGEFAHREN *)
					IF b_sensor_ausgefahren_vorhanden AND st_config.b_endlage1_aktiv AND NOT e_sensor1_ausgefahren THEN
						fb_ton_uz_endlage1.IN := TRUE;
						IF fb_ton_uz_endlage1.Q THEN
							st_sm.b_endlage1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage1.IN := FALSE;
					END_IF

				4:	(* Alle Zylinder mit 2 Sensoren für EINGEFAHREN *)
					IF b_sensor_ausgefahren_vorhanden AND st_config.b_endlage1_aktiv AND NOT e_sensor1_ausgefahren THEN
						fb_ton_uz_endlage1.IN := TRUE;
						IF fb_ton_uz_endlage1.Q THEN
							st_sm.b_endlage1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage1.IN := FALSE;
					END_IF
					IF b_sensor_ausgefahren_vorhanden AND st_config.b_endlage2_aktiv AND NOT e_sensor2_ausgefahren THEN
						fb_ton_uz_endlage2.IN := TRUE;
						IF fb_ton_uz_endlage2.Q THEN
							st_sm.b_endlage2 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage2.IN := FALSE;
					END_IF

				6:	(* Alle Zylinder mit 3 Sensoren für EINGEFAHREN *)
					IF b_sensor_ausgefahren_vorhanden AND st_config.b_endlage1_aktiv AND NOT e_sensor1_ausgefahren THEN
						fb_ton_uz_endlage1.IN := TRUE;
						IF fb_ton_uz_endlage1.Q THEN
							st_sm.b_endlage1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage1.IN := FALSE;
					END_IF
					IF b_sensor_ausgefahren_vorhanden AND st_config.b_endlage2_aktiv AND NOT e_sensor2_ausgefahren THEN
						fb_ton_uz_endlage2.IN := TRUE;
						IF fb_ton_uz_endlage2.Q THEN
							st_sm.b_endlage2 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage2.IN := FALSE;
					END_IF
					IF b_sensor_ausgefahren_vorhanden AND st_config.b_endlage3_aktiv AND NOT e_sensor3_ausgefahren THEN
						fb_ton_uz_endlage3.IN := TRUE;
						IF fb_ton_uz_endlage3.Q THEN
							st_sm.b_endlage3 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_endlage3.IN := FALSE;
					END_IF
			END_CASE
		END_IF

(*=======================================================*)
	BEWEGUNG_EINFAHREN:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_gestoppt := FALSE;
			st_ctrl_out.b_eingefahren := FALSE;
			st_ctrl_out.b_ausgefahren := FALSE;
			st_ctrl_out.b_ohne_luft := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			a_ventil_ausfahren := FALSE;
			a_ventil_einfahren := TRUE;
			fb_ton_uz_fahren.IN := TRUE;
			fb_ton_einausfahren.IN := TRUE;
			fb_ton_uz_endlage1.IN := FALSE;
			fb_ton_uz_endlage2.IN := FALSE;
			fb_ton_uz_endlage3.IN := FALSE;
			st_sm.b_zeit_ausfahren1:= FALSE;
			st_sm.b_zeit_einfahren1:= FALSE;
			st_sm.b_endlage1	:= FALSE;
			st_sm.b_sensor1:= FALSE;
			st_sm.b_zeit_ausfahren2 := FALSE;
			st_sm.b_zeit_einfahren2 := FALSE;
			st_sm.b_endlage2	:= FALSE;
			st_sm.b_sensor2 := FALSE;
			st_sm.b_zeit_ausfahren3 := FALSE;
			st_sm.b_zeit_einfahren3 := FALSE;
			st_sm.b_endlage3	:= FALSE;
			st_sm.b_sensor3 := FALSE;
			st_sm.b_winkel_ausfahren1:= FALSE;
			st_sm.b_winkel_einfahren1:= FALSE;
			st_sm.b_winkel_ausfahren2 := FALSE;
			st_sm.b_winkel_einfahren2 := FALSE;
			st_sm.b_winkel_ausfahren3 := FALSE;
			st_sm.b_winkel_einfahren3 := FALSE;
			st_sm.b_zyltyp_nicht_definiert := FALSE;
			st_sm.b_reserve1:= FALSE;
			(* Verhindere die sofortige Fehlerauslösung, wenn Überwachungsnocken bei Stateentry schon vorhanden ist *)
			IF uw_nocken_zylinder_einfahren THEN
				b_zustand_uw_nocken_einfahren := TRUE;
			END_IF
		END_IF

		(* Fehlermeldung für nockengesteuerte Zylinder wieder freischalten *)
		IF fb_ton_uz_fahren.Q THEN
			b_zustand_uw_nocken_einfahren := FALSE;
		END_IF

		CASE i16_betriebsart OF
		KEINE:
			;
		AUTO, TIPPEN, DUMMY, PSEUDO:
			IF 	(st_ctrl_in.b_ausfahren AND
				NOT bw_nocken_zylinder_ausfahren AND
				NOT b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren) OR
				(NOT st_ctrl_in.b_ausfahren AND
				bw_nocken_zylinder_ausfahren AND
				NOT b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren) OR
				(NOT st_ctrl_in.b_ausfahren AND
				NOT bw_nocken_zylinder_ausfahren AND
				b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren)
				THEN
					IF i16_anzahl_sensoren >= 1AND b_sensor_ausgefahren_vorhanden AND b_mit_tzk THEN
						st_tzk.t_ausfahrzeit_kompensiert := (st_tzk.t_ausfahrzeit * st_config.i16_tzk_faktor_ausfahren) / 100;
					END_IF
					fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
			END_IF
		HAND:
			IF	(st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND (st_visu.b_taste_ausfahren OR e_taste_ausfahren)) OR
				(bw_nocken_zylinder_ausfahren AND b_nockengesteuert AND b_masterachse_hand_dialog_aktiv)
				THEN
					IF i16_anzahl_sensoren >= 1AND b_sensor_ausgefahren_vorhanden AND b_mit_tzk THEN
						st_tzk.t_ausfahrzeit_kompensiert := (st_tzk.t_ausfahrzeit * st_config.i16_tzk_faktor_ausfahren) / 100;
					END_IF
					fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;
			END_IF
		END_CASE

		(* Totzeitkompensation mit Plausibilitätscheck der ermittelten Kompensationszeit *)
		IF 	i16_anzahl_sensoren >= 1AND
			b_sensor_eingefahren_vorhanden AND
			b_mit_tzk AND
			st_tzk.t_einfahrzeit_kompensiert < st_tzk.t_einfahrzeit
			THEN
				st_tzk.fb_ton_tzk.PT := st_tzk.t_einfahrzeit_kompensiert ;
				st_tzk.fb_ton_tzk.IN := TRUE;
				(* Totzeit ist abgelaufen -> vorzeitig "eingefahren" melden*)
				IF st_tzk.fb_ton_tzk.Q THEN
					st_tzk.fb_ton_tzk.IN := FALSE;
					st_ctrl_out.b_eingefahren := TRUE;
				END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Bedingungen für Zylinder ist eingefahren und Fehlervorkommen*)
		(* Die Sensorkonfiguration "vorhanden" ist nur für die Fälle 1, 2 von Bedeutung wegen Sonderzylinder *)
		CASE i16_anzahl_sensoren OF
			0:
				IF fb_ton_einausfahren.Q THEN
					fb_state_entry.i16_next_step := EINGEFAHREN;
				END_IF

			1:
				IF b_sensor_eingefahren_vorhanden THEN
					IF e_sensor1_eingefahren THEN
						fb_state_entry.i16_next_step := EINGEFAHREN;
					ELSE
						IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb)THEN
								st_sm.b_zeit_einfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_einfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_einfahren THEN
								st_sm.b_winkel_einfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				ELSIF b_sensor_ausgefahren_vorhanden THEN
					IF  NOT e_sensor1_ausgefahren THEN
						fb_state_entry.i16_next_step := EINGEFAHREN;
					ELSE
						IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb)THEN
								st_sm.b_zeit_einfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_einfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_einfahren THEN
								st_sm.b_winkel_einfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				END_IF

			2:
				IF b_sensor_eingefahren_vorhanden AND b_sensor_ausgefahren_vorhanden THEN
					IF e_sensor1_eingefahren AND NOT e_sensor1_ausgefahren THEN
						fb_state_entry.i16_next_step := EINGEFAHREN;
					ELSE
						IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb)THEN
								st_sm.b_zeit_einfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_einfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_einfahren THEN
								st_sm.b_winkel_einfahren1 := TRUE;
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				ELSIF b_sensor_ausgefahren_vorhanden THEN
					IF NOT e_sensor1_ausgefahren AND NOT e_sensor2_ausgefahren THEN
						fb_state_entry.i16_next_step := EINGEFAHREN;
					ELSE
						IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb)THEN
								IF e_sensor1_ausgefahren THEN
									st_sm.b_zeit_einfahren1 := TRUE;
								END_IF
								IF e_sensor2_ausgefahren THEN
									st_sm.b_zeit_einfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_einfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_einfahren THEN
								IF e_sensor1_ausgefahren THEN
								st_sm.b_winkel_einfahren1 := TRUE;
								END_IF
								IF e_sensor2_ausgefahren THEN
								st_sm.b_winkel_einfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				ELSIF  b_sensor_eingefahren_vorhanden THEN
					IF e_sensor1_eingefahren AND e_sensor2_eingefahren THEN
						fb_state_entry.i16_next_step := EINGEFAHREN;
					ELSE
						IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb)THEN
								IF NOT e_sensor1_eingefahren THEN
									st_sm.b_zeit_einfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_eingefahren THEN
									st_sm.b_zeit_einfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_einfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_einfahren THEN
								IF NOT e_sensor1_eingefahren THEN
									st_sm.b_winkel_einfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_eingefahren THEN
									st_sm.b_winkel_einfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				END_IF
				IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
					(* Überwachung auf Sensorfehler *)
					IF e_sensor1_ausgefahren  AND e_sensor1_eingefahren  AND st_config.b_sensor1_aktiv THEN
						fb_ton_uz_sensor1.IN := TRUE;
						IF fb_ton_uz_sensor1.Q THEN
							st_sm.b_sensor1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor1.IN := FALSE;
					END_IF
				END_IF

			3:
				IF	(* Zylinder ist ausgefahren *)
					(e_sensor1_eingefahren AND NOT e_sensor1_ausgefahren AND NOT e_sensor_mittegefahren) OR
					(* Zylinder steht in Mittelstellung *)
					(e_sensor_mittegefahren AND NOT e_sensor1_eingefahren AND NOT e_sensor1_ausgefahren)
					THEN
						fb_state_entry.i16_next_step := EINGEFAHREN;
				ELSE
					IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
						(* Zeitüberwachung *)
						IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb)THEN
							st_sm.b_zeit_einfahren1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						(* Winkelüberwachung *)
						ELSIF uw_nocken_zylinder_einfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_einfahren THEN
							st_sm.b_winkel_einfahren1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					END_IF
				END_IF
				IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
					(* Überwachung auf Sensorfehler *)
					IF e_sensor1_ausgefahren  AND e_sensor1_eingefahren  AND st_config.b_sensor1_aktiv THEN
						fb_ton_uz_sensor1.IN := TRUE;
						IF fb_ton_uz_sensor1.Q THEN
							st_sm.b_sensor1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor1.IN := FALSE;
					END_IF
				END_IF

			4:
				IF e_sensor1_eingefahren AND e_sensor2_eingefahren AND NOT e_sensor1_ausgefahren AND NOT e_sensor2_ausgefahren	THEN
					fb_state_entry.i16_next_step := EINGEFAHREN;
				ELSE
					IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
						IF NOT e_sensor1_eingefahren OR NOT e_sensor2_eingefahren THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb)THEN
								IF NOT e_sensor1_eingefahren THEN
									st_sm.b_zeit_einfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_eingefahren THEN
									st_sm.b_zeit_einfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_einfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_einfahren THEN
								IF NOT e_sensor1_eingefahren THEN
									st_sm.b_winkel_einfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_eingefahren THEN
									st_sm.b_winkel_einfahren2 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				END_IF

				IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
					(* Überwachung auf Sensorfehler *)
					IF e_sensor1_ausgefahren  AND e_sensor1_eingefahren  AND st_config.b_sensor1_aktiv THEN
						fb_ton_uz_sensor1.IN := TRUE;
						IF fb_ton_uz_sensor1.Q THEN
							st_sm.b_sensor1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor1.IN := FALSE;
					END_IF
					IF e_sensor2_ausgefahren  AND e_sensor2_eingefahren  AND st_config.b_sensor2_aktiv THEN
						fb_ton_uz_sensor2.IN := TRUE;
						IF fb_ton_uz_sensor2.Q THEN
							st_sm.b_sensor2 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor2.IN := FALSE;
					END_IF
				END_IF

			6:
				IF 	e_sensor1_eingefahren AND
					e_sensor2_eingefahren AND
					e_sensor3_eingefahren AND
					NOT e_sensor1_ausgefahren AND
					NOT e_sensor2_ausgefahren AND
					NOT e_sensor3_ausgefahren
					THEN
						fb_state_entry.i16_next_step := EINGEFAHREN;
				ELSE
					IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
						IF NOT e_sensor1_eingefahren OR NOT e_sensor2_eingefahren OR NOT e_sensor3_eingefahren THEN
							(* Zeitüberwachung *)
							IF fb_ton_uz_fahren.Q AND (NOT b_nockengesteuert OR b_no_gesteuert_im_norm_betrieb)THEN
								IF NOT e_sensor1_eingefahren THEN
									st_sm.b_zeit_einfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_eingefahren THEN
									st_sm.b_zeit_einfahren2 := TRUE;
								END_IF
								IF NOT e_sensor3_eingefahren THEN
									st_sm.b_zeit_einfahren3 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							(* Winkelüberwachung *)
							ELSIF uw_nocken_zylinder_einfahren AND b_nockengesteuert AND NOT b_no_gesteuert_im_norm_betrieb AND NOT b_zustand_uw_nocken_einfahren THEN
								IF NOT e_sensor1_eingefahren THEN
									st_sm.b_winkel_einfahren1 := TRUE;
								END_IF
								IF NOT e_sensor2_eingefahren THEN
									st_sm.b_winkel_einfahren2 := TRUE;
								END_IF
								IF NOT e_sensor3_eingefahren THEN
									st_sm.b_winkel_einfahren3 := TRUE;
								END_IF
								fb_state_entry.i16_next_step := ZYL_FEHLER;
							END_IF
						END_IF
					END_IF
				END_IF

				IF i16_betriebsart <> HAND AND st_config.b_aktiv THEN
					(* Überwachung auf Sensorfehler *)
					IF e_sensor1_ausgefahren  AND e_sensor1_eingefahren  AND st_config.b_sensor1_aktiv THEN
						fb_ton_uz_sensor1.IN := TRUE;
						IF fb_ton_uz_sensor1.Q THEN
							st_sm.b_sensor1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor1.IN := FALSE;
					END_IF
					IF e_sensor2_ausgefahren  AND e_sensor2_eingefahren  AND st_config.b_sensor2_aktiv THEN
						fb_ton_uz_sensor2.IN := TRUE;
						IF fb_ton_uz_sensor2.Q THEN
							st_sm.b_sensor2 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor2.IN := FALSE;
					END_IF
					IF e_sensor3_ausgefahren  AND e_sensor3_eingefahren  AND st_config.b_sensor3_aktiv THEN
						fb_ton_uz_sensor3.IN := TRUE;
						IF fb_ton_uz_sensor3.Q THEN
							st_sm.b_sensor3 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
						END_IF
					ELSE
						fb_ton_uz_sensor3.IN := FALSE;
					END_IF
				END_IF
		END_CASE

(*=======================================================*)
	LUFTLOS:
		IF fb_state_entry.E THEN
			a_ventil_ausfahren := FALSE;
			a_ventil_einfahren	:= FALSE;
			st_ctrl_out.b_gestoppt := FALSE;
			st_ctrl_out.b_ohne_luft := TRUE;
			st_ctrl_out.b_fehler := FALSE;
		END_IF
(*
		(* Überwachung der Sensoren *)
		CASE i16_anzahl_sensoren OF
			0:
				;

			1:
				IF b_sensor_eingefahren_vorhanden THEN
					IF st_ctrl_out.b_eingefahren AND NOT e_sensor1_eingefahren THEN
						st_sm.b_endlage1 := TRUE;
						fb_state_entry.i16_next_step := ZYL_FEHLER;
					END_IF
				ELSIF b_sensor_ausgefahren_vorhanden THEN
					IF  st_ctrl_out.b_ausgefahren AND NOT e_sensor1_ausgefahren THEN
						st_sm.b_endlage1 := TRUE;
						fb_state_entry.i16_next_step := ZYL_FEHLER;
					END_IF
				END_IF

			2:
				IF b_sensor_eingefahren_vorhanden AND b_sensor_ausgefahren_vorhanden THEN
					IF 	(st_ctrl_out.b_eingefahren AND NOT e_sensor1_eingefahren) OR
						(st_ctrl_out.b_ausgefahren AND NOT e_sensor1_ausgefahren)
						THEN
							st_sm.b_endlage1 := TRUE;
							fb_state_entry.i16_next_step := ZYL_FEHLER;
					END_IF
				ELSIF b_sensor_ausgefahren_vorhanden THEN
					IF st_ctrl_out.b_ausgefahren AND (NOT e_sensor1_ausgefahren OR NOT e_sensor2_ausgefahren) THEN
						st_sm.b_endlage1 := NOT e_sensor1_ausgefahren;
						st_sm.b_endlage2 := NOT e_sensor2_ausgefahren;
						fb_state_entry.i16_next_step := ZYL_FEHLER;
					END_IF
				ELSIF  b_sensor_eingefahren_vorhanden THEN
					IF st_ctrl_out.b_eingefahren AND (NOT e_sensor1_eingefahren OR NOT e_sensor2_eingefahren) THEN
						st_sm.b_endlage1 := NOT e_sensor1_eingefahren;
						st_sm.b_endlage2 := NOT e_sensor2_eingefahren;
						fb_state_entry.i16_next_step := ZYL_FEHLER;
					END_IF
				END_IF

			3:
				;

			4:
				IF st_ctrl_out.b_eingefahren AND (NOT e_sensor1_eingefahren OR NOT e_sensor2_eingefahren)THEN
					st_sm.b_endlage1 := NOT e_sensor1_eingefahren;
					st_sm.b_endlage2 := NOT e_sensor2_eingefahren;
					fb_state_entry.i16_next_step := ZYL_FEHLER;
				ELSIF st_ctrl_out.b_ausgefahren AND (NOT e_sensor1_ausgefahren OR NOT e_sensor2_ausgefahren)THEN
					st_sm.b_endlage1 := NOT e_sensor1_ausgefahren;
					st_sm.b_endlage2 := NOT e_sensor2_ausgefahren;
					fb_state_entry.i16_next_step := ZYL_FEHLER;
				END_IF

			6:
				IF st_ctrl_out.b_eingefahren AND (NOT e_sensor1_eingefahren OR NOT e_sensor2_eingefahren OR NOT e_sensor3_eingefahren)THEN
					st_sm.b_endlage1 := NOT e_sensor1_eingefahren;
					st_sm.b_endlage2 := NOT e_sensor2_eingefahren;
					st_sm.b_endlage3 := NOT e_sensor3_eingefahren;
					fb_state_entry.i16_next_step := ZYL_FEHLER;
				ELSIF st_ctrl_out.b_ausgefahren AND (NOT e_sensor1_ausgefahren OR NOT e_sensor2_ausgefahren OR NOT e_sensor2_ausgefahren)THEN
					st_sm.b_endlage1 := NOT e_sensor1_ausgefahren;
					st_sm.b_endlage2 := NOT e_sensor2_ausgefahren;
					st_sm.b_endlage3 := NOT e_sensor3_ausgefahren;
					fb_state_entry.i16_next_step := ZYL_FEHLER;
				END_IF
		END_CASE
*)
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE i16_betriebsart OF
		KEINE:
			;
		AUTO, TIPPEN, DUMMY, PSEUDO:
			IF 	(st_ctrl_in.b_ausfahren AND
				NOT st_ctrl_in.b_luftlos AND
				NOT bw_nocken_zylinder_ausfahren AND
				NOT b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren) OR
				(NOT st_ctrl_in.b_ausfahren AND
				NOT st_ctrl_in.b_luftlos AND
				bw_nocken_zylinder_ausfahren AND
				NOT b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren) OR
				(NOT st_ctrl_in.b_ausfahren AND
				NOT st_ctrl_in.b_luftlos AND
				NOT bw_nocken_zylinder_ausfahren AND
				b_ibn_zylinder_ausfahren AND
				NOT b_direkttaste_ausfahren AND
				NOT e_taste_ausfahren)
				THEN
					fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;

			ELSIF	(st_ctrl_in.b_einfahren AND
					NOT st_ctrl_in.b_luftlos AND
					NOT bw_nocken_zylinder_einfahren AND
					NOT b_ibn_zylinder_einfahren AND
					NOT b_direkttaste_einfahren AND
					NOT e_taste_einfahren) OR
					(NOT st_ctrl_in.b_einfahren AND
					NOT st_ctrl_in.b_luftlos AND
					bw_nocken_zylinder_einfahren AND
					NOT b_ibn_zylinder_einfahren AND
					NOT b_direkttaste_einfahren AND
					NOT e_taste_einfahren) OR
					(NOT st_ctrl_in.b_einfahren AND
					NOT st_ctrl_in.b_luftlos AND
					NOT bw_nocken_zylinder_einfahren AND
					b_ibn_zylinder_einfahren AND
					NOT b_direkttaste_einfahren AND
					NOT e_taste_einfahren)
					THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
			END_IF
		HAND:
			IF	(st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND (st_visu.b_taste_ausfahren OR e_taste_ausfahren)) OR
				(bw_nocken_zylinder_ausfahren AND b_nockengesteuert AND b_masterachse_hand_dialog_aktiv)
				THEN
					fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;

			ELSIF	(st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND (st_visu.b_taste_einfahren OR e_taste_einfahren)) OR
					(bw_nocken_zylinder_einfahren AND b_nockengesteuert AND b_masterachse_hand_dialog_aktiv)
					THEN
						fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
			END_IF
		END_CASE


(*=======================================================*)
	ZYL_FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			st_ctrl_out.b_eingefahren := FALSE;
			st_ctrl_out.b_ausgefahren := FALSE;
			st_ctrl_out.b_gestoppt := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_visu.i16_zyl_id := st_config.i16_identnummer;
			st_visu.i16_zyl_fehlergruppe := st_config.i16_gruppe;
		END_IF

		(* Fehler wurde quittiert *)
		IF (st_ctrl_in.b_quittieren  OR b_ibn_zylinderfehler_quit ) AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := ZYL_INIT;
		END_IF

		(* Weiterschaltbedingungen für das Bewegen der Zylinder im Visu-Auswahlmenü im Handbetrieb, Hardwaretaster *)
		(* Zylinder einfahren im Handbetrieb über Tasten *)
		IF	i16_betriebsart = HAND AND
			st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND
			st_visu.b_taste_ausfahren AND
			NOT st_visu.b_taste_einfahren
			THEN
				st_ctrl_out.b_fehler := FALSE;
				st_sm.b_zeit_ausfahren1:= FALSE;
				st_sm.b_zeit_einfahren1:= FALSE;
				st_sm.b_endlage1	:= FALSE;
				st_sm.b_sensor1:= FALSE;
				st_sm.b_zeit_ausfahren2 := FALSE;
				st_sm.b_zeit_einfahren2 := FALSE;
				st_sm.b_endlage2	:= FALSE;
				st_sm.b_sensor2 := FALSE;
				st_sm.b_zeit_ausfahren3 := FALSE;
				st_sm.b_zeit_einfahren3 := FALSE;
				st_sm.b_endlage3	:= FALSE;
				st_sm.b_sensor3 := FALSE;
				st_sm.b_winkel_ausfahren1:= FALSE;
				st_sm.b_winkel_einfahren1:= FALSE;
				st_sm.b_winkel_ausfahren2 := FALSE;
				st_sm.b_winkel_einfahren2 := FALSE;
				st_sm.b_winkel_ausfahren3 := FALSE;
				st_sm.b_winkel_einfahren3 := FALSE;
				st_sm.b_zyltyp_nicht_definiert := FALSE;
				st_sm.b_reserve1:= FALSE;
				fb_state_entry.i16_next_step := BEWEGUNG_AUSFAHREN;

		(* Zylinder einfahren im Handbetrieb über Tasten *)
		ELSIF i16_betriebsart = HAND AND
			st_visu.i16_nr_zyl_im_handbetrieb = st_config.i16_identnummer AND
			st_visu.b_taste_einfahren AND
			NOT st_visu.b_taste_ausfahren
			THEN
				st_ctrl_out.b_fehler := FALSE;
				st_sm.b_zeit_ausfahren1:= FALSE;
				st_sm.b_zeit_einfahren1:= FALSE;
				st_sm.b_endlage1	:= FALSE;
				st_sm.b_sensor1:= FALSE;
				st_sm.b_zeit_ausfahren2 := FALSE;
				st_sm.b_zeit_einfahren2 := FALSE;
				st_sm.b_endlage2	:= FALSE;
				st_sm.b_sensor2 := FALSE;
				st_sm.b_zeit_ausfahren3 := FALSE;
				st_sm.b_zeit_einfahren3 := FALSE;
				st_sm.b_endlage3	:= FALSE;
				st_sm.b_sensor3 := FALSE;
				st_sm.b_winkel_ausfahren1:= FALSE;
				st_sm.b_winkel_einfahren1:= FALSE;
				st_sm.b_winkel_ausfahren2 := FALSE;
				st_sm.b_winkel_einfahren2 := FALSE;
				st_sm.b_winkel_ausfahren3 := FALSE;
				st_sm.b_winkel_einfahren3 := FALSE;
				st_sm.b_zyltyp_nicht_definiert := FALSE;
				st_sm.b_reserve1:= FALSE;
				fb_state_entry.i16_next_step := BEWEGUNG_EINFAHREN;
		END_IF

(*=======================================================*)
	DIREKT_AUSFAHREN:
		IF fb_state_entry.E THEN
			a_ventil_ausfahren := TRUE;
			a_ventil_einfahren := FALSE;
		END_IF

		IF NOT b_direkttaste_ausfahren AND NOT e_taste_ausfahren THEN
			fb_state_entry.i16_next_step := GESTOPPT;
		END_IF

(*=======================================================*)
	DIREKT_EINFAHREN:
		IF fb_state_entry.E THEN
			a_ventil_ausfahren := FALSE;
			a_ventil_einfahren := TRUE;
		END_IF

		IF NOT b_direkttaste_einfahren AND NOT e_taste_einfahren THEN
			fb_state_entry.i16_next_step := GESTOPPT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := st_sm.b_zeit_ausfahren1;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := st_sm.b_zeit_einfahren1;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := st_sm.b_endlage1;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := st_sm.b_sensor1;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := st_sm.b_zeit_ausfahren2;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := st_sm.b_zeit_einfahren2;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := st_sm.b_endlage2;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := st_sm.b_sensor2;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := st_sm.b_zeit_ausfahren3;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := st_sm.b_zeit_einfahren3;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := st_sm.b_endlage3;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := st_sm.b_sensor3;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := st_sm.b_winkel_ausfahren1;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := st_sm.b_winkel_einfahren1;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := st_sm.b_winkel_ausfahren2;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := st_sm.b_winkel_einfahren2;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := st_sm.b_winkel_ausfahren3;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := st_sm.b_winkel_einfahren3;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := st_sm.b_zyltyp_nicht_definiert;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := st_sm.b_reserve1;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Achsen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION F_Servobandeinzug_Strecke_zu_Grad : LREAL
VAR_INPUT
	strecke	: LREAL;
END_VAR
VAR
	Umfang : LREAL;
END_VAR
(* @END_DECLARATION := '0' *)

Umfang :=  gst_datensatz.st_band.i16_igelrad_zaehne * gst_datensatz.st_band.r_raster;
lr_debug :=  (360.0 * strecke ) / Umfang ;
F_Servobandeinzug_Strecke_zu_Grad := lr_debug;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Achsen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION F_Startpos_Servobandeinzug : LREAL
VAR_INPUT
	r_actual_pos : LREAL:= 1.0;
END_VAR
VAR
	i16_gerundet : INT:= 0;
	startpos : INT := 3;
	i16_grad_pro_zahn : INT := 10;
	r_grad_pro_zahn : LREAL := 10.0;
END_VAR
(* @END_DECLARATION := '0' *)
(* Das Igelrad muss zum Einfädeln an einer bestimmten Gradzahl stehen.
Diese ist abhängig von der größe des Igelrads *)

i16_gerundet := LREAL_TO_INT(r_actual_pos/r_grad_pro_zahn);

F_Startpos_Servobandeinzug := INT_TO_LREAL(i16_gerundet * i16_grad_pro_zahn - gst_datensatz.st_band.i16_startpos_einfaedeln);
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Achsen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Bestueckachse
VAR_INPUT
	st_config_achse						: struct_ecd_config;
	st_ctrl_in								: struct_ctrl_in;
	e_steuerung_ein						: BOOL;
	e_ba_mit_bedingungen				: BOOL;
	e_tuere_vorne_offen					: BOOL;
	e_tuere_hinten_offen					: BOOL;
END_VAR
VAR_IN_OUT
	st_visu								: struct_ecd_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
END_VAR
VAR
	st_sm						 		: struct_ecd_meldungen;
	st_drive_cmd							: struct_ecd_cmd;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_wz_disable						: TON;
	fb_r_trig_tippen						: R_TRIG;
	fb_f_trig_tippen						: F_TRIG;
	fb_r_trig_taste_plus					: R_TRIG;
	fb_r_trig_taste_minus					: R_TRIG;
	fb_r_trig_start							: R_TRIG;
	fb_r_trig_hand_dialog					: R_TRIG;
	fb_r_trig_nullpunkt_setzen				: R_TRIG;
	fb_axis								: ST_AxisJobCtrl_Motion;
	fb_state_entry							: ST_StateEntry;
	fb_ton_uez							: TON;
	i, j									: INT := 0;
	lr_pos_ohneverschiebung			: LREAL;
	st_geschwindigkeiten					: struct_ecd_geschwindigkeiten;
	b_hand_dialog_aktiv					: BOOL := FALSE;
	b_nullnockenmerker					: BOOL := FALSE;

	sm_fehler_initialposition_achse			: BOOL := FALSE;
	sm_keine_nocken_definiert				: BOOL := FALSE;
	sm_fehler_ot_ut						: BOOL := FALSE;

	e_referenz_sensor						AT %I* : BOOL;
	i16_torque							AT %I* : INT;

	fb_ot_ut_ueberwachung				: ST_OT_UT_Ueberwachung;

	lr_decceleration_nothalt				: LREAL;
	lr_decceleration_normal				: LREAL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= ,PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= ,	PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_wz_disable(IN:= , PT:= t#500ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_taste_plus(CLK:= ST_Euchner_Handbedienpult.b_Taste_Plus, Q=> );
fb_r_trig_taste_minus(CLK:= ST_Euchner_Handbedienpult.b_Taste_Minus, Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );
fb_r_trig_hand_dialog(CLK:= b_hand_dialog_aktiv, Q=> );
fb_r_trig_nullpunkt_setzen(CLK:= axis_bestueckachse.st_visu.b_nullpunkt_setzen, Q=> );

(* Achse steuern *)
(* Bestueckachse *)
fb_axis(
	e_referenznocken:= ,
	b_refsensor_vorhanden:= st_config_achse.b_refsensor_vorhanden,
	b_limitsensor_positiv_vorhanden:= st_config_achse.b_limitsensor_positiv_vorhanden,
	b_limitsensor_negativ_vorhanden:= st_config_achse.b_limitsensor_negativ_vorhanden,
	i16_achstyp := st_config_achse.i16_achstyp,
	st_position:= ,
	lr_override_vorgabe:= ST_TippTasten.lr_override,
	mc_richtung_modulo:= ,
	mc_richtung_velocity:= ,
	mc_referenzmodus:= ,
	mc_buffermode_axis:= ,
	ui16_soeparam_write_value:= ,
	w_idn:= ,
	i16_nc_parameter_nummer:= ,
	r_wert_nc_write_parameter:= ,
	st_vorgabe_geschwindigkeiten:= st_geschwindigkeiten,
	lr_soll_geschwindigkeit:=,
	b_bedingung_sls:= NOT e_tuere_vorne_offen OR NOT e_tuere_hinten_offen,
	st_ads_info := ,
	st_eccoe_sdo := ,
	st_masterachse:= bestueckachse,
	st_visu_axis:= st_visu,
	st_ecd_cmd:= st_drive_cmd,
	ui16_soeparam_read_value=> ,
	r_wert_nc_read_parameter=> );

IF gi16_betriebsart <> AUTO THEN
	(* Bausteinaufruf für Kontrolle der korrekten Abfolge von OT zu UT. Nicht für Automatikbetrieb geeignet, da Aufruf in der normalen Task! *)
	fb_ot_ut_ueberwachung(
		lr_achsposition:= bestueckachse.NcToPlc.ModuloActPos,
		b_error=> sm_fehler_ot_ut);
ELSE
	sm_fehler_ot_ut := FALSE;
END_IF

IF gi16_betriebsart = HAND THEN
	(* Achse mit dem Euchner Handbediengerät vorwärts und rückwärts Bewegen*)
	IF fb_r_trig_hand_dialog.Q THEN
		fb_state_entry.i16_next_step := HANDRAD;
	END_IF

	(* Button in der Oberfläche zum setzen des Nullpunktes *)
	IF fb_r_trig_nullpunkt_setzen.Q THEN
		fb_state_entry.i16_next_step :=	NULLPUNKT_SETZEN;
	END_IF
END_IF


(* =======================================Toplevel========================================== *)
(* Starte Inbetriebnahme-Sequenz *)
IF st_ctrl_in.b_gehe_step_ibn THEN
	fb_state_entry.i16_next_step := INBETRIEBNAHME;
END_IF

(* =====Achse wird disabled===== *)
IF (NOT e_steuerung_ein OR NOT e_ba_mit_bedingungen) AND bestueckachse.Status.Operational THEN
	st_drive_cmd.enu_cmd := POWER_DISABLE;
END_IF

IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* =====Fehler vom Achskontroller===== *)
	IF st_drive_cmd.b_job_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF

	IF fb_state_entry.i16_next_step > 45 THEN
		(* Devicefehler *)
		IF bestueckachse.Status.Error THEN
			st_sm.b_achsfehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSIF bestueckachse.Status.DriveDeviceError THEN
			st_sm.b_devicefehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	END_IF

	IF fb_state_entry.i16_next_step < STOP THEN
		(* =====Achse wird gestoppt===== *)
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		ELSIF fb_state_entry.i16_next_step < HALT THEN
			(* =====Achse wird angehalten===== *)
			IF st_ctrl_in.b_halt THEN
				fb_state_entry.i16_next_step := HALT;
			END_IF
		END_IF
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config_achse.b_config_fertig THEN
			fb_state_entry.i16_next_step := 1;
		END_IF

(*=======================================================*)
	1:	(* Warte bis NetID´s der Slaves ausgelesen sind *)
		IF fb_state_entry.E THEN
			;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_EthercatDiag.st_ctrl_out.b_fertig THEN
			fb_state_entry.i16_next_step := 3;
		END_IF

(*=======================================================*)
	3:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			FOR i := 0  TO (SIZEOF (nockenschaltwerk_bestueckachse.fb.arr_spur) / SIZEOF (nockenschaltwerk_bestueckachse.fb.arr_spur[0])) - 1 BY 1DO
				gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[i].b_camvalid := TRUE;
			END_FOR

			fb_axis.i16_nc_parameter_nummer := MaxVelocitySystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_maximalgeschwindigkeit := fb_axis.r_wert_nc_read_parameter(* °/s *) * 60 / 360;
			st_geschwindigkeiten.lr_auto_max := st_geschwindigkeiten.lr_maximalgeschwindigkeit;
			st_geschwindigkeiten.lr_auto_min := 50;
			st_geschwindigkeiten.lr_jog := 100;
			fb_state_entry.i16_next_step := 4;
		END_IF

(*=======================================================*)
	4:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxAccelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_beschleunigung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 5;
		END_IF

(*=======================================================*)
	5:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxDecelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_verzoegerung := fb_axis.r_wert_nc_read_parameter;
			lr_decceleration_normal := st_geschwindigkeiten.lr_verzoegerung;
			lr_decceleration_nothalt := 200000.0;
			fb_state_entry.i16_next_step := 6;
		END_IF

(*=======================================================*)
	6:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxJerk;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_ruck := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 7;
		END_IF

(*=======================================================*)
	7:	(* Konfigurationen der Achse *)
		IF fb_state_entry.E THEN
			fb_axis.st_eccoe_sdo.s_ec_slave_net_id := ST_EthercatDiag.s_ec_slave_net_id[2];
			fb_axis.st_eccoe_sdo.ui16_slave_addr := st_config_achse.ui16_ethercat_adr;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := FEHLER; (*in Fehler gehen damit die Achsen resetet werden. Sonst steigen die Achsen bei einem TC Restart aus*)

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_quitt.IN := FALSE;
			fb_ton_wz_disable.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_prebereit := FALSE;

 			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto;

			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_normal;

			(* Reset Stoermeldungen *)
			st_sm.b_achse_nicht_auf_startpos := FALSE;
			st_sm.b_achsfehler := FALSE;
			st_sm.b_devicefehler := FALSE;
			st_sm.b_keine_verfahrfreigabe := FALSE;
			st_sm.b_ende_skalierungs_nocke := FALSE;
			st_sm.b_ende_camming_nocke := FALSE;
			st_sm.b_skalierung_noch_aktiv := FALSE;

			sm_fehler_initialposition_achse := FALSE;
			sm_keine_nocken_definiert := FALSE;

		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_preinit THEN
			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto;
			fb_state_entry.i16_next_step := 15;
		END_IF

(*=======================================================*)
	15:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;	(* vom Datentyp MC_AxisParameter *)
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 45;	(* Reglerfreigabe setzen *)
			ELSE
				fb_state_entry.i16_next_step := 30;	(* Nullpunktverschiebung schreiben *)
			END_IF
		END_IF
(*
(*=======================================================*)
	25:	(* Überprüfung der Achsposition mit Referenzsensor *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_referenz_sensor THEN
			fb_state_entry.i16_next_step := 30;	(* Achse steht im korrekten Winkelbereich *)
		ELSE
			sm_fehler_initialposition_achse := TRUE;
			fb_state_entry.i16_next_step := FEHLER;	(* Achsposition ist um Vielfache von 72° verschoben *)
		END_IF
*)
(*=======================================================*)
	30:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
		(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 45;
		END_IF

(*=======================================================*)
	45:	(* Reglerfreigabe setzen , Reset wird bei Bedarf automatisch ausgeführt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_prebereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60:	(* Überprüfe, ob überhaupt Nocken angelegt sind *)
		IF fb_state_entry.E THEN
			b_nullnockenmerker := TRUE;
			FOR i := 0  TO 5 BY 1DO
				b_nullnockenmerker :=	b_nullnockenmerker AND
								 	gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[i].r_cam_begin = 0 AND
									gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[i].r_cam_end = 0;
			END_FOR
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF b_nullnockenmerker	THEN
			sm_keine_nocken_definiert := TRUE;
			 fb_state_entry.i16_next_step := FEHLER;
		ELSE
			fb_state_entry.i16_next_step := 70;
		END_IF

(*=======================================================*)
	70: (* Alle Nocken einschalten *)
		IF fb_state_entry.E THEN
			FOR i := 0  TO (SIZEOF (nockenschaltwerk_bestueckachse.fb.arr_spur) / SIZEOF (nockenschaltwerk_bestueckachse.fb.arr_spur[0])) - 1 BY 1DO
				gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[i].b_camvalid := TRUE;
				gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[i].b_eff_direction_neg := TRUE;
				gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[i].b_eff_direction_pos := TRUE;
				gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[i].i16_track_no := i;
			END_FOR
			(* Nachbearbeitung von bestimmten Nocken *)
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_OT].b_eff_direction_neg := FALSE;

			(* Zylinder für Bandeinzug mit Vorsteuerzeit belegen *)
			(* 1700 *)
			CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
				KEIN_EINZUG:
					;

				STANDARD_2FACH_V2:
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_BAEZV2_EINFAHREN].t_vorsteuerzeit := t#16ms;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_BAEZV2_AUSFAHREN].t_vorsteuerzeit := t#16ms;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_BAEZV2_EINFAHREN].t_vorsteuerzeit := t#16ms;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_BAEZV2_AUSFAHREN].t_vorsteuerzeit := t#16ms;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_BAEZV2_EINFAHREN].t_vorsteuerzeit := t#16ms;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_BAEZV2_AUSFAHREN].t_vorsteuerzeit := t#16ms;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_BAEZV2_EINFAHREN].t_vorsteuerzeit := t#16ms;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_BAEZV2_AUSFAHREN].t_vorsteuerzeit := t#16ms;

				BANDWECHSLER_V2:
					(* Bandwechsler V2 ohne Sensoren und anderen Zylindern *)
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_EINFAHREN].t_vorsteuerzeit := t#16ms;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_AUSFAHREN].t_vorsteuerzeit := t#16ms;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_EINFAHREN].t_vorsteuerzeit := t#16ms;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN].t_vorsteuerzeit := t#16ms;

				SERVO:
					;
(*					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_SERVOBANDEINZUG_LUEFTEN].r_cam_begin := 135;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_SERVOBANDEINZUG_LUEFTEN].r_cam_end := 178;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_SERVOBANDEINZUG_GLS].r_cam_begin := 50;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_SERVOBANDEINZUG_GLS].r_cam_end := 100;*)
			END_CASE;

			(*-----------------------Weiterschaltbedingungen----------------------------*)
			fb_state_entry.i16_next_step := 80;
		END_IF

(*=======================================================*)
	80:  (* Auf Startposition fahren *)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700, RASTERFOLIE:
				IF fb_state_entry.E THEN
					st_drive_cmd.enu_cmd := MOVE_MODULO;
					fb_axis.mc_richtung_modulo := MC_Shortest_Way ;
					fb_axis.st_position.r_soll := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
				END_IF

			BESTUECKZELLE_1720:
				IF fb_state_entry.E THEN
					IF bestueckachse.NcToPlc.ModuloActPos > 0 AND bestueckachse.NcToPlc.ModuloActPos < 90 THEN
						fb_axis.mc_richtung_modulo := MC_Shortest_Way ;
					ELSE
						fb_axis.mc_richtung_modulo := MC_Positive_Direction;
					END_IF
					st_drive_cmd.enu_cmd := MOVE_MODULO;
					fb_axis.st_position.r_soll := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
				END_IF
		END_CASE

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 90;
		END_IF

(*=======================================================*)
	90:	(* Finale Überprüfung der Achsposition auf Bereich OT oder UT *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_referenz_sensor AND
			bestueckachse.NcToPlc.ModuloActPos >= 0 AND
			bestueckachse.NcToPlc.ModuloActPos < 71.99 THEN
			fb_state_entry.i16_next_step := BEREIT;	(* Achse steht im korrekten Winkelbereich *)
		ELSE
			sm_fehler_initialposition_achse := TRUE;
			fb_state_entry.i16_next_step := FEHLER;	(* Achsposition ist um Vielfache von 72° verschoben *)
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_drive_cmd.enu_cmd := RESET;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF st_ctrl_in.b_stop AND NOT bestueckachse.Status.HasBeenStopped THEN
			st_drive_cmd.enu_cmd := STOP_AXIS;
		END_IF

		IF st_ctrl_in.b_halt AND bestueckachse.Status.Moving THEN
			st_drive_cmd.enu_cmd := HALT_AXIS;
			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_nothalt;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			IF bestueckachse.NcToPlc.CoupleState = 0 THEN
				st_drive_cmd.enu_cmd := STOP_AXIS;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND AND bestueckachse.Status.NotMoving THEN
			fb_state_entry.i16_next_step := STILLSTAND;
		END_IF

(*=======================================================*)
	STILLSTAND:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HALT:
		IF fb_state_entry.E THEN
			IF bestueckachse.NcToPlc.CoupleState = 0 THEN
				st_drive_cmd.enu_cmd := HALT_AXIS;
				st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_nothalt;
			END_IF
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HANDRAD:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 2040;	(* Jogbetrieb *)
			ELSE
				fb_state_entry.i16_next_step := 2010;	(* Reglerfreigabe nehmen und Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	2010:	(* Reglerfreigabe wegnehmen , damit Nullpunktverschiebung geschrieben werden kannt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2020;
		END_IF

(*=======================================================*)
	2020:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
			(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2030;
		END_IF

(*=======================================================*)
	2030:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2040;
		END_IF

(*=======================================================*)
	2040:	(* Jogbetrieb *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
		END_IF

		IF ST_Euchner_Handbedienpult.i16_Handrad_delta > 0 THEN
			st_drive_cmd.enu_cmd := JOG_VORWAERTS;
		ELSIF ST_Euchner_Handbedienpult.i16_Handrad_delta < 0 THEN
			st_drive_cmd.enu_cmd := JOG_RUECKWAERTS;
		ELSE
			IF bestueckachse.Status.Moving THEN
				st_drive_cmd.enu_cmd := JOG_STOP;
			END_IF
		END_IF

		IF fb_r_trig_taste_plus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_AUF;
		END_IF
		IF fb_r_trig_taste_minus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_ZU;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gi16_betriebsart <> HAND OR NOT b_hand_dialog_aktiv THEN
			fb_state_entry.i16_next_step := 2050;
		END_IF

(*=======================================================*)
	2050:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2060;
		END_IF

(*=======================================================*)
	2060:
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;	(* Motorbremse im Automatikbetrieb für reguläres Fahren *)
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2070;
		END_IF

(*=======================================================*)
	2070:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	MOTORBREMSE_AUF:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2110;
		END_IF

(*=======================================================*)
	2110:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2120;
		END_IF

(*=======================================================*)
	2120:	(* Bremse auf machen *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 2;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND AND
			(gi16_betriebsart <> HAND OR
			NOT b_hand_dialog_aktiv OR
			ST_Euchner_Handbedienpult.i16_Handrad_delta > 0)
			THEN
				fb_state_entry.i16_next_step := HANDRAD;
		ELSIF fb_r_trig_taste_minus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_ZU;
		END_IF

(*=======================================================*)
	MOTORBREMSE_ZU:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2210;
		END_IF

(*=======================================================*)
	2210:	(* Reglerfreigabe setzen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2220;
		END_IF

(*=======================================================*)
	2220:	(* Bremse zu machen *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;	(* Motorbremse im Automatikbetrieb für reguläres Fahren *)
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND AND
			(gi16_betriebsart <> HAND OR
			NOT b_hand_dialog_aktiv OR
			ST_Euchner_Handbedienpult.i16_Handrad_delta > 0)
			THEN
				fb_state_entry.i16_next_step := HANDRAD;
		ELSIF fb_r_trig_taste_plus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_AUF;
		END_IF

(*=======================================================*)
	NULLPUNKT_SETZEN:
		(* Aktuellen Jog beenden, sonst Probleme beim Softwareendschalter*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := JOG_STOP;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2505;
		END_IF

(*=======================================================*)
	2505:
		(* 	Lese aktuelle Nullpunkt verschiebung von der Hardware. Der Benutze könnte einen falschen
			Wert eingetragen haben *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 2510;
		END_IF

(*=======================================================*)
	2510:	(* Nullpunktverschiebung berechnen *)
		IF fb_state_entry.E THEN
			lr_pos_ohneverschiebung := axis_bestueckachse.st_visu.lr_position_ist - gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung;
		
			gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung := - lr_pos_ohneverschiebung;
	
			WHILE (gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung > 360)
			DO
				gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung :=
					gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung - 360;
			END_WHILE
		
			WHILE (gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung < 0)
			DO
				gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung :=
					gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung + 360;
			END_WHILE
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Aktiviere den wert in die Hardware *)
		fb_state_entry.i16_next_step := HANDRAD;

(*=======================================================*)
	INBETRIEBNAHME:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 5100;	(* Reversiersequenz*)
			ELSE
				fb_state_entry.i16_next_step := 5010;	(* Reglerfreigabe nehmen und Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	5010:	(* Reglerfreigabe wegnehmen, damit Nullpunktverschiebung geschrieben werden kannt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5020;
		END_IF

(*=======================================================*)
	5020:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
			(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5030;
		END_IF

(*=======================================================*)
	5030:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_bestueckachse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5100;
		END_IF

(*=======================================================*)
	5100:	(* Verfahren der Achse zwischen zwei Punkten zum Testen verschiedener Achsparameter *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
			fb_axis.st_position.lr_ibn_pos_start := 0.0;
			fb_axis.st_position.lr_ibn_pos_ziel := 180.0;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_ibn_start THEN
			fb_state_entry.i16_next_step := 5110;
		END_IF

(*=======================================================*)
	5110: (* Fahre Bestückachse auf Startposition *)
(*
		IF fb_state_entry.E THEN
			 fb_axis.st_position.r_soll := fb_axis.st_position.lr_ibn_pos_start;
			fb_axis.mc_richtung_modulo :=MC_Positive_Direction ;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5120;
		END_IF
*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			;
		END_IF

(*=======================================================*)
	5120: (* Pause *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#1s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 5130;
		END_IF

(*=======================================================*)
	5130: (* Fahre Bestückachse auf Zielposition *)
		IF fb_state_entry.E THEN
			 fb_axis.st_position.r_soll := fb_axis.st_position.lr_ibn_pos_ziel;
			fb_axis.mc_richtung_modulo :=MC_Negative_Direction ;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5140;
		END_IF

(*=======================================================*)
	5140: (* Pause *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#1s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 5100;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config_achse.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 0] := st_sm.b_achse_nicht_bb;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 1] := st_sm.b_achse_nicht_referenziert;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 2] := st_sm.b_keine_verfahrfreigabe;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 3] := st_sm.b_achse_nicht_auf_startpos;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 4] := st_sm.b_ende_skalierungs_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 5] := st_sm.b_ende_camming_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 6] := st_sm.b_skalierung_noch_aktiv;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 12] := sm_fehler_initialposition_achse;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 13] := sm_keine_nocken_definiert;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 15] := sm_fehler_ot_ut;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 16] := st_drive_cmd.meldungen.sm_write_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 17] := st_drive_cmd.meldungen.sm_read_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 18] := st_drive_cmd.meldungen.sm_write_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 19] := st_drive_cmd.meldungen.sm_read_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 20] := st_drive_cmd.meldungen.sm_power_enable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 21] := st_drive_cmd.meldungen.sm_power_disable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 22] := st_drive_cmd.meldungen.sm_reset;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 23] := st_drive_cmd.meldungen.sm_home;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 24] := st_drive_cmd.meldungen.sm_setposition;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 25] := st_drive_cmd.meldungen.sm_jog_vorwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 26] := st_drive_cmd.meldungen.sm_jog_rueckwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 27] := st_drive_cmd.meldungen.sm_move_absolute;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 28] := st_drive_cmd.meldungen.sm_move_relative;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 29] := st_drive_cmd.meldungen.sm_move_velocity;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 30] := st_drive_cmd.meldungen.sm_move_modulo;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 31] := st_drive_cmd.meldungen.sm_stop_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 32] := st_drive_cmd.meldungen.sm_halt_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 33] := st_drive_cmd.meldungen.sm_motion_command_timeout;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 34] := st_sm.b_achsfehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 35] := st_sm.b_devicefehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 36] := st_drive_cmd.meldungen.sm_limit_positiv_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 37] := st_drive_cmd.meldungen.sm_limit_negativ_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 38] := st_drive_cmd.meldungen.sm_ec_coe_sdo_write_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 39] := st_drive_cmd.meldungen.sm_ec_coe_sdo_read_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 40] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 41] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 42] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 43] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 44] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 45] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 46] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 47] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 48] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 49] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 50] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 51] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 52] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 53] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 54] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 55] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 56] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 57] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 58] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 59] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 60] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 61] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 62] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 63] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 64] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 65] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 66] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 67] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 68] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 69] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 70] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 71] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 72] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 73] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 74] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 75] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 76] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 77] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 78] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 79] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 80] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 81] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 82] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 83] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 84] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 85] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 86] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 87] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 88] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 89] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 90] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 91] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 92] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 93] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 94] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 95] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 96] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 97] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 98] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 99] :=  FALSE;

	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 19] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 20] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 21] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 22] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 23] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 24] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 25] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 26] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 27] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 28] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 29] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 30] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 31] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 32] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 33] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 34] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 35] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 36] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 37] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 38] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 39] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 40] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 41] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 42] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 43] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 44] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 45] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 46] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 47] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 48] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 49] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 50] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 51] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 52] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 53] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 54] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 55] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 56] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 57] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 58] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 59] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 60] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 61] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 62] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 63] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 64] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 65] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 66] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 67] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 68] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 69] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 70] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 71] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 72] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 73] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 74] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 75] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 76] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 77] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 78] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 79] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 80] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 81] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 82] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 83] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 84] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 85] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 86] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 87] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 88] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 89] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 90] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 91] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 92] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 93] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 94] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 95] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 96] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 97] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 98] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 99] :=  FALSE;
END_IF




END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Achsen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_MotionFunctionPoints
VAR_INPUT
	st_ctrl_in								: struct_ctrl_in;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_state_entry						: ST_StateEntry;
	i, j									: INT := 0;
	udi_table_id_bestueckachse			: UDINT := 0;
	arr_motion_function_points		: ARRAY[1..ARRAY_LAENGE_MFP] OF struct_db_motionfunctionpoint;
END_VAR
VAR CONSTANT
	ARRAY_LAENGE_MFP				: INT := 100;
	YZTischMasterPos2					 : LREAL := 125;
	YZTischMasterPos3					 : LREAL := 185;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= ,PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#50ms, Q=> , ET=> );

(* =====Berechnung MFPs===== *)
(* Berechnung von Punkten in einer Kurvenscheibe und der maximalen Mastergeschwindigkeit *)

(* =====Kopplung: Virtuelle Masterachse <-> Z-Achse ===== *)
fb_edit_mfps_bestuecken_z.fb(
	st_config:= fb_edit_mfps_bestuecken_z.st_config,
	st_ctrl_in:= fb_edit_mfps_bestuecken_z.st_ctrl.in,
	udiTableId:= 1,
	eMotionFunctionType:= MOTIONFUNCTYPE_POLYNOM5,
	i16_startpunkt_edit_mf_tab:= 2,
	arr_db_mf_tab:= arr_motion_function_points,
	lrVeloMax:= ST_Z_Achse.st_geschwindigkeiten.lr_maximalgeschwindigkeit,
	lrAccMax:= ST_Z_Achse.st_geschwindigkeiten.lr_beschleunigung,
	lrDecMax:= ST_Z_Achse.st_geschwindigkeiten.lr_verzoegerung,
	lrModuloValue:= 360.0,
	st_AxisRefMaster:= virtuelle_master_achse,
	st_AxisRefSlave:= z_achse,
	lrMasterVeloMax=> ,		(* Maximum Master Velocity [°/s] *)
	lrMasterRotPerMinMax=> ,	(* Maximum Master Rotations per Minute [1/min] *)
	st_ctrl_out=> fb_edit_mfps_bestuecken_z.st_ctrl.out);

(* =====Kopplung: Virtuelle Masterachse <-> Y-Achse ===== *)
fb_edit_mfps_bestuecken_y.fb(
	st_config:= fb_edit_mfps_bestuecken_y.st_config,
	st_ctrl_in:= fb_edit_mfps_bestuecken_y.st_ctrl.in,
	udiTableId:= 3,
	eMotionFunctionType:= MOTIONFUNCTYPE_POLYNOM5,
	i16_startpunkt_edit_mf_tab:= 2,
	arr_db_mf_tab:= arr_motion_function_points,
	lrVeloMax:= ST_Y_Achse.st_geschwindigkeiten.lr_maximalgeschwindigkeit,
	lrAccMax:= ST_Y_Achse.st_geschwindigkeiten.lr_beschleunigung,
	lrDecMax:= ST_Y_Achse.st_geschwindigkeiten.lr_verzoegerung,
	lrModuloValue:= 360.0,
	st_AxisRefMaster:= virtuelle_master_achse,
	st_AxisRefSlave:= y_achse,
	lrMasterVeloMax=> ,		(* Maximum Master Velocity [°/s] *)
	lrMasterRotPerMinMax=> ,	(* Maximum Master Rotations per Minute [1/min] *)
	st_ctrl_out=> fb_edit_mfps_bestuecken_y.st_ctrl.out);

(* =====Kopplung: Virtuelle Masterachse <-> Servobandeinzug-Achse ===== *)
fb_edit_mfps_bestuecken_b.fb(
	st_config:= fb_edit_mfps_bestuecken_b.st_config,
	st_ctrl_in:= fb_edit_mfps_bestuecken_b.st_ctrl.in,
	udiTableId:= 4,
	eMotionFunctionType:= MOTIONFUNCTYPE_POLYNOM5,
	i16_startpunkt_edit_mf_tab:= 2,
	arr_db_mf_tab:= arr_motion_function_points,
	lrVeloMax:= ST_Servobandeinzug.st_geschwindigkeiten.lr_maximalgeschwindigkeit,
	lrAccMax:= ST_Servobandeinzug.st_geschwindigkeiten.lr_beschleunigung,
	lrDecMax:= ST_Servobandeinzug.st_geschwindigkeiten.lr_verzoegerung,
	lrModuloValue:= 360.0,
	st_AxisRefMaster:= bestueckachse,
	st_AxisRefSlave:= b_achse,
	lrMasterVeloMax=> ,		(* Maximum Master Velocity [°/s] *)
	lrMasterRotPerMinMax=> ,	(* Maximum Master Rotations per Minute [1/min] *)
	st_ctrl_out=> fb_edit_mfps_bestuecken_b.st_ctrl.out);

(* =====Kopplung: Z-Achse <-> Y-Achse ===== *)
fb_edit_mfps_yz_tisch.fb(
	st_config:= fb_edit_mfps_yz_tisch.st_config,
	st_ctrl_in:= fb_edit_mfps_yz_tisch.st_ctrl.in,
	udiTableId:= 2,
	eMotionFunctionType:= MOTIONFUNCTYPE_POLYNOM5,
	i16_startpunkt_edit_mf_tab:= 2,
	arr_db_mf_tab:= arr_motion_function_points,
	lrVeloMax:= ST_Y_Achse.st_geschwindigkeiten.lr_maximalgeschwindigkeit,
	lrAccMax:= ST_Y_Achse.st_geschwindigkeiten.lr_beschleunigung,
	lrDecMax:= ST_Y_Achse.st_geschwindigkeiten.lr_verzoegerung,
	lrModuloValue:= 0.0,
	st_AxisRefMaster:= z_achse,
	st_AxisRefSlave:= y_achse,
	lrMasterVeloMax=> ,		(* Maximum Master Velocity [mm/s] *)
	lrMasterRotPerMinMax=> ,	(* Maximum Master Rotations per Minute [1/min] *)
	st_ctrl_out=> fb_edit_mfps_yz_tisch.st_ctrl.out);

(* =====Kopplung: Virtuelle Masterachse <-> Bestueckachse ===== *)
(*
fb_edit_mfps_bestueckachse.fb(
	st_config:= fb_edit_mfps_bestueckachse.st_config,
	st_ctrl_in:= fb_edit_mfps_bestueckachse.st_ctrl.in,
	udiTableId:= udi_table_id_bestueckachse,
	eMotionFunctionType:= MOTIONFUNCTYPE_POLYNOM5,
	i16_startpunkt_edit_mf_tab:= 1,
	arr_db_mf_tab:= gst_datensatz.st_wkz.st_virtmaster_bestueckachse.arr_motion_function_points,
	lrVeloMax:= ST_Bestueckachse.st_geschwindigkeiten.lr_maximalgeschwindigkeit,
	lrAccMax:= ST_Bestueckachse.st_geschwindigkeiten.lr_beschleunigung,
	lrDecMax:= ST_Bestueckachse.st_geschwindigkeiten.lr_verzoegerung,
	lrModuloValue:= 360.0,
	st_AxisRefMaster:= virtuelle_master_achse,
	st_AxisRefSlave:= bestueckachse,
	lrMasterVeloMax=> ,		(* Maximum Master Velocity [°/s] *)
	lrMasterRotPerMinMax=> ,	(* Maximum Master Rotations per Minute [1/min] *)
	st_ctrl_out=> fb_edit_mfps_bestueckachse.st_ctrl.out);
*)
fb_camtable_bestueckachse.fb(
	st_config:= fb_camtable_bestueckachse.st_config,
	st_ctrl_in:= fb_camtable_bestueckachse.st_ctrl.in,
	udiTableId:= udi_table_id_bestueckachse,
	arr_db_mf_tab:= arr_motion_function_points,
	lrModuloValue:= 360,
	st_AxisRefMaster:= virtuelle_master_achse,
	st_AxisRefSlave:= bestueckachse,
	st_ctrl_out=> fb_camtable_bestueckachse.st_ctrl.out);

(* =======================================Toplevel========================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* =====Fehler MFP-Berechnung===== *)
	IF 	fb_edit_mfps_bestuecken_z.st_ctrl.out.b_fehler OR
		fb_edit_mfps_bestuecken_y.st_ctrl.out.b_fehler OR
		fb_edit_mfps_bestuecken_b.st_ctrl.out.b_fehler OR
		fb_edit_mfps_yz_tisch.st_ctrl.out.b_fehler OR
		fb_camtable_bestueckachse.st_ctrl.out.b_fehler
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF

	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
	INIT_OBJ:
		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_bereit := FALSE;

			fb_edit_mfps_bestuecken_z.st_ctrl.in.b_start := FALSE;
			fb_edit_mfps_bestuecken_y.st_ctrl.in.b_start := FALSE;
			fb_edit_mfps_bestuecken_b.st_ctrl.in.b_start := FALSE;
			fb_edit_mfps_yz_tisch.st_ctrl.in.b_start := FALSE;
			fb_camtable_bestueckachse.st_ctrl.in.b_start := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_edit_mfps_bestuecken_z.st_ctrl.in.b_quitt := FALSE;
			fb_edit_mfps_bestuecken_y.st_ctrl.in.b_quitt := FALSE;
			fb_edit_mfps_bestuecken_b.st_ctrl.in.b_quitt := FALSE;
			fb_edit_mfps_yz_tisch.st_ctrl.in.b_quitt := FALSE;
			fb_camtable_bestueckachse.st_ctrl.in.b_quitt := FALSE;

			CASE gst_datensatz.st_md.i16_typ_zelle OF
				KEINE_ZELLE:
					;

				BESTUECKZELLE_1700:
					fb_state_entry.i16_next_step := 20;

				BESTUECKZELLE_1720:
					fb_state_entry.i16_next_step := 40;

				RASTERFOLIE:
					fb_state_entry.i16_next_step := 50;
			END_CASE
		END_IF

(*===========================MFP berechnen============================*)
	20:	(* Initialisierung der Kurvenscheibenwerte für Bestückachse-ZAchse aus der DB -> grundlegende Definition der Motionfunktion *)
		(* 1700 *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe Best-Z-Achse *)
			subr_ST_MFP_Z_Achse();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_edit_mfps_bestuecken_z.fb.st_ctrl_out.b_fertig AND NOT fb_state_entry.E THEN
			fb_edit_mfps_bestuecken_z.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 21;
		END_IF

(*=======================================================*)
	21:	(* 1700 *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe Best-Y-Achse *)
			subr_ST_MFP_Y_Achse();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_edit_mfps_bestuecken_y.fb.st_ctrl_out.b_fertig AND NOT fb_state_entry.E THEN
			fb_edit_mfps_bestuecken_y.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 22;
		END_IF

(*=======================================================*)
	22:	(* 1700 *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe Y-Z-Tisch *)
			subr_ST_MFP_YZ_Tisch();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_edit_mfps_yz_tisch.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			fb_edit_mfps_yz_tisch.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 23;
		END_IF

(*=======================================================*)
	23:	(* 1700 *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe mit Scalierung 1 Virtuelle Masterachse - Bestückachse *)
			subr_ST_MFP_Bestueckachse_S1();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_camtable_bestueckachse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			fb_camtable_bestueckachse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 24;
		END_IF

(*=======================================================*)
	24:	(* 1700 *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe mit Scalierung 0 Virtuelle Masterachse - Bestückachse *)
			subr_ST_MFP_Bestueckachse_S0();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_camtable_bestueckachse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			fb_camtable_bestueckachse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 25;
		END_IF

(*=======================================================*)
	25:	(* 1700 *)
		IF fb_state_entry.E THEN
			CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
				BANDWECHSLER_V2:
					fb_state_entry.i16_next_step := BEREIT;
				SERVO:
					(* Kurvenscheibe Best-Servobandeinzug-Achse *)
					subr_ST_MFP_B_Achse();
			END_CASE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_edit_mfps_bestuecken_b.fb.st_ctrl_out.b_fertig AND NOT fb_state_entry.E THEN
			fb_edit_mfps_bestuecken_b.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	30:	(* Initialisierung der Kurvenscheibenwerte für Bestückachse-ZAchse aus der DB -> grundlegende Definition der Motionfunktion *)
		(* RASTERPLATTE *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe Y-Z-Tisch *)
			subr_ST_MFP_YZ_Tisch();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_edit_mfps_yz_tisch.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			fb_edit_mfps_yz_tisch.st_ctrl.in.b_start := TRUE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	40:	(* Initialisierung der Kurvenscheibenwerte für Bestückachse-ZAchse aus der DB -> grundlegende Definition der Motionfunktion *)
		(* 1720 *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe Best-Z-Achse *)
			FOR i := 1 TO ARRAY_LAENGE_MFP BY 1DO
				arr_motion_function_points[i].PointIndex := i;
				arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_NOTDEF;
				arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_IGNORE;
				arr_motion_function_points[i].MasterPos := 0.0;
				arr_motion_function_points[i].SlavePos := 0.0;
			END_FOR
			FOR i := 1 TO 4 BY 1DO
				arr_motion_function_points[i].PointIndex := i;
				arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_POLYNOM1;
				arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_VELOCITY;
			END_FOR
			arr_motion_function_points[2].FunctionType := MOTIONFUNCTYPE_POLYNOM5_MM;
			arr_motion_function_points[1].MasterPos := 0.0;
			arr_motion_function_points[1].SlavePos := 0.0;
			arr_motion_function_points[2].MasterPos := 250;
			arr_motion_function_points[2].SlavePos := 0.0;
			arr_motion_function_points[3].MasterPos := 340;
			arr_motion_function_points[3].SlavePos := 1;
			arr_motion_function_points[4].MasterPos := 360;
			arr_motion_function_points[4].SlavePos := 1;
			fb_edit_mfps_bestuecken_z.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_edit_mfps_bestuecken_z.fb.st_ctrl_out.b_fertig AND NOT fb_state_entry.E THEN
			fb_edit_mfps_bestuecken_z.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 41;
		END_IF

(*=======================================================*)
	41:	(* 1720 *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe mit Scalierung 1 Virtuelle Masterachse - Bestückachse *)
			subr_ST_MFP_Bestueckachse_S1();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_camtable_bestueckachse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			fb_camtable_bestueckachse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 42;
		END_IF

(*=======================================================*)
	42:	(* 1720 *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe mit Scalierung 0 Virtuelle Masterachse - Bestückachse *)
			subr_ST_MFP_Bestueckachse_S0();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_camtable_bestueckachse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			fb_camtable_bestueckachse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	50:	(* Rasterfolie *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe Best-Z-Achse *)
			subr_ST_MFP_Z_Achse();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_edit_mfps_bestuecken_z.fb.st_ctrl_out.b_fertig AND NOT fb_state_entry.E THEN
			fb_edit_mfps_bestuecken_z.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 51;
		END_IF

(*=======================================================*)
	51:	(* Rasterfolie *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe Best-Y-Achse *)
			subr_ST_MFP_Y_Achse();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_edit_mfps_bestuecken_y.fb.st_ctrl_out.b_fertig AND NOT fb_state_entry.E THEN
			fb_edit_mfps_bestuecken_y.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 52;
		END_IF

(*=======================================================*)
	52:	(* Rasterfolie *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe Y-Z-Tisch *)
			FOR i := 1 TO ARRAY_LAENGE_MFP BY 1DO
				arr_motion_function_points[i].PointIndex := i;
				arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_NOTDEF;
				arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_IGNORE;
				arr_motion_function_points[i].MasterPos := 0.0;
				arr_motion_function_points[i].SlavePos := 0.0;
			END_FOR
			FOR i := 1 TO 4 BY 1DO
				arr_motion_function_points[i].PointIndex := i;
				arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_POLYNOM1;
				arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_VELOCITY;
			END_FOR
			arr_motion_function_points[2].FunctionType := MOTIONFUNCTYPE_POLYNOM5_MM;
			arr_motion_function_points[1].MasterPos := -115;
			arr_motion_function_points[1].SlavePos := gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_y;
			arr_motion_function_points[2].MasterPos := gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_z;
			arr_motion_function_points[2].SlavePos := gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_y;
			arr_motion_function_points[3].MasterPos := 175;
			arr_motion_function_points[3].SlavePos := gst_datensatz.st_md.st_md_y_achse.lr_wt_uebergabepos;
			arr_motion_function_points[4].MasterPos := 200;
			arr_motion_function_points[4].SlavePos := gst_datensatz.st_md.st_md_y_achse.lr_wt_uebergabepos;
			fb_edit_mfps_yz_tisch.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_edit_mfps_yz_tisch.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			fb_edit_mfps_yz_tisch.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 53;
		END_IF

(*=======================================================*)
	53:	(* Rasterfolie *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe mit Scalierung 1 Virtuelle Masterachse - Bestückachse *)
			subr_ST_MFP_Bestueckachse_S1();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_camtable_bestueckachse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			fb_camtable_bestueckachse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 54;
		END_IF

(*=======================================================*)
	54:	(* Rasterfolie *)
		IF fb_state_entry.E THEN
			(* Kurvenscheibe mit Scalierung 0 Virtuelle Masterachse - Bestückachse *)
			subr_ST_MFP_Bestueckachse_S0();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_camtable_bestueckachse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			fb_camtable_bestueckachse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			fb_edit_mfps_bestuecken_z.st_ctrl.in.b_quitt := FALSE;
			fb_edit_mfps_bestuecken_y.st_ctrl.in.b_quitt := FALSE;
			fb_edit_mfps_bestuecken_b.st_ctrl.in.b_quitt := FALSE;
			fb_edit_mfps_yz_tisch.st_ctrl.in.b_quitt := FALSE;
			fb_camtable_bestueckachse.st_ctrl.in.b_quitt := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
			fb_edit_mfps_bestuecken_z.st_ctrl.in.b_quitt := TRUE;
			fb_edit_mfps_bestuecken_y.st_ctrl.in.b_quitt := TRUE;
			fb_edit_mfps_bestuecken_b.st_ctrl.in.b_quitt := TRUE;
			fb_edit_mfps_yz_tisch.st_ctrl.in.b_quitt := TRUE;
			fb_camtable_bestueckachse.st_ctrl.in.b_quitt := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			fb_edit_mfps_bestuecken_z.st_ctrl.in.b_quitt := FALSE;
			fb_edit_mfps_bestuecken_y.st_ctrl.in.b_quitt := FALSE;
			fb_edit_mfps_bestuecken_b.st_ctrl.in.b_quitt := FALSE;
			fb_edit_mfps_yz_tisch.st_ctrl.in.b_quitt := FALSE;
			fb_camtable_bestueckachse.st_ctrl.in.b_quitt := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			fb_edit_mfps_bestuecken_z.st_ctrl.in.b_quitt := TRUE;
			fb_edit_mfps_bestuecken_y.st_ctrl.in.b_quitt := TRUE;
			fb_edit_mfps_bestuecken_b.st_ctrl.in.b_quitt := TRUE;
			fb_edit_mfps_yz_tisch.st_ctrl.in.b_quitt := TRUE;
			fb_camtable_bestueckachse.st_ctrl.in.b_quitt := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

END_PROGRAM
ACTION	subr_ST_MFP_B_Achse:
(* Kurvenscheibe Best-Servobandeinzug-Achse *)
FOR i := 1 TO ARRAY_LAENGE_MFP BY 1DO
	arr_motion_function_points[i].PointIndex := i;
	arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_NOTDEF;
	arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_IGNORE;
	arr_motion_function_points[i].MasterPos := 0.0;
	arr_motion_function_points[i].SlavePos := 0.0;
END_FOR
FOR i := 1 TO 5 BY 1DO
	arr_motion_function_points[i].PointIndex := i;
	arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_POLYNOM1;
	arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_VELOCITY;
END_FOR
arr_motion_function_points[2].FunctionType := MOTIONFUNCTYPE_POLYNOM5_MM;
arr_motion_function_points[1].MasterPos := 0.0;
arr_motion_function_points[1].SlavePos := 0.0;
arr_motion_function_points[2].MasterPos := 50;
arr_motion_function_points[2].SlavePos := 0.0;
arr_motion_function_points[3].MasterPos := 100;
arr_motion_function_points[3].SlavePos := 1;
arr_motion_function_points[4].MasterPos := 200;
arr_motion_function_points[4].SlavePos := 1;
arr_motion_function_points[5].MasterPos := 360;
arr_motion_function_points[5].SlavePos := 1;
fb_edit_mfps_bestuecken_b.st_ctrl.in.b_start := TRUE;
END_ACTION

ACTION	subr_ST_MFP_Bestueckachse_S0:
(* Kurvenscheibe mit Scalierung 0 Virtuelle Masterachse - Bestückachse *)
udi_table_id_bestueckachse := 6;
FOR i := 1 TO ARRAY_LAENGE_MFP BY 1DO
	arr_motion_function_points[i].PointIndex := i;
	arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_NOTDEF;
	arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_IGNORE;
	arr_motion_function_points[i].MasterPos := 0.0;
	arr_motion_function_points[i].SlavePos := 0.0;
END_FOR
FOR i := 1 TO 2 BY 1DO
	arr_motion_function_points[i].PointIndex := i;
	arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_POLYNOM1;
	arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_VELOCITY;
END_FOR
arr_motion_function_points[1].MasterPos := 0;
arr_motion_function_points[1].SlavePos := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
arr_motion_function_points[2].MasterPos := 360;
arr_motion_function_points[2].SlavePos := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
fb_camtable_bestueckachse.st_ctrl.in.b_start := TRUE;
END_ACTION

ACTION	subr_ST_MFP_Bestueckachse_S1:
(* Kurvenscheibe mit Scalierung 1 Virtuelle Masterachse - Bestückachse *)
udi_table_id_bestueckachse := 5;
FOR i := 1 TO ARRAY_LAENGE_MFP BY 1DO
	arr_motion_function_points[i].PointIndex := i;
	arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_NOTDEF;
	arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_IGNORE;
	arr_motion_function_points[i].MasterPos := 0.0;
	arr_motion_function_points[i].SlavePos := 0.0;
END_FOR
FOR i := 1 TO 2 BY 1DO
	arr_motion_function_points[i].PointIndex := i;
	arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_POLYNOM1;
	arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_VELOCITY;
END_FOR
arr_motion_function_points[1].MasterPos := 0;
arr_motion_function_points[1].SlavePos := 0;
arr_motion_function_points[2].MasterPos := 360;
arr_motion_function_points[2].SlavePos := 360;
fb_camtable_bestueckachse.st_ctrl.in.b_start := TRUE;
END_ACTION

ACTION	subr_ST_MFP_Y_Achse:
(* Kurvenscheibe Best-Y-Achse *)
FOR i := 1 TO ARRAY_LAENGE_MFP BY 1DO
	arr_motion_function_points[i].PointIndex := i;
	arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_NOTDEF;
	arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_IGNORE;
	arr_motion_function_points[i].MasterPos := 0.0;
	arr_motion_function_points[i].SlavePos := 0.0;
END_FOR
FOR i := 1 TO 4 BY 1DO
	arr_motion_function_points[i].PointIndex := i;
	arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_POLYNOM1;
	arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_VELOCITY;
END_FOR
arr_motion_function_points[2].FunctionType := MOTIONFUNCTYPE_POLYNOM5_MM;
arr_motion_function_points[1].MasterPos := 0.0;
arr_motion_function_points[1].SlavePos := 0.0;
arr_motion_function_points[2].MasterPos := 40;
arr_motion_function_points[2].SlavePos := 0.0;
arr_motion_function_points[3].MasterPos := 260;
arr_motion_function_points[3].SlavePos := 1;
arr_motion_function_points[4].MasterPos := 360;
arr_motion_function_points[4].SlavePos := 1;
fb_edit_mfps_bestuecken_y.st_ctrl.in.b_start := TRUE;


END_ACTION

ACTION	subr_ST_MFP_YZ_Tisch:
(* Kurvenscheibe Y-Z-Tisch *)


	CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
					;

			BESTUECKZELLE_1700, BESTUECKZELLE_1720, RASTERFOLIE:

				FOR i := 1 TO ARRAY_LAENGE_MFP BY 1DO
					arr_motion_function_points[i].PointIndex := i;
					arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_NOTDEF;
					arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_IGNORE;
					arr_motion_function_points[i].MasterPos := 0.0;
					arr_motion_function_points[i].SlavePos := 0.0;
				END_FOR
				FOR i := 1 TO 4 BY 1DO
					arr_motion_function_points[i].PointIndex := i;
					arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_POLYNOM1;
					arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_VELOCITY;
				END_FOR

				IF gst_datensatz.st_wkz.b_variable_einfahrposition THEN
					arr_motion_function_points[2].FunctionType := MOTIONFUNCTYPE_POLYNOM5_MM;
					arr_motion_function_points[1].MasterPos := -115;
					arr_motion_function_points[1].SlavePos := gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_y;
					arr_motion_function_points[2].MasterPos :=gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_z;
					arr_motion_function_points[2].SlavePos := gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_y;
					arr_motion_function_points[3].MasterPos := YZTischMasterPos3;
					arr_motion_function_points[3].SlavePos := gst_datensatz.st_md.st_md_y_achse.lr_wt_uebergabepos;
					arr_motion_function_points[4].MasterPos := 200;
					arr_motion_function_points[4].SlavePos := gst_datensatz.st_md.st_md_y_achse.lr_wt_uebergabepos;
				ELSE
					arr_motion_function_points[2].FunctionType := MOTIONFUNCTYPE_POLYNOM5_MM;
					arr_motion_function_points[1].MasterPos := -115;
					arr_motion_function_points[1].SlavePos := gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_y;
					arr_motion_function_points[2].MasterPos := YZTischMasterPos2;
					arr_motion_function_points[2].SlavePos := gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_y;
					arr_motion_function_points[3].MasterPos := YZTischMasterPos3;
					arr_motion_function_points[3].SlavePos := gst_datensatz.st_md.st_md_y_achse.lr_wt_uebergabepos;
					arr_motion_function_points[4].MasterPos := 200;
					arr_motion_function_points[4].SlavePos := gst_datensatz.st_md.st_md_y_achse.lr_wt_uebergabepos;
				END_IF
				fb_edit_mfps_yz_tisch.st_ctrl.in.b_start := TRUE;


	END_CASE

END_ACTION

ACTION	subr_ST_MFP_Z_Achse:
(* Kurvenscheibe Best-Z-Achse *)
FOR i := 1 TO ARRAY_LAENGE_MFP BY 1DO
	arr_motion_function_points[i].PointIndex := i;
	arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_NOTDEF;
	arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_IGNORE;
	arr_motion_function_points[i].MasterPos := 0.0;
	arr_motion_function_points[i].SlavePos := 0.0;
END_FOR
FOR i := 1 TO 4 BY 1DO
	arr_motion_function_points[i].PointIndex := i;
	arr_motion_function_points[i].FunctionType := MOTIONFUNCTYPE_POLYNOM1;
	arr_motion_function_points[i].PointType := MOTIONPOINTTYPE_VELOCITY;
END_FOR
arr_motion_function_points[2].FunctionType := MOTIONFUNCTYPE_POLYNOM5_MM;
arr_motion_function_points[1].MasterPos := 0.0;
arr_motion_function_points[1].SlavePos := 0.0;
arr_motion_function_points[2].MasterPos := 40;
arr_motion_function_points[2].SlavePos := 0.0;
arr_motion_function_points[3].MasterPos := 260;
arr_motion_function_points[3].SlavePos := 1;
arr_motion_function_points[4].MasterPos := 360;
arr_motion_function_points[4].SlavePos := 1;
fb_edit_mfps_bestuecken_z.st_ctrl.in.b_start := TRUE;


END_ACTION









(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Achsen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Servobandeinzug
VAR_INPUT
	st_config_achse						: struct_ecd_config;
	st_ctrl_in								: struct_ctrl_in;
	e_steuerung_ein						: BOOL;
	e_ba_mit_bedingungen				: BOOL;
	e_tuere_vorne_offen					: BOOL;
	e_tuere_hinten_offen					: BOOL;
	i_Stromlimit							: INT;		(* Werte zwischen 0 und 1000 möglich*)
END_VAR
VAR_IN_OUT
	st_visu								: struct_ecd_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
END_VAR
VAR
	st_sm						 		: struct_ecd_meldungen;
	st_drive_cmd							: struct_ecd_cmd;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_r_trig_taste_plus					: R_TRIG;
	fb_r_trig_taste_minus					: R_TRIG;
	fb_r_trig_bremse						: R_TRIG;
	fb_r_trig_tippen						: R_TRIG;
	fb_r_trig_hand_dialog					: R_TRIG;
	fb_axis								: ST_AxisJobCtrl_Motion;
	fb_state_entry							: ST_StateEntry;
	fb_ton_uez							: TON;
	b_ibn_start							: BOOL := FALSE;
	fb_r_trig_ibn_start						: R_TRIG;
	fb_ton_ibn_start						: TON;
	fb_ton_wz_rueckzug					: TON;
	fb_tof_gls_ref							: TOF;
	fb_r_trig_gls_ref						: R_TRIG;
	fb_ton_wz_disable						: TON;
	fb_ton_wz_param						: TON;
	i									: UINT := 0;
	fb_r_trig_limit_sensor_positiv			: R_TRIG;
	fb_r_trig_limit_sensor_negativ			: R_TRIG;
	fb_r_trig_achse_lueften					: R_TRIG;
	b_referenzieren						: BOOL := FALSE;

	b_hand_dialog_aktiv					: BOOL := FALSE;
	st_geschwindigkeiten					: struct_ecd_geschwindigkeiten;
	i_zaehler_steigende_flanke				: INT;	(* Zähler für Bandvorschubkontrolle Gabellichtschranke *)
	i_zaehler_fallende_flanke				: INT;	(* Zähler für Bandvorschubkontrolle Gabellichtschranke *)
	fb_r_trig_vorschubkontrolle				: R_TRIG;
	fb_f_trig_vorschubkontrolle				: F_TRIG;
	fb_r_trig_nocke_einzug					: R_TRIG;
	fb_f_trig_nocke_einzug					: F_TRIG;
	i16_max_torque						: INT := 1000;
	i16_lueft_torque						: INT := 2;	(* sehr klein, damit sich Band ausrichten kann und Servo nicht dagegen arbeitet *)
	i16_man_einfaedel_torque				: INT := 30;
	i16_auto_einfaedel_torque				: INT := 150;
	i16_einfaedel_torque					: INT := 20;
	i16_block_torque						: INT := 40;
	lr_rueckzugposition					: LREAL := 0.5;
	b_merker_bremse						: BOOL := FALSE;
	b_merker_bremse_auf_zu				: BOOL := FALSE;
	r_raster_alt							: REAL := 0.0;
	i16_raster_nc_parameter				: INT := 0;
	b_merker_lueften						: BOOL := FALSE;
	b_merker_regeln						: BOOL := FALSE;

	err_id								: DWORD := 0;

	mc_set_cam_online_change_mode		: MC_SetCamOnlineChangeMode;

	lr_posmerker_an_faenger				: LREAL := 0;

	sm_bandrueckzug						: BOOL := FALSE;
	sm_bandreferenzieren					: BOOL := FALSE;
	sm_fehler_bandvorschub				: BOOL := FALSE;
	sm_fehler_raster						: BOOL := FALSE;
	sm_fehler_bandeinfaedeln				: BOOL := FALSE;
	sm_fahren_auf_gls					: BOOL := FALSE;
	sm_band_rausgezogen				: BOOL := FALSE;
	sm_band_nicht_in_lichtschranke			: BOOL := FALSE;

	e_limit_sensor_positive				AT %I* : BOOL;
	e_limit_sensor_negative				AT %I* : BOOL;
	e_gls_bandreferenzieren				AT %I* : BOOL;	(* Sensor dient auch als Vorschubkontrolle *)
	i16_torque							AT %I* : INT;
	i16_vorgabe_stromlimit					AT %Q* : INT;

	i16_debug 							: INT;

	(* Lueften *)
	fb_r_trig_bandeinzug_lueften			: R_TRIG;

	lr_merker_pos_vor_lueften				: LREAL := 0.0;
	lr_merker_pos_nach_lueften			: LREAL := 0.0;
	lr_merker_pos_diff_lueften				: LREAL := 0.0;

	lr_startpos							: LREAL := 0;

END_VAR

VAR CONSTANT
	lr_konst_strecke_ls_bandeinzug			: LREAL := 70;
	lr_max_strecke_gls_wkz				: LREAL := 110;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_wz_rueckzug(IN:= , PT:= t#300ms, Q=> , ET=> );
fb_tof_gls_ref(IN:= e_gls_bandreferenzieren, PT:= t#150ms, Q=>  , ET=> );
fb_ton_wz_disable(IN:= , PT:= t#500ms, Q=> , ET=> );
fb_ton_wz_param(IN:= , PT:= t#500ms, Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );


(* Flanken *)
fb_r_trig_limit_sensor_positiv(CLK:= st_config_achse.b_limitsensor_positiv_vorhanden AND NOT e_limit_sensor_positive, Q=> );
fb_r_trig_limit_sensor_negativ(CLK:= st_config_achse.b_limitsensor_negativ_vorhanden AND NOT e_limit_sensor_negative, Q=> );
fb_r_trig_taste_plus(CLK:= ST_Euchner_Handbedienpult.b_Taste_Plus, Q=> );
fb_r_trig_taste_minus(CLK:= ST_Euchner_Handbedienpult.b_Taste_Minus, Q=> );
fb_r_trig_bremse(CLK:= visu_hinten.out.ST_Servobandeinzug.b_taste_bremse, Q=> );
fb_r_trig_tippen(CLK:= visu_hinten.out.ST_Servobandeinzug.b_taste_tippen, Q=> );
fb_r_trig_gls_ref(CLK:= e_gls_bandreferenzieren, Q=> );
fb_r_trig_vorschubkontrolle(CLK:= e_gls_bandreferenzieren, Q=> );
fb_f_trig_vorschubkontrolle(CLK:= e_gls_bandreferenzieren, Q=> );

fb_r_trig_hand_dialog(CLK:= b_hand_dialog_aktiv, Q=> );

fb_f_trig_nocke_einzug(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_SERVOBANDEINZUG_GLS], Q=> );
fb_r_trig_nocke_einzug(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_SERVOBANDEINZUG_GLS], Q=> );

(* Inbetriebnahme *)
fb_r_trig_ibn_start (CLK:= b_ibn_start , Q=> );
fb_ton_ibn_start (IN:= , PT:= t#1s, Q=> , ET=> );

i16_debug := fb_state_entry.i16_step;

IF fb_r_trig_ibn_start .Q THEN
	fb_ton_ibn_start .IN := TRUE;
ELSE
	IF fb_ton_ibn_start .Q THEN
		b_ibn_start  := FALSE;
	 	fb_ton_ibn_start .IN := FALSE;
	END_IF
END_IF

(* Vorgabewert an Regler übergeben*)
i16_vorgabe_stromlimit := i_Stromlimit;

(* Achse steuern *)
IF fb_state_entry.i16_step >= 500 AND fb_state_entry.i16_step < 700 THEN
	fb_axis.lr_override_vorgabe := 3.0;
ELSIF fb_state_entry.i16_step >= 700 AND fb_state_entry.i16_step < 800 THEN
	fb_axis.lr_override_vorgabe := 25.0;
ELSE
	fb_axis.lr_override_vorgabe := ST_TippTasten.lr_override;
END_IF

fb_axis(
	e_referenznocken:= ,
	b_refsensor_vorhanden:= st_config_achse.b_refsensor_vorhanden,
	b_limitsensor_positiv_vorhanden:= st_config_achse.b_limitsensor_positiv_vorhanden,
	b_limitsensor_negativ_vorhanden:= st_config_achse.b_limitsensor_negativ_vorhanden,
	i16_achstyp := st_config_achse.i16_achstyp,
	st_position:= ,
	lr_override_vorgabe:= ,
	mc_richtung_modulo:= ,
	mc_richtung_velocity:= ,
	mc_referenzmodus:= ,
	mc_buffermode_axis:= ,
	ui16_soeparam_write_value:= ,
	w_idn:= ,
	i16_nc_parameter_nummer:= ,
	r_wert_nc_write_parameter:= ,
	st_vorgabe_geschwindigkeiten:= st_geschwindigkeiten,
	lr_soll_geschwindigkeit:=,
	b_bedingung_sls:= NOT e_tuere_vorne_offen OR NOT e_tuere_hinten_offen,
	st_ads_info := ,
	st_eccoe_sdo := ,
	st_masterachse:= b_achse,
	st_visu_axis:= st_visu,
	st_ecd_cmd:= st_drive_cmd,
	ui16_soeparam_read_value=> ,
	r_wert_nc_read_parameter=> );

(* Achse mit dem Euchner Handbediengerät vorwärts und rückwärts Bewegen*)
IF ST_Betriebsarten.i16_betriebsart = HAND AND fb_r_trig_hand_dialog.Q THEN
	fb_state_entry.i16_next_step := HANDRAD;
END_IF

(* Visualisierung des Bremsenzustandes am Backpanel *)
IF fb_axis.ui16_soeparam_write_value = 0 THEN
	 visu_hinten.in.b_zustand_bremse := FALSE;
ELSIF fb_axis.ui16_soeparam_write_value = 2 THEN
	 visu_hinten.in.b_zustand_bremse := TRUE;
END_IF

(* Motorbremse von Hand am Backpanel öffnen *)
IF fb_r_trig_bremse.Q THEN
	fb_ton_wz_disable.IN := FALSE;
	fb_ton_wz_param.IN := FALSE;
	b_merker_bremse := TRUE;
END_IF

IF b_merker_bremse THEN
	(* Reglerfreigabe wegnehmen/setzen und Motorbremse auf/zu *)
	IF NOT fb_ton_wz_disable.IN AND NOT fb_ton_wz_param.IN THEN
		IF b_merker_bremse_auf_zu THEN
			(* Bremse ZU *)
			st_drive_cmd.enu_cmd := POWER_ENABLE;
			fb_axis.ui16_soeparam_write_value := 0;
			b_merker_bremse_auf_zu := FALSE;
		ELSE
			(* Bremse AUF *)
			st_drive_cmd.enu_cmd := POWER_DISABLE;
			fb_axis.ui16_soeparam_write_value := 2;
			b_merker_bremse_auf_zu := TRUE;
		END_IF
		fb_ton_wz_disable.IN := TRUE;
	END_IF

	IF fb_ton_wz_disable.Q AND st_drive_cmd.enu_cmd = NO_COMMAND THEN
		fb_axis.w_idn := P_0_IDN + 96;
		st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		fb_ton_wz_disable.IN := FALSE;
		fb_ton_wz_param.IN := TRUE;
	END_IF

	IF fb_ton_wz_param.Q AND st_drive_cmd.enu_cmd = NO_COMMAND THEN
		fb_ton_wz_param.IN := FALSE;
		b_merker_bremse := FALSE;
	END_IF
END_IF

(* Vorschubkontrolle des Bandes *)
IF fb_state_entry.i16_next_step >= BEREIT AND fb_state_entry.i16_next_step < 400 THEN
	subr_ST_Vorschubkontrolle();
END_IF

(* =======================================Toplevel========================================== *)
(* Starte Inbetriebnahme-Sequenz *)
IF st_ctrl_in.b_gehe_step_ibn THEN
	fb_state_entry.i16_next_step := INBETRIEBNAHME;
END_IF

IF (NOT e_steuerung_ein OR NOT e_ba_mit_bedingungen) AND y_achse.Status.Operational THEN
	st_drive_cmd.enu_cmd := POWER_DISABLE;
END_IF

IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* =====Fehler vom Achskontroller===== *)
	IF st_drive_cmd.b_job_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF

	IF fb_state_entry.i16_next_step > 70 THEN
		(* Devicefehler *)
		IF b_achse.Status.Error THEN
			st_sm.b_achsfehler := TRUE;
			(*  Bei einem Achsfehler des Servomotors wird das Drehmoment weggeschalten, um ein Zerstören des Igelrads zu vermeiden. *)
			i_Stromlimit := i16_lueft_torque;
			fb_state_entry.i16_next_step := FEHLER;
		ELSIF b_achse.Status.DriveDeviceError THEN
			st_sm.b_devicefehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	END_IF

	IF fb_state_entry.i16_next_step < STOP THEN
		(* =====Achse wird gestoppt===== *)
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		ELSIF fb_state_entry.i16_next_step < HALT THEN
			(* =====Achse wird angehalten===== *)
			IF st_ctrl_in.b_halt THEN
				fb_state_entry.i16_next_step := HALT;
			END_IF
		END_IF
	END_IF
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config_achse.b_config_fertig THEN
			fb_state_entry.i16_next_step := 1;
		END_IF

(*=======================================================*)
	1:	(* Warte bis NetID´s der Slaves ausgelesen sind *)
		IF fb_state_entry.E THEN
			;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_EthercatDiag.st_ctrl_out.b_fertig THEN
			fb_state_entry.i16_next_step := 2;
		END_IF

(*=======================================================*)
	2:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxVelocitySystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_auto_max := fb_axis.r_wert_nc_read_parameter;
			st_geschwindigkeiten.lr_maximalgeschwindigkeit := fb_axis.r_wert_nc_read_parameter;
			st_geschwindigkeiten.lr_auto_min := 1;
			st_geschwindigkeiten.lr_jog := 50;
			fb_state_entry.i16_next_step := 3;
		END_IF

(*=======================================================*)
	3:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxAccelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_beschleunigung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 4;
		END_IF

(*=======================================================*)
	4:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxDecelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_verzoegerung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 5;
		END_IF

(*=======================================================*)
	5:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxJerk;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_ruck := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 6;
		END_IF

(*=======================================================*)
	6:	(* Konfigurationen der Achse *)
		IF fb_state_entry.E THEN
			fb_axis.st_eccoe_sdo.s_ec_slave_net_id := ST_EthercatDiag.s_ec_slave_net_id[2];
			fb_axis.st_eccoe_sdo.ui16_slave_addr := st_config_achse.ui16_ethercat_adr;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := FEHLER; (*in Fehler gehen damit die Achsen resetet werden. Sonst steigen die Achsen bei einem TC Restart aus*)

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_quitt.IN := FALSE;
			fb_ton_wz_rueckzug.IN := FALSE;
			fb_tof_gls_ref.IN := FALSE;
			fb_ton_wz_disable.IN := FALSE;
			b_referenzieren := FALSE;
			sm_bandrueckzug := FALSE;
			sm_bandreferenzieren := FALSE;
			sm_fehler_bandvorschub := FALSE;
			sm_fehler_raster := FALSE;
			sm_fehler_bandeinfaedeln := FALSE;
			sm_fahren_auf_gls := FALSE;
			sm_band_rausgezogen := FALSE;
			sm_band_nicht_in_lichtschranke := FALSE;
			st_sm.b_achse_nicht_auf_startpos := FALSE;
			st_sm.b_achsfehler := FALSE;
			st_sm.b_devicefehler := FALSE;
			st_sm.b_keine_verfahrfreigabe := FALSE;
			st_sm.b_ende_skalierungs_nocke := FALSE;
			st_sm.b_ende_camming_nocke := FALSE;
			st_sm.b_skalierung_noch_aktiv := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_fertig_2 := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_prebereit := FALSE;
			st_ctrl_out.b_bandende := FALSE;
			st_ctrl_out.b_bremse_geoeffnet := FALSE;
			st_ctrl_out.b_bremse_geschlossen := FALSE;
			st_ctrl_out.b_servo_auf_einfaedelpos := FALSE;
			i16_max_torque := 1000;
			i16_lueft_torque := 2;	(* sehr klein, damit sich Band ausrichten kann und Servo nicht dagegen arbeitet *)
			i16_man_einfaedel_torque := 30;
			i16_auto_einfaedel_torque := 150;
			i16_einfaedel_torque := 20;
			i16_block_torque := 40;
			i_Stromlimit := i16_max_torque;
			mc_set_cam_online_change_mode.Execute := FALSE;

			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_bandeinzug;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_preinit THEN
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Schleppabstandsüberwachung einschalten *)
		IF fb_state_entry.E THEN
			fb_axis.r_wert_nc_write_parameter := 1;
			fb_axis.i16_nc_parameter_nummer := EnablePosLagMonitoring;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 25;
		END_IF

(*=======================================================*)
	25:	(* Abfrage auf geändertes Raster *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF r_raster_alt = gst_datensatz.st_band.r_raster THEN
			fb_state_entry.i16_next_step := 60;
		ELSE
			fb_state_entry.i16_next_step := 30;	(* Rasterwechsel -> NC-Parameter müssen neu eingelesen werden! *)
		END_IF

(*=======================================================*)
	30:	(* Konfiguration der Achse in Abhängigkeit des Igelrades/Rasters *)
		(* Die Werte wurden in der Achs-Konfiguration des Systemmanagers für die verschiedenen Raster berechnet *)
		IF fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 41;
		END_IF

(*=======================================================*)
	41:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxVelocitySystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_auto_max := fb_axis.r_wert_nc_read_parameter;
			st_geschwindigkeiten.lr_maximalgeschwindigkeit := fb_axis.r_wert_nc_read_parameter;
			st_geschwindigkeiten.lr_auto_min := 1;
			st_geschwindigkeiten.lr_jog :=360;
			fb_state_entry.i16_next_step := 42;
		END_IF

(*=======================================================*)
	42:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxAccelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_beschleunigung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 43;
		END_IF

(*=======================================================*)
	43:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxDecelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_verzoegerung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 44;
		END_IF

(*=======================================================*)
	44:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxJerk;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_ruck := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 45;
		END_IF

(*=======================================================*)
	45:	(* Bremse auf "automtisch" stellen. *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:	(* Änderungen im Camtable mit Eigenschaft: "mit sofortiger Wirkung" aktivieren *)
		IF fb_state_entry.E THEN
			mc_set_cam_online_change_mode.ActivationMode := MC_CAMACTIVATION_INSTANTANEOUS;
			mc_set_cam_online_change_mode.MasterScalingMode := MC_CAMSCALING_USERDEFINED;
			mc_set_cam_online_change_mode.SlaveScalingMode := MC_CAMSCALING_USERDEFINED;
			mc_set_cam_online_change_mode.CamTableID := 4;
			mc_set_cam_online_change_mode.Execute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF mc_set_cam_online_change_mode.Done THEN
			mc_set_cam_online_change_mode.Execute := FALSE;
			fb_state_entry.i16_next_step := 55;
		ELSIF mc_set_cam_online_change_mode.Error THEN
			err_id := mc_set_cam_online_change_mode.ErrorID;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	55:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;	(* vom Datentyp MC_AxisParameter *)
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_b_achse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 60;	(* Reglerfreigabe setzen *)
			ELSE
				fb_state_entry.i16_next_step := 56;	(* Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	56:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
		(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 57;
		END_IF

(*=======================================================*)
	57:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_b_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60:	(* Reglerfreigabe setzen , Reset wird bei Bedarf automatisch ausgeführt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 70;
		END_IF

(*=======================================================*)
	70:	(* Nullpunktverschiebung ist geschrieben *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_prebereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			b_referenzieren := FALSE;
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_bremse_auf THEN
			fb_state_entry.i16_next_step := 200;	(* Motorbremse lösen *)
		ELSIF st_ctrl_in.b_bremse_zu THEN
			fb_state_entry.i16_next_step := 300;	(* Motorbremse fest *)
		ELSIF st_ctrl_in.b_home THEN
			fb_state_entry.i16_next_step := 400;	(* HOME *)
			st_ctrl_out.b_fertig_2 := FALSE;
		ELSIF st_ctrl_in.b_start THEN
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_fertig_2 := FALSE;
			fb_state_entry.i16_next_step := 500;	(* Einfädelprozedur *)
		ELSIF st_ctrl_in.b_ausfaedeln_servo THEN
			fb_state_entry.i16_next_step := 700;	(* Band ausfädeln *)
		ELSIF st_ctrl_in.b_startpos THEN
			st_ctrl_out.b_servo_auf_einfaedelpos := FALSE;
			fb_state_entry.i16_next_step := 800; (*Igelrad auf Startposition fahren*)
		END_IF

(*=======================================================*)
	200:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* Motorbremse auf *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 2;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 220;
		END_IF

(*=======================================================*)
	220:	(* Fertig *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bremse_geoeffnet := TRUE;
			fb_ton_wz.PT := t#50ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			st_ctrl_out.b_bremse_geoeffnet := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	300:	(* Reglerfreigabe setzen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_ctrl_out.b_bremse_geschlossen := TRUE;
			(* Einzug wieder mit vollem Strom fahren *)
			i_Stromlimit := i16_max_torque;
			fb_state_entry.i16_next_step := 310;
		END_IF

(*=======================================================*)
	310:	(* Motorbremse zu *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 320;
		END_IF

(*=======================================================*)
	320:	(* Fertig *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bremse_geschlossen := TRUE;
			fb_ton_wz.PT := t#50ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			st_ctrl_out.b_bremse_geschlossen := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	400:	(* HOME *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := HOME;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fertig_2 := TRUE;
			fb_state_entry.i16_next_step := 410;

			(* Torqueerst nach HOME wieder hoch nehmen *)
			lr_merker_pos_nach_lueften := b_achse.NcToPlc.ActPos;
			i_Stromlimit := i16_max_torque;
		
			lr_merker_pos_diff_lueften := lr_merker_pos_nach_lueften - lr_merker_pos_vor_lueften;
		END_IF

	410:
		IF NOT st_ctrl_in.b_home THEN
			st_ctrl_out.b_fertig_2 := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	500:(* Band von Bediener in das Igelrad einfädeln oder Vorschub ins Igelrad einfädeln *)
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
		END_IF

		IF 	(zyl_bawe_querschub.fb.e_sensor1_eingefahren AND
			zyl_bawe_halter_li.st_ctrl.out.b_eingefahren AND
			zyl_bawe_faenger_li.st_ctrl.out.b_eingefahren AND
			(visu_hinten.out.ST_Servobandeinzug.b_taste_tippen OR
			st_ctrl_in.b_einfaedeln_servo)) OR
			(zyl_bawe_querschub.fb.e_sensor1_ausgefahren AND
			zyl_bawe_halter_re.st_ctrl.out.b_eingefahren AND
			zyl_bawe_faenger_re.st_ctrl.out.b_eingefahren AND
			(visu_hinten.out.ST_Servobandeinzug.b_taste_tippen OR
			st_ctrl_in.b_einfaedeln_servo))
			THEN
				fb_state_entry.i16_next_step := 531;
		END_IF

(*=======================================================*)
	531:(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step :=533;
		END_IF

(*=======================================================*)
	533:	(* Reglerfreigabe setzen aktuelle Position wird Sollpositon*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step :=535;
		END_IF

(*=======================================================*)
	535:	(* Band fährt in GLS*)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
			(* Drehmoment hochsetzen *)
			i_Stromlimit := i16_man_einfaedel_torque;
			IF st_ctrl_in.b_einfaedeln_servo THEN
				fb_ton_uez.PT := t#10s;
				fb_ton_uez.IN := TRUE;
			END_IF
		END_IF

		st_drive_cmd.enu_cmd := JOG_VORWAERTS;

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_gls_bandreferenzieren THEN
			fb_state_entry.i16_next_step := 540;
		END_IF

		IF fb_ton_uez.Q THEN
			sm_band_nicht_in_lichtschranke := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

		IF fb_state_entry.X THEN
			fb_ton_uez.IN := FALSE;
		END_IF

(*=======================================================*)
	540:	(* Einzug Tippen Stop. *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := JOG_STOP;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 550;
		END_IF

(*=======================================================*)
	550:	(* Schleppabstandsüberwachung einschalten. *)
		IF fb_state_entry.E THEN
			i_Stromlimit := i16_auto_einfaedel_torque;
			fb_axis.i16_nc_parameter_nummer := EnablePosLagMonitoring;
			fb_axis.r_wert_nc_write_parameter := 1;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 560;
		END_IF

(*=======================================================*)
	560:	(* Band zurück bis GLS sicher aus (Sicherstellen das das Band an der Richtigen Position startet) *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := MOVE_RELATIVE;
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
			fb_axis.st_position.r_soll := F_Servobandeinzug_Strecke_zu_Grad( strecke := - lr_max_strecke_gls_wkz);
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			(* Zielposition wurde erreicht -> kein korrekter Abschluss *)
			fb_state_entry.i16_next_step := FEHLER;
			sm_bandrueckzug := TRUE;
		ELSIF NOT fb_tof_gls_ref.Q THEN
			fb_state_entry.i16_next_step := 570;
		END_IF

(*=======================================================*)
	570:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := STOP_AXIS;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 580;
		END_IF

(*=======================================================*)
	580: (* Fahre Band langsam bis zur GLS *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := MOVE_RELATIVE;
			fb_axis.lr_soll_geschwindigkeit := 0.2 * st_geschwindigkeiten.lr_jog;
			fb_axis.st_position.r_soll :=  F_Servobandeinzug_Strecke_zu_Grad( strecke := lr_max_strecke_gls_wkz );
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			(* Zielposition wurde erreicht -> kein korrekter Abschluss *)
			fb_state_entry.i16_next_step := FEHLER;
			sm_fahren_auf_gls := TRUE;
		ELSIF e_gls_bandreferenzieren THEN
			fb_state_entry.i16_next_step := 590;
		END_IF

(*=======================================================*)
	590:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := STOP_AXIS;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 600;
		END_IF

(*=======================================================*)
	600:	(* Band bis zum ersten Fänger im WKZ  fahren - Unterteilung in 2 Wegstrecken mit 2 Geschwindigkeiten. *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
			fb_axis.st_position.r_soll := F_Servobandeinzug_Strecke_zu_Grad( strecke := lr_konst_strecke_ls_bandeinzug );
			st_drive_cmd.enu_cmd := MOVE_RELATIVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 605;
		END_IF

(*=======================================================*)
	605:	(* Schleppabstandsüberwachung ausschalten *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := EnablePosLagMonitoring;
			fb_axis.r_wert_nc_write_parameter := 0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 610;
		END_IF

(*=======================================================*)
	610:	(* Band bis zum ersten Fänger im WKZ  fahren *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := 0.2 * st_geschwindigkeiten.lr_jog;
			fb_axis.st_position.r_soll :=  F_Servobandeinzug_Strecke_zu_Grad( strecke := lr_max_strecke_gls_wkz - lr_konst_strecke_ls_bandeinzug );
			st_drive_cmd.enu_cmd := MOVE_RELATIVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			(* Zielposition wurde erreicht -> kein korrekter Abschluss *)
			sm_fehler_bandeinfaedeln := TRUE;
			st_drive_cmd.enu_cmd := STOP_AXIS;
			fb_state_entry.i16_next_step := FEHLER;
		ELSIF ABS(i16_torque) > i16_block_torque THEN
			(* Wenn Strom steigt, dann steht Band an Fänger im WKZ an. *)
			fb_state_entry.i16_next_step := 620;
		END_IF

(*=======================================================*)
	620:	(* Einzug STOP - Einfädelprozedur beendet. *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := STOP_AXIS;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 630;
		END_IF

(*=======================================================*)
	630:	(* Antrieb kurzfristig kraftlos schalten zum Bandlüften. *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#1000ms;
			fb_ton_wz.IN := TRUE;
			i_Stromlimit := i16_einfaedel_torque;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 640;
		END_IF

(*=======================================================*)
	640: (* Warte kurz *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#1000ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 650;
		END_IF

(*=======================================================*)
	650:	(* Position nullen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := HOME;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			(* Volles Drehmoment *)
			i_Stromlimit := i16_max_torque;
			fb_state_entry.i16_next_step := 660;
		END_IF

(*=======================================================*)
	660:	(* Schleppabstandsüberwachung wieder einschalten *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := EnablePosLagMonitoring;
			fb_axis.r_wert_nc_write_parameter := 1;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_ctrl_out.b_fertig := TRUE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	700:	(* Band ausfädeln, damit der Ausschiebezylinder sicher trifft. *)
		IF fb_state_entry.E THEN
			i_Stromlimit := i16_auto_einfaedel_torque;(*i16_max_torque*)
			fb_axis.lr_soll_geschwindigkeit := 0.2 * st_geschwindigkeiten.lr_jog;
			fb_axis.st_position.r_soll :=  F_Servobandeinzug_Strecke_zu_Grad( strecke := - gst_datensatz.st_band.r_raster * 93);
			st_drive_cmd.enu_cmd := MOVE_RELATIVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 705;
		END_IF

(*=======================================================*)
	705:	(* Schleppabstandsüberwachung ausschalten *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := EnablePosLagMonitoring;
			fb_axis.r_wert_nc_write_parameter := 0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 710;
		END_IF

(*=======================================================*)
	710:	(* Fertig *)
		IF fb_state_entry.E THEN
(*			i_Stromlimit := 25;(*Neu*)*)
			st_ctrl_out.b_ausgefaedelt_servo := TRUE;
			fb_ton_wz.PT := t#50ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			st_ctrl_out.b_ausgefaedelt_servo := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	800:	(* Reglerfreigabe setzen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step :=810;
		END_IF

(*=======================================================*)
	810:	(* Bremse automatisch *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 820;
		END_IF

(*=======================================================*)
	820:	(* Startposition Igelrad berechnen *)
		IF fb_state_entry.E THEN
			lr_startpos :=  F_Startpos_Servobandeinzug( r_actual_pos := b_achse.NcToPlc.ModuloActPos);
			IF lr_startpos < b_achse.NcToPlc.ModuloActPos THEN
				fb_axis.st_position.r_soll :=  lr_startpos - b_achse.NcToPlc.ModuloActPos;
			ELSE
				fb_axis.st_position.r_soll := b_achse.NcToPlc.ModuloActPos - lr_startpos ;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 830;

(*=======================================================*)
	830: (* Positioniere Achse auf Einfädelposition *)
		IF fb_state_entry.E THEN
			i_Stromlimit := i16_max_torque;
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
			st_drive_cmd.enu_cmd := MOVE_RELATIVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 840;
		END_IF

(*=======================================================*)
	840:	(* Schleppabstandsüberwachung ausschalten *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := EnablePosLagMonitoring;
			fb_axis.r_wert_nc_write_parameter := 0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 850;
		END_IF

(*=======================================================*)
	850:	(* Drehmoment auf ein Minimum begrenzen zum Einfädeln *)
		IF fb_state_entry.E THEN
			(* Drehmoment auf Minimum reduzieren *)
			i_Stromlimit := i16_lueft_torque;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := BEREIT;
		st_ctrl_out.b_servo_auf_einfaedelpos := TRUE;

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(* =====Achse wird gestoppt===== *)
		IF st_ctrl_in.b_stop AND NOT b_achse.Status.HasBeenStopped THEN
			st_drive_cmd.enu_cmd := STOP_AXIS;

		(* =====Achse wird angehalten===== *)
		ELSIF st_ctrl_in.b_halt AND NOT b_achse.Status.NotMoving THEN
			st_drive_cmd.enu_cmd := HALT_AXIS;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_drive_cmd.enu_cmd := RESET;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			IF b_achse.NcToPlc.CoupleState = 0 THEN
				st_drive_cmd.enu_cmd := STOP_AXIS;
			END_IF
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND AND b_achse.Status.NotMoving THEN
			fb_state_entry.i16_next_step := STILLSTAND;
		END_IF

(*=======================================================*)
	STILLSTAND:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HALT:
		IF fb_state_entry.E THEN
			IF b_achse.NcToPlc.CoupleState = 0 THEN
				st_drive_cmd.enu_cmd := HALT_AXIS;
			END_IF
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HANDRAD:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
			i_Stromlimit := i16_max_torque / 2;
		END_IF


		IF 	zyl_bawe_querschub.fb.e_sensor1_eingefahren AND
			zyl_bawe_halter_li.st_ctrl.out.b_eingefahren AND
			zyl_bawe_faenger_li.st_ctrl.out.b_eingefahren
			THEN
				IF ST_Euchner_Handbedienpult.i16_Handrad_delta > 0 THEN
					st_drive_cmd.enu_cmd := JOG_VORWAERTS;
				END_IF
				IF ST_Euchner_Handbedienpult.i16_Handrad_delta < 0 THEN
						st_drive_cmd.enu_cmd := JOG_RUECKWAERTS;
				END_IF
		ELSIF 	zyl_bawe_querschub.fb.e_sensor1_ausgefahren AND
				zyl_bawe_halter_re.st_ctrl.out.b_eingefahren AND
				zyl_bawe_faenger_re.st_ctrl.out.b_eingefahren
				THEN
					IF ST_Euchner_Handbedienpult.i16_Handrad_delta > 0 THEN
						st_drive_cmd.enu_cmd := JOG_VORWAERTS;
					END_IF
					IF ST_Euchner_Handbedienpult.i16_Handrad_delta < 0 THEN
							st_drive_cmd.enu_cmd := JOG_RUECKWAERTS;
					END_IF
		ELSE
			IF b_achse.Status.Moving THEN
				st_drive_cmd.enu_cmd := JOG_STOP;
			END_IF
		END_IF

		IF fb_r_trig_taste_plus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_AUF;
		END_IF
		IF fb_r_trig_taste_minus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_ZU;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gi16_betriebsart <> HAND OR NOT b_hand_dialog_aktiv THEN
			fb_state_entry.i16_next_step := 2010;
		END_IF

(*=======================================================*)
	2010:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2020;
		END_IF

(*=======================================================*)
	2020:
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2030;
		END_IF

(*=======================================================*)
	2030:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	MOTORBREMSE_AUF:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2110;
		END_IF

(*=======================================================*)
	2110:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2120;
		END_IF

(*=======================================================*)
	2120:	(* Bremse auf machen *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 2;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND AND
			(gi16_betriebsart <> HAND OR
			NOT b_hand_dialog_aktiv OR
			ST_Euchner_Handbedienpult.i16_Handrad_delta > 0)
			THEN
				fb_state_entry.i16_next_step := HANDRAD;
		ELSIF fb_r_trig_taste_minus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_ZU;
		END_IF

(*=======================================================*)
	MOTORBREMSE_ZU:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2210;
		END_IF

(*=======================================================*)
	2210:	(* Reglerfreigabe setzen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2220;
		END_IF

(*=======================================================*)
	2220:	(* Bremse zu machen *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND AND
			(gi16_betriebsart <> HAND OR
			NOT b_hand_dialog_aktiv OR
			ST_Euchner_Handbedienpult.i16_Handrad_delta > 0)
			THEN
				fb_state_entry.i16_next_step := HANDRAD;
		ELSIF fb_r_trig_taste_plus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_AUF;
		END_IF

(*=======================================================*)
	LUEFTEN:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
			fb_ton_wz_disable.IN := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		IF fb_ton_wz_disable.Q AND st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 2;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
			fb_ton_wz_disable.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_wz_disable.IN := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	REGELN:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_wz_disable.IN := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INBETRIEBNAHME:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_b_achse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 5100;	(* Reversiersequenz*)
			ELSE
				fb_state_entry.i16_next_step := 5010;	(* Reglerfreigabe nehmen und Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	5010:	(* Reglerfreigabe wegnehmen, damit Nullpunktverschiebung geschrieben werden kannt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5020;
		END_IF

(*=======================================================*)
	5020:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
			(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5030;
		END_IF

(*=======================================================*)
	5030:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_b_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5100;
		END_IF

(*=======================================================*)
	5100:	(* Verfahren der Achse zwischen zwei Punkten zum Testen verschiedener Achsparameter *)		(* Achse wird genullt *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := HOME;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5110;
		END_IF

(*=======================================================*)
	5110:	(* Warte Start *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
			fb_axis.st_position.lr_ibn_pos_ziel := 10.0;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_ibn_start THEN
			fb_state_entry.i16_next_step := 5120;
		END_IF

(*=======================================================*)
	5120: (* Fahre Z-Achse auf Zielposition *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			;
		END_IF

(*=======================================================*)
	5130: (* Pause *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#500ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 5110;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

mc_set_cam_online_change_mode(
	Execute:= , 
	ActivationMode:= , 
	ActivationPosition:= , 
	MasterScalingMode:= , 
	SlaveScalingMode:= ,
	CamTableID:= ,
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );

IF st_config_achse.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 0] := st_sm.b_achse_nicht_bb;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 1] := st_sm.b_achse_nicht_referenziert;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 2] := st_sm.b_keine_verfahrfreigabe;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 3] := st_sm.b_achse_nicht_auf_startpos;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 4] := st_sm.b_ende_skalierungs_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 5] := st_sm.b_ende_camming_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 6] := st_sm.b_skalierung_noch_aktiv;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 8] := sm_bandrueckzug;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 9] := sm_bandreferenzieren;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 10] := sm_fehler_bandvorschub;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 11] := sm_fehler_raster;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 12] := sm_fehler_bandeinfaedeln;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 13] := sm_fahren_auf_gls;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 14] := sm_band_rausgezogen;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 15] := sm_band_nicht_in_lichtschranke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 16] := st_drive_cmd.meldungen.sm_write_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 17] := st_drive_cmd.meldungen.sm_read_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 18] := st_drive_cmd.meldungen.sm_write_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 19] := st_drive_cmd.meldungen.sm_read_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 20] := st_drive_cmd.meldungen.sm_power_enable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 21] := st_drive_cmd.meldungen.sm_power_disable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 22] := st_drive_cmd.meldungen.sm_reset;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 23] := st_drive_cmd.meldungen.sm_home;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 24] := st_drive_cmd.meldungen.sm_setposition;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 25] := st_drive_cmd.meldungen.sm_jog_vorwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 26] := st_drive_cmd.meldungen.sm_jog_rueckwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 27] := st_drive_cmd.meldungen.sm_move_absolute;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 28] := st_drive_cmd.meldungen.sm_move_relative;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 29] := st_drive_cmd.meldungen.sm_move_velocity;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 30] := st_drive_cmd.meldungen.sm_move_modulo;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 31] := st_drive_cmd.meldungen.sm_stop_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 32] := st_drive_cmd.meldungen.sm_halt_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 33] := st_drive_cmd.meldungen.sm_motion_command_timeout;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 34] := st_sm.b_achsfehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 35] := st_sm.b_devicefehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 36] := st_drive_cmd.meldungen.sm_limit_positiv_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 37] := st_drive_cmd.meldungen.sm_limit_negativ_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 38] := st_drive_cmd.meldungen.sm_ec_coe_sdo_write_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 39] := st_drive_cmd.meldungen.sm_ec_coe_sdo_read_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 40] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 41] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 42] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 43] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 44] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 45] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 46] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 47] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 49] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 50] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 51] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 52] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 53] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 54] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 55] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 56] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 57] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 58] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 59] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 60] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 61] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 62] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 63] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 64] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 65] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 66] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 67] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 68] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 69] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 70] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 71] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 72] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 73] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 74] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 75] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 76] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 77] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 78] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 79] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 80] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 81] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 82] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 83] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 84] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 85] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 86] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 87] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 88] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 89] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 90] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 91] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 92] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 93] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 94] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 95] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 96] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 97] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 98] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 99] := FALSE;
	
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 19] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 20] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 21] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 22] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 23] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 24] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 25] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 26] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 27] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 28] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 29] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 30] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 31] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 32] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 33] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 34] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 35] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 36] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 37] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 38] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 39] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 40] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 41] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 42] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 43] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 44] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 45] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 46] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 47] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 48] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 49] := FALSE;
END_IF
END_PROGRAM
ACTION	subr_ST_Vorschubkontrolle:
IF gi16_betriebsart <> HAND AND NOT ST_TippTasten.b_einfaedeln_aktiv AND st_ctrl_in.b_freigabe THEN
(* Warte auf Vorschubnocke  und Freigabe von der Virtuellen Masterachse *)
(* Die Freigabe erfolgt nur im normalen Produktionsablauf; nicht bei Bandwechsel, Einfädeln, ... da hier keine Überwachung erfolgen soll. *)

	(* Am Anfang des Bandvorschubs Zähler zurücksetzen *)
	IF  fb_r_trig_nocke_einzug.Q THEN
		i_zaehler_steigende_flanke := 0;
		i_zaehler_fallende_flanke := 0;
	END_IF

	(* Zähler Vorschubkontrolle durch positive Flanke erhöhen *)
	IF fb_r_trig_vorschubkontrolle.Q THEN
		i_zaehler_steigende_flanke := i_zaehler_steigende_flanke + 1;
	END_IF
	(* Zähler Vorschubkontrolle durch negative Flanke erhöhen *)
	IF fb_f_trig_vorschubkontrolle.Q THEN
		i_zaehler_fallende_flanke := i_zaehler_fallende_flanke + 1;
	END_IF

	(* Am Ende des Bandvorschubs die Zähler mit der Vorgabe vergleichen *)
	IF fb_f_trig_nocke_einzug.Q THEN
		IF 	i_zaehler_steigende_flanke <> gst_datensatz.st_bestueckprogramm.i16_b[ST_Virtuelle_Masterachse.i16_bestueckposzaehler] OR
			i_zaehler_fallende_flanke <> gst_datensatz.st_bestueckprogramm.i16_b[ST_Virtuelle_Masterachse.i16_bestueckposzaehler] THEN
			sm_fehler_bandvorschub := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	END_IF
ELSE
	i_zaehler_steigende_flanke := 0;
	i_zaehler_fallende_flanke := 0;
END_IF
END_ACTION




(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Achsen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_TouchProbe
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_state_entry				: ST_StateEntry;
	st_ctrl_in_empty				: struct_ctrl_in;
	fb_ton_quitt					: TON;
	fb_ton_uez					: TON;
	fb_ton_wz					: TON;

	sm_CompareY				:BOOL;
	sm_CompareZ				:BOOL;
	sm_keinMessergebnisY		:BOOL;
	sm_keinMessergebnisZ		:BOOL;
	sm_WtAufSchlitten				:BOOL;

	i16_Counter					:INT;

	fb_TouchProbeLog			: FB_ExporString;	(* Fehlermeldungen in Errorlog (txt) schreiben *)
	s_FileName					: STRING;			(* Name Errorlogdatei *)
	s_ExportStr					: T_MaxString;		(* kompletter Text zum Eintrag in Errorlog *)
	s_ProductionsDate				: STRING;		(* Datum für Logeintrag *)

	lr_RecPosZ					:LREAL;		(*Wird beim Anlagenstart beschrieben*)
	lr_RecPosY					:LREAL;		(*Wird beim Anlagenstart beschrieben*)

END_VAR

VAR CONSTANT
	Trennzeichen					: STRING(3):=' |';
END_VAR
(* @END_DECLARATION := '0' *)
(*======================================================
   PRG: ST_TouchProbe
 ------------------------------------------------------
   Auth: 		Werner Friedl    						 
   Date: 		10.09.2019    						     
   Rev.: 		1.0	
   Desc:		Es werden nacheinander die Z- und Y Achse auf einen Messtaster gefahren und dabei
			die Ermittelten Tastpositionen in ein Lofile eingetregen. ("Projektpad"\TouchProbeLog)

			ACHTUNG!		auf dem Schlitten darf kein WT sein
							bei allen Anlagen Softwarelimits überprüfen und die Taster so motieren, dass sie kurz vor dem Softwarelimit schalten.

			Ablauf und Funktion.
			- bei einem Anlagen Neustart wird das erste Messergebnis in die VAR lr_RecPosZ und lr_RecPosY eingetragen.
			  Diese Messwerte werden dann mit allen darauf folgenden Messungen verglichen.
			- im Prg. "ST_AxisJobCtrl_Motion" muss die Touchprobe Funktion eingefügt sein ( MOVE_TOUCH_PROBE)

			gst_datensatz.st_md.lr_ToleranzTouchProbe				(Toleranz für den Vergleich)
			gst_datensatz.st_md.i16_WdhTouchProbe				(Anzahl der WT-wechsel bis zur nächsten Messung bei 0 wird keine Prüfung gemacht)

			Das Programm wird im ST_WT_Transport_Beladen gestartet (Schritt 140)

   Historie:   1.0

 ========================================================*)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Flanken *)

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF

	IF	axis_y_achse.st_ctrl.out.b_fehler	OR
		axis_z_achse.st_ctrl.out.b_fehler OR
		NOT ST_Safetyprogramm.se_steuerung_ein THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF

END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(i16_pos:= 1);

CASE fb_state_entry.i16_step OF
(*=======================================================*)
INIT_OBJ:
	IF st_config.b_config_fertig THEN
		fb_state_entry.i16_next_step := INIT;
	END_IF

(*=======================================================*)
INIT:
	IF fb_state_entry.E THEN
		fb_ton_wz.IN := FALSE;
		fb_ton_uez.IN	:= FALSE;
		fb_ton_quitt.IN := FALSE;

		sm_CompareY:=FALSE;
		sm_CompareZ:=FALSE;
		sm_keinMessergebnisY:=FALSE;
		sm_keinMessergebnisZ:=FALSE;
		sm_WtAufSchlitten:=	FALSE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	st_ctrl_in.b_init THEN
		fb_state_entry.i16_next_step := 20;
	END_IF

(*=======================================================*)
20: (* Initialisierung*)

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	fb_state_entry.i16_next_step := BEREIT;

(*=======================================================*)
BEREIT:	(* Warte auf Anforderung von vorheriger Station zum aufnehmen des WT *)
	IF 	fb_state_entry.E THEN
		st_ctrl_out.b_bereit := TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	st_ctrl_in.b_start  OR st_ctrl_in.b_start_2 THEN
		fb_state_entry.i16_next_step := 110;
	END_IF

	IF 	fb_state_entry.X THEN
		st_ctrl_out.b_fertig := FALSE;
		st_ctrl_out.b_busy := TRUE;
	END_IF

(*=======================================================*)
110: (* Prüfe Startbedinung*)

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	(*Prüfen ob ein Taster angeklemmt ist*)
	IF	NOT ST_Z_Achse.fb_axis.b_TriggerInput OR
		gst_datensatz.st_md.i16_WdhTouchProbe <= 0 OR
		gst_datensatz.st_md.lr_ToleranzTouchProbe <= 0 THEN
		fb_state_entry.i16_next_step := BEREIT;
		st_ctrl_out.b_fertig := TRUE;
		st_ctrl_out.b_busy := FALSE;
	ELSE
		IF	i16_Counter >= gst_datensatz.st_md.i16_WdhTouchProbe  OR
			i16_Counter = 0 THEN
			fb_state_entry.i16_next_step := 115;
		ELSE
			st_ctrl_out.b_fertig := TRUE;
			st_ctrl_out.b_busy := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF
	END_IF

	IF 	fb_state_entry.X THEN
		i16_Counter:=i16_Counter+1;
	END_IF

(*=======================================================*)
115: (* Prüfe ob Schlitten ohne WT ist*)
	IF fb_state_entry.E THEN
		fb_ton_wz.PT := t#1000ms;
	END_IF

	IF	gst_datensatz.st_md.i16_typ_zelle = BESTUECKZELLE_1720   THEN
		fb_ton_wz.IN:=ST_WT_Transport_Beladen_1720.e_wt_auf_beladepos;
		IF NOT ST_WT_Transport_Beladen_1720.e_wt_auf_beladepos THEN
			fb_state_entry.i16_next_step := 120;
		END_IF
	ELSE
		fb_ton_wz.IN:=ST_WT_Transport_Beladen.e_wt_auf_beladepos;
		IF NOT ST_WT_Transport_Beladen.e_wt_auf_beladepos THEN
			fb_state_entry.i16_next_step := 120;
		END_IF
	END_IF

	IF	fb_ton_wz.Q THEN
		sm_WtAufSchlitten:=TRUE;
		fb_state_entry.i16_next_step := FEHLER;
	END_IF

	IF fb_state_entry.X THEN
		fb_ton_wz.IN := FALSE;
	END_IF

(*=======================================================*)
120: (* CAM_OUT_SLAVE*)
	IF fb_state_entry.E THEN
		ST_Z_Achse.b_start_in := TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_z_achse.st_ctrl.out.b_busy  THEN
		fb_state_entry.i16_next_step := 122;
	END_IF

(*=======================================================*)
122:(*warten auf  fertig*)
	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_z_achse.st_ctrl.out.b_fertig  THEN
		fb_state_entry.i16_next_step := 124;
	END_IF

(*=======================================================*)
124:(*prüfe CoupleState*)

	IF 	(y_achse.NcToPlc.CoupleState = 0 OR gst_datensatz.st_md.i16_typ_zelle = BESTUECKZELLE_1720)AND
	 	z_achse.NcToPlc.CoupleState = 0  THEN
		fb_state_entry.i16_next_step := 126;
	END_IF

(*=======================================================*)
126: (* Z-Achse vor TouchProbe fahren*)
	IF fb_state_entry.E THEN
		ST_Z_Achse.lr_Achspos_in:=-95 + 20 ;				(*Taster befindet sich in Der Nähe vom Motor*)
		ST_Z_Achse.lr_Velo_in:=ST_Z_Achse.st_geschwindigkeiten.lr_auto_max ;
		ST_Z_Achse.enu_cmd_in:=MOVE_TOUCH_PROBE;
		ST_Z_Achse.b_start_in := TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_z_achse.st_ctrl.out.b_busy  THEN
		fb_state_entry.i16_next_step := 128;
	END_IF

(*=======================================================*)
128:(*warten auf  fertig*)
	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_z_achse.st_ctrl.out.b_fertig  THEN
		fb_state_entry.i16_next_step := 130;
	END_IF

(*=======================================================*)
130: (* Z-Achse auf TouchProbe fahren*)
	IF fb_state_entry.E THEN
		ST_Z_Achse.lr_Achspos_in:=-95 ;				(*Taster befindet sich in Der Nähe vom Motor*)
		ST_Z_Achse.lr_Velo_in:=ST_Z_Achse.st_geschwindigkeiten.lr_auto_max / 5;
		ST_Z_Achse.enu_cmd_in:=MOVE_TOUCH_PROBE;
		ST_Z_Achse.b_start_in := TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_z_achse.st_ctrl.out.b_busy  THEN
		fb_state_entry.i16_next_step := 132;
	END_IF

(*=======================================================*)
132:(*warten auf  fertig*)
	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_z_achse.st_ctrl.out.b_fertig  THEN
		fb_state_entry.i16_next_step := 134;
	END_IF

(*=======================================================*)
134: (* Z-Achse vom TouchProbe runter fahren und Positionieren für die Y Achse *)
	IF fb_state_entry.E THEN
		IF	gst_datensatz.st_md.i16_typ_zelle <> BESTUECKZELLE_1720 THEN
			ST_Z_Achse.lr_Achspos_in:=70;				(*Taster befindet sich in DerNähe vom Motor*)
		ELSE
			ST_Z_Achse.lr_Achspos_in:=gst_datensatz.st_md.st_md_z_achse.lr_wt_uebergabepos  ;
		END_IF
		ST_Z_Achse.lr_Velo_in:=ST_Z_Achse.st_geschwindigkeiten.lr_auto_max ;
		ST_Z_Achse.enu_cmd_in:=MOVE_ABSOLUTE;
		ST_Z_Achse.b_start_in := TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_z_achse.st_ctrl.out.b_busy  THEN
		fb_state_entry.i16_next_step := 140;
	END_IF

(*=======================================================*)
140:(*warten auf  fertig*)
	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_z_achse.st_ctrl.out.b_fertig  THEN

		IF	gst_datensatz.st_md.i16_typ_zelle = BESTUECKZELLE_1720 THEN
			fb_state_entry.i16_next_step := 220;
		ELSE
			fb_state_entry.i16_next_step := 150;
		END_IF
	END_IF

(*=======================================================*)
150: (* Y-Achse auf TouchProbe fahren*)
	IF fb_state_entry.E THEN
		ST_Y_Achse.lr_Achspos_in:=30;				(*Taster befindet sich in der Nähe vom Motor*)
		ST_Y_Achse.lr_Velo_in:=ST_Y_Achse.st_geschwindigkeiten.lr_auto_max;
		ST_Y_Achse.enu_cmd_in:=MOVE_ABSOLUTE;
		ST_Y_Achse.b_start_in := TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_y_achse.st_ctrl.out.b_busy  THEN
		fb_state_entry.i16_next_step := 160;
	END_IF

(*=======================================================*)
160:(*warten auf  fertig*)
	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_y_achse.st_ctrl.out.b_fertig  THEN
		fb_state_entry.i16_next_step := 162;
	END_IF

(*=======================================================*)
162: (* Y-Achse auf TouchProbe fahren*)
	IF fb_state_entry.E THEN
		ST_Y_Achse.lr_Achspos_in:=65;				(*Taster befindet sich in der Nähe vom Motor*)
		ST_Y_Achse.lr_Velo_in:=ST_Y_Achse.st_geschwindigkeiten.lr_auto_max / 5;
		ST_Y_Achse.enu_cmd_in:=MOVE_TOUCH_PROBE;
		ST_Y_Achse.b_start_in := TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_y_achse.st_ctrl.out.b_busy  THEN
		fb_state_entry.i16_next_step := 164;
	END_IF

(*=======================================================*)
164:(*warten auf  fertig*)
	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_y_achse.st_ctrl.out.b_fertig  THEN
		fb_state_entry.i16_next_step := 170;
	END_IF

(*=======================================================*)
170: (* Y-Achse vom TouchProbe runter fahren*)
	IF fb_state_entry.E THEN
		ST_Y_Achse.lr_Achspos_in:=30 ;
		ST_Y_Achse.lr_Velo_in:=ST_Y_Achse.st_geschwindigkeiten.lr_auto_max;
		ST_Y_Achse.enu_cmd_in:=MOVE_ABSOLUTE;
		ST_Y_Achse.b_start_in := TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_y_achse.st_ctrl.out.b_busy  THEN
		fb_state_entry.i16_next_step := 180;
	END_IF

(*=======================================================*)
180:(*warten auf  Vorschub zurück fertig*)
	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_y_achse.st_ctrl.out.b_fertig  THEN
		fb_state_entry.i16_next_step := 190;
	END_IF

(*=======================================================*)
190: (* Y-Achse vom TouchProbe runter fahren*)
	IF fb_state_entry.E THEN
		ST_Y_Achse.lr_Achspos_in:=gst_datensatz.st_md.st_md_y_achse.lr_wt_uebergabepos;
		ST_Y_Achse.enu_cmd_in:=MOVE_ABSOLUTE;
		ST_Y_Achse.b_start_in := TRUE;
		ST_Z_Achse.lr_Achspos_in:=gst_datensatz.st_md.st_md_z_achse.lr_wt_uebergabepos  ;
		ST_Z_Achse.enu_cmd_in:=MOVE_ABSOLUTE;
		ST_Z_Achse.b_start_in := TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_y_achse.st_ctrl.out.b_busy  AND
		axis_z_achse.st_ctrl.out.b_busy THEN
		fb_state_entry.i16_next_step := 200;
	END_IF

(*=======================================================*)
200:(*warten auf  Vorschub zurück fertig*)
	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_y_achse.st_ctrl.out.b_fertig AND
		axis_z_achse.st_ctrl.out.b_fertig THEN
		fb_state_entry.i16_next_step := 210;
	END_IF

(*=======================================================*)
210: (* Y- und Z_Achse auf Startposition fahren*)
	IF fb_state_entry.E THEN
		ST_Z_Achse.enu_cmd_in:=CAM_IN_SLAVE;			(*Y-Achse wird wieder angekoppelt*)
		ST_Z_Achse.b_start_in := TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_z_achse.st_ctrl.out.b_busy THEN
		fb_state_entry.i16_next_step := 220;
	END_IF

(*=======================================================*)
220:(*warten auf  Vorschub zurück fertig*)
	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	axis_z_achse.st_ctrl.out.b_fertig  THEN
		fb_state_entry.i16_next_step := 230;
		st_ctrl_out.b_fertig := TRUE;
		st_ctrl_out.b_busy := FALSE;
	END_IF

(*=======================================================*)
230:(*Wenn die RecPos=0 sind dann funktionieren die Messtaster nicht*)

	IF	gst_datensatz.st_md.i16_typ_zelle <> BESTUECKZELLE_1720 THEN
		sm_keinMessergebnisY := ST_Y_Achse.lr_RecPos = 0;
	END_IF
	sm_keinMessergebnisZ := ST_Z_Achse.lr_RecPos = 0;

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	sm_keinMessergebnisY OR
		sm_keinMessergebnisZ THEN
		fb_state_entry.i16_next_step := FEHLER;
	ELSE
		fb_state_entry.i16_next_step := 500;
		i16_Counter:=1;
	END_IF

(*=======================================================*)
500:	(*Eintrag in die ErrorLog===========================================*)
	IF	fb_state_entry.E THEN

		s_ProductionsDate:=DT_TO_SPECIALSTRING_YYYY_MM(inDT:=gdt_system_time);
		s_FileName:=CONCAT('TouchProbeLog_',s_ProductionsDate);
		s_FileName:=CONCAT(s_FileName,'.txt');
		s_ExportStr:=DELETE(DT_TO_STRING(gdt_system_time),3,1);
		s_ExportStr:=CONCAT(s_ExportStr,Trennzeichen);
		s_ExportStr:=CONCAT(s_ExportStr,'Axis Z: ');
		s_ExportStr:=CONCAT(s_ExportStr,LREAL_TO_FMTSTR(ST_Z_Achse.lr_RecPos,5,TRUE));
		IF	gst_datensatz.st_md.i16_typ_zelle <> BESTUECKZELLE_1720 THEN
			s_ExportStr:=CONCAT(s_ExportStr,Trennzeichen);
			s_ExportStr:=CONCAT(s_ExportStr,'Axis Y: ');
			s_ExportStr:=CONCAT(s_ExportStr,LREAL_TO_FMTSTR(ST_Y_Achse.lr_RecPos,5,TRUE));
		END_IF

		IF 	lr_RecPosY = 0 THEN		(*Wird beim Anlagenstart beschrieben*)
			lr_RecPosY:= ST_Y_Achse.lr_RecPos;
		END_IF

		IF 	lr_RecPosZ = 0 THEN		(*Wird beim Anlagenstart beschrieben*)
			lr_RecPosZ:= ST_Z_Achse.lr_RecPos;
			s_ExportStr:=CONCAT(s_ExportStr,' start compare ');
		END_IF

		sm_CompareY:=ABS(lr_RecPosY - ST_Y_Achse.lr_RecPos) > gst_datensatz.st_md.lr_ToleranzTouchProbe;
		sm_CompareZ:=ABS(lr_RecPosZ - ST_Z_Achse.lr_RecPos) > gst_datensatz.st_md.lr_ToleranzTouchProbe;

		IF 	sm_CompareY OR
			sm_CompareZ THEN
			s_ExportStr:=CONCAT(s_ExportStr,' error compare   difference > ');
			s_ExportStr:=CONCAT(s_ExportStr,LREAL_TO_FMTSTR(gst_datensatz.st_md.lr_ToleranzTouchProbe,4,TRUE));
		END_IF

	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	NOT fb_TouchProbeLog.Busy AND
		NOT fb_TouchProbeLog.Error  THEN
		fb_state_entry.i16_next_step:=510;
	ELSE
		fb_state_entry.i16_next_step:=FEHLER;
	END_IF

(*=======================================================*)
510:	(* Starte Schreibvorgang *)
	IF	fb_state_entry.E THEN
		fb_TouchProbeLog.Start:=TRUE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	NOT fb_TouchProbeLog.Busy AND
		fb_TouchProbeLog.Done THEN
		fb_state_entry.i16_next_step:=BEREIT;
	END_IF
	IF	fb_TouchProbeLog.Error OR
		sm_CompareY OR
 		sm_CompareZ THEN
		fb_state_entry.i16_next_step:=FEHLER;
	END_IF


(*=======================================================*)
FEHLER:
	IF fb_state_entry.E THEN
		fb_ton_quitt.IN := FALSE;
		st_ctrl_out.b_fehler := TRUE;
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fertig := FALSE;
		st_ctrl_out.b_busy := FALSE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
		st_ctrl_out.b_fehler := FALSE;
		fb_ton_quitt.IN := TRUE;
	END_IF


	IF fb_ton_quitt.Q THEN
		fb_ton_quitt.IN := FALSE;
		fb_state_entry.i16_next_step := INIT;
	END_IF

(*=======================================================*)
STOP:
	IF fb_state_entry.E THEN
		fb_ton_quitt.IN := FALSE;
		st_ctrl_out.b_gestoppt := TRUE;
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fertig := FALSE;
		st_ctrl_out.b_busy := FALSE;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF 	st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
		st_ctrl_out.b_gestoppt := FALSE;
		fb_ton_quitt.IN := TRUE;
	END_IF

	IF fb_ton_quitt.Q THEN
		fb_ton_quitt.IN := FALSE;
		fb_state_entry.i16_next_step := INIT;
	END_IF
END_CASE

st_ctrl_in:=st_ctrl_in_empty;

fb_state_entry(i16_pos:= 2);

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_CompareY;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_CompareZ;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_keinMessergebnisY;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_keinMessergebnisZ;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_WtAufSchlitten;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;

	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;

END_IF


fb_TouchProbeLog(
	Start:= ,
	Reset:= ,
	ExportStr:= s_ExportStr,
	FileName:= s_FileName,
	Path:=  CONCAT(s_Projekt_path,'TouchProbeLog\'),
	Mode:=FOPEN_MODEAPPEND,	(*am Ende anhängen*)
	Ready=> ,
	Busy=> ,
	Done=> ,
	Error=> ,
	ErrorMsg=> );
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Achsen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Virtuelle_Masterachse
VAR_INPUT
	st_config_achse							: struct_ecd_config;
	e_ls_bandende_re				         		: BOOL;
	e_ls_bandende_li							: BOOL;
	st_ctrl_in									: struct_ctrl_in;
	e_steuerung_ein							: BOOL;
	e_ba_mit_bedingungen					: BOOL;
END_VAR
VAR_IN_OUT
	st_visu									: struct_ecd_visu;
	st_visu_virtuell							: struct_ecd_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out								: struct_ctrl_out;
	b_materialmangel							: BOOL;
	b_materialmangel2						: BOOL;
END_VAR
VAR
	st_sm						 			: struct_ecd_meldungen;
	st_drive_cmd								: struct_ecd_cmd;
	st_drive_cmd_bestueckachse				: struct_ecd_cmd;
	st_drive_cmd_z_achse						: struct_ecd_cmd;
	st_drive_cmd_y_achse						: struct_ecd_cmd;
	st_drive_cmd_b_achse						: struct_ecd_cmd;
	st_drive_cmd_virtuell						: struct_ecd_cmd;
	fb_ton_wz								: TON;
	fb_ton_quitt								: TON;
	fb_ton_wz_disable							: TON;
	fb_r_trig_tippen							: R_TRIG;
	fb_f_trig_tippen							: F_TRIG;
	fb_r_trig_start								: R_TRIG;
	fb_r_trig_start_remove_pos					: R_TRIG;
	fb_virt_master_axis						: ST_AxisJobCtrl_Motion;
	fb_axis_bestueckachse					: ST_AxisJobCtrl_Cam_Gear;
	fb_axis_z_achse							: ST_AxisJobCtrl_Cam_Gear;
	fb_axis_y_achse							: ST_AxisJobCtrl_Cam_Gear;
	fb_axis_b_achse							: ST_AxisJobCtrl_Cam_Gear;
	fb_state_entry								: ST_StateEntry;
	fb_ton_uez								: TON;
	fb_ton_pm_speed							: TON;
	fb_r_trig_pm_speed							: R_TRIG;
	i, j										: INT := 0;
	bm_an_visu_hinten						: STRING[255] := '';
	b_automatischer_bandwechsel				: BOOL := FALSE;
	b_bestueckschieber_ueberwachung_aktiv 	: BOOL := FALSE;
	b_einfaedeln_aktiv_servo					: BOOL := FALSE;	(* wenn TRUE dann entlüftet Serovbandeinzug nicht *)
	lr_merker_z_pos							: LREAL := 0.0;
	lr_merker_y_pos							: LREAL := 0.0;
	lr_merker_z_pos_alt						: LREAL := 0.0;
	lr_merker_z_pos_neu						: LREAL := 0.0;
	lr_merker_y_pos_alt						: LREAL := 0.0;
	lr_merker_y_pos_neu						: LREAL := 0.0;
	lr_abstand_yz								: LREAL := 0.0;
	lr_ErsteBestueckposY						: LREAL := 0.0;
	i16_merker_last_state						: INT := 0;
	i16_state_msg								:INT;
	fb_tof_bandende_li						: TOF;
	fb_tof_bandende_re						: TOF;
	fb_tof_bandende_rafo					: TOF;

	sm_fehler_bestueckanzahl					: BOOL := FALSE;
	sm_fehler_bestueckposition_z				: BOOL := FALSE;
	sm_fehler_bestueckposition_y				: BOOL := FALSE;
	sm_fehler_positionierung_z					: BOOL := FALSE;
	sm_fehler_positionierung_y					: BOOL := FALSE;
	sm_fehler_achse_lueften					: BOOL := FALSE;
	sm_fehler_raster_oder_zaehne				: BOOL := FALSE;
	sm_fehler_bestueckschieberanzahl			: BOOL := FALSE;
	sm_keine_busverbindung					: BOOL := FALSE;
	sm_fehler_nach_bandwechsel				: BOOL := FALSE;	(* Dieser Fehler soll kommen, damit Bediener Chargennummer des Bandes ins LTS einträgt, Wunsch von Sebastian Hechenrieder 27.11.17 *)
	sm_fehler_positionierung_bestueckachse		: BOOL := FALSE;

	(* Betriebsmeldungen *)
	bm_bandende_einzug_links_erreicht			: BOOL := FALSE;
	bm_bandende_einzug_rechts_erreicht		: BOOL := FALSE;
	bm_bandende_beide_einzuege_erreicht		: BOOL := FALSE;
	bm_einzug_links_band_entnehmen			: BOOL := FALSE;
	bm_einzug_links_band_auf_anschlag		: BOOL := FALSE;
	bm_einzug_rechts_band_entnehmen			: BOOL := FALSE;
	bm_einzug_rechts_band_auf_anschlag		: BOOL := FALSE;
	bm_override_kleiner_stufe9					: BOOL := FALSE;
	bm_einzug_rechts_band_bis_gls			: BOOL := FALSE;
	bm_einzug_links_band_bis_gls				: BOOL := FALSE;
	bm_beide_Bandklemmen_oeffnen			: BOOL := FALSE;
	bm_md_offset_z_pos_0_zu_hoch 			: BOOL := FALSE;
	bm_md_offset_y_pos_0_zu_hoch 			: BOOL := FALSE;

	b_merker_bandende_links					: BOOL := FALSE;
	b_merker_bandende_rechts				: BOOL := FALSE;
	b_hand_dialog_aktiv						: BOOL := FALSE;
	fb_r_trig_bestueckhubzaehler				: R_TRIG;
	fb_r_trig_skalierungsnocken					: R_TRIG;
	fb_f_trig_skalierungsnocken					: F_TRIG;
	fb_f_trig_ot								: F_TRIG;
	fb_r_trig_nockenumschaltung				: R_TRIG;
	err_id									: DWORD := 0;
	i16_bestueckachse_cam_table_id			: INT := 0;
	i16_bestueckachse_cam_table_id_alt		: INT := 0;

	fb_berechnung_override_achse				: ST_BerechnungOverride;

	i16_bestueckposzaehler					: INT := 0;

	i16_anzahl								: INT := 0;
	i16_einfaedelzaehler						: INT := 0;

	st_geschwindigkeiten						: struct_ecd_geschwindigkeiten;
	lr_decceleration_nothalt					: LREAL;
	lr_decceleration_normal					: LREAL;

	(* Lueften *)
	i16_step_lueften							: INT := 0;
	fb_r_trig_bandeinzug_lueften				: R_TRIG;
	fb_f_trig_bandeinzug_lueften				: F_TRIG;

	i16_LeftPins							: INT;
END_VAR
VAR CONSTANT
	r_auto_einfaedeln							: LREAL := 300.0;
	lr_faktor_override_reduzierung				: LREAL := 0.0025;
END_VAR

(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= ,PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= ,	PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_wz_disable(IN:= , PT:= t#500ms, Q=> , ET=> );
fb_ton_pm_speed(IN:= , PT:= t#1h, Q=> , ET=> );

(* Flanken *)
fb_r_trig_skalierungsnocken(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_START_SKALIERUNG], Q=> );
fb_f_trig_skalierungsnocken(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_START_SKALIERUNG], Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );
fb_r_trig_bestueckhubzaehler(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BESTUECKSCHIEBERHUB ], Q=> );
fb_f_trig_ot(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_OT], Q=> );
fb_r_trig_nockenumschaltung(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BESTUECKSCHIEBER_EINSTEUERN], Q=> );
fb_r_trig_start_remove_pos(CLK:= visu.b_start_remove_pos, Q=> );

(* Bandende Entprellen *)
fb_tof_bandende_li(IN:= e_ls_bandende_li , PT:=t#1100ms , Q=>  , ET=> );
fb_tof_bandende_re(IN:=e_ls_bandende_re , PT:=t#1100ms , Q=>  , ET=> );
fb_tof_bandende_rafo(IN:=ST_Rasterfolieneinzug.e_rasfo_ende , PT:=t#1100ms , Q=>  , ET=> );

(*Bei der Rasterfolie soll die Hubzahlreduzierung nicht angewendet werden*)
IF gst_datensatz.st_md.i16_typ_zelle <> RASTERFOLIE THEN
	fb_berechnung_override_achse.lr_FaktorHub := ST_BBGen.lr_FaktorHub;
ELSE
	fb_berechnung_override_achse.lr_FaktorHub := 1;
END_IF

(* Der Override der Virtuellen Masterachse wird an die zu fahrende Wegstrecke der Z-Achse angepasst *)
fb_berechnung_override_achse(
	lr_faktor := lr_faktor_override_reduzierung,
	i16_betriebsart:= gi16_betriebsart,
	lr_skalierung_slave_achse1:= ,
	lr_skalierung_slave_achse2:= ,
	lr_HubAuto:=gst_datensatz.st_wkz.r_auto,
	lr_override_vorgabe:= ST_TippTasten.lr_override_gestuft,
	lr_override=> );

(*Beim Einfädeln soll eine feste Geschwindigkeit verwendet werden*)
IF ST_TippTasten.b_einfaedeln_aktiv OR ST_TippTasten.b_initialisierungsphase THEN
	fb_virt_master_axis.lr_soll_geschwindigkeit := r_auto_einfaedeln;
ELSE
	fb_virt_master_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto;
END_IF

(* Achse steuern *)
(* Virtuelle Masterachse/Leitachse für die Bestückzelle*)
fb_virt_master_axis(
	e_referenznocken:= ,
	b_refsensor_vorhanden:= st_config_achse.b_refsensor_vorhanden,
	b_limitsensor_positiv_vorhanden:= st_config_achse.b_limitsensor_positiv_vorhanden,
	b_limitsensor_negativ_vorhanden:= st_config_achse.b_limitsensor_negativ_vorhanden,
	i16_achstyp := st_config_achse.i16_achstyp,
	lr_override_vorgabe := fb_berechnung_override_achse.lr_override,
	st_position:= ,
	mc_richtung_modulo:= ,
	mc_richtung_velocity:= ,
	mc_referenzmodus:= ,
	mc_buffermode_axis:= ,
	ui16_soeparam_write_value:= ,
	w_idn:= ,
	i16_nc_parameter_nummer:= ,
	r_wert_nc_write_parameter:= ,
	st_vorgabe_geschwindigkeiten:= st_geschwindigkeiten,
	b_bedingung_sls:= ,
	st_ads_info := ,
	st_eccoe_sdo := ,
	st_masterachse:= virtuelle_master_achse,
	st_visu_axis:= st_visu,
	st_ecd_cmd:= st_drive_cmd,
	ui16_soeparam_read_value=> ,
	r_wert_nc_read_parameter=> );

(* Entkoppeln der Slaveachsen bei Handbetrieb *)
IF gi16_betriebsart = HAND THEN
	(* Bei manuellem Fahren der Slaveachsen, muss diese erst entkoppelt werden *)
	IF ST_Bestueckachse.b_hand_dialog_aktiv AND bestueckachse.NcToPlc.CoupleState > 0 THEN
		st_drive_cmd_bestueckachse.enu_cmd := CAM_OUT_SLAVE;
	END_IF
	IF ST_Z_Achse.b_hand_dialog_aktiv AND z_achse.NcToPlc.CoupleState > 0 THEN
		st_drive_cmd_z_achse.enu_cmd := CAM_OUT_SLAVE;
	END_IF
	IF ST_Y_Achse.b_hand_dialog_aktiv AND y_achse.NcToPlc.CoupleState > 0 THEN
		st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
	END_IF
	IF ST_Servobandeinzug.b_hand_dialog_aktiv AND b_achse.NcToPlc.CoupleState > 0 THEN
		st_drive_cmd_b_achse.enu_cmd := CAM_OUT_SLAVE;
	END_IF
END_IF

(* Bei betätigen der Bremse am hinteren Panel muss die Master-Slave-Kopplung gelöst werden. *)
IF visu_hinten.out.ST_Servobandeinzug.b_taste_bremse AND b_achse.NcToPlc.CoupleState > 0 THEN
	st_drive_cmd_b_achse.enu_cmd := CAM_OUT_SLAVE;
END_IF

(* Override kleiner als Stufe 10 dann Meldelampe*)
IF	ST_TippTasten.i16_akt_stufe<>9 AND gst_datensatz.st_md.i16_typ_bestueckmodus<>BESTUECKUNG_MANUAL THEN
	b_materialmangel :=TRUE;
	bm_override_kleiner_stufe9:= TRUE;
	fb_ton_pm_speed.IN := TRUE;
ELSE
	b_materialmangel :=FALSE;
	bm_override_kleiner_stufe9:= FALSE;
	fb_ton_pm_speed.IN := FALSE;
END_IF

fb_r_trig_pm_speed(CLK:= fb_ton_pm_speed.Q, Q=> );

IF fb_r_trig_pm_speed.Q THEN
	i16_state_msg := 1;
END_IF

(*Produktionsmeldung für Geschwindigkeit zu niedrig*)
CASE i16_state_msg OF
	1: (*Warten bis keine ander Produktions Meldung ansteht *)
		IF	TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			i16_state_msg := 2;
		END_IF

	2:  (*Produktions Meldung*)
		Visu.MeldungProduktion.Color_R := 255;
		Visu.MeldungProduktion.Color_G := 255;
		Visu.MeldungProduktion.Color_B := 0;
		IF visu.s_akt_sprache = 'de' THEN
			Visu.MeldungProduktion.Name:='Geschwindigkeit zu niedrig eingestellt.';
		ELSIF visu.s_akt_sprache = 'en' THEN
			Visu.MeldungProduktion.Name:='stiching speed is set too low.';
		ELSIF visu.s_akt_sprache = 'cz' THEN
			Visu.MeldungProduktion.Name:='Rychlost osazovani je priliz nizka.';
		END_IF
		Visu.MeldungProduktion.ShowMessage := TRUE;
		Visu.MeldungProduktion.Button1.sichtbar:=TRUE;	(*OK*)
		Visu.MeldungProduktion.Button1.Text:='Ok';
		i16_state_msg := 3;

	3:  (*Warte auf OK*)
		IF Visu.MeldungProduktion.Button1.tasten THEN
			i16_state_msg:=0;
			fb_ton_pm_speed.IN := FALSE;
		END_IF
END_CASE

(* Korrekturwerte für X- und Z- Achse sind zu hoch *)
IF ABS(gst_datensatz.st_md.lr_offset_z_pos_0) > 0.5 THEN
	bm_md_offset_z_pos_0_zu_hoch := TRUE;
ELSE
	bm_md_offset_z_pos_0_zu_hoch := FALSE;
END_IF

IF ABS(gst_datensatz.st_md.lr_offset_y_pos_0) > 0.5 THEN
	bm_md_offset_y_pos_0_zu_hoch := TRUE;
ELSE
	bm_md_offset_y_pos_0_zu_hoch := FALSE;
END_IF

IF bm_md_offset_z_pos_0_zu_hoch OR bm_md_offset_y_pos_0_zu_hoch THEN
	b_materialmangel2 := TRUE;
ELSE
	b_materialmangel2 := FALSE;
END_IF

(* Hinweis: Die Y-Achse darf nur dann in den Slavebetrieb mit der Bestückachse gehen, wenn diese nicht als Slave an die Z-Achse gekoppelt ist. *)
(* Ansonsten kommt es zum Fehler, weil eine Slaveachse nicht gleichzeitig an zwei Masterachsen gekoppelt werden kann!  *)
CASE gst_datensatz.st_md.i16_typ_zelle OF
	KEINE_ZELLE:
		;

	BESTUECKZELLE_1700,  RASTERFOLIE:
		IF bestueckachse.NcToPlc.CoupleState > 0 OR st_drive_cmd_bestueckachse.enu_cmd > NO_COMMAND THEN
			(* Slave Bestückachse *)
			fb_axis_bestueckachse.st_camin_options.CamOperationMode := CAMOPERATIONMODE_EXCHANGE;
			fb_axis_bestueckachse.st_camscaling_data.MasterScalingMode := MC_CAMSCALING_OFF;
			fb_axis_bestueckachse.st_camscaling_data.SlaveScalingMode := MC_CAMSCALING_AUTOOFFSET;
			(* Kurvenscheibenkopplung ein/ausschalten *)
			fb_axis_bestueckachse(
				r_getriebefaktor := 1.0,
				r_master_position:= ,
				mc_activation_mode_camin:= ,
				lr_activation_position_camin:= ,
				mc_activation_mode_scaleing:= ,
				lr_activation_position_scaleing:= ,
				mc_buffermode_axis:= ,
				mc_cam_table_id:=  i16_bestueckachse_cam_table_id,
				mc_cam_point_id:= ,
				mc_motion_function_point:= ,
				st_camin_options:= ,
				st_camexchange_options:= ,
				mc_reference_cam_table_id:= ,
				st_camscaling_data:= ,
				st_masterachse:= virtuelle_master_achse,
				st_slaveachse:= bestueckachse,
				st_ecd_cmd:= st_drive_cmd_bestueckachse);
		END_IF

		IF z_achse.NcToPlc.CoupleState > 0 OR st_drive_cmd_z_achse.enu_cmd > NO_COMMAND THEN
			(* Slave Z-Achse *)
			fb_axis_z_achse.st_camscaling_data.SlaveRelative := TRUE;
			(* Kurvenscheibenkopplung ein/ausschalten *)
			fb_axis_z_achse(
				r_getriebefaktor:= 1.0,
				r_master_position:= ,
				mc_activation_mode_camin:= MC_CAMACTIVATION_INSTANTANEOUS,
				lr_activation_position_camin:= 0.0,
				mc_activation_mode_scaleing:= MC_CAMACTIVATION_INSTANTANEOUS,
				lr_activation_position_scaleing:= 0.0,
				mc_buffermode_axis:= ,
				mc_cam_table_id:=  1,
				mc_cam_point_id:= ,
				mc_motion_function_point:= ,
				st_camin_options:= ,
				st_camexchange_options:= ,
				mc_reference_cam_table_id:= ,
				st_camscaling_data:= ,
				st_masterachse:= virtuelle_master_achse,
				st_slaveachse:= z_achse,
				st_ecd_cmd:= st_drive_cmd_z_achse );
		END_IF

		(* Fallunterscheidung Bandeinzug *)
		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			KEIN_EINZUG:
				;
			STANDARD_2FACH_V2:
				;
			BANDWECHSLER_V2:
				;
			SERVO:
				(* Slave B-Achse *)
				fb_axis_b_achse.st_camscaling_data.SlaveRelative := TRUE;
				(* Kurvenscheibenkopplung ein/ausschalten *)
				fb_axis_b_achse(
					r_getriebefaktor:= 1.0,
					r_master_position:= ,
					mc_activation_mode_camin:= MC_CAMACTIVATION_INSTANTANEOUS,
					lr_activation_position_camin:= 0.0,
					mc_activation_mode_scaleing:= MC_CAMACTIVATION_INSTANTANEOUS,
					lr_activation_position_scaleing:= 0.0,
					mc_buffermode_axis:= ,
					mc_cam_table_id:=  4,
					mc_cam_point_id:= ,
					mc_motion_function_point:= ,
					st_camin_options:= ,
					st_camexchange_options:= ,
					mc_reference_cam_table_id:= ,
					st_camscaling_data:= ,
					st_masterachse:= bestueckachse,
					st_slaveachse:= b_achse,
					st_ecd_cmd:= st_drive_cmd_b_achse );
		END_CASE

		IF y_achse.NcToPlc.CoupleState > 0 OR st_drive_cmd_y_achse.enu_cmd > NO_COMMAND THEN
			(* Slave Y-Achse *)
			fb_axis_y_achse.st_camscaling_data.SlaveRelative := TRUE;
			(* Kurvenscheibenkopplung ein/ausschalten *)
			fb_axis_y_achse(
				r_getriebefaktor:= 1.0,
				r_master_position:= ,
				mc_activation_mode_camin:= MC_CAMACTIVATION_INSTANTANEOUS,
				lr_activation_position_camin:= 0.0,
				mc_activation_mode_scaleing:= MC_CAMACTIVATION_INSTANTANEOUS,
				lr_activation_position_scaleing:= 0.0,
				mc_buffermode_axis:= ,
				mc_cam_table_id:= 3 ,
				mc_cam_point_id:= ,
				mc_motion_function_point:= ,
				st_camin_options:= ,
				st_camexchange_options:= ,
				mc_reference_cam_table_id:= ,
				st_camscaling_data:= ,
				st_masterachse:= virtuelle_master_achse,
				st_slaveachse:= y_achse,
				st_ecd_cmd:= st_drive_cmd_y_achse );
		END_IF

	BESTUECKZELLE_1720:
		IF bestueckachse.NcToPlc.CoupleState > 0 OR st_drive_cmd_bestueckachse.enu_cmd > NO_COMMAND THEN
			(* Slave Bestückachse *)
			fb_axis_bestueckachse.st_camin_options.CamOperationMode := CAMOPERATIONMODE_EXCHANGE;
			fb_axis_bestueckachse.st_camscaling_data.MasterScalingMode := MC_CAMSCALING_OFF;
			fb_axis_bestueckachse.st_camscaling_data.SlaveScalingMode := MC_CAMSCALING_OFF;
			(* Kurvenscheibenkopplung ein/ausschalten *)
			fb_axis_bestueckachse(
				r_getriebefaktor := 1.0,
				r_master_position:= ,
				mc_activation_mode_camin:= ,
				lr_activation_position_camin:= ,
				mc_activation_mode_scaleing:= ,
				lr_activation_position_scaleing:= ,
				mc_buffermode_axis:= ,
				mc_cam_table_id:=  i16_bestueckachse_cam_table_id,
				mc_cam_point_id:= ,
				mc_motion_function_point:= ,
				st_camin_options:= ,
				st_camexchange_options:= ,
				mc_reference_cam_table_id:= ,
				st_camscaling_data:= ,
				st_masterachse:= virtuelle_master_achse,
				st_slaveachse:= bestueckachse,
				st_ecd_cmd:= st_drive_cmd_bestueckachse);
		END_IF

		IF z_achse.NcToPlc.CoupleState > 0 OR st_drive_cmd_z_achse.enu_cmd > NO_COMMAND THEN
			(* Slave Z-Achse *)
			fb_axis_z_achse.st_camscaling_data.SlaveRelative := TRUE;
			(* Kurvenscheibenkopplung ein/ausschalten *)
			fb_axis_z_achse(
				r_getriebefaktor:= 1.0,
				r_master_position:= ,
				mc_activation_mode_camin:= MC_CAMACTIVATION_INSTANTANEOUS,
				lr_activation_position_camin:= 0.0,
				mc_activation_mode_scaleing:= MC_CAMACTIVATION_INSTANTANEOUS,
				lr_activation_position_scaleing:= 0.0,
				mc_buffermode_axis:= ,
				mc_cam_table_id:=  1,
				mc_cam_point_id:= ,
				mc_motion_function_point:= ,
				st_camin_options:= ,
				st_camexchange_options:= ,
				mc_reference_cam_table_id:= ,
				st_camscaling_data:= ,
				st_masterachse:= virtuelle_master_achse,
				st_slaveachse:= z_achse,
				st_ecd_cmd:= st_drive_cmd_z_achse );
		END_IF

END_CASE

(* Bandeinzug lüften-regeln *)
subr_ST_EinzugLueften();

(* =======================================Toplevel========================================== *)
(* =====Achse wird disabled===== *)
IF (NOT e_steuerung_ein OR NOT e_ba_mit_bedingungen) AND bestueckachse.Status.Operational THEN
	st_drive_cmd.enu_cmd := POWER_DISABLE;
END_IF

IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* =====Fehler vom Achskontroller===== *)
	IF	st_drive_cmd.b_job_fehler OR
		st_drive_cmd_bestueckachse.b_job_fehler OR
		st_drive_cmd_z_achse.b_job_fehler OR
		st_drive_cmd_y_achse.b_job_fehler OR
		st_drive_cmd_b_achse.b_job_fehler
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF

	IF fb_state_entry.i16_next_step > 45 THEN
		(* Devicefehler *)
		IF virtuelle_master_achse.Status.Error THEN
			st_sm.b_achsfehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSIF virtuelle_master_achse.Status.DriveDeviceError THEN
			st_sm.b_devicefehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	END_IF

	IF fb_state_entry.i16_next_step < STOP THEN
		(* =====Achse wird gestoppt===== *)
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		ELSIF fb_state_entry.i16_next_step < HALT THEN
			(* =====Achse wird angehalten===== *)
			IF st_ctrl_in.b_halt THEN
				fb_state_entry.i16_next_step := HALT;
			END_IF
		END_IF
	END_IF

END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config_achse.b_config_fertig THEN
			fb_state_entry.i16_next_step := 2;
		END_IF

(*=======================================================*)
	2:	(* Antriebsbegrenzende Konstantwerte *)
		IF fb_state_entry.E THEN
			CASE gst_datensatz.st_md.i16_typ_zelle OF
				KEINE_ZELLE:
					;

				BESTUECKZELLE_1700 :
					st_geschwindigkeiten.lr_auto_max := 350;	(* Hub/min *)
					st_geschwindigkeiten.lr_auto_min := 15;
					st_geschwindigkeiten.lr_jog := 50;
					gst_datensatz.st_md.st_md_bestueckachse.lr_startposition := 17;

				BESTUECKZELLE_1720:
					st_geschwindigkeiten.lr_auto_max := 300;	(* Hub/min *)
					st_geschwindigkeiten.lr_auto_min := 15;
					st_geschwindigkeiten.lr_jog := 50;
					gst_datensatz.st_md.st_md_bestueckachse.lr_startposition := 3;

				RASTERFOLIE:
					st_geschwindigkeiten.lr_auto_max := 300;	(* Hub/min *)
					st_geschwindigkeiten.lr_auto_min := 15;
					st_geschwindigkeiten.lr_jog := 50;
					gst_datensatz.st_md.st_md_bestueckachse.lr_startposition := 17;
			END_CASE

			fb_state_entry.i16_next_step := 3;
		END_IF

(*=======================================================*)
	3:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			subr_ST_Bandeinzugsnocken_ein();
			fb_virt_master_axis.i16_nc_parameter_nummer := MaxVelocitySystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_maximalgeschwindigkeit := fb_virt_master_axis.r_wert_nc_read_parameter(* °/s *) * 60 / 360;
			fb_state_entry.i16_next_step := 4;
		END_IF

(*=======================================================*)
	4:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.i16_nc_parameter_nummer := MaxAccelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_beschleunigung := fb_virt_master_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 5;
		END_IF

(*=======================================================*)
	5:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.i16_nc_parameter_nummer := MaxDecelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_verzoegerung := fb_virt_master_axis.r_wert_nc_read_parameter;
			lr_decceleration_normal := st_geschwindigkeiten.lr_verzoegerung;
			lr_decceleration_nothalt := 200000.0;
			fb_state_entry.i16_next_step := 6;
		END_IF

(*=======================================================*)
	6:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.i16_nc_parameter_nummer := MaxJerk;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_ruck := fb_virt_master_axis.r_wert_nc_read_parameter;
		fb_state_entry.i16_next_step := FEHLER; (*in Fehler gehen damit die Achsen resetet werden. Sonst steigen die Achsen bei einem TC Restart aus*)
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_quitt.IN := FALSE;
			fb_ton_wz_disable.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_prebereit := FALSE;
			b_merker_bandende_links := FALSE;
			b_merker_bandende_rechts := FALSE;

			(* Reset Stoermeldungen *)
			st_sm.b_achse_nicht_auf_startpos := FALSE;
			st_sm.b_achsfehler := FALSE;
			st_sm.b_devicefehler := FALSE;
			st_sm.b_keine_verfahrfreigabe := FALSE;
			st_sm.b_ende_skalierungs_nocke := FALSE;
			st_sm.b_ende_camming_nocke := FALSE;
			st_sm.b_skalierung_noch_aktiv := FALSE;
			sm_fehler_bestueckanzahl := FALSE;
			sm_fehler_bestueckposition_z := FALSE;
			sm_fehler_positionierung_z := FALSE;
			sm_fehler_bestueckposition_y := FALSE;
			sm_fehler_positionierung_y := FALSE;
			sm_fehler_achse_lueften := FALSE;
			sm_fehler_raster_oder_zaehne := FALSE;
			sm_fehler_bestueckschieberanzahl := FALSE;
			sm_keine_busverbindung := FALSE;
			sm_fehler_nach_bandwechsel := FALSE;
			sm_fehler_positionierung_bestueckachse := FALSE;

			(* Reset Betriebsmeldungen *)
			bm_bandende_einzug_links_erreicht := FALSE;
			bm_bandende_einzug_rechts_erreicht := FALSE;
			bm_bandende_beide_einzuege_erreicht := FALSE;
			bm_einzug_links_band_entnehmen := FALSE;
			bm_einzug_links_band_auf_anschlag := FALSE;
			bm_einzug_rechts_band_entnehmen := FALSE;
			bm_einzug_rechts_band_auf_anschlag := FALSE;
			bm_einzug_rechts_band_bis_gls := FALSE;
			bm_einzug_links_band_bis_gls := FALSE;
			bm_beide_Bandklemmen_oeffnen := FALSE;
			bm_an_visu_hinten := '';

			ST_TippTasten.b_einfaedeln_aktiv := FALSE;
			bandwechsel_kontroller.st_ctrl.in.b_start := FALSE;
			einpresskraft_kontroller.st_ctrl.in.b_start := FALSE;
			bandeinzug_kontroller.st_ctrl.in.b_freigabe := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_freigabe := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_bremse_auf := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_bremse_zu := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_start_schreiben := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_start := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_home := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_ausfaedeln_servo := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_einfaedeln_servo := FALSE;

			fb_berechnung_override_achse.lr_skalierung_slave_achse1 := 1;
			fb_berechnung_override_achse.lr_skalierung_slave_achse2 := 1;

			i16_step_lueften := 0;
			i16_einfaedelzaehler := 0;

			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_normal;

			b_bestueckschieber_ueberwachung_aktiv := TRUE;

			b_einfaedeln_aktiv_servo := FALSE;

			gb_memEndOfBandMarkNIO := FALSE;
		END_IF

		(* Gearout/Camout der Slaveachsen, damit diese quittiert werden können *)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700:
				IF bestueckachse.NcToPlc.CoupleState > 0 THEN
					st_drive_cmd_bestueckachse.enu_cmd := CAM_OUT_SLAVE;
				END_IF
				IF z_achse.NcToPlc.CoupleState > 0 THEN
					st_drive_cmd_z_achse.enu_cmd := CAM_OUT_SLAVE;
				END_IF
				IF y_achse.NcToPlc.CoupleState > 0 THEN
					st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
				END_IF

				CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
					KEIN_EINZUG:
						;
					STANDARD_2FACH_V2:
						;
					 BANDWECHSLER_V2:
						;
					SERVO:
						IF b_achse.NcToPlc.CoupleState > 0 THEN
							st_drive_cmd_b_achse.enu_cmd := CAM_OUT_SLAVE;
						END_IF
				END_CASE

			BESTUECKZELLE_1720:
				IF bestueckachse.NcToPlc.CoupleState > 0 THEN
					st_drive_cmd_bestueckachse.enu_cmd := CAM_OUT_SLAVE;
				END_IF
				IF z_achse.NcToPlc.CoupleState > 0 THEN
					st_drive_cmd_z_achse.enu_cmd := CAM_OUT_SLAVE;
				END_IF

			RASTERFOLIE:
				IF bestueckachse.NcToPlc.CoupleState > 0 THEN
					st_drive_cmd_bestueckachse.enu_cmd := CAM_OUT_SLAVE;
				END_IF
				IF z_achse.NcToPlc.CoupleState > 0 THEN
					st_drive_cmd_z_achse.enu_cmd := CAM_OUT_SLAVE;
				END_IF
		END_CASE

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_preinit THEN
			fb_state_entry.i16_next_step := 12;
		END_IF

(*=======================================================*)
	12:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 14;
		END_IF

(*=======================================================*)
	14:	(* Lade Wkz von Festplatte *)
		IF fb_state_entry.E THEN
			gi16_bbgen_auftrag := LESE_WKZ;
		END_IF

		IF  gi16_bbgen_auftrag = KEIN_BB_AUFTRAG THEN
			fb_ton_wz.pt := t#5ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		IF fb_ton_wz.Q THEN
			fb_state_entry.i16_next_step := 16;
			fb_ton_wz.IN := FALSE;
		END_IF

(*=======================================================*)
	16: (* Band aus DB von Festplatte einlesen. *)
		IF fb_state_entry.E THEN
			gi16_bbgen_auftrag := LESE_BAND;
		END_IF

		IF  gi16_bbgen_auftrag = KEIN_BB_AUFTRAG THEN
			fb_ton_wz.pt := t#5ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		IF fb_ton_wz.Q THEN
			fb_state_entry.i16_next_step := 20;
			fb_ton_wz.IN := FALSE;
		END_IF

(*=======================================================*)
	20:	(* CAM_OUT Bestückachse *)
		IF fb_state_entry.E THEN
			st_drive_cmd_bestueckachse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_bestueckachse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* CAM Out Z-Achse *)
		IF fb_state_entry.E THEN
			st_drive_cmd_z_achse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_z_achse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			CASE gst_datensatz.st_md.i16_typ_zelle OF
				KEINE_ZELLE:
					;

				BESTUECKZELLE_1700:
					CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
						KEIN_EINZUG,  STANDARD_2FACH_V2,  BANDWECHSLER_V2:
							fb_state_entry.i16_next_step := 40;
						SERVO:
							fb_state_entry.i16_next_step := 35;
					END_CASE;

				RASTERFOLIE:
					fb_state_entry.i16_next_step := 40;

				BESTUECKZELLE_1720:
					fb_state_entry.i16_next_step := 45;
			END_CASE
		END_IF

(*=======================================================*)
	35:	(* CAM Out B-Achse *)
		IF fb_state_entry.E THEN
			st_drive_cmd_b_achse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_b_achse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:	(* CAM Out Y-Achse *)
		IF fb_state_entry.E THEN
			st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_y_achse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 45;
		END_IF

(*=======================================================*)
	45:	(* Reglerfreigabe setzen , Reset wird bei Bedarf automatisch ausgeführt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_prebereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60:  (* Die Masterachsposition auf Startposition der Bestückachse setzen *)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700, BESTUECKZELLE_1720, RASTERFOLIE:
				IF fb_state_entry.E THEN
					fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
					st_drive_cmd.enu_cmd := SET_POSITION;
				END_IF
		END_CASE

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 70;
		END_IF

(*=======================================================*)
	70:	(* Camin Bestückachse -> synchronisiere sofort Virtuelle Masterachse mit Bestückachse *)
		IF fb_state_entry.E THEN
			i16_bestueckachse_cam_table_id := 5;
			fb_axis_bestueckachse.st_camscaling_data.SlaveScaling := axis_bestueckachse.st_config.r_getriebefaktor;
			fb_axis_bestueckachse.mc_activation_mode_camin:= MC_CAMACTIVATION_INSTANTANEOUS;
			fb_axis_bestueckachse.lr_activation_position_camin := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd_bestueckachse.enu_cmd := CAM_IN_SLAVE;
			i16_bestueckachse_cam_table_id_alt := i16_bestueckachse_cam_table_id;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_bestueckachse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 80;
		END_IF

(*=======================================================*)
	80: (* Prüfe Bandeinzugsdaten wenn Servo verwendet wird => Verhindere Div by 0 *)
		IF fb_state_entry.E THEN
			IF gst_datensatz.st_wkz.i16_typ_bandeinzug = SERVO THEN
				IF gst_datensatz.st_band.r_raster < 0.05 OR
					gst_datensatz.st_band.i16_igelrad_zaehne <= 0 THEN
					sm_fehler_raster_oder_zaehne := TRUE;
					fb_state_entry.i16_next_step := FEHLER;;
				END_IF
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_state_entry.i16_next_step <> FEHLER AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
			i16_bestueckposzaehler := 0;
			bandeinzug_kontroller.st_ctrl.in.b_freigabe := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_freigabe := FALSE;
		END_IF

		(* Bedienergeführter Einfädelablauf mit Anstanzprogramm aus der Grundstellung. *)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700:
				CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
					 BANDWECHSLER_V2:
						IF NOT gst_datensatz.st_md.b_wt_transport_simulation THEN
							IF NOT fb_tof_bandende_li.Q AND zyl_bawe_querschub.fb.e_sensor1_eingefahren THEN
								bm_bandende_einzug_links_erreicht := TRUE;
								b_merker_bandende_links := TRUE;
								i16_merker_last_state := fb_state_entry.i16_step;
								fb_state_entry.i16_next_step :=300;	(* ->Bandwechsel *)
							ELSIF NOT fb_tof_bandende_re.Q AND zyl_bawe_querschub.fb.e_sensor1_ausgefahren THEN
								bm_bandende_einzug_rechts_erreicht := TRUE;
								b_merker_bandende_rechts := TRUE;
								i16_merker_last_state := fb_state_entry.i16_step;
								fb_state_entry.i16_next_step := 300;	(* ->Bandwechsel *)
							END_IF
						END_IF

					SERVO:
						IF NOT gst_datensatz.st_md.b_wt_transport_simulation THEN
							IF NOT fb_tof_bandende_li.Q AND zyl_bawe_querschub.fb.e_sensor1_eingefahren THEN
								bm_bandende_einzug_links_erreicht := TRUE;
								b_merker_bandende_links := TRUE;
								i16_merker_last_state := fb_state_entry.i16_step;
								fb_state_entry.i16_next_step := 640;
							ELSIF  NOT fb_tof_bandende_re.Q AND zyl_bawe_querschub.fb.e_sensor1_ausgefahren THEN
								bm_bandende_einzug_rechts_erreicht := TRUE;
								b_merker_bandende_rechts := TRUE;
								i16_merker_last_state := fb_state_entry.i16_step;
								fb_state_entry.i16_next_step := 640;
							END_IF
						END_IF
				END_CASE;


			BESTUECKZELLE_1720:
				CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
					  STANDARD_2FACH_V2:
						IF NOT gst_datensatz.st_md.b_wt_transport_simulation THEN
							(* Band wird nur am Steckeranfang nach Neueinfädeln angestanzt. *)
							IF NOT fb_tof_bandende_li.Q OR NOT fb_tof_bandende_re.Q THEN
								b_merker_bandende_links := TRUE;
								b_merker_bandende_rechts := TRUE;
								bm_bandende_beide_einzuege_erreicht := TRUE;
								i16_merker_last_state := fb_state_entry.i16_step;
								fb_state_entry.i16_next_step := 420;
							END_IF
						END_IF
				END_CASE

			RASTERFOLIE:
				(*Beim 92 pol. Stecker muss eine Einfädelroutine gestartet werden*)
				IF gst_datensatz.st_wkz.b_rafo_auto_einf_aktiv AND NOT fb_tof_bandende_rafo.Q THEN
					bm_bandende_einzug_links_erreicht := TRUE;
					fb_state_entry.i16_next_step := 810;
				END_IF
		END_CASE

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_start.Q AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fertig := FALSE;
			ST_TippTasten.b_einfaedeln_aktiv := FALSE;
			b_einfaedeln_aktiv_servo := FALSE;
			bandeinzug_kontroller.st_ctrl.in.b_freigabe := TRUE;
			gb_memEndOfBandMarkNIO := FALSE;
			fb_state_entry.i16_next_step := 110;
			IF gst_barcode_daten.b_band_links_ok THEN
				b_merker_bandende_links := FALSE;
			END_IF
			IF gst_barcode_daten.b_band_rechts_ok THEN
				b_merker_bandende_rechts := FALSE;
			END_IF
		ELSIF fb_r_trig_start_remove_pos.Q AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 900;
		END_IF

(*=======================================================*)
	110:	(* Auswahl als was die Zelle Betrieben wird *)
		IF fb_state_entry.E THEN
			CASE gst_datensatz.st_md.i16_typ_zelle OF
				KEINE_ZELLE:
					;

				BESTUECKZELLE_1700, BESTUECKZELLE_1720:
					fb_state_entry.i16_next_step := 130;

				RASTERFOLIE:
					fb_state_entry.i16_next_step := 800;
			END_CASE
		END_IF

(*=========================Regulärer Bestückablauf==============================*)
	130:	(* Fahre vorgegebene Anzahl von Bestückhüben *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.st_position.r_soll := (DINT_TO_LREAL(gst_datensatz.st_bestueckprogramm.i32_anzahl)) * 360.0 + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;	(* Achtung beim MODULO-Befehl: fährt nur bis 360° *)
			fb_virt_master_axis.mc_richtung_modulo :=MC_Positive_Direction ;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 140;

(*=======================================================*)
	140:	(* Positionsmerker für die Bestückpositionsüberwachung *)
		IF fb_state_entry.E THEN
			lr_merker_z_pos := gst_datensatz.st_isk.lr_pos_z_0 + gst_datensatz.st_wkz.lr_offset_z_pos_0 + gst_datensatz.st_wt.lr_offset_z_pos_0 + gst_datensatz.st_md.lr_offset_z_pos_0;
			lr_merker_y_pos := gst_datensatz.st_isk.lr_pos_y_0 + gst_datensatz.st_wkz.lr_offset_y_pos_0 + gst_datensatz.st_wt.lr_offset_y_pos_0 + gst_datensatz.st_md.lr_offset_y_pos_0;
			subr_ST_Cam_Bestueck_Maschine();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 150;

(*=======================================================*)
	150:	(* Bestückachse läuft im Getriebegleichlauf, die Z-Achse bzw. Y-Achse wird gekoppelt oder skaliert *)
		IF fb_state_entry.E THEN
			lr_merker_z_pos_alt := 500.0;	(* einfach ein Wert ausserhalb des Verfahrbereichs der Z-Achse *)
			lr_merker_y_pos_alt := 100.0;	(* einfach ein Wert ausserhalb des Verfahrbereichs der Y-Achse *)

			einpresskraft_kontroller.st_ctrl.in.b_start := TRUE;

			IF gst_datensatz.st_wkz.i16_typ_bandeinzug = SERVO THEN
				axis_bandeinzug_achse.st_ctrl.in.b_freigabe := TRUE;
			END_IF
		END_IF

		IF gst_datensatz.st_md.i16_typ_zelle = BESTUECKZELLE_1700 THEN
			(*Überwachungsfunktion, ob das Auskoppeln der Bestückachse geklappt hat.*)
			subr_ST_PosUW_Bestueckachse();
		END_IF

		IF fb_r_trig_bestueckhubzaehler.Q THEN
			CASE gst_datensatz.st_md.i16_typ_zelle OF
				KEINE_ZELLE:
					;
				BESTUECKZELLE_1700:
					(* Positionsüberwachung Achsen *)
					CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
						 BANDWECHSLER_V2:
							subr_ST_PosUW_YZ_Achse();

						SERVO:
							subr_ST_PosUW_YZ_Achse();
							subr_ST_B_Achse();
					END_CASE;
					(* Zählt die gesetzten Pins während des gesamten Bestückvorganges *)
					i16_bestueckposzaehler := i16_bestueckposzaehler + 1;

					(* >>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<< *)
					(*
					Diese Änderung wurde 1:1 aus Tschechien übernommen.
					Merker "gb_memEndOfBandMarkNIO" für Bandende während des Bestückens. Diese Variable gilt nur
					für den One27 in Tschechien. Während des Bestückens wird der Bandende Sensor abgefragt. Wenn
					noch mehr wie 80 Pins zu bestücken sind und der Bandende Sensor anschlägt, wird ein "HALT_AXIS"
					der virtuellen Masterachse ausgeführt. Die Achse bleibt zufällig irgendwo stehen. Der WT bleibt auf
					Bestückposition stehen. Eine Fehlermeldung kommt vom Bandwechselkontroller. Dann muss die 
					Anlage quittiert werden. Bestückachse fährt in Grundstellung und WT fährt auf Übergabeposition.
					Danach wird der Bandwechselvorgang gestartet. *)
					i16_LeftPins := DINT_TO_INT(gst_datensatz.st_bestueckprogramm.i32_anzahl) - i16_bestueckposzaehler;
					IF (NOT fb_tof_bandende_li.Q) AND
						(F_ToUCase(gst_bestueckbild_halbauto.s_beschreibung) = 'ONE27') AND
						(i16_LeftPins > 80) THEN
						i16_bestueckposzaehler := DINT_TO_INT(gst_datensatz.st_bestueckprogramm.i32_anzahl);
						gb_memEndOfBandMarkNIO := TRUE;
						st_drive_cmd.enu_cmd := HALT_AXIS;
					END_IF
					(* >>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<< *)

				BESTUECKZELLE_1720:
					(* Positionsüberwachung Achsen *)
					CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
						STANDARD_2FACH_V2:
							subr_ST_PosUW_Z_Achse();
						SERVO:
							subr_ST_B_Achse();
					END_CASE;
					(* Zählt die gesetzten Pins während des gesamten Bestückvorganges *)
					i16_bestueckposzaehler := i16_bestueckposzaehler + 1;

				RASTERFOLIE:
					;
			END_CASE
		END_IF

		(* Auf Startposition achten, damit die Erstskalierung nicht übersehen wird *)
		IF i16_bestueckposzaehler >= 0 AND i16_bestueckposzaehler <= gst_datensatz.st_bestueckprogramm.i32_anzahl THEN
			(* Warte auf OT-Nocken für Skalierungsfreigabe *)
			IF fb_f_trig_ot.Q THEN
				subr_ST_Cam_Bestueck_Maschine();
			END_IF

			(* Warte auf Nocken für die Skalierungsfreigabe *)
			IF fb_r_trig_skalierungsnocken.Q THEN
				CASE gst_datensatz.st_md.i16_typ_zelle OF
					KEINE_ZELLE:
						;
					BESTUECKZELLE_1700:
						CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
							 BANDWECHSLER_V2:
								(* Skalierung der Kurvenscheibe *)
								subr_ST_Cam_Z_Achse();
								subr_ST_Cam_Y_Achse();

							SERVO:
								(* Skalierung der Kurvenscheibe *)
								subr_ST_Cam_Z_Achse();
								subr_ST_Cam_Y_Achse();
								subr_ST_Cam_B_Achse();
						END_CASE;

					BESTUECKZELLE_1720:
						CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
							STANDARD_2FACH_V2:
								(* Skalierung der Kurvenscheibe *)
								subr_ST_Cam_Z_Achse();
						END_CASE;

					RASTERFOLIE:
						;
				END_CASE
			END_IF
		END_IF

		(*====================================================================================================================*)
		IF  i16_bestueckposzaehler = gst_datensatz.st_bestueckprogramm.i32_anzahl THEN
			(* Wenn alle Bestückhübe gemacht sind warte auf Bestückachse im Ziel *)
			CASE gst_datensatz.st_md.i16_typ_zelle OF
				KEINE_ZELLE:
					;
				BESTUECKZELLE_1700:
					CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
						 BANDWECHSLER_V2:
							IF	virtuelle_master_achse.Status.NotMoving  AND
								virtuelle_master_achse.Status.InTargetPosition AND
								st_drive_cmd.enu_cmd = NO_COMMAND 	AND
								st_drive_cmd_z_achse.enu_cmd = NO_COMMAND AND
								st_drive_cmd_y_achse.enu_cmd = NO_COMMAND
								THEN
									(* Kontrolle, ob die gemachten Bestückhübe der Vorgabe aus dem Bestückprogramm entsprechen *)
									IF i16_bestueckposzaehler = gst_datensatz.st_bestueckprogramm.i32_anzahl THEN
										fb_state_entry.i16_next_step := 170;
									ELSE
										sm_fehler_bestueckanzahl := TRUE;
										fb_state_entry.i16_next_step := FEHLER;
									END_IF
							END_IF

						SERVO:
							IF	virtuelle_master_achse.Status.NotMoving  AND
								virtuelle_master_achse.Status.InTargetPosition AND
								st_drive_cmd.enu_cmd = NO_COMMAND 	AND
								st_drive_cmd_z_achse.enu_cmd = NO_COMMAND AND
								st_drive_cmd_y_achse.enu_cmd = NO_COMMAND AND
								st_drive_cmd_b_achse.enu_cmd = NO_COMMAND
								THEN
									(* Kontrolle, ob die gemachten Bestückhübe der Vorgabe aus dem Bestückprogramm entsprechen *)
									IF i16_bestueckposzaehler = gst_datensatz.st_bestueckprogramm.i32_anzahl THEN
										fb_state_entry.i16_next_step := 160;
									ELSE
										sm_fehler_bestueckanzahl := TRUE;
										fb_state_entry.i16_next_step := FEHLER;
									END_IF
							END_IF
					END_CASE;

				BESTUECKZELLE_1720:
					CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
						 STANDARD_2FACH_V2:
							IF	virtuelle_master_achse.Status.NotMoving  AND
								virtuelle_master_achse.Status.InTargetPosition AND
								st_drive_cmd.enu_cmd = NO_COMMAND 	AND
								st_drive_cmd_z_achse.enu_cmd = NO_COMMAND
								THEN
									(* Kontrolle, ob die gemachten Bestückhübe der Vorgabe aus dem Bestückprogramm entsprechen *)
									IF i16_bestueckposzaehler = gst_datensatz.st_bestueckprogramm.i32_anzahl THEN
										fb_state_entry.i16_next_step := 180;
									ELSE
										sm_fehler_bestueckanzahl := TRUE;
										fb_state_entry.i16_next_step := FEHLER;
									END_IF
							END_IF
					END_CASE

				RASTERFOLIE:
					;
			END_CASE
		END_IF

		(* Nach dem ersten WT wird die Bestückschieberüberwachung ausgeschaltet (Wunsch von Häußerer Josy) *)
		(* Bei der Grundstellungsfahrt wird die Abfrage wieder aktiviert *)
		IF fb_state_entry.X THEN
			axis_bandeinzug_achse.st_ctrl.in.b_freigabe := FALSE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BESTUECKSCHIEBER_ON].b_camvalid := FALSE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BESTUECKSCHIEBER_OFF].b_camvalid := FALSE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_UW_BESTUECKSCHIEBER_ON].b_camvalid := FALSE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_UW_BESTUECKSCHIEBER_OFF].b_camvalid := FALSE;
			b_bestueckschieber_ueberwachung_aktiv := FALSE;
			einpresskraft_kontroller.st_ctrl.in.b_start := FALSE;
		END_IF

(*=======================================================*)
	160:	(* Kopplung mit B-Achse lösen *)
		IF fb_state_entry.E THEN
			st_drive_cmd_b_achse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_b_achse.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 170;
		END_IF

(*=======================================================*)
	170:	(* Kopplung mit Y-Achse lösen *)
		IF fb_state_entry.E THEN
			fb_berechnung_override_achse.lr_skalierung_slave_achse2 := 1;
			st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_y_achse.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 180;
		END_IF

(*=======================================================*)
	180:	(* Kopplung mit Z-Achse lösen *)
		IF fb_state_entry.E THEN
			fb_berechnung_override_achse.lr_skalierung_slave_achse1 := 1;
			st_drive_cmd_z_achse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_z_achse.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	300:	(* Cam_in_Slave*)
		IF fb_state_entry.E THEN
			subr_ST_Bandeinzugsnocken_aus();
			bandeinzug_kontroller.st_ctrl.in.b_freigabe := FALSE;           (* GLS überwachung ausschalten*)
			ST_TippTasten.b_einfaedeln_aktiv := TRUE;
			i16_bestueckachse_cam_table_id := 5;
			fb_axis_bestueckachse.mc_activation_mode_camin:= MC_CAMACTIVATION_ATMASTERCAMPOS;
			fb_axis_bestueckachse.lr_activation_position_camin := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd_bestueckachse.enu_cmd := CAM_IN_SLAVE;
			i16_bestueckachse_cam_table_id_alt := i16_bestueckachse_cam_table_id;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_bestueckachse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step :=305;
		END_IF

(*===========================Anstanzen 1700 mit Klemmbandeinzug V2============================*)
	305:	(* Nocken sind deaktiviert, Bandeinzug ist bereits ausgeschaltet, jetzt beide Zylinder lösen. *)
		IF fb_state_entry.E THEN
			(* Band freigeben für Bedienerentnahme *)
			bandwechsel_kontroller.st_ctrl.in.b_start := TRUE;
			zyl_bandfaenger.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandklemmen.st_ctrl.in.b_einfahren := TRUE;
			gi16_anzahl_Teile_autostop_bandwechsel := 0;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT bandwechsel_kontroller.st_ctrl.out.b_fertig AND NOT bandwechsel_kontroller.st_ctrl.out.b_fertig_2 THEN
			fb_state_entry.i16_next_step := 306;
		END_IF

(*=======================================================*)
	306:	(* Warten auf Bandwechselkontroller fertig*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(*Einfädeln nach automatischem Bandwechsel*)
		IF bandwechsel_kontroller.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			bandwechsel_kontroller.st_ctrl.in.b_start := FALSE;
			bm_bandende_einzug_links_erreicht := FALSE;
			bm_bandende_einzug_rechts_erreicht := FALSE;
			b_automatischer_bandwechsel := TRUE;
			fb_state_entry.i16_next_step := 360;
		(*Einfädeln nach manuellem Bandwechsel*)
		ELSIF bandwechsel_kontroller.st_ctrl.out.b_fertig_2 AND NOT fb_state_entry.E THEN
			bandwechsel_kontroller.st_ctrl.in.b_start := FALSE;
			bm_bandende_einzug_links_erreicht := FALSE;
			bm_bandende_einzug_rechts_erreicht := FALSE;
			b_automatischer_bandwechsel := FALSE;
			fb_state_entry.i16_next_step := 310;
		END_IF

(*=======================================================*)
	310:	(* Bandende im linken oder rechten Einzug ohne Bandwechsel ->Meldung und warte auf Bediener *)
		IF fb_state_entry.E THEN
			bm_bandende_einzug_links_erreicht := FALSE;
			bm_bandende_einzug_rechts_erreicht := FALSE;
			IF b_merker_bandende_links THEN
				bm_einzug_links_band_entnehmen := TRUE;
			ELSIF b_merker_bandende_rechts THEN
				bm_einzug_rechts_band_entnehmen := TRUE;
			END_IF
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[0];(*Band am Einzug entnehmen -> Taste TIPPEN.*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_TippTasten.r_trig_tippen_einfaedeln.Q THEN
			(* Bei Tastendruck darf sich kein Band im Einzug befinden *)
			IF b_merker_bandende_links THEN
				IF NOT e_ls_bandende_li THEN
					fb_state_entry.i16_next_step :=320;
				END_IF
			ELSIF b_merker_bandende_rechts THEN
				IF NOT e_ls_bandende_re THEN
					fb_state_entry.i16_next_step := 320;
				END_IF
			END_IF
		ELSIF fb_r_trig_start_remove_pos.Q AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 900;
		END_IF

(*=======================================================*)
	320:	(* Fahre auf UT, Bestückachse ist wieder gekoppelt *)
		IF fb_state_entry.E THEN
			bm_einzug_links_band_entnehmen := FALSE;
			bm_einzug_rechts_band_entnehmen := FALSE;
			bm_an_visu_hinten := '';

			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_wkz.lr_einfaedelposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 330;
		END_IF

(*=======================================================*)
	330:	(* Meldung und warte auf Bediener *)
		IF fb_state_entry.E THEN
			IF b_merker_bandende_links THEN
				bm_einzug_links_band_auf_anschlag := TRUE;
				bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[8];(*Band an Einzug links auf Anschlag in WKZ -> Taste TIPPEN.*)
			ELSIF b_merker_bandende_rechts THEN
				bm_einzug_rechts_band_auf_anschlag := TRUE;
				bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[9];(*Band an Einzug rechts auf Anschlag in WKZ -> Taste TIPPEN*)
			END_IF
		END_IF

		IF ST_TippTasten.r_trig_tippen_einfaedeln.Q  THEN
			bm_einzug_links_band_auf_anschlag := FALSE;
			bm_einzug_rechts_band_auf_anschlag := FALSE;
			bm_an_visu_hinten := '';

			(* Klemme das Band *)
			zyl_bandklemmen.st_ctrl.in.b_einfahren := FALSE;
			zyl_bandklemmen.st_ctrl.in.b_ausfahren := TRUE;
			zyl_bandfaenger.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandfaenger.st_ctrl.in.b_ausfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bandfaenger.st_ctrl.out.b_eingefahren AND zyl_bandklemmen.st_ctrl.out.b_ausgefahren THEN
			fb_state_entry.i16_next_step := 340;
		END_IF

(*=======================================================*)
	340:	(* Warte kurz auf Zylinder *)
		IF fb_state_entry.E THEN
 			fb_ton_wz.PT := t#1s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 350;
		END_IF

(*=======================================================*)
	350:	(* Fahre auf OT - Band ist geklemmt *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[1];(*Werkzeug fährt auf OT.*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 360;
		END_IF

(*=======================================================*)
	360:	(* Die Zylinder wieder den Nocken überlassen *)
		IF fb_state_entry.E THEN
			zyl_bandfaenger.st_ctrl.in.b_einfahren := FALSE;
			zyl_bandfaenger.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bandklemmen.st_ctrl.in.b_einfahren := FALSE;
			zyl_bandklemmen.st_ctrl.in.b_ausfahren := FALSE;
			(* Alle Nocken aktivieren, damit die Zylinder wieder winkelgesteuert werden *)
			subr_ST_Bandeinzugsnocken_ein();

			zyl_bandfaenger.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
			zyl_bandklemmen.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 370;

(*=======================================================*)
	370: (* Band neu eingefädelt: Fahre Einfädelhübe und starte dann wieder Bestückzyklus *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			(* Beim automatischen Bandwechsel braucht man wengiger Einfädelhübe bis bestückt werden kann*)
			IF b_automatischer_bandwechsel = TRUE THEN
				fb_virt_master_axis.st_position.r_soll := (gst_datensatz.st_wkz.i16_anzahl_einfaedel_auto_pins * 360.0) + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			ELSE
				fb_virt_master_axis.st_position.r_soll := (gst_datensatz.st_wkz.i16_anzahl_einfaedel_pins * 360.0) + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			END_IF

			st_drive_cmd.enu_cmd := MOVE_MODULO;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[2];(*Anstanzhübe werden aktuell gefahren.*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			subr_ST_Bandeinzugsnocken_ein();
			bm_an_visu_hinten := '';
			fb_state_entry.i16_next_step := 380;
		END_IF

(*=======================================================*)
	380:(* Band Scannen*)
		IF 	fb_state_entry.E THEN
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[3];(*Band scannen*)
		END_IF

		IF 	(gst_barcode_daten.b_band_links_ok AND gst_barcode_daten.b_band_ID_links_ok AND zyl_bandeinzuege_verschieben.st_ctrl.out.b_ausgefahren)OR
			(gst_barcode_daten.b_band_rechts_ok AND gst_barcode_daten.b_band_ID_rechts_ok AND zyl_bandeinzuege_verschieben.st_ctrl.out.b_eingefahren)
			THEN
				IF	ST_TippTasten.b_einfaedeln_aktiv THEN
					IF 	gst_datensatz.st_md.b_auto_Bandwechsel THEN
						fb_state_entry.i16_next_step := BEREIT;
					ELSE
						sm_fehler_nach_bandwechsel := TRUE;
						(* Dieser Fehler soll kommen, damit Bediener Chargennummer des Bandes ins LTS einträgt, Wunsch von Sebastian Hechenrieder 27.11.17 *)
						fb_state_entry.i16_next_step := FEHLER;(*BEREIT*)
					END_IF
				ELSE
					IF i16_merker_last_state = 150 THEN
						(* Bandende während Bestückablauf *)
						fb_state_entry.i16_next_step := 390;
					ELSE
						(* Bandende aus Step BEREIT *)
						fb_state_entry.i16_next_step := i16_merker_last_state;
					END_IF
				END_IF
		END_IF

		IF fb_state_entry.X THEN
			ST_TippTasten.b_einfaedeln_aktiv:=FALSE;
			b_merker_bandende_links := FALSE;
			b_merker_bandende_rechts := FALSE;
			bm_an_visu_hinten := '';
		END_IF

(*=======================================================*)
	390:	(* Fahre vorgegebene Anzahl von Bestückhüben *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.st_position.r_soll := (DINT_TO_LREAL(gst_datensatz.st_bestueckprogramm.i32_anzahl - i16_bestueckposzaehler)) * 360.0 + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;	(* Achtung beim MODULO-Befehl: fährt nur bis 360° *)
			fb_virt_master_axis.mc_richtung_modulo := MC_Positive_Direction ;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_bestueckhubzaehler.Q THEN
			(* Zählt die gesetzten Pins während des gesamten Bestückvorganges *)
			i16_bestueckposzaehler := i16_bestueckposzaehler + 1;
			(* Sobald ein Pin gesetzt wurde wird in den regulären Ablauf mit Camming gesprungen *)
			fb_state_entry.i16_next_step := 150;
		END_IF

(*=======================================================*)
	420:	(* Meldung und warte auf Bediener *)
		IF fb_state_entry.E THEN
			ST_TippTasten.b_einfaedeln_aktiv := TRUE;
			subr_ST_Bandeinzugsnocken_aus();
			bandeinzug_kontroller.st_ctrl.in.b_freigabe := FALSE;           (* GLS überwachung ausschalten*)

			bm_beide_Bandklemmen_oeffnen := TRUE;

			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[11];(*beide Bandklemmen öffnen -> Taste TIPPEN.*)

			gi16_anzahl_Teile_autostop_bandwechsel := 0;
		END_IF

		IF ST_TippTasten.r_trig_tippen_einfaedeln.Q THEN

			bm_beide_Bandklemmen_oeffnen := FALSE;
			bm_an_visu_hinten := '';
			fb_ton_wz.PT := t#200ms;
			fb_ton_wz.IN := TRUE;

			(* Gib beide Bänder frei *)
			zyl_bandfaenger_li.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandfaenger_li.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bandklemmen_li.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandklemmen_li.st_ctrl.in.b_ausfahren := FALSE;

			zyl_bandfaenger_re.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandfaenger_re.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bandklemmen_re.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandklemmen_re.st_ctrl.in.b_ausfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			IF 	zyl_bandfaenger_li.st_ctrl.out.b_eingefahren AND
				zyl_bandklemmen_li.st_ctrl.out.b_eingefahren AND
				zyl_bandfaenger_re.st_ctrl.out.b_eingefahren AND
				zyl_bandklemmen_re.st_ctrl.out.b_eingefahren
				THEN
					zyl_bandfaenger_li.st_ctrl.in.b_einfahren := FALSE;
					zyl_bandklemmen_li.st_ctrl.in.b_einfahren := FALSE;
					zyl_bandfaenger_re.st_ctrl.in.b_einfahren := FALSE;
					zyl_bandklemmen_re.st_ctrl.in.b_einfahren := FALSE;
					IF i16_merker_last_state = 150 THEN
						fb_state_entry.i16_next_step := 425;
					ELSE
						fb_state_entry.i16_next_step := 440;
					END_IF
			END_IF
		END_IF

(*=======================================================*)
	425: (* Bestückachse mit Bandeinzug steht. Virtuelle Masterachse nochmals eine Umdrehung fahren ohne zu Bestücken, damit Z und Y noch eine Position weiter fahren *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := MOVE_MODULO;
			fb_virt_master_axis.mc_richtung_modulo := MC_Positive_Direction  ;
(**)			fb_virt_master_axis.st_position.r_soll := 360 + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			fb_berechnung_override_achse.lr_skalierung_slave_achse1 := fb_berechnung_override_achse.lr_skalierung_slave_achse2 := 1;
			bandeinzug_kontroller.st_ctrl.in.b_freigabe := FALSE;
		END_IF

		IF fb_r_trig_bestueckhubzaehler.Q THEN
			(* Positionsüberwachung Achsen *)
			subr_ST_PosUW_Z_Achse();

			(* Den Bestückposzähler hier nicht erhöhen, weil auch kein Pin gesetzt wird *)
			i16_bestueckposzaehler := i16_bestueckposzaehler + 1;
		END_IF

		(* Warte auf OT-Nocken für Skalierungsfreigabe *)
		IF fb_f_trig_ot.Q THEN
			(* Skalierung der Kurvenscheibe *)
			subr_ST_Cam_Bestueckachse();
		END_IF

		(* Warte auf Nocken für die Skalierungsfreigabe *)
		IF fb_r_trig_skalierungsnocken.Q THEN
			(* Skalierung der Kurvenscheibe *)
			subr_ST_Cam_Z_Achse();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Bestückachse auf Startposition *)
		IF	virtuelle_master_achse.Status.NotMoving  AND virtuelle_master_achse.Status.InTargetPosition AND
			st_drive_cmd.enu_cmd = NO_COMMAND AND
			st_drive_cmd_z_achse.enu_cmd = NO_COMMAND
			THEN
				fb_state_entry.i16_next_step := 430;
		END_IF

(*=======================================================*)
	430:	(* Z-Achse muss entkoppelt werden, damit sie bei den Einfädelhüben nicht mitfahren *)
		IF fb_state_entry.E THEN
			st_drive_cmd_z_achse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_z_achse.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 440;
		END_IF

(*=======================================================*)
	440:	(* Meldung und warte auf Bediener *)
		IF fb_state_entry.E THEN
			bm_bandende_beide_einzuege_erreicht := FALSE;
			bm_einzug_links_band_entnehmen := TRUE;
			bm_einzug_rechts_band_entnehmen := TRUE;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[4];(*Band an beiden Einzügen entnehmen -> Taste TIPPEN.*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Bei Tastendruck darf sich kein Band im entsprechenden Einzug befinden *)
		IF	 ST_TippTasten.r_trig_tippen_einfaedeln.Q AND
			NOT e_ls_bandende_li AND NOT e_ls_bandende_re THEN
			fb_state_entry.i16_next_step := 450;
		END_IF

(*=======================================================*)
	450:	(* Gearin Bestückachse  *)
		IF fb_state_entry.E THEN
			fb_axis_bestueckachse.r_getriebefaktor := axis_bestueckachse.st_config.r_getriebefaktor;
			st_drive_cmd_bestueckachse.enu_cmd := GEAR_IN_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_bestueckachse.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 455;
		END_IF

(*=======================================================*)
	455:	(* Fahre auf UT *)
		IF fb_state_entry.E THEN
			bm_einzug_links_band_entnehmen := FALSE;
			bm_einzug_rechts_band_entnehmen := FALSE;
			bm_an_visu_hinten := '';

			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_wkz.lr_einfaedelposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 460;
		END_IF

(*=======================================================*)
	460:	(* Meldung und warte auf Bediener *)
		IF fb_state_entry.E THEN
			bm_einzug_links_band_auf_anschlag := TRUE;
			bm_einzug_rechts_band_auf_anschlag := TRUE;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[7];(*Band an beiden Einzügen auf Anschlag in WKZ -> Taste TIPPEN.*)
		END_IF

		IF ST_TippTasten.r_trig_tippen_einfaedeln.Q THEN
			bm_einzug_links_band_auf_anschlag := FALSE;
			bm_einzug_rechts_band_auf_anschlag := FALSE;
			bm_an_visu_hinten := '';
			fb_ton_wz.PT := t#200ms;
			fb_ton_wz.IN := TRUE;

			(* Zylinder ausfahren *)
			(* Klemme das Linke und Rechte Band *)
			zyl_bandfaenger_li.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandfaenger_li.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bandklemmen_li.st_ctrl.in.b_einfahren := FALSE;
			zyl_bandklemmen_li.st_ctrl.in.b_ausfahren := TRUE;

			zyl_bandfaenger_re.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandfaenger_re.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bandklemmen_re.st_ctrl.in.b_einfahren := FALSE;
			zyl_bandklemmen_re.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			IF 	zyl_bandfaenger_li.st_ctrl.out.b_eingefahren AND
				zyl_bandklemmen_li.st_ctrl.out.b_ausgefahren AND
				zyl_bandfaenger_re.st_ctrl.out.b_eingefahren AND
				zyl_bandklemmen_re.st_ctrl.out.b_ausgefahren
				THEN
					zyl_bandfaenger_li.st_ctrl.in.b_einfahren := FALSE;
					zyl_bandklemmen_li.st_ctrl.in.b_ausfahren := FALSE;
					zyl_bandfaenger_re.st_ctrl.in.b_einfahren := FALSE;
					zyl_bandklemmen_re.st_ctrl.in.b_ausfahren := FALSE;
					fb_state_entry.i16_next_step := 470;
					fb_ton_wz.IN := FALSE;
			END_IF
		END_IF

(*=======================================================*)
	470:	(* Warte kurz auf Zylinder *)
		IF fb_state_entry.E THEN
 			fb_ton_wz.PT := t#1s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 475;
		END_IF

(*=======================================================*)
	475:	(* Fahre auf OT - beide Bänder sind geklemmt *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[1];(*Werkzeug fährt auf OT.*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 480;
		END_IF

(*=======================================================*)
	480:	(* Entsprechende Zylinder wieder den Nocken überlassen *)

		(* Links -> Nockenfahrt / Rechts -> Nockenfahrt *)
		zyl_bandfaenger_li.st_ctrl.in.b_einfahren := FALSE;
		zyl_bandfaenger_li.st_ctrl.in.b_ausfahren := FALSE;
		zyl_bandklemmen_li.st_ctrl.in.b_einfahren := FALSE;
		zyl_bandklemmen_li.st_ctrl.in.b_ausfahren := FALSE;

		zyl_bandfaenger_re.st_ctrl.in.b_einfahren := FALSE;
		zyl_bandfaenger_re.st_ctrl.in.b_ausfahren := FALSE;
		zyl_bandklemmen_re.st_ctrl.in.b_einfahren := FALSE;
		zyl_bandklemmen_re.st_ctrl.in.b_ausfahren := FALSE;

		(* Alle Nocken aktivieren, damit die Zylinder wieder winkelgesteuert werden *)
		subr_ST_Bandeinzugsnocken_ein();

		zyl_bandfaenger_li.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandklemmen_li.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandfaenger_re.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandklemmen_re.fb.b_no_gesteuert_im_norm_betrieb := FALSE;

		fb_state_entry.i16_next_step := 490;

(*=======================================================*)
	490: (* Band neu eingefädelt: Fahre Einfädelhübe und starte dann wieder Bestückzyklus *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := (INT_TO_LREAL(gst_datensatz.st_wkz.i16_anzahl_einfaedel_pins)) * 360.0 + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[2];(*Anstanzhübe werden aktuell gefahren.*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN

			(* Alle Nocken aktivieren, damit die Zylinder wieder winkelgesteuert werden *)
			subr_ST_Bandeinzugsnocken_ein();

			bm_an_visu_hinten := '';
			bm_an_visu_hinten := '';

			fb_state_entry.i16_next_step := 500;
		END_IF

(*=======================================================*)
	500:(* Band Scannen*)
		IF 	fb_state_entry.E THEN
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[3];(*Band scannen*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gst_barcode_daten.b_band_ok THEN
			IF	ST_TippTasten.b_einfaedeln_aktiv  THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSE
				IF i16_merker_last_state = 150 THEN
					(* Bandende während Bestückablauf *)
					fb_state_entry.i16_next_step := 510;
				ELSE
					(* Bandende aus Step BEREIT oder Step 110 *)
					fb_state_entry.i16_next_step := i16_merker_last_state;
				END_IF
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			ST_TippTasten.b_einfaedeln_aktiv:=FALSE;
			b_merker_bandende_links := FALSE;
			b_merker_bandende_rechts := FALSE;
			bm_an_visu_hinten := '';
		END_IF

(*=======================================================*)
	510:	(* Fahre vorgegebene Anzahl von Bestückhüben *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.st_position.r_soll := (DINT_TO_LREAL(gst_datensatz.st_bestueckprogramm.i32_anzahl - i16_bestueckposzaehler)) * 360.0 + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;	(* Achtung beim MODULO-Befehl: fährt nur bis 360° *)
			fb_virt_master_axis.mc_richtung_modulo :=MC_Positive_Direction ;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 150;

(*=======================================================*)
	640:	(* Cam_in_Slave*)
		IF fb_state_entry.E THEN
			ST_TippTasten.b_einfaedeln_aktiv := TRUE;
			b_einfaedeln_aktiv_servo := TRUE;
			bandeinzug_kontroller.st_ctrl.in.b_freigabe := FALSE;           (* GLS überwachung ausschalten*)
			i16_bestueckachse_cam_table_id := 5;
			fb_axis_bestueckachse.mc_activation_mode_camin:= MC_CAMACTIVATION_ATMASTERCAMPOS;
			fb_axis_bestueckachse.lr_activation_position_camin := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd_bestueckachse.enu_cmd := CAM_IN_SLAVE;
			i16_bestueckachse_cam_table_id_alt := i16_bestueckachse_cam_table_id;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_bestueckachse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 645;
		END_IF

(*=======================================================*)
	645:	(* Starte automatischen Bandwechsel bzw. manueller Wechsel bis Band heraus gezogen wurde *)
		(* Die Bremse des Servobandeinzugs wird im Bandwechselablauf angesteuert *)
		IF fb_state_entry.E THEN
			bandwechsel_kontroller.st_ctrl.in.b_start := TRUE;
			fb_ton_wz.pt := t#300ms;
			fb_ton_wz.IN := TRUE;
			gi16_anzahl_Teile_autostop_bandwechsel := 0;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bandwechsel_kontroller.st_ctrl.out.b_fertig AND NOT fb_state_entry.E AND fb_ton_wz.Q THEN
		(*Bandwechsel ist vollzogen und die Seite wurde getauscht *)
			bandwechsel_kontroller.st_ctrl.in.b_start := FALSE;
			bm_bandende_einzug_links_erreicht := FALSE;
			bm_bandende_einzug_rechts_erreicht := FALSE;
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 650;
		(*Es ist kein Band im anderen Einzug. Gleiche Seite wird wieder verwendet *)
		ELSIF bandwechsel_kontroller.st_ctrl.out.b_fertig_2 AND NOT fb_state_entry.E AND fb_ton_wz.Q THEN
			bandwechsel_kontroller.st_ctrl.in.b_start := FALSE;
			bm_bandende_einzug_links_erreicht := FALSE;
			bm_bandende_einzug_rechts_erreicht := FALSE;
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 700;
		END_IF

(*=======================================================*)
	650:	(* Gearin Bestückachse  *)
		IF fb_state_entry.E THEN
			fb_axis_bestueckachse.r_getriebefaktor := axis_bestueckachse.st_config.r_getriebefaktor;
			st_drive_cmd_bestueckachse.enu_cmd := GEAR_IN_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_bestueckachse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 655;
		END_IF

(*=======================================================*)
	655:	(* Fahre auf UT *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_wkz.lr_einfaedelposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 660;
		END_IF

(*=======================================================*)
	660:	(* Starte Einfädelprozedur Servobandeinzug *)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_start := TRUE;
			axis_bandeinzug_achse.st_ctrl.in.b_einfaedeln_servo := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_start := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_einfaedeln_servo := FALSE;
			fb_state_entry.i16_next_step := 665;
		END_IF

(*=======================================================*)
	665:	(* Bremse an Servobandeinzug wieder fest. *)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_bremse_zu := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_bremse_geschlossen AND NOT fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_bremse_zu := FALSE;
			fb_state_entry.i16_next_step := 670; (* Überspringe schreiben *)
		END_IF

(*=======================================================*)
	670:	(* Fahre auf OT - Band ist fest *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[1];(*Werkzeug fährt auf OT.*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 675;
		END_IF

(*=======================================================*)
	675:	(* Band neu eingefädelt: Fahre Einfädelhübe und starte dann wieder Bestückzyklus *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := MOVE_MODULO;
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_wkz.i16_anzahl_einfaedel_pins * 360.0 + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			i16_einfaedelzaehler := 0;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[2];(*Anstanzhübe werden aktuell gefahren.*)
		END_IF

		(* Warte auf Nocken für die Skalierungsfreigabe *)
		IF fb_r_trig_skalierungsnocken.Q THEN
			fb_axis_b_achse.st_camscaling_data.SlaveScaling := F_Servobandeinzug_Strecke_zu_Grad( strecke := gst_datensatz.st_band.r_raster);
			i16_einfaedelzaehler := i16_einfaedelzaehler + 1;

			IF b_achse.Status.CamScalingPending THEN
				st_sm.b_skalierung_noch_aktiv := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			ELSE
				IF b_achse.NcToPlc.CoupleState = 0 THEN
					st_drive_cmd_b_achse.enu_cmd := CAM_IN_SLAVE;
				ELSE
					st_drive_cmd_b_achse.enu_cmd := CAM_SCALEING_SLAVE;
				END_IF
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND AND st_drive_cmd_b_achse.enu_cmd = NO_COMMAND THEN;
			ST_TippTasten.b_einfaedeln_aktiv := FALSE;
			b_einfaedeln_aktiv_servo := FALSE;
			bm_an_visu_hinten := '';
			IF i16_merker_last_state = 100 THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSIF i16_merker_last_state = 150 THEN
				fb_state_entry.i16_next_step := 680;
			ELSE
				sm_fehler_nach_bandwechsel := TRUE;
				(* Dieser Fehler soll kommen, damit Bediener Chargennummer des Bandes ins LTS einträgt, Wunsch von Sebastian Hechenrieder 27.11.17 *)
				fb_state_entry.i16_next_step := FEHLER;(*BEREIT*)
			END_IF
		END_IF

(*=======================================================*)
	680:	(* Fahre vorgegebene Anzahl von Bestückhüben *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.st_position.r_soll := (DINT_TO_LREAL(gst_datensatz.st_bestueckprogramm.i32_anzahl - i16_bestueckposzaehler)) * 360.0 + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;	(* Achtung beim MODULO-Befehl: fährt nur bis 360° *)
			fb_virt_master_axis.mc_richtung_modulo :=MC_Positive_Direction ;
		END_IF

		(* Warte auf Nocken für die Skalierungsfreigabe *)
		IF fb_r_trig_skalierungsnocken.Q THEN
			subr_ST_Cam_B_Achse();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_bestueckhubzaehler.Q THEN
			(* Zählt die gesetzten Pins während des gesamten Bestückvorganges *)
			i16_bestueckposzaehler := i16_bestueckposzaehler + 1;
			(* Sobald ein Pin gesetzt wurde, wird in den regulären Ablauf mit Camming gesprungen *)
			fb_state_entry.i16_next_step := 150;
		END_IF

(*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*)
(*===========================Anstanzen 1700 mit Servobandeinzug============================*)
	700:	(* Bandende im linken oder rechten Einzug ohne Bandwechsel ->Meldung und warte auf Bediener *)
		IF fb_state_entry.E THEN
			bm_bandende_einzug_links_erreicht := FALSE;
			bm_bandende_einzug_rechts_erreicht := FALSE;
			IF b_merker_bandende_links THEN
				bm_einzug_links_band_entnehmen := TRUE;
			ELSIF b_merker_bandende_rechts THEN
				bm_einzug_rechts_band_entnehmen := TRUE;
			END_IF
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[0];(*Band am Einzug entnehmen -> Taste TIPPEN.*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_TippTasten.r_trig_tippen_einfaedeln.Q THEN
			(* Bei Tastendruck darf sich kein Band im Einzug befinden *)
			IF b_merker_bandende_links THEN
				IF NOT e_ls_bandende_li THEN
					fb_state_entry.i16_next_step := 710;
				END_IF
			ELSIF b_merker_bandende_rechts THEN
				IF NOT e_ls_bandende_re THEN
					fb_state_entry.i16_next_step := 710;
				END_IF
			END_IF
		END_IF

(*=======================================================*)
	710:	(* Gearin Bestückachse  *)
		IF fb_state_entry.E THEN
			fb_axis_bestueckachse.r_getriebefaktor := axis_bestueckachse.st_config.r_getriebefaktor;
			st_drive_cmd_bestueckachse.enu_cmd := GEAR_IN_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_bestueckachse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 720;
		END_IF

(*=======================================================*)
	720:	(* Fahre auf UT *)
		IF fb_state_entry.E THEN
			bm_einzug_links_band_entnehmen := FALSE;
			bm_einzug_rechts_band_entnehmen := FALSE;
			bm_an_visu_hinten := '';

			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_wkz.lr_einfaedelposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 725;
		END_IF

(*=======================================================*)
	725:	(* Fahre Igelrad auf Position*)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_startpos := TRUE;
			fb_ton_wz.PT := t#100ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_servo_auf_einfaedelpos AND fb_ton_wz.Q THEN
			axis_bandeinzug_achse.st_ctrl.in.b_startpos := FALSE;
			fb_state_entry.i16_next_step := 730;
		END_IF

		IF fb_state_entry.X THEN
			fb_ton_wz.IN := FALSE;
		END_IF

(*=======================================================*)
	730:	(* Meldung Band in Igelrad einführen *)
		IF fb_state_entry.E THEN
			IF b_merker_bandende_links THEN
				bm_einzug_links_band_bis_gls := TRUE;
			ELSIF b_merker_bandende_rechts THEN
				bm_einzug_rechts_band_bis_gls := TRUE;
			END_IF
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[10];(*Band bis zum Igelrad einschieben -> Taste Servo manuell fahren *)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 735;

(*=======================================================*)
	735:	(* Starte Einfädelprozedur Servobandeinzug *)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 740;
		END_IF

(*=======================================================*)
	740:	(* Bremse an Servobandeinzug wieder fest. *)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_bremse_zu := TRUE;
			bm_einzug_rechts_band_bis_gls := FALSE;
			bm_einzug_links_band_bis_gls := FALSE;
			bm_an_visu_hinten := '';
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_bremse_geschlossen AND NOT fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_bremse_zu := FALSE;
			fb_state_entry.i16_next_step := 750;
		END_IF

(*=======================================================*)
	750:	(* Fahre auf OT - Band ist fest *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[1];(*Werkzeug fährt auf OT.*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 770;
		END_IF

(*=======================================================*)
	770:	(* Band neu eingefädelt: Fahre Einfädelhübe und starte dann wieder Bestückzyklus *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := MOVE_MODULO;
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_wkz.i16_anzahl_einfaedel_pins * 360.0 + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			i16_einfaedelzaehler := 0;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[2];(*Anstanzhübe werden aktuell gefahren.*)
		END_IF

		(* Warte auf Nocken für die Skalierungsfreigabe *)
		IF fb_r_trig_skalierungsnocken.Q THEN
			IF (i16_einfaedelzaehler = 0) THEN
				fb_axis_b_achse.st_camscaling_data.SlaveScaling := F_Servobandeinzug_Strecke_zu_Grad( strecke := gst_datensatz.st_band.r_raster + gst_datensatz.st_band.lr_offset_erster_hub_wkz_mm);
			ELSE
				fb_axis_b_achse.st_camscaling_data.SlaveScaling := F_Servobandeinzug_Strecke_zu_Grad( strecke := gst_datensatz.st_band.r_raster);
			END_IF
			i16_einfaedelzaehler := i16_einfaedelzaehler + 1;

			IF b_achse.Status.CamScalingPending THEN
				st_sm.b_skalierung_noch_aktiv := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			ELSE
				IF b_achse.NcToPlc.CoupleState = 0 THEN
					st_drive_cmd_b_achse.enu_cmd := CAM_IN_SLAVE;
				ELSE
					st_drive_cmd_b_achse.enu_cmd := CAM_SCALEING_SLAVE;
				END_IF
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			bm_an_visu_hinten := '';
			b_einfaedeln_aktiv_servo := FALSE;
			fb_state_entry.i16_next_step := 780;
		END_IF

(*=======================================================*)
	780:	(* Band Scannen*)
		IF 	fb_state_entry.E THEN
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[3];(*Band scannen*)
		END_IF

		IF 	(gst_barcode_daten.b_band_links_ok AND gst_barcode_daten.b_band_ID_links_ok AND zyl_bandeinzuege_verschieben.st_ctrl.out.b_ausgefahren)OR
			(gst_barcode_daten.b_band_rechts_ok AND gst_barcode_daten.b_band_ID_rechts_ok AND zyl_bandeinzuege_verschieben.st_ctrl.out.b_eingefahren)
			THEN
				IF	ST_TippTasten.b_einfaedeln_aktiv THEN
					fb_state_entry.i16_next_step := BEREIT;
				ELSE
					IF i16_merker_last_state = 150 THEN
						(* Bandende während Bestückablauf *)
						fb_state_entry.i16_next_step := 790;
					ELSE
						(* Bandende aus Step BEREIT *)
						fb_state_entry.i16_next_step := BEREIT;
					END_IF
				END_IF
		END_IF

		IF fb_state_entry.X THEN
			ST_TippTasten.b_einfaedeln_aktiv:=FALSE;
			b_merker_bandende_links := FALSE;
			b_merker_bandende_rechts := FALSE;
			bm_an_visu_hinten := '';
		END_IF

(*=======================================================*)
	790:	(* Fahre vorgegebene Anzahl von Bestückhüben *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.st_position.r_soll := ((gst_datensatz.st_bestueckprogramm.i32_anzahl - i16_bestueckposzaehler) * 360.0) + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;	(* Achtung beim MODULO-Befehl: fährt nur bis 360° *)
			fb_virt_master_axis.mc_richtung_modulo :=MC_Positive_Direction ;
			ST_TippTasten.b_einfaedeln_aktiv := FALSE;
		END_IF

		(* Warte auf Nocken für die Skalierungsfreigabe *)
		IF fb_r_trig_skalierungsnocken.Q THEN
			subr_ST_Cam_B_Achse();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_bestueckhubzaehler.Q THEN
			(* Zählt die gesetzten Pins während des gesamten Bestückvorganges *)
			i16_bestueckposzaehler := i16_bestueckposzaehler + 1;
			(* Sobald ein Pin gesetzt wurde wird in den regulären Ablauf mit Camming gesprungen *)
			fb_state_entry.i16_next_step := 150;
		END_IF

(*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*)
(*===========================Rasterfolie============================*)
	800:	(* Fahre nur einen Hub zum Rasterfolien setzen *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := 360 + gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
		END_IF

		(* Rasterfolieneinzug lüften
		Dies wird nur gemacht, wenn die Nocken ungleich 0 sind und Anfangs- und Endnocke aunterschiedlich sind 
		Zwischen den Nocken wird die Rasterfolie vom Werkzeug gehalten *)
		IF gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_RASTERFOLIE_LUEFTEN].r_cam_begin <> 0 AND
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_RASTERFOLIE_LUEFTEN].r_cam_begin <> gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_RASTERFOLIE_LUEFTEN].r_cam_end THEN
			IF st_visu.i32_position_ist > gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_RASTERFOLIE_LUEFTEN].r_cam_begin AND
				st_visu.i32_position_ist < (gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_RASTERFOLIE_LUEFTEN].r_cam_begin + 5) THEN
				zyl_rafo_klemmen.st_ctrl.in.b_einfahren := TRUE;
			ELSE
				zyl_rafo_klemmen.st_ctrl.in.b_einfahren := FALSE;
			END_IF

			IF st_visu.i32_position_ist > gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_RASTERFOLIE_LUEFTEN].r_cam_end AND
				st_visu.i32_position_ist < (gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_RASTERFOLIE_LUEFTEN].r_cam_end + 5) THEN
				zyl_rafo_faenger.st_ctrl.in.b_ausfahren := TRUE;
			ELSE
				zyl_rafo_faenger.st_ctrl.in.b_ausfahren := FALSE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*===========================Rasterfolie Einfädelvorgang============================*)
	810:	(* Fänger einfahren, damit das Band drunter geschoben werden kann *)
		IF fb_state_entry.E THEN
			ST_TippTasten.b_einfaedeln_aktiv:=TRUE;
			zyl_rafo_faenger.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_faenger.st_ctrl.out.b_eingefahren THEN
			zyl_rafo_faenger.st_ctrl.in.b_einfahren := FALSE;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[0];(*Band am Einzug entnehmen -> Taste TIPPEN.*)
			IF ST_TippTasten.r_trig_tippen_einfaedeln.Q  THEN
				fb_state_entry.i16_next_step := 820;
			END_IF
		END_IF

(*=======================================================*)
	820:	(* Meldung fahre Werkzeug auf UT *)
		IF fb_state_entry.E THEN
			bm_an_visu_hinten := '';
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_wkz.lr_einfaedelposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 830;
		END_IF

(*=======================================================*)
	830:	(* Rasterfolie von Hand einschieben und bestätigen *)

		IF fb_state_entry.E THEN
			bm_einzug_links_band_auf_anschlag := TRUE;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[8];(*Band an Einzug links auf Anschlag in WKZ -> Taste TIPPEN.*)
		END_IF

		IF ST_TippTasten.r_trig_tippen_einfaedeln.Q  THEN
			bm_einzug_links_band_auf_anschlag := FALSE;
			bm_an_visu_hinten := '';

			(* Fange das Band *)
			zyl_rafo_faenger.st_ctrl.in.b_einfahren := FALSE;
			zyl_rafo_faenger.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_faenger.st_ctrl.out.b_ausgefahren THEN
			zyl_rafo_faenger.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 840;
		END_IF

(*=======================================================*)
	840:	(* Fahre auf OT - Band ist fest *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
			bm_an_visu_hinten :=  visu_hinten.in.texte.txt_bm_einfaedeln[1];(*Werkzeug fährt auf OT.*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			bm_an_visu_hinten := '';
			ST_TippTasten.b_einfaedeln_aktiv := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*)
(*===========================Werkzeug Ausbauposition============================*)
	900:	(* Fahre zur Ausbauposition des Werkzeugs *)
		IF fb_state_entry.E THEN
			fb_virt_master_axis.mc_richtung_modulo :=  MC_Positive_Direction  ;
			fb_virt_master_axis.st_position.r_soll := gst_datensatz.st_wkz.lr_ausbauposition;
			st_drive_cmd.enu_cmd := MOVE_MODULO;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 905;
		END_IF

(*=======================================================*)
	905: (*Warten bis keine ander Produktions Meldung ansteht *)
		IF	TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			fb_state_entry.i16_next_step := 910;
		END_IF

(*=======================================================*)
	910:  (*Produktions Meldung*)
		Visu.MeldungProduktion.Color_R := 255;
		Visu.MeldungProduktion.Color_G := 0;
		Visu.MeldungProduktion.Color_B := 0;
		IF visu.s_akt_sprache = 'de' THEN
			Visu.MeldungProduktion.Name:='Werkzeug kann ausgebaut werden. Weiter mit OK';
		ELSIF visu.s_akt_sprache = 'en' THEN
			Visu.MeldungProduktion.Name:='Tool can now be removed. Confirm with OK';
		ELSIF visu.s_akt_sprache = 'cz' THEN
			Visu.MeldungProduktion.Name:='Nastroj muze byt vyjmut. Pokracovat pres OK';
		END_IF
		Visu.MeldungProduktion.ShowMessage := TRUE;
		Visu.MeldungProduktion.Button1.sichtbar:=TRUE;	(*OK*)
		Visu.MeldungProduktion.Button1.Text:='Ok';
		fb_state_entry.i16_next_step := 915;

(*=======================================================*)
	915:  (*Warte auf OK*)
		IF Visu.MeldungProduktion.Button1.tasten THEN
			fb_state_entry.i16_next_step:=FEHLER;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;

		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_drive_cmd.enu_cmd := RESET;
			st_drive_cmd_bestueckachse.enu_cmd := RESET;
			st_drive_cmd_z_achse.enu_cmd := RESET;
			st_drive_cmd_y_achse.enu_cmd := RESET;
			st_drive_cmd_b_achse.enu_cmd := RESET;
			fb_ton_quitt.IN := TRUE;

		END_IF

		IF st_ctrl_in.b_stop AND NOT virtuelle_master_achse.Status.HasBeenStopped THEN
			st_drive_cmd.enu_cmd := STOP_AXIS;
		END_IF

		IF st_ctrl_in.b_halt AND virtuelle_master_achse.Status.Moving THEN
			st_drive_cmd.enu_cmd := HALT_AXIS;
			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_nothalt;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := STOP_AXIS;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND AND virtuelle_master_achse.Status.NotMoving THEN
			fb_state_entry.i16_next_step := STILLSTAND;
		END_IF

(*=======================================================*)
	STILLSTAND:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
			fb_ton_quitt.IN := FALSE;

		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HALT:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := HALT_AXIS;
			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_nothalt;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config_achse.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 0] := st_sm.b_achse_nicht_bb;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 1] := st_sm.b_achse_nicht_referenziert;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 2] := st_sm.b_keine_verfahrfreigabe;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 3] := st_sm.b_achse_nicht_auf_startpos;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 4] := st_sm.b_ende_skalierungs_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 5] := st_sm.b_ende_camming_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 6] := st_sm.b_skalierung_noch_aktiv;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 9] := sm_fehler_raster_oder_zaehne;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 12] := sm_fehler_achse_lueften;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 13] := sm_keine_busverbindung;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 14] := sm_fehler_bestueckanzahl;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 15] := sm_fehler_nach_bandwechsel;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 16] := st_drive_cmd.meldungen.sm_write_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 17] := st_drive_cmd.meldungen.sm_read_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 18] := st_drive_cmd.meldungen.sm_write_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 19] := st_drive_cmd.meldungen.sm_read_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 20] := st_drive_cmd.meldungen.sm_power_enable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 21] := st_drive_cmd.meldungen.sm_power_disable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 22] := st_drive_cmd.meldungen.sm_reset;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 23] := st_drive_cmd.meldungen.sm_home;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 24] := st_drive_cmd.meldungen.sm_setposition;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 25] := st_drive_cmd.meldungen.sm_jog_vorwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 26] := st_drive_cmd.meldungen.sm_jog_rueckwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 27] := st_drive_cmd.meldungen.sm_move_absolute;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 28] := st_drive_cmd.meldungen.sm_move_relative;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 29] := st_drive_cmd.meldungen.sm_move_velocity;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 30] := st_drive_cmd.meldungen.sm_move_modulo;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 31] := st_drive_cmd.meldungen.sm_stop_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 32] := st_drive_cmd.meldungen.sm_halt_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 33] := st_drive_cmd.meldungen.sm_motion_command_timeout;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 34] := st_sm.b_achsfehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 35] := st_sm.b_devicefehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 36] := st_drive_cmd.meldungen.sm_limit_positiv_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 37] := st_drive_cmd.meldungen.sm_limit_negativ_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 38] := st_drive_cmd.meldungen.sm_ec_coe_sdo_write_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 39] := st_drive_cmd.meldungen.sm_ec_coe_sdo_read_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 40] := st_drive_cmd_z_achse.meldungen.sm_gear_in_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 41] := st_drive_cmd_z_achse.meldungen.sm_gear_out_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 42] := st_drive_cmd_z_achse.meldungen.sm_cam_in_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 43] := st_drive_cmd_z_achse.meldungen.sm_cam_out_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 44] := st_drive_cmd_z_achse.meldungen.sm_cam_scaleing_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 45] := st_drive_cmd_z_achse.meldungen.sm_camgear_command_timeout;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 46] := st_drive_cmd_z_achse.meldungen.sm_read_motion_funktion_point;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 47] := st_drive_cmd_z_achse.meldungen.sm_write_motion_funktion_point;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 48] := st_drive_cmd_z_achse.meldungen.sm_read_camtable_slave_dynamics;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 49] := st_drive_cmd_z_achse.meldungen.sm_read_camtable_charakteristik;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 50] := st_drive_cmd_y_achse.meldungen.sm_gear_in_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 51] := st_drive_cmd_y_achse.meldungen.sm_gear_out_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 52] := st_drive_cmd_y_achse.meldungen.sm_cam_in_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 53] := st_drive_cmd_y_achse.meldungen.sm_cam_out_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 54] := st_drive_cmd_y_achse.meldungen.sm_cam_scaleing_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 55] := st_drive_cmd_y_achse.meldungen.sm_camgear_command_timeout;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 56] := st_drive_cmd_y_achse.meldungen.sm_read_motion_funktion_point;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 57] := st_drive_cmd_y_achse.meldungen.sm_write_motion_funktion_point;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 58] := st_drive_cmd_y_achse.meldungen.sm_read_camtable_slave_dynamics;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 59] := st_drive_cmd_y_achse.meldungen.sm_read_camtable_charakteristik;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 60] := st_drive_cmd_b_achse.meldungen.sm_gear_in_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 61] := st_drive_cmd_b_achse.meldungen.sm_gear_out_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 62] := st_drive_cmd_b_achse.meldungen.sm_cam_in_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 63] := st_drive_cmd_b_achse.meldungen.sm_cam_out_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 64] := st_drive_cmd_b_achse.meldungen.sm_cam_scaleing_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 65] := st_drive_cmd_b_achse.meldungen.sm_camgear_command_timeout;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 66] := st_drive_cmd_b_achse.meldungen.sm_read_motion_funktion_point;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 67] := st_drive_cmd_b_achse.meldungen.sm_write_motion_funktion_point;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 68] := st_drive_cmd_b_achse.meldungen.sm_read_camtable_slave_dynamics;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 69] := st_drive_cmd_b_achse.meldungen.sm_read_camtable_charakteristik;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 70] :=  sm_fehler_positionierung_z;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 71] :=  sm_fehler_positionierung_y;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 72] :=  sm_fehler_bestueckschieberanzahl;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 73] :=  sm_fehler_bestueckposition_z;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 74] :=  sm_fehler_bestueckposition_y;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 75] :=  sm_fehler_positionierung_bestueckachse;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 76] :=  st_drive_cmd_bestueckachse.meldungen.sm_gear_in_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 77] :=  st_drive_cmd_bestueckachse.meldungen.sm_gear_out_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 78] :=  st_drive_cmd_bestueckachse.meldungen.sm_cam_in_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 79] :=  st_drive_cmd_bestueckachse.meldungen.sm_cam_out_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 80] :=  st_drive_cmd_bestueckachse.meldungen.sm_camgear_command_timeout;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 81] :=  st_drive_cmd_bestueckachse.meldungen.sm_read_motion_funktion_point;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 82] :=  st_drive_cmd_bestueckachse.meldungen.sm_write_motion_funktion_point;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 83] :=  st_drive_cmd_bestueckachse.meldungen.sm_read_camtable_slave_dynamics;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 84] :=  st_drive_cmd_bestueckachse.meldungen.sm_read_camtable_charakteristik;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 85] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 86] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 87] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 88] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 89] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 90] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 91] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 92] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 93] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 94] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 95] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 96] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 97] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 98] :=  FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 99] :=  FALSE;
	
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 0] := bm_bandende_einzug_links_erreicht;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 1] := bm_einzug_links_band_entnehmen;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 2] := bm_einzug_links_band_auf_anschlag;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 10] := bm_bandende_einzug_rechts_erreicht;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 11] := bm_einzug_rechts_band_entnehmen;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 12] := bm_einzug_rechts_band_auf_anschlag;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 19] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 20] := bm_bandende_beide_einzuege_erreicht;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 21] := bm_override_kleiner_stufe9;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 22] := bm_md_offset_z_pos_0_zu_hoch;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 23] := bm_md_offset_y_pos_0_zu_hoch;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 24] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 25] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 26] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 27] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 28] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 29] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 30] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 31] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 32] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 33] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 34] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 35] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 36] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 37] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 38] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 39] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 40] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 41] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 42] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 43] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 44] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 45] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 46] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 47] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 48] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 49] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 50] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 51] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 52] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 53] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 54] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 55] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 56] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 57] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 58] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 59] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 60] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 61] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 62] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 63] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 64] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 65] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 66] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 67] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 68] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 69] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 70] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 71] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 72] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 73] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 74] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 75] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 76] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 77] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 78] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 79] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 80] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 81] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 82] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 83] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 84] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 85] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 86] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 87] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 88] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 89] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 90] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 91] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 92] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 93] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 94] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 95] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 96] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 97] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 98] :=  FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 99] :=  FALSE;
END_IF
END_PROGRAM
ACTION	subr_ST_B_Achse:
(* Überwachung, wenn falsche Info aus dem Bestückbild kommt *)
(* Fehler, wenn mehr bestückt werden soll als das WKZ Bestückschieber hat *)
IF gst_datensatz.st_bestueckprogramm.i16_b[i16_bestueckposzaehler] > gst_datensatz.st_wkz.i16_anzahl_bestueckschieber THEN
	sm_fehler_bestueckschieberanzahl := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
END_IF
END_ACTION

ACTION	subr_ST_Bandeinzugsnocken_aus:
CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
	 STANDARD_2FACH_V2:

		(* Bandeinzug: Standard_2fach_V1 *)
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_LI_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_LI_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_LI_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_LI_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_RE_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_RE_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_RE_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_RE_AUSFAHREN].b_camvalid := FALSE;
		(* Bandeinzug: Standard_2fach_V2 *)
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_BAEZV2_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_BAEZV2_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_BAEZV2_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_BAEZV2_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_BAEZV2_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_BAEZV2_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_BAEZV2_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_BAEZV2_AUSFAHREN].b_camvalid := FALSE;

		zyl_bandfaenger_li.fb.b_no_gesteuert_im_norm_betrieb := TRUE;
		zyl_bandklemmen_li.fb.b_no_gesteuert_im_norm_betrieb := TRUE;
		zyl_bandfaenger_re.fb.b_no_gesteuert_im_norm_betrieb := TRUE;
		zyl_bandklemmen_re.fb.b_no_gesteuert_im_norm_betrieb := TRUE;

	BANDWECHSLER_V2:
		(* Klemmbandeinzug ohne Sensoren *)
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN].b_camvalid := FALSE;

		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_AUSFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_EINFAHREN].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_AUSFAHREN].b_camvalid := FALSE;

		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_PNEUMATIKBANDEINZUG_GLS].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BESTUECKSCHIEBER_ON].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BESTUECKSCHIEBER_OFF].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_UW_BESTUECKSCHIEBER_ON].b_camvalid := FALSE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_UW_BESTUECKSCHIEBER_OFF].b_camvalid := FALSE;


		zyl_bandfaenger.fb.b_no_gesteuert_im_norm_betrieb := TRUE;
		zyl_bandklemmen.fb.b_no_gesteuert_im_norm_betrieb := TRUE;

		zyl_bandfaenger.fb.b_no_gesteuert_im_norm_betrieb := TRUE;
		zyl_bandklemmen.fb.b_no_gesteuert_im_norm_betrieb := TRUE;

END_CASE;



END_ACTION

ACTION	subr_ST_Bandeinzugsnocken_ein:
CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
	 STANDARD_2FACH_V2:

		(* Bandeinzug: Standard_2fach_V2 *)
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_LI_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_LI_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_LI_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_LI_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_RE_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_RE_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_RE_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_RE_AUSFAHREN].b_camvalid := TRUE;
		(* Bandeinzug: Standard_2fach_V2 *)
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_BAEZV2_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_BAEZV2_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_BAEZV2_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_BAEZV2_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_BAEZV2_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_BAEZV2_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_BAEZV2_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_BAEZV2_AUSFAHREN].b_camvalid := TRUE;

		zyl_bandfaenger_li.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandklemmen_li.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandfaenger_re.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandklemmen_re.fb.b_no_gesteuert_im_norm_betrieb := FALSE;

	BANDWECHSLER_V2:
		(* Klemmbandeinzug ohne Sensoren *)
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN].b_camvalid := TRUE;

		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_AUSFAHREN].b_camvalid := TRUE;

		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_PNEUMATIKBANDEINZUG_GLS].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BESTUECKSCHIEBER_ON].b_camvalid := b_bestueckschieber_ueberwachung_aktiv;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BESTUECKSCHIEBER_OFF].b_camvalid := b_bestueckschieber_ueberwachung_aktiv;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_UW_BESTUECKSCHIEBER_ON].b_camvalid := b_bestueckschieber_ueberwachung_aktiv;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_UW_BESTUECKSCHIEBER_OFF].b_camvalid := b_bestueckschieber_ueberwachung_aktiv;

		zyl_bandfaenger.fb.b_no_gesteuert_im_norm_betrieb := TRUE;
		zyl_bandklemmen.fb.b_no_gesteuert_im_norm_betrieb := TRUE;
END_CASE;



END_ACTION

ACTION	subr_ST_Bandeinzugsnocken_li_ein:
CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
	STANDARD_2FACH_V2:

		(* Bandeinzug: Standard_2fach_V1 *)
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_LI_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_LI_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_LI_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_LI_AUSFAHREN].b_camvalid := TRUE;
		(* Bandeinzug: Standard_2fach_V2 *)
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_BAEZV2_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_LI_BAEZV2_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_BAEZV2_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_LI_BAEZV2_AUSFAHREN].b_camvalid := TRUE;

		zyl_bandfaenger_li.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandklemmen_li.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandfaenger_re.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandklemmen_re.fb.b_no_gesteuert_im_norm_betrieb := FALSE;

END_CASE;



END_ACTION

ACTION	subr_ST_Bandeinzugsnocken_re_ein:
CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
	STANDARD_2FACH_V2:

		(* Bandeinzug: Standard_2fach_V1 *)
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_RE_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_RE_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_RE_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_RE_AUSFAHREN].b_camvalid := TRUE;
		(* Bandeinzug: Standard_2fach_V2 *)
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_BAEZV2_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_RE_BAEZV2_AUSFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_BAEZV2_EINFAHREN].b_camvalid := TRUE;
		gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_RE_BAEZV2_AUSFAHREN].b_camvalid := TRUE;
		
		zyl_bandfaenger_li.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandklemmen_li.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandfaenger_re.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
		zyl_bandklemmen_re.fb.b_no_gesteuert_im_norm_betrieb := FALSE;

END_CASE;
END_ACTION

ACTION	subr_ST_Cam_B_Achse:
(* B-Achse *)
fb_axis_b_achse.st_camscaling_data.SlaveScaling :=
	F_Servobandeinzug_Strecke_zu_Grad(
		strecke := INT_TO_LREAL(gst_datensatz.st_bestueckprogramm.i16_b[i16_bestueckposzaehler])
			* gst_datensatz.st_band.r_raster);

IF b_achse.Status.CamScalingPending THEN
	st_sm.b_skalierung_noch_aktiv := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
ELSE
	IF b_achse.NcToPlc.CoupleState = 0 THEN
		st_drive_cmd_b_achse.enu_cmd := CAM_IN_SLAVE;
	ELSE
		st_drive_cmd_b_achse.enu_cmd := CAM_SCALEING_SLAVE;
	END_IF
END_IF
END_ACTION

ACTION	subr_ST_Cam_Bestueck_Maschine:
CASE gst_datensatz.st_md.i16_typ_zelle OF
	KEINE_ZELLE:
		;
	BESTUECKZELLE_1700, BESTUECKZELLE_1720:
		subr_ST_Cam_Bestueckachse();

	RASTERFOLIE:
		;
END_CASE
END_ACTION

ACTION	subr_ST_Cam_Bestueckachse:
(* Bestueckachse *)
IF gst_datensatz.st_bestueckprogramm.i16_b[i16_bestueckposzaehler] <= 0 THEN
	i16_bestueckachse_cam_table_id := 6;	(* 0-Scalierung *)
	subr_ST_Bandeinzugsnocken_aus();
ELSE
	i16_bestueckachse_cam_table_id := 5;	(* 1-Scalierung *)
	subr_ST_Bandeinzugsnocken_ein();
END_IF

IF i16_bestueckachse_cam_table_id <> i16_bestueckachse_cam_table_id_alt THEN
	fb_axis_bestueckachse.mc_activation_mode_camin:= MC_CAMACTIVATION_ATMASTERCAMPOS;
	fb_axis_bestueckachse.lr_activation_position_camin := gst_datensatz.st_md.st_md_bestueckachse.lr_startposition;
	st_drive_cmd_bestueckachse.enu_cmd := CAM_IN_SLAVE;
	i16_bestueckachse_cam_table_id_alt := i16_bestueckachse_cam_table_id;
END_IF


END_ACTION

ACTION	subr_ST_Cam_Y_Achse:
(* Y-Achse *)
IF i16_bestueckposzaehler = 0 THEN
	lr_ErsteBestueckposY := gst_datensatz.st_isk.lr_pos_y_0 +
						gst_datensatz.st_wkz.lr_offset_y_pos_0 +
						gst_datensatz.st_wt.lr_offset_y_pos_0 +
						gst_datensatz.st_md.lr_offset_y_pos_0 +
						gst_datensatz.st_bestueckprogramm.lr_y[0];
	fb_axis_y_achse.st_camscaling_data.SlaveScaling := fb_berechnung_override_achse.lr_skalierung_slave_achse2 := lr_ErsteBestueckposY - y_achse.NcToPlc.ActPos;
	(* Falls die Positionierung Probleme macht, könnte man auch so rechnen *)
	(*fb_axis_y_achse.st_camscaling_data.SlaveScaling := fb_berechnung_override_achse.lr_skalierung_slave_achse2 := lr_ErsteBestueckposY - gst_datensatz.st_wkz.r_wkz_einfahrpos_y;*)
ELSIF i16_bestueckposzaehler > 0 AND i16_bestueckposzaehler < gst_datensatz.st_bestueckprogramm.i32_anzahl THEN
	fb_axis_y_achse.st_camscaling_data.SlaveScaling := fb_berechnung_override_achse.lr_skalierung_slave_achse2 := gst_datensatz.st_bestueckprogramm.lr_y[i16_bestueckposzaehler] - gst_datensatz.st_bestueckprogramm.lr_y[i16_bestueckposzaehler - 1];
ELSE
	fb_axis_y_achse.st_camscaling_data.SlaveScaling := fb_berechnung_override_achse.lr_skalierung_slave_achse2 := 0.0;
END_IF
IF y_achse.Status.CamScalingPending THEN
	st_sm.b_skalierung_noch_aktiv := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
ELSE
	IF y_achse.NcToPlc.CoupleState = 0 THEN
		st_drive_cmd_y_achse.enu_cmd := CAM_IN_SLAVE;
	ELSE
		st_drive_cmd_y_achse.enu_cmd := CAM_SCALEING_SLAVE;
	END_IF
END_IF
END_ACTION

ACTION	subr_ST_Cam_Z_Achse:
(* Z-Achse *)
IF i16_bestueckposzaehler > 0 AND i16_bestueckposzaehler < gst_datensatz.st_bestueckprogramm.i32_anzahl THEN
	fb_axis_z_achse.st_camscaling_data.SlaveScaling := fb_berechnung_override_achse.lr_skalierung_slave_achse1 := gst_datensatz.st_bestueckprogramm.lr_z[i16_bestueckposzaehler] - gst_datensatz.st_bestueckprogramm.lr_z[i16_bestueckposzaehler - 1];
ELSE
	fb_axis_z_achse.st_camscaling_data.SlaveScaling := fb_berechnung_override_achse.lr_skalierung_slave_achse1 := 0.0;
END_IF
IF z_achse.Status.CamScalingPending THEN
	st_sm.b_skalierung_noch_aktiv := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
ELSE
	IF z_achse.NcToPlc.CoupleState = 0 THEN
		st_drive_cmd_z_achse.enu_cmd := CAM_IN_SLAVE;
	ELSE
		st_drive_cmd_z_achse.enu_cmd := CAM_SCALEING_SLAVE;
	END_IF
END_IF

END_ACTION

ACTION	subr_ST_EinzugLueften:
(* SP_SERVOBANDEINZUG_LUEFTEN niemals vorsteuern *)
gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_SERVOBANDEINZUG_LUEFTEN].t_vorsteuerzeit := t#0ms;

fb_r_trig_bandeinzug_lueften(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_SERVOBANDEINZUG_LUEFTEN], Q=> );
fb_f_trig_bandeinzug_lueften(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_SERVOBANDEINZUG_LUEFTEN], Q=> );

(* Abschalten, falls die Schrittkette beim Lüften aus irgendwelchen Gründen hängen bleibt *)
IF fb_r_trig_bandeinzug_lueften.Q AND
	i16_step_lueften > 0 THEN
		sm_fehler_achse_lueften := TRUE;
		fb_state_entry.i16_next_step := FEHLER;
END_IF


(* Schrittkette zum Einzug in Regelung setzen mit Positionsangleich  *)
CASE i16_step_lueften OF
(*=======================================================*)
	0:	(* CAM Out bei R Trig Lueftnocke *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_bandeinzug_lueften.Q AND
			bestueckachse.NcToPlc.CoupleState <> 0 AND
			((NOT b_einfaedeln_aktiv_servo AND
			(* Bei einer Umfahrung soll Servo nicht lüften, weil die Fänger des WKZ das Band nicht halten *)
			gst_datensatz.st_bestueckprogramm.i16_b[i16_bestueckposzaehler] >= 1 ) OR
			(b_einfaedeln_aktiv_servo AND
			i16_einfaedelzaehler >= gst_datensatz.st_wkz.i16_einfaedelhub_lueften)) THEN		(* Nach x Einfädelhüben ist Band sicher im WKZ, dann darf Servobaneinzug wieder entlüften *)
			st_drive_cmd_b_achse.enu_cmd := CAM_OUT_SLAVE;
			i16_step_lueften := 10;
		END_IF

(*=======================================================*)
	10:

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_b_achse.enu_cmd = NO_COMMAND THEN
			ST_Servobandeinzug.i_Stromlimit := ST_Servobandeinzug.i16_lueft_torque;
			i16_step_lueften := 20;
		END_IF

(*=======================================================*)
	20: (* HOME Servobandeinzug bei F Trig Lueftnocke *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_f_trig_bandeinzug_lueften.Q THEN
			axis_bandeinzug_achse.st_ctrl.in.b_home := TRUE;
			i16_step_lueften := 30;
		END_IF

(*=======================================================*)
	30:

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_fertig_2 THEN
			axis_bandeinzug_achse.st_ctrl.in.b_home := FALSE;
			i16_step_lueften := 0;
		END_IF

END_CASE

END_ACTION

ACTION	subr_ST_PosUW_Bestueckachse:
(* Wenn die Betückachse von der Virtuellen Achse entkoppelt wird, muss dauerhaft der OT Sensor belegt sein.
Überwachung, ob das Auskoppeln rechtzeitig gemacht wird. Ab 300 Hub gibt es Probleme *)
IF i16_bestueckachse_cam_table_id = 6 AND NOT ST_Bestueckachse.e_referenz_sensor THEN
	sm_fehler_positionierung_bestueckachse := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
END_IF
END_ACTION

ACTION	subr_ST_PosUW_YZ_Achse:
(* Y *)
(* Kontrolle der Skalierungsposition der Achse nach dem Setzen eines Pins *)
IF ABS(y_achse.NcToPlc.ActPos - (lr_merker_y_pos + gst_datensatz.st_bestueckprogramm.lr_y[i16_bestueckposzaehler])) > 0.1THEN
	sm_fehler_bestueckposition_y := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
END_IF

(* Überwachung auf Kommando abgeschlossen. Zusätzliche Kontrolle auf Ausführung des Skalierungskommandos *)
IF st_drive_cmd_y_achse.enu_cmd <> NO_COMMAND THEN
	st_sm.b_ende_camming_nocke := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
END_IF

(* Z *)
(* Kontrolle der Skalierungsposition der Achse nach dem Setzen eines Pins *)
IF ABS(z_achse.NcToPlc.ActPos - (lr_merker_z_pos + gst_datensatz.st_bestueckprogramm.lr_z[i16_bestueckposzaehler])) > 0.2THEN
	sm_fehler_bestueckposition_z := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
END_IF

(* Überwachung auf Kommando abgeschlossen. Zusätzliche Kontrolle auf Ausführung des Skalierungskommandos *)
IF st_drive_cmd_z_achse.enu_cmd <> NO_COMMAND THEN
	st_sm.b_ende_camming_nocke := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
END_IF

(* Pythagoras YZ *)
(*	tv + gg: 10.08.2021
	Wir müssen nicht nur jede Achse einzeln überwachen, sondern beide Achsen zusammen überwachen.
	Bsp. 74pol 2-Fach WT: Es gibt hier Sprünge die nur 0.04 in Y Verschoben, welche dann die 
	Überwachung in Y-Achse ausgelöst hat, obwohl alles funktionert hat. Z Pos ist um 5 mm verschoben*)

(* Kontrolle, ob die Achsen gegenüber dem letzten Bestückhub weiter gefahren ist *)
lr_merker_y_pos_neu := y_achse.NcToPlc.ActPos;
lr_merker_z_pos_neu := z_achse.NcToPlc.ActPos;

lr_abstand_yz := SQRT(	EXPT(lr_merker_y_pos_alt - lr_merker_y_pos_neu, 2) +
						EXPT(lr_merker_z_pos_alt - lr_merker_z_pos_neu, 2));

IF 	(fb_axis_y_achse.st_camscaling_data.SlaveScaling <> 0 OR
	fb_axis_z_achse.st_camscaling_data.SlaveScaling <> 0) AND
	lr_abstand_yz < 0.05
THEN
	sm_fehler_positionierung_y := TRUE;
	sm_fehler_positionierung_z := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
END_IF

lr_merker_y_pos_alt := lr_merker_y_pos_neu;
lr_merker_z_pos_alt := lr_merker_z_pos_neu;

END_ACTION

ACTION	subr_ST_PosUW_Z_Achse:
(* Kontrolle der Skalierungsposition der Achse nach dem Setzen eines Pins *)
IF ABS(z_achse.NcToPlc.ActPos - (lr_merker_z_pos + gst_datensatz.st_bestueckprogramm.lr_z[i16_bestueckposzaehler])) > 0.2THEN
	sm_fehler_bestueckposition_z := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
END_IF

(* Überwachung auf Kommando abgeschlossen. Zusätzliche Kontrolle auf Ausführung des Skalierungskommandos *)
IF st_drive_cmd_z_achse.enu_cmd <> NO_COMMAND THEN
	st_sm.b_ende_camming_nocke := TRUE;
	fb_state_entry.i16_next_step := FEHLER;
END_IF

(* Kontrolle, ob die Achse gegenüber dem letzten Bestückhub weiter gefahren ist *)
lr_merker_z_pos_neu := z_achse.NcToPlc.ActPos;
IF fb_axis_z_achse.st_camscaling_data.SlaveScaling <> 0 THEN
	IF ABS(lr_merker_z_pos_alt - lr_merker_z_pos_neu) > 0.05 THEN
		lr_merker_z_pos_alt := lr_merker_z_pos_neu;
	ELSE
		sm_fehler_positionierung_z := TRUE;
		fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF
END_ACTION

















(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Achsen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_WT_Transport_Achse
VAR_INPUT
	st_config_achse						: struct_ecd_config;
	st_ctrl_in								: struct_ctrl_in;
	e_steuerung_ein						: BOOL;
	e_ba_mit_bedingungen				: BOOL;
	e_tuere_vorne_offen					: BOOL;
	e_tuere_hinten_offen					: BOOL;
	lr_tmp_Achspos						: LREAL;
	lr_Achspos_in						: LREAL;
	lr_Velo_in							: LREAL;
	enu_cmd_in						: enum_ecd_cmd;
END_VAR
VAR_IN_OUT
	st_visu								: struct_ecd_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
END_VAR
VAR
	st_sm						 		: struct_ecd_meldungen;
	st_drive_cmd							: struct_ecd_cmd;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_wz_disable						: TON;
	fb_r_trig_start							: R_TRIG;
	fb_r_trig_taste_plus					: R_TRIG;
	fb_r_trig_taste_minus					: R_TRIG;
	fb_r_trig_hand_dialog					: R_TRIG;
	fb_axis								: ST_AxisJobCtrl_Motion;
	fb_state_entry							: ST_StateEntry;
	fb_ton_uez							: TON;
	i									: UINT := 0;
	lr_pos_ohneverschiebung			: LREAL;
	fb_r_trig_limit_sensor_positiv			: R_TRIG;
	fb_r_trig_limit_sensor_negativ			: R_TRIG;
	fb_r_trig_skalierungsnocken				: R_TRIG;
	fb_r_trig_nullpunkt_setzen				: R_TRIG;

	i16_aktuelle_anzahl_bestueckungen		: UINT := 0;
	i16_aktuelle_anzahl_leere_schaechte	: UINT := 0;

	b_hand_dialog_aktiv					: BOOL := FALSE;
	sm_kein_nocken_definiert				: BOOL := FALSE;

	st_geschwindigkeiten					: struct_ecd_geschwindigkeiten;
	e_referenz_sensor						AT %I* : BOOL;
	i16_torque							AT %I* : INT;

	lr_decceleration_nothalt				: LREAL;
	lr_decceleration_normal				: LREAL;

END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_wz_disable(IN:= , PT:= t#500ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_limit_sensor_positiv(CLK:= st_config_achse.b_limitsensor_positiv_vorhanden AND NOT fb_axis.e_limit_sensor_positive, Q=> );
fb_r_trig_limit_sensor_negativ(CLK:= st_config_achse.b_limitsensor_negativ_vorhanden AND NOT fb_axis.e_limit_sensor_negative, Q=> );
fb_r_trig_taste_plus(CLK:= ST_Euchner_Handbedienpult.b_Taste_Plus, Q=> );
fb_r_trig_taste_minus(CLK:= ST_Euchner_Handbedienpult.b_Taste_Minus, Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );
fb_r_trig_skalierungsnocken(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_START_SKALIERUNG], Q=> );
fb_r_trig_hand_dialog(CLK:= b_hand_dialog_aktiv, Q=> );
fb_r_trig_nullpunkt_setzen(CLK:=axis_transport_wt_achse.st_visu.b_nullpunkt_setzen);

(* Achse steuern *)
fb_axis(
	e_referenznocken:= ,
	b_refsensor_vorhanden:= st_config_achse.b_refsensor_vorhanden,
	b_limitsensor_positiv_vorhanden:= st_config_achse.b_limitsensor_positiv_vorhanden,
	b_limitsensor_negativ_vorhanden:= st_config_achse.b_limitsensor_negativ_vorhanden,
	i16_achstyp := st_config_achse.i16_achstyp,
	st_position:= ,
	lr_override_vorgabe:= ST_TippTasten.lr_override,
	mc_richtung_modulo:= ,
	mc_richtung_velocity:= ,
	mc_referenzmodus:= ,
	mc_buffermode_axis:= ,
	ui16_soeparam_write_value:= ,
	w_idn:= ,
	i16_nc_parameter_nummer:= ,
	r_wert_nc_write_parameter:= ,
	st_vorgabe_geschwindigkeiten:= st_geschwindigkeiten,
	lr_soll_geschwindigkeit:= ,
	b_bedingung_sls:= NOT e_tuere_vorne_offen OR NOT e_tuere_hinten_offen,
	st_ads_info := ,
	st_eccoe_sdo := ,
	st_masterachse:= transport_wt_achse,
	st_visu_axis:= st_visu,
	st_ecd_cmd:= st_drive_cmd,
	ui16_soeparam_read_value=> ,
	r_wert_nc_read_parameter=> );

(* Achse mit dem Euchner Handbediengerät vorwärts und rückwärts Bewegen*)
IF gi16_betriebsart = HAND AND fb_r_trig_hand_dialog.Q THEN
	fb_state_entry.i16_next_step := HANDRAD;
END_IF

IF gi16_betriebsart = HAND THEN
	(* Button in der Oberfläche zum setzen des Nullpunktes *)
	IF fb_r_trig_nullpunkt_setzen.Q THEN
		fb_state_entry.i16_next_step := NULLPUNKT_SETZEN;
	END_IF
END_IF


(* =======================================Toplevel========================================== *)
(* Starte Inbetriebnahme-Sequenz *)
IF st_ctrl_in.b_gehe_step_ibn THEN
	fb_state_entry.i16_next_step := INBETRIEBNAHME;
END_IF

(* =====Achse wird disabled===== *)
IF (NOT e_steuerung_ein OR NOT e_ba_mit_bedingungen) AND transport_wt_achse.Status.Operational THEN
	st_drive_cmd.enu_cmd := POWER_DISABLE;
END_IF

IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* =====Fehler vom Achskontroller===== *)
	IF st_drive_cmd.b_job_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF

	IF fb_state_entry.i16_next_step > 35 THEN
		(* Devicefehler *)
		IF transport_wt_achse.Status.Error THEN
			st_sm.b_achsfehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSIF transport_wt_achse.Status.DriveDeviceError THEN
			st_sm.b_devicefehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	END_IF

	IF fb_state_entry.i16_next_step < STOP THEN
		(* =====Achse wird gestoppt===== *)
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		ELSIF fb_state_entry.i16_next_step < HALT THEN
			(* =====Achse wird angehalten===== *)
			IF st_ctrl_in.b_halt THEN
				fb_state_entry.i16_next_step := HALT;
			END_IF
		END_IF
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF 	st_config_achse.b_config_fertig AND
			gst_datensatz.st_md.b_anwahl_transport_achse THEN
			fb_state_entry.i16_next_step := 1;
		END_IF

(*=======================================================*)
	1:	(* Warte bis NetID´s der Slaves ausgelesen sind *)
		IF fb_state_entry.E THEN
			;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_EthercatDiag.st_ctrl_out.b_fertig THEN
			fb_state_entry.i16_next_step := 2;
		END_IF

(*=======================================================*)
	2:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxVelocitySystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_auto_max := st_geschwindigkeiten.lr_maximalgeschwindigkeit := fb_axis.r_wert_nc_read_parameter;
			st_geschwindigkeiten.lr_auto_min := 25.0;
			st_geschwindigkeiten.lr_jog := 50;
			fb_state_entry.i16_next_step := 3;
		END_IF

(*=======================================================*)
	3:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxAccelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_beschleunigung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 4;
		END_IF

(*=======================================================*)
	4:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxDecelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_verzoegerung := fb_axis.r_wert_nc_read_parameter;
			lr_decceleration_normal := st_geschwindigkeiten.lr_verzoegerung;
			lr_decceleration_nothalt := 200000.0;
			fb_state_entry.i16_next_step := 5;
		END_IF

(*=======================================================*)
	5:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxJerk;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_ruck := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 6;
		END_IF

(*=======================================================*)
	6:	(* Konfigurationen der Achse *)
		IF fb_state_entry.E THEN
			fb_axis.st_eccoe_sdo.s_ec_slave_net_id := ST_EthercatDiag.s_ec_slave_net_id[2];
			fb_axis.st_eccoe_sdo.ui16_slave_addr := st_config_achse.ui16_ethercat_adr;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := FEHLER; (*in Fehler gehen damit die Achsen resetet werden. Sonst steigen die Achsen bei einem TC Restart aus*)

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_quitt.IN := FALSE;
			(* Reset Stoermeldungen *)
			st_sm.b_achse_nicht_auf_startpos := FALSE;
			st_sm.b_achsfehler := FALSE;
			st_sm.b_devicefehler := FALSE;
			st_sm.b_keine_verfahrfreigabe := FALSE;
			st_sm.b_ende_skalierungs_nocke := FALSE;
			st_sm.b_ende_camming_nocke := FALSE;
			st_sm.b_skalierung_noch_aktiv := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_busy:=FALSE;


			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_prebereit := FALSE;
			sm_kein_nocken_definiert := FALSE;

			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_md.r_geschwindigkeit_achse_transport;

			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_normal;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_preinit THEN
			fb_state_entry.i16_next_step := 15;
		END_IF

(*=======================================================*)
	15:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;	(* vom Datentyp MC_AxisParameter *)
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_transport_wt_achse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 35;	(* Reglerfreigabe setzen *)
			ELSE
				fb_state_entry.i16_next_step := 25;	(* Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	25:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
		(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_transport_wt_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 35;
		END_IF

(*=======================================================*)
	35:	(* Reglerfreigabe setzen , Reset wird bei Bedarf automatisch ausgeführt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:	(* Nullpunktverschiebung ist geschrieben *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_prebereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	45: (* Warte auf Startsignal zum Positionieren *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_start THEN
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50: (* Positioniere Achse auf ausgelesene Slaveposition *)
		IF fb_state_entry.E THEN
			fb_axis.st_position.r_soll := ST_Z_Achse.lr_slave_position;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60: (* Warte bis WT Transport Achsegekoppelt wurde *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF transport_wt_achse.NcToPlc.CoupleState = 3 THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_start.Q THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

		IF 	fb_state_entry.X THEN
			st_ctrl_out.b_busy:= TRUE;
		END_IF

(*=======================================================*)
	110:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120: (* Positioniere Achse  *)
		IF 	fb_state_entry.E THEN
			fb_axis.st_position.r_soll := lr_Achspos_in ;
			fb_axis.lr_soll_geschwindigkeit:=lr_Velo_in;
			st_drive_cmd.enu_cmd := enu_cmd_in;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_ctrl_out.b_fertig := TRUE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

		IF 	fb_state_entry.X THEN
			st_ctrl_out.b_busy:=FALSE;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		IF  st_ctrl_in.b_stop AND NOT y_achse.Status.HasBeenStopped THEN
			st_drive_cmd.enu_cmd := STOP_AXIS;
		END_IF

		IF st_ctrl_in.b_halt AND y_achse.Status.Moving THEN
			st_drive_cmd.enu_cmd := HALT_AXIS;
			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_nothalt;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_drive_cmd.enu_cmd := RESET;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

		IF	NOT gst_datensatz.st_md.b_anwahl_transport_achse THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_state_entry.i16_next_step := INIT_ObJ;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			IF y_achse.NcToPlc.CoupleState = 0 THEN
				st_drive_cmd.enu_cmd := STOP_AXIS;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND AND y_achse.Status.NotMoving THEN
			fb_state_entry.i16_next_step := STILLSTAND;
		END_IF

(*=======================================================*)
	STILLSTAND:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HALT:
		IF fb_state_entry.E THEN
			IF y_achse.NcToPlc.CoupleState = 0 THEN
				st_drive_cmd.enu_cmd := HALT_AXIS;
				st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_nothalt;
			END_IF
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HANDRAD:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_transport_wt_achse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 2040;	(* Jogbetrieb *)
			ELSE
				fb_state_entry.i16_next_step := 2010;	(* Reglerfreigabe nehmen und Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	2010:	(* Reglerfreigabe wegnehmen , damit Nullpunktverschiebung geschrieben werden kannt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2020;
		END_IF

(*=======================================================*)
	2020:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
			(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2030;
		END_IF

(*=======================================================*)
	2030:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_transport_wt_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2040;
		END_IF

(*=======================================================*)
	2040:	(* Jogbetrieb *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
		END_IF

		IF ST_Euchner_Handbedienpult.i16_Handrad_delta > 0 THEN
			st_drive_cmd.enu_cmd := JOG_VORWAERTS;
		ELSIF ST_Euchner_Handbedienpult.i16_Handrad_delta < 0 THEN
			st_drive_cmd.enu_cmd := JOG_RUECKWAERTS;
		ELSIF  y_achse.Status.Moving THEN
			st_drive_cmd.enu_cmd := JOG_STOP;
		END_IF

		IF fb_r_trig_taste_plus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_AUF;
		END_IF
		IF fb_r_trig_taste_minus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_ZU;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gi16_betriebsart <> HAND OR NOT b_hand_dialog_aktiv THEN
			fb_state_entry.i16_next_step := 2050;
		END_IF

(*=======================================================*)
	2050:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2060;
		END_IF

(*=======================================================*)
	2060:
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;	(* Motorbremse im Automatikbetrieb für reguläres Fahren *)
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2070;
		END_IF

(*=======================================================*)
	2070:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	MOTORBREMSE_AUF:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2110;
		END_IF

(*=======================================================*)
	2110:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2120;
		END_IF

(*=======================================================*)
	2120:	(* Bremse auf machen *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 2;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND AND
			(gi16_betriebsart <> HAND OR
			NOT b_hand_dialog_aktiv OR
			ST_Euchner_Handbedienpult.i16_Handrad_delta > 0)
			THEN
				fb_state_entry.i16_next_step := HANDRAD;
		ELSIF fb_r_trig_taste_minus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_ZU;
		END_IF

(*=======================================================*)
	MOTORBREMSE_ZU:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2210;
		END_IF

(*=======================================================*)
	2210:	(* Reglerfreigabe setzen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2220;
		END_IF

(*=======================================================*)
	2220:	(* Bremse zu machen *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND AND
			(gi16_betriebsart <> HAND OR
			NOT b_hand_dialog_aktiv OR
			ST_Euchner_Handbedienpult.i16_Handrad_delta > 0)
			THEN
				fb_state_entry.i16_next_step := HANDRAD;
		ELSIF fb_r_trig_taste_plus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_AUF;
		END_IF

(*=======================================================*)
	NULLPUNKT_SETZEN:
		(* Aktuellen Jog beenden, sonst Probleme beim Softwareendschalter*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := JOG_STOP;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2505;
		END_IF

(*=======================================================*)
	2505:
		(* 	Lese aktuelle Nullpunkt verschiebung von der Hardware. Der Benutze könnte einen falschen
			Wert eingetragen haben *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			gst_datensatz.st_md.st_md_transport_wt_achse.lr_nullpunktverschiebung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 2510;
		END_IF

(*=======================================================*)
	2510:	(* Nullpunktverschiebung berechnen *)
		IF fb_state_entry.E THEN
			lr_pos_ohneverschiebung := axis_transport_wt_achse.st_visu.lr_position_ist - gst_datensatz.st_md.st_md_transport_wt_achse.lr_nullpunktverschiebung;

			gst_datensatz.st_md.st_md_transport_wt_achse.lr_nullpunktverschiebung := - lr_pos_ohneverschiebung;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Aktiviere den wert in die Hardware *)
		fb_state_entry.i16_next_step := HANDRAD;

(*=======================================================*)
	INBETRIEBNAHME:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_transport_wt_achse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 5100;	(* Reversiersequenz*)
			ELSE
				fb_state_entry.i16_next_step := 5010;	(* Reglerfreigabe nehmen und Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	5010:	(* Reglerfreigabe wegnehmen, damit Nullpunktverschiebung geschrieben werden kannt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5020;
		END_IF

(*=======================================================*)
	5020:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
			(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5030;
		END_IF

(*=======================================================*)
	5030:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_transport_wt_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5100;
		END_IF

(*=======================================================*)
	5100:	(* Verfahren der Achse zwischen zwei Punkten zum Testen verschiedener Achsparameter *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
			fb_axis.st_position.lr_ibn_pos_start := 0.0;
			fb_axis.st_position.lr_ibn_pos_ziel := 25.0;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_ibn_start THEN
			fb_state_entry.i16_next_step := 5110;
		END_IF

(*=======================================================*)
	5110: (* Fahre Y-Achse auf Startposition *)
(*
		IF fb_state_entry.E THEN
			 fb_axis.st_position.r_soll := fb_axis.st_position.lr_ibn_pos_start;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5120;
		END_IF
*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			;
		END_IF

(*=======================================================*)
	5120: (* Pause *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#1s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 5130;
		END_IF

(*=======================================================*)
	5130: (* Fahre Z-Achse auf Zielposition *)
		IF fb_state_entry.E THEN
			 fb_axis.st_position.r_soll := fb_axis.st_position.lr_ibn_pos_ziel;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5140;
		END_IF

(*=======================================================*)
	5140: (* Pause *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#1s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 5100;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config_achse.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 0] := st_sm.b_achse_nicht_bb;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 1] := st_sm.b_achse_nicht_referenziert;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 2] := st_sm.b_keine_verfahrfreigabe;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 3] := st_sm.b_achse_nicht_auf_startpos;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 4] := st_sm.b_ende_skalierungs_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 5] := st_sm.b_ende_camming_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 6] := st_sm.b_skalierung_noch_aktiv;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 10] := sm_kein_nocken_definiert;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 16] := st_drive_cmd.meldungen.sm_write_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 17] := st_drive_cmd.meldungen.sm_read_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 18] := st_drive_cmd.meldungen.sm_write_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 19] := st_drive_cmd.meldungen.sm_read_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 20] := st_drive_cmd.meldungen.sm_power_enable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 21] := st_drive_cmd.meldungen.sm_power_disable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 22] := st_drive_cmd.meldungen.sm_reset;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 23] := st_drive_cmd.meldungen.sm_home;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 24] := st_drive_cmd.meldungen.sm_setposition;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 25] := st_drive_cmd.meldungen.sm_jog_vorwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 26] := st_drive_cmd.meldungen.sm_jog_rueckwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 27] := st_drive_cmd.meldungen.sm_move_absolute;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 28] := st_drive_cmd.meldungen.sm_move_relative;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 29] := st_drive_cmd.meldungen.sm_move_velocity;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 30] := st_drive_cmd.meldungen.sm_move_modulo;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 31] := st_drive_cmd.meldungen.sm_stop_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 32] := st_drive_cmd.meldungen.sm_halt_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 33] := st_drive_cmd.meldungen.sm_motion_command_timeout;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 34] := st_sm.b_achsfehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 35] := st_sm.b_devicefehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 36] := st_drive_cmd.meldungen.sm_limit_positiv_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 37] := st_drive_cmd.meldungen.sm_limit_negativ_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 38] := st_drive_cmd.meldungen.sm_ec_coe_sdo_write_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 39] := st_drive_cmd.meldungen.sm_ec_coe_sdo_read_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 40] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 41] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 42] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 43] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 44] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 45] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 46] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 47] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 48] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 49] := FALSE;

	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 19] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 20] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 21] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 22] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 23] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 24] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 25] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 26] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 27] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 28] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 29] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 30] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 31] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 32] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 33] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 34] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 35] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 36] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 37] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 38] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 39] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 40] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 41] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 42] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 43] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 44] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 45] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 46] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 47] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 48] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 49] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Achsen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Y_Achse
VAR_INPUT
	st_config_achse						: struct_ecd_config;
	st_ctrl_in								: struct_ctrl_in;
	e_steuerung_ein						: BOOL;
	e_ba_mit_bedingungen				: BOOL;
	e_tuere_vorne_offen					: BOOL;
	e_tuere_hinten_offen					: BOOL;
	e_not_steu_tuer_schutz_ok				: BOOL;
	lr_tmp_Achspos						: LREAL;

	b_start_in							: BOOL;
	lr_Achspos_in						: LREAL;
	lr_Velo_in							: LREAL;
	enu_cmd_in							: enum_ecd_cmd;
END_VAR
VAR_IN_OUT
	st_visu								: struct_ecd_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
	lr_RecPos							: LREAL;
END_VAR
VAR
	st_sm						 		: struct_ecd_meldungen;
	st_drive_cmd							: struct_ecd_cmd;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_wz_disable						: TON;
	fb_r_trig_start							: R_TRIG;
	fb_r_trig_start_in						: R_TRIG;
	fb_r_trig_taste_plus					: R_TRIG;
	fb_r_trig_taste_minus					: R_TRIG;
	fb_r_trig_hand_dialog					: R_TRIG;
	fb_axis								: ST_AxisJobCtrl_Motion;
	fb_state_entry							: ST_StateEntry;
	fb_ton_uez							: TON;
	fb_ton_regelfreigabe_y_achse			: TON;
	i									: UINT := 0;
	lr_pos_ohneverschiebung			: LREAL;
	fb_r_trig_limit_sensor_positiv			: R_TRIG;
	fb_r_trig_limit_sensor_negativ			: R_TRIG;
	fb_r_trig_skalierungsnocken				: R_TRIG;
	fb_r_trig_nullpunkt_setzen				: R_TRIG;

	b_hand_dialog_aktiv					: BOOL := FALSE;
	sm_kein_nocken_definiert				: BOOL := FALSE;

	st_geschwindigkeiten					: struct_ecd_geschwindigkeiten;
	e_referenz_sensor						AT %I* : BOOL;
	i16_torque							AT %I* : INT;
	i16_DigitalInput						AT %I* : INT;

	lr_decceleration_nothalt				: LREAL;
	lr_decceleration_normal				: LREAL;

	i16_state_msg						: INT;
	lr_MaxSoftPosLimit					:LREAL;
	lr_MinSoftPosLimit						:LREAL;
	b_EndlageErreicht						:BOOL;
	fb_r_trig_Endlage						: R_TRIG;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_wz_disable(IN:= , PT:= t#500ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_limit_sensor_positiv(CLK:= st_config_achse.b_limitsensor_positiv_vorhanden AND NOT fb_axis.e_limit_sensor_positive, Q=> );
fb_r_trig_limit_sensor_negativ(CLK:= st_config_achse.b_limitsensor_negativ_vorhanden AND NOT fb_axis.e_limit_sensor_negative, Q=> );
fb_r_trig_taste_plus(CLK:= ST_Euchner_Handbedienpult.b_Taste_Plus, Q=> );
fb_r_trig_taste_minus(CLK:= ST_Euchner_Handbedienpult.b_Taste_Minus, Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );
fb_r_trig_start_in(CLK:= b_start_in, Q=> );
fb_r_trig_skalierungsnocken(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_START_SKALIERUNG], Q=> );
fb_r_trig_hand_dialog(CLK:= b_hand_dialog_aktiv, Q=> );
fb_r_trig_nullpunkt_setzen(CLK:=axis_y_achse.st_visu.b_nullpunkt_setzen);

(* Achse steuern *)
fb_axis(
	e_referenznocken:= ,
	b_refsensor_vorhanden:= st_config_achse.b_refsensor_vorhanden,
	b_limitsensor_positiv_vorhanden:= st_config_achse.b_limitsensor_positiv_vorhanden,
	b_limitsensor_negativ_vorhanden:= st_config_achse.b_limitsensor_negativ_vorhanden,
	i16_achstyp := st_config_achse.i16_achstyp,
	lr_override_vorgabe:= ST_TippTasten.lr_override,
	st_position:= ,
	mc_richtung_modulo:= ,
	mc_richtung_velocity:= ,
	mc_referenzmodus:= ,
	mc_buffermode_axis:= ,
	ui16_soeparam_write_value:= ,
	w_idn:= ,
	i16_nc_parameter_nummer:= ,
	r_wert_nc_write_parameter:= ,
	st_vorgabe_geschwindigkeiten:= st_geschwindigkeiten,
	lr_soll_geschwindigkeit:= ,
	b_bedingung_sls:= NOT e_tuere_vorne_offen OR NOT e_tuere_hinten_offen,
	st_ads_info := ,
	st_eccoe_sdo := ,
	st_masterachse:= y_achse,
	st_visu_axis:= st_visu,
	st_ecd_cmd:= st_drive_cmd,
	ui16_soeparam_read_value=> ,
	r_wert_nc_read_parameter=>  ,
	lr_RecPos=> lr_RecPos,
	b_TriggerInput:=i16_DigitalInput.2,
	b_FallingEdge:=TRUE);

(* Achse mit dem Euchner Handbediengerät vorwärts und rückwärts Bewegen*)
IF gi16_betriebsart = HAND AND fb_r_trig_hand_dialog.Q THEN
	fb_state_entry.i16_next_step := HANDRAD;
END_IF

IF gi16_betriebsart = HAND THEN
	(* Button in der Oberfläche zum setzen des Nullpunktes *)
	IF fb_r_trig_nullpunkt_setzen.Q THEN
		fb_state_entry.i16_next_step :=	NULLPUNKT_SETZEN;
	END_IF
END_IF


(*Meldung Achse hat Endlage überfahren*)
IF lr_MinSoftPosLimit<>0 AND
 lr_MinSoftPosLimit > gst_datensatz.st_md.st_md_y_achse.lr_wt_uebergabepos THEN
	b_EndlageErreicht:=TRUE;
ELSE
	b_EndlageErreicht:=FALSE;
END_IF

fb_r_trig_Endlage(CLK:= b_EndlageErreicht , Q=> );

IF fb_r_trig_Endlage.Q THEN
	i16_state_msg := 1;
END_IF

(*Produktionsmeldung für Endlage überfahren*)
CASE i16_state_msg OF
	1: (*Warten bis keine ander Produktions Meldung ansteht *)
		IF	TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			i16_state_msg := 2;
		END_IF

	2:  (*Produktions Meldung*)
		Visu.MeldungProduktion.Color_R := 255;
		Visu.MeldungProduktion.Color_G := 255;
		Visu.MeldungProduktion.Color_B := 0;
		IF visu.s_akt_sprache = 'de' THEN
			Visu.MeldungProduktion.Name:='Y-Achse WT Übergabepos größer als Endlage';
		ELSIF visu.s_akt_sprache = 'en' THEN
			Visu.MeldungProduktion.Name:='Y-Achse WT Übergabepos größer als Endlage';
		ELSIF visu.s_akt_sprache = 'cz' THEN
			Visu.MeldungProduktion.Name:='Y-Achse WT Übergabepos größer als Endlage';
		END_IF
		Visu.MeldungProduktion.ShowMessage := TRUE;
		Visu.MeldungProduktion.Button1.sichtbar:= FALSE;	(*OK*)
		Visu.MeldungProduktion.Button1.Text:='Ok';
		i16_state_msg := 3;

	3:  (*Warte auf OK*)
		IF NOT b_EndlageErreicht THEN
			ST_Message_Produktion.b_PM_Quitt:=TRUE;
			i16_state_msg:=0;
		END_IF
END_CASE

(* =======================================Toplevel========================================== *)
(* Starte Inbetriebnahme-Sequenz *)
IF st_ctrl_in.b_gehe_step_ibn THEN
	fb_state_entry.i16_next_step := INBETRIEBNAHME;
END_IF

(* =====Achse wird disabled===== *)
IF (NOT e_steuerung_ein OR NOT e_ba_mit_bedingungen) AND y_achse.Status.Operational THEN
	st_drive_cmd.enu_cmd := POWER_DISABLE;
END_IF

IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* =====Fehler vom Achskontroller===== *)
	IF st_drive_cmd.b_job_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF

	IF fb_state_entry.i16_next_step > 35 THEN
		(* Devicefehler *)
		IF y_achse.Status.Error THEN
			st_sm.b_achsfehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSIF y_achse.Status.DriveDeviceError THEN
			st_sm.b_devicefehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	END_IF

	IF fb_state_entry.i16_next_step < STOP THEN
		(* =====Achse wird gestoppt===== *)
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		ELSIF fb_state_entry.i16_next_step < HALT THEN
			(* =====Achse wird angehalten===== *)
			IF st_ctrl_in.b_halt THEN
				fb_state_entry.i16_next_step := HALT;
			END_IF
		END_IF
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config_achse.b_config_fertig THEN
			fb_state_entry.i16_next_step := 1;
		END_IF

(*=======================================================*)
	1:	(* Warte bis NetID´s der Slaves ausgelesen sind *)
		IF fb_state_entry.E THEN
			;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_EthercatDiag.st_ctrl_out.b_fertig THEN
			fb_state_entry.i16_next_step := 2;
		END_IF

(*=======================================================*)
	2:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxVelocitySystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			lr_Velo_in:=st_geschwindigkeiten.lr_maximalgeschwindigkeit;
			st_geschwindigkeiten.lr_auto_max := st_geschwindigkeiten.lr_maximalgeschwindigkeit := fb_axis.r_wert_nc_read_parameter;
			st_geschwindigkeiten.lr_auto_min := 25.0;
			st_geschwindigkeiten.lr_jog := 50;
			fb_state_entry.i16_next_step := 3;
		END_IF

(*=======================================================*)
	3:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxAccelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_beschleunigung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 4;
		END_IF

(*=======================================================*)
	4:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxDecelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_verzoegerung := fb_axis.r_wert_nc_read_parameter;
			lr_decceleration_normal := st_geschwindigkeiten.lr_verzoegerung;
			lr_decceleration_nothalt := 200000.0;
			fb_state_entry.i16_next_step := 5;
		END_IF

(*=======================================================*)
	5:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxJerk;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_ruck := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 6;
		END_IF

(*=======================================================*)
	6:	(* Konfigurationen der Achse *)
		IF fb_state_entry.E THEN
			fb_axis.st_eccoe_sdo.s_ec_slave_net_id := ST_EthercatDiag.s_ec_slave_net_id[2];
			fb_axis.st_eccoe_sdo.ui16_slave_addr := st_config_achse.ui16_ethercat_adr;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 7;

(*=======================================================*)
	7:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisMinSoftPosLimit;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			lr_MinSoftPosLimit := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 8;
		END_IF


(*=======================================================*)
	8:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisMaxSoftPosLimit;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			lr_MaxSoftPosLimit := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := FEHLER; (*in Fehler gehen damit die Achsen resetet werden. Sonst steigen die Achsen bei einem TC Restart aus*)
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_quitt.IN := FALSE;
			(* Reset Stoermeldungen *)
			st_sm.b_achse_nicht_auf_startpos := FALSE;
			st_sm.b_achsfehler := FALSE;
			st_sm.b_devicefehler := FALSE;
			st_sm.b_keine_verfahrfreigabe := FALSE;
			st_sm.b_ende_skalierungs_nocke := FALSE;
			st_sm.b_ende_camming_nocke := FALSE;
			st_sm.b_skalierung_noch_aktiv := FALSE;
			b_start_in:=FALSE;
			st_ctrl_out.b_busy:=FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_fertig := FALSE;

			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_prebereit := FALSE;
			sm_kein_nocken_definiert := FALSE;

			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_y;

			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_normal;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_preinit THEN
			fb_state_entry.i16_next_step := 15;
		END_IF

(*=======================================================*)
	15:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;	(* vom Datentyp MC_AxisParameter *)
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_y_achse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 35;	(* Reglerfreigabe setzen *)
			ELSE
				fb_state_entry.i16_next_step := 25;	(* Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	25:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
		(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_y_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 35;
		END_IF

(*=======================================================*)
	35:	(* Reglerfreigabe setzen , Reset wird bei Bedarf automatisch ausgeführt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:	(* Nullpunktverschiebung ist geschrieben *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_prebereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := 45;
		END_IF

(*=======================================================*)
	45: (* Warte auf Startsignal zum Positionieren *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_start THEN
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50: (* Positioniere Achse auf ausgelesene Slaveposition *)
		IF fb_state_entry.E THEN
			fb_axis.st_position.r_soll := ST_Z_Achse.lr_slave_position;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60: (* Warte bis Y-Achse gekoppelt wurde *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF y_achse.NcToPlc.CoupleState = 3 THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			enu_cmd_in:=NO_COMMAND;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_start.Q THEN
			st_ctrl_out.b_fertig_2 := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

		IF 	fb_r_trig_start_in.Q THEN		(*neu! zum Starten einer Positionierung von einem externen Prg.*)
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := 102;
		END_IF

		IF fb_state_entry.X THEN
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_busy:=TRUE;
		END_IF

(*=======================================================*)
	102:
		IF 	fb_state_entry.E THEN
			b_start_in:=FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 104;
		END_IF

(*=======================================================*)
	104: (* Positioniere Achse  *)
		IF 	fb_state_entry.E THEN
			fb_axis.st_position.r_soll := lr_Achspos_in ;
			fb_axis.lr_soll_geschwindigkeit:=lr_Velo_in;
			st_drive_cmd.enu_cmd := enu_cmd_in;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_ctrl_out.b_fertig := TRUE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

		IF 	fb_state_entry.X THEN
			st_ctrl_out.b_busy:=FALSE;
		END_IF

(*=======================================================*)
	110: (* Fallunterscheidung *)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700:
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				fb_state_entry.i16_next_step := 200;

			RASTERFOLIE:
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				fb_state_entry.i16_next_step := 120;

		END_CASE

(*=======================================================*)
	120: (* Positioniere Achse auf  0-Koordinate  des ISK *)
		IF fb_state_entry.E THEN
			fb_axis.st_position.r_soll := 	gst_datensatz.st_isk.lr_pos_y_0 +
										gst_datensatz.st_wkz.lr_offset_y_pos_0 +
										gst_datensatz.st_wt.lr_offset_y_pos_0 +
										gst_datensatz.st_md.lr_offset_y_pos_0 +
										gst_datensatz.st_bestueckprogramm.lr_y[0];
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_ctrl_out.b_fertig := TRUE;
			st_ctrl_out.b_busy:=FALSE;
			fb_state_entry.i16_next_step := 300;
		END_IF

(*=======================================================*)
	200:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig := TRUE;
			st_ctrl_out.b_busy:=FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_start_2 THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210: (* Positioniere Achse auf gewünschte Position *)
		IF fb_state_entry.E THEN
			fb_axis.st_position.r_soll :=  ST_Z_Achse.lr_slave_position;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 220;
		END_IF

(*=======================================================*)
	220: (* Warte bis Y-Achse gekoppelt wurde *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig_2 := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF y_achse.NcToPlc.CoupleState = 3 THEN
			st_ctrl_out.b_fertig_2 := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	300:(* Verfahre Y-Achse undwarte auf Start von Z-Achse *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Verfahre Y-Achse *)
		IF	gst_datensatz.st_md.i16_typ_zelle = RASTERFOLIE AND
			ST_Rasterfolienmontage.b_start_y_Achse THEN
			fb_state_entry.i16_next_step := 310;
		END_IF

		(* Warte auf Start von Z-Achse *)
		IF st_ctrl_in.b_start_2 THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := 350;
		END_IF

(*=======================================================*)
	310: (* Positioniere Achse  *)
		IF fb_state_entry.E THEN
			fb_axis.st_position.r_soll := 	lr_tmp_Achspos;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 300;
			ST_Rasterfolienmontage.b_start_y_Achse:=FALSE;
		END_IF


(*=======================================================*)
	350: (* Positioniere Achse auf gewünschte Position am Ende der Kurvenscheibe *)
		IF fb_state_entry.E THEN
			fb_axis.st_position.r_soll :=  ST_Z_Achse.lr_slave_position;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 360;
		END_IF

(*=======================================================*)
	360: (* Warte bis Y-Achse gekoppelt wurde *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig_2 := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF y_achse.NcToPlc.CoupleState = 3 THEN
			st_ctrl_out.b_fertig_2 := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_busy:=FALSE;
		END_IF

		IF st_ctrl_in.b_stop AND NOT y_achse.Status.HasBeenStopped THEN
			st_drive_cmd.enu_cmd := STOP_AXIS;
		END_IF

		IF st_ctrl_in.b_halt AND y_achse.Status.Moving THEN
			st_drive_cmd.enu_cmd := HALT_AXIS;
			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_nothalt;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_drive_cmd.enu_cmd := RESET;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_busy:=FALSE;
			IF y_achse.NcToPlc.CoupleState = 0 THEN
				st_drive_cmd.enu_cmd := STOP_AXIS;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND AND y_achse.Status.NotMoving THEN
			fb_state_entry.i16_next_step := STILLSTAND;
		END_IF

(*=======================================================*)
	STILLSTAND:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HALT:
		IF fb_state_entry.E THEN
			IF y_achse.NcToPlc.CoupleState = 0 THEN
				st_drive_cmd.enu_cmd := HALT_AXIS;
				st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_nothalt;
			END_IF
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HANDRAD:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_y_achse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 2040;	(* Jogbetrieb *)
			ELSE
				fb_state_entry.i16_next_step := 2010;	(* Reglerfreigabe nehmen und Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	2010:	(* Reglerfreigabe wegnehmen , damit Nullpunktverschiebung geschrieben werden kannt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2020;
		END_IF

(*=======================================================*)
	2020:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
			(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2030;
		END_IF

(*=======================================================*)
	2030:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_y_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2040;
		END_IF

(*=======================================================*)
	2040:	(* Jogbetrieb *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
		END_IF

		IF ST_Euchner_Handbedienpult.i16_Handrad_delta > 0 THEN
			st_drive_cmd.enu_cmd := JOG_VORWAERTS;
		ELSIF ST_Euchner_Handbedienpult.i16_Handrad_delta < 0 THEN
			st_drive_cmd.enu_cmd := JOG_RUECKWAERTS;
		ELSIF  y_achse.Status.Moving THEN
			st_drive_cmd.enu_cmd := JOG_STOP;
		END_IF

		IF fb_r_trig_taste_plus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_AUF;
		END_IF
		IF fb_r_trig_taste_minus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_ZU;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gi16_betriebsart <> HAND OR NOT b_hand_dialog_aktiv THEN
			fb_state_entry.i16_next_step := 2050;
		END_IF

(*=======================================================*)
	2050:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2060;
		END_IF

(*=======================================================*)
	2060:
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;	(* Motorbremse im Automatikbetrieb für reguläres Fahren *)
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2070;
		END_IF

(*=======================================================*)
	2070:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	MOTORBREMSE_AUF:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2110;
		END_IF

(*=======================================================*)
	2110:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2120;
		END_IF

(*=======================================================*)
	2120:	(* Bremse auf machen *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 2;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND AND
			(gi16_betriebsart <> HAND OR
			NOT b_hand_dialog_aktiv OR
			ST_Euchner_Handbedienpult.i16_Handrad_delta > 0)
			THEN
				fb_state_entry.i16_next_step := HANDRAD;
		ELSIF fb_r_trig_taste_minus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_ZU;
		END_IF

(*=======================================================*)
	MOTORBREMSE_ZU:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2210;
		END_IF

(*=======================================================*)
	2210:	(* Reglerfreigabe setzen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2220;
		END_IF

(*=======================================================*)
	2220:	(* Bremse zu machen *)
		IF fb_state_entry.E THEN
			fb_axis.w_idn := P_0_IDN + 96;
			fb_axis.ui16_soeparam_write_value := 0;
			st_drive_cmd.enu_cmd := SOE_WRITE_PARAM;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND AND
			(gi16_betriebsart <> HAND OR
			NOT b_hand_dialog_aktiv OR
			ST_Euchner_Handbedienpult.i16_Handrad_delta > 0)
			THEN
				fb_state_entry.i16_next_step := HANDRAD;
		ELSIF fb_r_trig_taste_plus.Q THEN
			fb_state_entry.i16_next_step := MOTORBREMSE_AUF;
		END_IF

(*=======================================================*)
	NULLPUNKT_SETZEN:
		(* Aktuellen Jog beenden, sonst Probleme beim Softwareendschalter*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := JOG_STOP;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2505;
		END_IF

(*=======================================================*)
	2505:
		(* 	Lese aktuelle Nullpunkt verschiebung von der Hardware. Der Benutze könnte einen falschen
			Wert eingetragen haben *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			gst_datensatz.st_md.st_md_y_achse.lr_nullpunktverschiebung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 2510;
		END_IF

(*=======================================================*)
	2510:	(* Nullpunktverschiebung berechnen *)
		IF fb_state_entry.E THEN
			lr_pos_ohneverschiebung := axis_y_achse.st_visu.lr_position_ist - gst_datensatz.st_md.st_md_y_achse.lr_nullpunktverschiebung;

			gst_datensatz.st_md.st_md_y_achse.lr_nullpunktverschiebung := - lr_pos_ohneverschiebung;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Aktiviere den wert in die Hardware *)
		fb_state_entry.i16_next_step := HANDRAD;

(*=======================================================*)
	INBETRIEBNAHME:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_y_achse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 5100;	(* Reversiersequenz*)
			ELSE
				fb_state_entry.i16_next_step := 5010;	(* Reglerfreigabe nehmen und Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	5010:	(* Reglerfreigabe wegnehmen, damit Nullpunktverschiebung geschrieben werden kannt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5020;
		END_IF

(*=======================================================*)
	5020:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
			(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5030;
		END_IF

(*=======================================================*)
	5030:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_y_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5100;
		END_IF

(*=======================================================*)
	5100:	(* Verfahren der Achse zwischen zwei Punkten zum Testen verschiedener Achsparameter *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
			fb_axis.st_position.lr_ibn_pos_start := 0.0;
			fb_axis.st_position.lr_ibn_pos_ziel := 25.0;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_ibn_start THEN
			fb_state_entry.i16_next_step := 5110;
		END_IF

(*=======================================================*)
	5110: (* Fahre Y-Achse auf Startposition *)
(*
		IF fb_state_entry.E THEN
			 fb_axis.st_position.r_soll := fb_axis.st_position.lr_ibn_pos_start;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5120;
		END_IF
*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			;
		END_IF

(*=======================================================*)
	5120: (* Pause *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#1s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 5130;
		END_IF

(*=======================================================*)
	5130: (* Fahre Z-Achse auf Zielposition *)
		IF fb_state_entry.E THEN
			 fb_axis.st_position.r_soll := fb_axis.st_position.lr_ibn_pos_ziel;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5140;
		END_IF

(*=======================================================*)
	5140: (* Pause *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#1s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 5100;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config_achse.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 0] := st_sm.b_achse_nicht_bb;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 1] := st_sm.b_achse_nicht_referenziert;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 2] := st_sm.b_keine_verfahrfreigabe;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 3] := st_sm.b_achse_nicht_auf_startpos;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 4] := st_sm.b_ende_skalierungs_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 5] := st_sm.b_ende_camming_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 6] := st_sm.b_skalierung_noch_aktiv;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 10] := sm_kein_nocken_definiert;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 16] := st_drive_cmd.meldungen.sm_write_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 17] := st_drive_cmd.meldungen.sm_read_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 18] := st_drive_cmd.meldungen.sm_write_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 19] := st_drive_cmd.meldungen.sm_read_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 20] := st_drive_cmd.meldungen.sm_power_enable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 21] := st_drive_cmd.meldungen.sm_power_disable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 22] := st_drive_cmd.meldungen.sm_reset;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 23] := st_drive_cmd.meldungen.sm_home;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 24] := st_drive_cmd.meldungen.sm_setposition;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 25] := st_drive_cmd.meldungen.sm_jog_vorwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 26] := st_drive_cmd.meldungen.sm_jog_rueckwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 27] := st_drive_cmd.meldungen.sm_move_absolute;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 28] := st_drive_cmd.meldungen.sm_move_relative;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 29] := st_drive_cmd.meldungen.sm_move_velocity;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 30] := st_drive_cmd.meldungen.sm_move_modulo;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 31] := st_drive_cmd.meldungen.sm_stop_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 32] := st_drive_cmd.meldungen.sm_halt_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 33] := st_drive_cmd.meldungen.sm_motion_command_timeout;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 34] := st_sm.b_achsfehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 35] := st_sm.b_devicefehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 36] := st_drive_cmd.meldungen.sm_limit_positiv_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 37] := st_drive_cmd.meldungen.sm_limit_negativ_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 38] := st_drive_cmd.meldungen.sm_ec_coe_sdo_write_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 39] := st_drive_cmd.meldungen.sm_ec_coe_sdo_read_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 40] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 41] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 42] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 43] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 44] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 45] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 46] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 47] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 48] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 49] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 50] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 51] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 52] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 53] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 54] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 55] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 56] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 57] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 58] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 59] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 60] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 61] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 62] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 63] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 64] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 65] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 66] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 67] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 68] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 69] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 70] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 71] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 72] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 73] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 74] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 75] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 76] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 77] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 78] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 79] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 80] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 81] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 82] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 83] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 84] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 85] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 86] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 87] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 88] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 89] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 90] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 91] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 92] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 93] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 94] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 95] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 96] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 97] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 98] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 99] := FALSE;
	
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 19] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 20] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 21] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 22] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 23] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 24] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 25] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 26] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 27] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 28] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 29] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 30] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 31] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 32] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 33] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 34] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 35] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 36] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 37] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 38] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 39] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 40] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 41] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 42] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 43] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 44] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 45] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 46] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 47] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 48] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 49] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Achsen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Z_Achse
VAR_INPUT
	st_config_achse						: struct_ecd_config;
	st_ctrl_in								: struct_ctrl_in;
	e_steuerung_ein						: BOOL;
	e_ba_mit_bedingungen				: BOOL;
	e_tuere_vorne_offen					: BOOL;
	e_tuere_hinten_offen					: BOOL;

	b_start_in							: BOOL;
	lr_Achspos_in						: LREAL;
	lr_Velo_in							: LREAL;
	enu_cmd_in							: enum_ecd_cmd;
END_VAR
VAR_IN_OUT
	st_visu								: struct_ecd_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
	t_Z_Achse_ausfahren				: TIME := t#0ms;
	t_Bestueckung					: TIME := t#0ms;
	t_Z_Achse_einfahren				: TIME := t#0ms;
	lr_RecPos						: LREAL;
END_VAR
VAR
	st_sm						 		: struct_ecd_meldungen;
	st_drive_cmd							: struct_ecd_cmd;
	st_drive_cmd_y_achse					: struct_ecd_cmd;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_wz_disable						: TON;
	fb_ton_taktzeitmessung_wt_wechsel		: TON;
	fb_ton_taktzeitmessung_bestuecken		: TON;
	fb_r_trig_tippen						: R_TRIG;
	fb_f_trig_tippen						: F_TRIG;
	fb_r_trig_taste_plus					: R_TRIG;
	fb_r_trig_start							: R_TRIG;
	fb_r_trig_start_in						: R_TRIG;
	fb_r_trig_hand_dialog					: R_TRIG;
	fb_r_trig_nullpunkt_setzen				: R_TRIG;
	fb_axis								: ST_AxisJobCtrl_Motion;
	fb_axis_y_achse						: ST_AxisJobCtrl_Cam_Gear;
	fb_state_entry							: ST_StateEntry;
	fb_ton_uez							: TON;
	i									: DINT := 0;
	k									: DINT := 0;
	lr_pos_ohneverschiebung			: LREAL;
	fb_r_trig_limit_sensor_positiv			: R_TRIG;
	fb_r_trig_limit_sensor_negativ			: R_TRIG;
	fb_r_trig_skalierungsnocken				: R_TRIG;
	lr_slave_position						: LREAL := 0.0;
	i16_auftrag_cameditor					: enum_auftrag_cameditor;
	i16_kollisionszaehler					: INT := 0;
	b_hand_dialog_aktiv					: BOOL := FALSE;
	b_all_state_parts_ok					: BOOL := FALSE;
	b_kommt_von_init						: BOOL := FALSE;
	i32_UsedTool						: DINT := 0;

	sm_positionsueberwachung				: BOOL := FALSE;
	sm_werkzeugreihenfolge_nicht_io		: BOOL := FALSE;
	sm_keine_bandfreigabe				: BOOL := FALSE;
	sm_tagnummer_ungueltig				: BOOL := FALSE;
	sm_typ_bestueckprogramm_falsch	: BOOL := FALSE;
	sm_keine_rafo_im_einzug		: BOOL := FALSE;


	bm_kein_Pin_im_BB				: BOOL := FALSE;

	(* Kurvenscheibeneditor *)
	i16_startpunkt_mf_tab					: INT := 0;

	st_geschwindigkeiten					: struct_ecd_geschwindigkeiten;
	e_referenz_sensor						AT %I* : BOOL;
	i16_torque							AT %I* : INT;
	i16_DigitalInput						AT %I* : INT;

	lr_vmax_festo							: LREAL := 100.0;

	lr_ReduzierungOverride				: LREAL := 1.0;

	zeit_wt_wechsel						: DINT := 0;
	zeit_wt_bestuecken					: DINT := 0;

	fb_Z_Achse_einfahren			: ST_Taktzeit;
	fb_Bestueckung					: ST_Taktzeit;
	fb_Z_Achse_ausfahren	: ST_Taktzeit;

	lr_decceleration_nothalt				: LREAL;
	lr_decceleration_normal				: LREAL;

	i32_anzahl_rasterfolie				: DINT := 0;

	b_rastnase_vorhanden_vorne			: BOOL;
	b_rastnase_vorhanden_hinten			: BOOL;
	bm_rastnasen_1_fehlt					: BOOL;
	bm_rastnasen_2_fehlt					: BOOL;
	e_kontrolle_rastnase 			AT %I* : BOOL;
	b_teach_pruef_pos1					: BOOL;
	b_teach_pruef_pos2					: BOOL;

	i16_state_msg						: INT;
	Teile_nach_Bandwechsel				: BOOL;
	fb_r_trig_Bandwechsel					: R_TRIG;

	lr_MaxSoftPosLimit					:LREAL;
	lr_MinSoftPosLimit						:LREAL;
	b_EndlageErreicht						:BOOL;
	fb_r_trig_Endlage						: R_TRIG;
	i16_state_msg2						: INT;
END_VAR

(* @END_DECLARATION := '0' *)
(* Die Z-Achse ist der Masterablauf. Sie "weis" wann es losgeht und kennt das Bestückbild.
 * Die Z-Achse schaltet die Bestückachse als Master der Kurvenscheibe ein und startet diese. *)

(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_wz_disable(IN:= , PT:= t#500ms, Q=> , ET=> );

fb_ton_taktzeitmessung_wt_wechsel(IN:= , PT:= t#2h, Q=> , ET=> );
fb_ton_taktzeitmessung_bestuecken(IN:= , PT:= t#2h, Q=> , ET=> );

(*Taktzeitmessung*)
fb_Z_Achse_einfahren(b_start:= , t_zeit=> );
fb_Bestueckung(b_start:= , t_zeit=> );
fb_Z_Achse_ausfahren(b_start:= , t_zeit=> );

(* Flanken *)
fb_r_trig_limit_sensor_positiv(CLK:= st_config_achse.b_limitsensor_positiv_vorhanden AND NOT fb_axis.e_limit_sensor_positive, Q=> );
fb_r_trig_limit_sensor_negativ(CLK:= st_config_achse.b_limitsensor_negativ_vorhanden AND NOT fb_axis.e_limit_sensor_negative, Q=> );
fb_r_trig_taste_plus(CLK:= ST_Euchner_Handbedienpult.b_Taste_Plus, Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );
fb_r_trig_start_in(CLK:= b_start_in, Q=> );
fb_r_trig_skalierungsnocken(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_START_SKALIERUNG], Q=> );
fb_r_trig_hand_dialog(CLK:= b_hand_dialog_aktiv, Q=> );
fb_r_trig_nullpunkt_setzen(CLK:=axis_z_achse.st_visu.b_nullpunkt_setzen);

(* Berechnung Override Reduzierung wenn Y-Achse die Rampe fahren muss *)
IF 	gst_datensatz.st_wkz.bFahreSofortAufUebergabePosition AND
	((z_achse.NcToPlc.ActPos > gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_z - 20 AND
	gst_datensatz.st_wkz.b_variable_einfahrposition) OR
	(z_achse.NcToPlc.ActPos > ST_MotionFunctionPoints.YZTischMasterPos2 - 20 AND
	NOT gst_datensatz.st_wkz.b_variable_einfahrposition)) THEN
	lr_ReduzierungOverride := gst_datensatz.st_wkz.r_auto_z / st_geschwindigkeiten.lr_auto_max;
ELSE
	lr_ReduzierungOverride := 1;

END_IF


(*Meldung Teile nach Bandwechsel*)
fb_r_trig_Bandwechsel(CLK:= Teile_nach_Bandwechsel , Q=> );
IF fb_r_trig_Bandwechsel.Q  THEN
	i16_state_msg := 1;
END_IF

(*Produktionsmeldung für Übergabe zu lange*)
CASE i16_state_msg OF
	1: (*Warten bis keine ander Produktions Meldung ansteht *)
		IF	TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			i16_state_msg := 2;
		END_IF

	2:  (*Produktions Meldung*)
		Visu.MeldungProduktion.Color_R := 255;
		Visu.MeldungProduktion.Color_G := 255;
		Visu.MeldungProduktion.Color_B := 0;
		IF visu.s_akt_sprache = 'de' THEN
			Visu.MeldungProduktion.Name:=('Teile nach Bandwechsel');
		ELSIF visu.s_akt_sprache = 'en' THEN
			Visu.MeldungProduktion.Name:=('Teile nach Bandwechsel');
		ELSIF visu.s_akt_sprache = 'cz' THEN
			Visu.MeldungProduktion.Name:=('Teile nach Bandwechsel');
		END_IF
		Visu.MeldungProduktion.ShowMessage := TRUE;
		Visu.MeldungProduktion.Button1.sichtbar:=TRUE;	(*OK*)
		Visu.MeldungProduktion.Button1.Text:='Ok';
		i16_state_msg := 3;

	3:  (*Warte auf OK*)
		IF Visu.MeldungProduktion.Button1.tasten THEN
			i16_state_msg:=0;
		END_IF
END_CASE


(* Achse steuern *)
fb_axis(
	e_referenznocken:= ,
	b_refsensor_vorhanden:= st_config_achse.b_refsensor_vorhanden,
	b_limitsensor_positiv_vorhanden:= st_config_achse.b_limitsensor_positiv_vorhanden,
	b_limitsensor_negativ_vorhanden:= st_config_achse.b_limitsensor_negativ_vorhanden,
	i16_achstyp := st_config_achse.i16_achstyp,
	lr_override_vorgabe:= ST_TippTasten.lr_override * lr_ReduzierungOverride,
	st_position:= ,
	mc_richtung_modulo:= ,
	mc_richtung_velocity:= ,
	mc_referenzmodus:= ,
	mc_buffermode_axis:= ,
	ui16_soeparam_write_value:= ,
	w_idn:= ,
	i16_nc_parameter_nummer:= ,
	r_wert_nc_write_parameter:= ,
	st_vorgabe_geschwindigkeiten:= st_geschwindigkeiten,
	lr_soll_geschwindigkeit:= ,
	b_bedingung_sls:= NOT e_tuere_vorne_offen OR NOT e_tuere_hinten_offen,
	st_ads_info := ,
	st_eccoe_sdo := ,
	st_masterachse:= z_achse,
	st_visu_axis:= st_visu,
	st_ecd_cmd:= st_drive_cmd,
	ui16_soeparam_read_value=> ,
	r_wert_nc_read_parameter=> ,
	lr_RecPos=> lr_RecPos,
	b_TriggerInput:=i16_DigitalInput.1, (*1*)
	b_FallingEdge:=TRUE);

CASE gst_datensatz.st_md.i16_typ_zelle OF
	KEINE_ZELLE:
		;

	BESTUECKZELLE_1700:
		IF gi16_betriebsart = HAND THEN
			(* Bei manuellem Fahren der Slaveachse, muss diese erst entkoppelt werden *)
			IF ST_Y_Achse.b_hand_dialog_aktiv AND y_achse.NcToPlc.CoupleState > 0 THEN
				st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
			END_IF
			(* Achse mit dem Euchner Handbediengerät vorwärts und rückwärts Bewegen*)
			IF fb_r_trig_hand_dialog.Q THEN
				IF y_achse.NcToPlc.CoupleState > 0 THEN
					st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
				END_IF
				fb_state_entry.i16_next_step := HANDRAD;
			END_IF
		END_IF

		IF y_achse.NcToPlc.CoupleState > 0 OR st_drive_cmd_y_achse.enu_cmd > NO_COMMAND THEN
			(* Kurvenscheibenkopplung ein/ausschalten *)
			fb_axis_y_achse(
				r_getriebefaktor:= ,
				r_master_position:= ,
				mc_activation_mode_camin:= ,
				lr_activation_position_camin:= ,
				mc_activation_mode_scaleing:= ,
				lr_activation_position_scaleing:= ,
				mc_buffermode_axis:= ,
				mc_cam_table_id:= 2 ,
				mc_cam_point_id:= ,
				mc_motion_function_point:= ,
				st_camin_options:= ,
				st_camexchange_options:= ,
				mc_reference_cam_table_id:= ,
				st_camscaling_data:= ,
				st_masterachse:= z_achse,
				st_slaveachse:= y_achse,
				st_ecd_cmd:= st_drive_cmd_y_achse );
		END_IF

	BESTUECKZELLE_1720:
		IF gi16_betriebsart = HAND THEN
			(* Achse mit dem Euchner Handbediengerät vorwärts und rückwärts Bewegen*)
			IF fb_r_trig_hand_dialog.Q THEN
				fb_state_entry.i16_next_step := HANDRAD;
			END_IF
		END_IF

	RASTERFOLIE:
		IF gi16_betriebsart = HAND THEN
			(* Bei manuellem Fahren der Slaveachse, muss diese erst entkoppelt werden *)
			IF ST_Y_Achse.b_hand_dialog_aktiv AND y_achse.NcToPlc.CoupleState > 0 THEN
				st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
			END_IF
			(* Achse mit dem Euchner Handbediengerät vorwärts und rückwärts Bewegen*)
			IF fb_r_trig_hand_dialog.Q THEN
				IF y_achse.NcToPlc.CoupleState = 3 THEN
					st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
				END_IF
				fb_state_entry.i16_next_step := HANDRAD;
			END_IF
		END_IF

		IF y_achse.NcToPlc.CoupleState > 0 OR st_drive_cmd_y_achse.enu_cmd > NO_COMMAND THEN
			(* Kurvenscheibenkopplung ein/ausschalten *)
			fb_axis_y_achse(
				r_getriebefaktor:= ,
				r_master_position:= ,
				mc_activation_mode_camin:= ,
				lr_activation_position_camin:= ,
				mc_activation_mode_scaleing:= ,
				lr_activation_position_scaleing:= ,
				mc_buffermode_axis:= ,
				mc_cam_table_id:= 2 ,
				mc_cam_point_id:= ,
				mc_motion_function_point:= ,
				st_camin_options:= ,
				st_camexchange_options:= ,
				mc_reference_cam_table_id:= ,
				st_camscaling_data:= ,
				st_masterachse:= z_achse,
				st_slaveachse:= y_achse,
				st_ecd_cmd:= st_drive_cmd_y_achse );
		END_IF
END_CASE


IF gi16_betriebsart = HAND THEN
	(* Button in der Oberfläche zum setzen des Nullpunktes *)
	IF fb_r_trig_nullpunkt_setzen.Q THEN
		fb_state_entry.i16_next_step :=	NULLPUNKT_SETZEN;
	END_IF
END_IF

(*Meldung Achse hat Endlage überfahren*)
IF lr_MaxSoftPosLimit<>0 AND
  lr_MaxSoftPosLimit < gst_datensatz.st_md.st_md_z_achse.lr_wt_uebergabepos  THEN
	b_EndlageErreicht:= TRUE;
ELSE
	b_EndlageErreicht:=FALSE;
END_IF

fb_r_trig_Endlage(CLK:= b_EndlageErreicht , Q=> );

IF fb_r_trig_Endlage.Q THEN
	i16_state_msg2 := 1;
END_IF

(*Produktionsmeldung für Endlage überfahren*)
CASE i16_state_msg2 OF
	1: (*Warten bis keine ander Produktions Meldung ansteht *)
		IF	TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			i16_state_msg2 := 2;
		END_IF

	2:  (*Produktions Meldung*)
		Visu.MeldungProduktion.Color_R := 255;
		Visu.MeldungProduktion.Color_G := 255;
		Visu.MeldungProduktion.Color_B := 0;
		IF visu.s_akt_sprache = 'de' THEN
			Visu.MeldungProduktion.Name:='Z-Achse WT Übergabepos größer als Endlage';
		ELSIF visu.s_akt_sprache = 'en' THEN
			Visu.MeldungProduktion.Name:='Z-Achse WT Übergabepos größer als Endlage';
		ELSIF visu.s_akt_sprache = 'cz' THEN
			Visu.MeldungProduktion.Name:='Z-Achse WT Übergabepos größer als Endlage';
		END_IF
		Visu.MeldungProduktion.ShowMessage := TRUE;
		Visu.MeldungProduktion.Button1.sichtbar:=FALSE;	(*OK*)
		Visu.MeldungProduktion.Button1.Text:='Ok';
		i16_state_msg2 := 3;

	3:  (*Warte auf OK*)
		IF NOT b_EndlageErreicht THEN
			ST_Message_Produktion.b_PM_Quitt:=TRUE;
			i16_state_msg2:=0;
		END_IF
END_CASE


(* =======================================Toplevel========================================== *)
(* Starte Inbetriebnahme-Sequenz *)
IF st_ctrl_in.b_gehe_step_ibn THEN
	fb_state_entry.i16_next_step := INBETRIEBNAHME;
END_IF

(* =====Achse wird disabled===== *)
IF (NOT e_steuerung_ein OR NOT e_ba_mit_bedingungen) AND z_achse.Status.Operational THEN
	st_drive_cmd.enu_cmd := POWER_DISABLE;
END_IF

IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* =====Fehler vom Achskontroller===== *)
	IF st_drive_cmd.b_job_fehler OR st_drive_cmd_y_achse.b_job_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF

	IF fb_state_entry.i16_next_step > 40 THEN
		(* Devicefehler *)
		IF z_achse.Status.Error THEN
			st_sm.b_achsfehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSIF z_achse.Status.DriveDeviceError THEN
			st_sm.b_devicefehler := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	END_IF

	IF fb_state_entry.i16_next_step < STOP THEN
		(* =====Achse wird gestoppt===== *)
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		ELSIF fb_state_entry.i16_next_step < HALT THEN
			(* =====Achse wird angehalten===== *)
			IF st_ctrl_in.b_halt THEN
				fb_state_entry.i16_next_step := HALT;
			END_IF
		END_IF
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config_achse.b_config_fertig THEN
			fb_state_entry.i16_next_step := 1;
		END_IF

(*=======================================================*)
	1:	(* Warte bis NetID´s der Slaves ausgelesen sind *)
		IF fb_state_entry.E THEN
			;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_EthercatDiag.st_ctrl_out.b_fertig THEN
			fb_state_entry.i16_next_step := 2;
		END_IF

(*=======================================================*)
	2:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxVelocitySystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			lr_Velo_in:=st_geschwindigkeiten.lr_maximalgeschwindigkeit;
			st_geschwindigkeiten.lr_auto_max := st_geschwindigkeiten.lr_maximalgeschwindigkeit := fb_axis.r_wert_nc_read_parameter;
			st_geschwindigkeiten.lr_auto_min := 50;
			st_geschwindigkeiten.lr_jog := 100;
			fb_state_entry.i16_next_step := 3;
		END_IF

(*=======================================================*)
	3:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxAccelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_beschleunigung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 4;
		END_IF

(*=======================================================*)
	4:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxDecelerationSystem;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_verzoegerung := fb_axis.r_wert_nc_read_parameter;
			lr_decceleration_normal := st_geschwindigkeiten.lr_verzoegerung;
			lr_decceleration_nothalt := 200000.0;
			fb_state_entry.i16_next_step := 5;
		END_IF

(*=======================================================*)
	5:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := MaxJerk;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_geschwindigkeiten.lr_ruck := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 6;
		END_IF

(*=======================================================*)
	6:	(* Konfigurationen der Achse *)
		IF fb_state_entry.E THEN
			fb_axis.st_eccoe_sdo.s_ec_slave_net_id := ST_EthercatDiag.s_ec_slave_net_id[2];
			fb_axis.st_eccoe_sdo.ui16_slave_addr := st_config_achse.ui16_ethercat_adr;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 7;

(*=======================================================*)
	7:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisMinSoftPosLimit;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			lr_MinSoftPosLimit := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 8;
		END_IF


(*=======================================================*)
	8:	(* Spezifische NC-Achsparameter auslesen *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisMaxSoftPosLimit;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			lr_MaxSoftPosLimit := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := FEHLER; (*in Fehler gehen damit die Achsen resetet werden. Sonst steigen die Achsen bei einem TC Restart aus*)
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_quitt.IN := FALSE;
			fb_ton_taktzeitmessung_wt_wechsel.IN := FALSE;
			fb_ton_taktzeitmessung_bestuecken.IN := FALSE;
			b_start_in:=FALSE;
			st_ctrl_in.b_start:=FALSE;
			st_ctrl_out.b_busy:=FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_fertig_2 := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_gestoppt := FALSE;
			st_ctrl_out.b_prebereit := FALSE;
			axis_y_achse.st_ctrl.in.b_start := FALSE;
			i16_kollisionszaehler := 0;
			(* Reset Stoermeldungen *)
			st_sm.b_achse_nicht_auf_startpos := FALSE;
			st_sm.b_achsfehler := FALSE;
			st_sm.b_devicefehler := FALSE;
			st_sm.b_keine_verfahrfreigabe := FALSE;
			st_sm.b_ende_skalierungs_nocke := FALSE;
			st_sm.b_ende_camming_nocke := FALSE;
			st_sm.b_skalierung_noch_aktiv := FALSE;
			sm_positionsueberwachung := FALSE;
			sm_werkzeugreihenfolge_nicht_io := FALSE;
			sm_keine_bandfreigabe := FALSE;
			sm_tagnummer_ungueltig := FALSE;
			sm_typ_bestueckprogramm_falsch := FALSE;
			sm_keine_rafo_im_einzug:=FALSE;

			bm_rastnasen_1_fehlt := FALSE;
			bm_rastnasen_2_fehlt := FALSE;

			bm_kein_Pin_im_BB:= FALSE;

			axis_y_achse.st_ctrl.in.b_start := FALSE;
			axis_y_achse.st_ctrl.in.b_start_2 := FALSE;
			axis_virt_master.st_ctrl.in.b_start := FALSE;
			rasterfolienmontage.st_ctrl.in.b_start := FALSE;
			balluff_tag_reader.st_ctrl.in.b_start_lesen := FALSE;
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;

			b_kommt_von_init := TRUE;

			fb_axis.mc_buffermode_axis := MC_Aborting;

			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_z;

			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_normal;
		END_IF

		IF y_achse.NcToPlc.CoupleState > 0 THEN
			st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_preinit THEN
			fb_state_entry.i16_next_step := 15;
		END_IF

(*=======================================================*)
	15:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;	(* vom Datentyp MC_AxisParameter *)
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_z_achse.lr_nullpunktverschiebung THEN
				CASE gst_datensatz.st_md.i16_typ_zelle OF
					KEINE_ZELLE:
						;

					BESTUECKZELLE_1700, RASTERFOLIE:
						fb_state_entry.i16_next_step := 35;
	
					BESTUECKZELLE_1720:
						fb_state_entry.i16_next_step := 40;
				END_CASE
			ELSE
				fb_state_entry.i16_next_step := 25;	(* Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	25:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
		(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_z_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			CASE gst_datensatz.st_md.i16_typ_zelle OF
				KEINE_ZELLE:
					;

				BESTUECKZELLE_1700, RASTERFOLIE:
					fb_state_entry.i16_next_step := 35;

				BESTUECKZELLE_1720:
					fb_state_entry.i16_next_step := 40;
			END_CASE
		END_IF

(*=======================================================*)
	35:	(* CAM OUT Y-Achse *)
		IF fb_state_entry.E THEN
			st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_y_achse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:	(* Reglerfreigabe setzen , Reset wird bei Bedarf automatisch ausgeführt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:	(* Nullpunktverschiebung ist geschrieben *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_prebereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			CASE gst_datensatz.st_md.i16_typ_zelle OF
				KEINE_ZELLE:
					;

				BESTUECKZELLE_1700, RASTERFOLIE:
					fb_state_entry.i16_next_step := 60;

				BESTUECKZELLE_1720:
					fb_state_entry.i16_next_step := 95;
			END_CASE
		END_IF

(*=======================================================*)
	60: (* Abfrage der Positionen von Z-Achse und Y-Achse *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	z_achse.NcToPlc.ActPos > ST_MotionFunctionPoints.YZTischMasterPos3 AND
			ABS(y_achse.NcToPlc.ActPos - gst_datensatz.st_md.st_md_y_achse.lr_wt_uebergabepos) > 0.5
			THEN
				(* Y-Achse steht in Kollision mit Antriebskonus des Förderbands *)
				fb_state_entry.i16_next_step := 70;
		ELSE
			i16_kollisionszaehler := 0;
			fb_state_entry.i16_next_step := 80;
		END_IF

(*=======================================================*)
	70: (* Im Wiederhohlungsfall -> Fehler *)
		IF fb_state_entry.E THEN
			i16_kollisionszaehler := i16_kollisionszaehler + 1;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF i16_kollisionszaehler > 1 THEN
			sm_positionsueberwachung := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSE
			fb_state_entry.i16_next_step := 75;
		END_IF

(*=======================================================*)
	75:	(* Fahre Z-Achse und damit Y-Achse aus der Kollisionsposition *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_z;
			fb_axis.st_position.r_soll := ST_MotionFunctionPoints.YZTischMasterPos3;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 80;
		END_IF

(*=======================================================*)
	80: (* Auslesen der Y-Position an der aktuellen Z-Position in der Kurvenscheibe *)
		IF fb_state_entry.E THEN
			fb_axis_y_achse.r_master_position := z_achse.NcToPlc.ActPos;
			st_drive_cmd_y_achse.enu_cmd := READ_SLAVE_DYNAMICS;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_y_achse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 85;
		END_IF

(*=======================================================*)
	85: (* Starte Y-Achse auf die entsprechende Position in der Kurvenscheibe *)
		IF fb_state_entry.E THEN
			lr_slave_position := fb_axis_y_achse.mc_read_camtable_slave_dynamics.SlavePosition;
			axis_y_achse.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_y_achse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			axis_y_achse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 90;
		END_IF

(*=======================================================*)
	90:	(* CAM IN Y-Achse *)
		IF fb_state_entry.E THEN
			fb_axis_y_achse.st_camscaling_data.SlaveScaling := 1;
			st_drive_cmd_y_achse.enu_cmd := CAM_IN_SLAVE;
		END_IF

		IF y_achse.NcToPlc.CoupleState = 0 THEN
			st_drive_cmd_y_achse.enu_cmd := CAM_IN_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_y_achse.enu_cmd = NO_COMMAND AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 95;
		END_IF

(*=======================================================*)
	95:	(* Fahre Z-Achse auf die WT-Übergabeposition *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_z;
			fb_axis.st_position.r_soll := gst_datensatz.st_md.st_md_z_achse.lr_wt_uebergabepos;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_busy:=FALSE;
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
			bm_rastnasen_1_fehlt := FALSE;
			bm_rastnasen_2_fehlt := FALSE;
			enu_cmd_in:=NO_COMMAND;
		END_IF

		IF NOT gst_datensatz.st_wkz.b_rafo_auto_einf_aktiv THEN
			IF 	gst_datensatz.st_md.i16_typ_zelle = RASTERFOLIE AND
				NOT ST_Rasterfolieneinzug.fb_tof_gls_rafo_ende.Q THEN
				fb_state_entry.i16_next_step := FEHLER;
				sm_keine_rafo_im_einzug:=TRUE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_start.Q  THEN
(*			(* Stoppe WT Wechselzeit *)
			zeit_wt_wechsel := TIME_TO_DWORD(fb_ton_taktzeitmessung_wt_wechsel.ET);
			fb_ton_taktzeitmessung_wt_wechsel.IN := FALSE;
			(* Starte Bestückzeit *)
			fb_ton_taktzeitmessung_bestuecken.IN := TRUE;*)
			fb_Z_Achse_einfahren(b_start:= TRUE, t_zeit=> );
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_busy:=TRUE;
			i32_anzahl_rasterfolie:=0;
			fb_state_entry.i16_next_step := 110;
		END_IF

		IF 	fb_r_trig_start_in.Q THEN		(*neu! zum Starten einer Positionierung von einem externen Prg.*)
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_busy:=TRUE;
			fb_state_entry.i16_next_step := 102;
		END_IF

(*=======================================================*)
	102:	(*Y Achse abkoppeln*)
		IF 	fb_state_entry.E THEN
			b_start_in:=FALSE;
		END_IF

		IF 	y_achse.NcToPlc.CoupleState > 0 THEN
			st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
		ELSE
			fb_state_entry.i16_next_step := 103;
		END_IF

(*=======================================================*)
	103:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	enu_cmd_in = NO_COMMAND THEN
			fb_state_entry.i16_next_step := BEREIT;
		ELSIF
			enu_cmd_in = CAM_IN_SLAVE THEN
			fb_state_entry.i16_next_step := 90;		 (* Y Achse Cam In und auf Grundstellung fahren   *)

		ELSE
			fb_state_entry.i16_next_step := 104;
		END_IF

(*=======================================================*)
	104: (* Positioniere Achse  *)
		IF 	fb_state_entry.E THEN
			fb_axis.st_position.r_soll := lr_Achspos_in ;
			fb_axis.lr_soll_geschwindigkeit:=lr_Velo_in;
			st_drive_cmd.enu_cmd := enu_cmd_in;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	110: (* WT-Tag mit RFID-Lesegerät auslesen *)
		IF fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_lesen := TRUE;
			balluff_tag_reader.fb.i16_addresse := 0;
			balluff_tag_reader.fb.i16_anzahl_byte := SIZEOF(gst_tag_data);
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			ST_Konvertiere_gelese_TagData();

			IF gst_tag_data.WpcNumber >= 1 AND gst_tag_data.WpcNumber <=50 THEN
				fb_state_entry.i16_next_step := 120;
			ELSE
				(* Fehler: Tagnummer ist nicht im gültigem Bereich *)
				sm_tagnummer_ungueltig := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			balluff_tag_reader.st_ctrl.in.b_start_lesen := FALSE;
			fb_ton_wz.IN := FALSE;
		END_IF

(*=======================================================*)
	120: (* Die WPCDaten vom ausgelesenen Tag abfragen *)
		IF fb_state_entry.E THEN
			CASE gst_datensatz.st_md.i16_typ_zelle OF
				KEINE_ZELLE:
					;
	
				BESTUECKZELLE_1700, RASTERFOLIE:
					(* Daten Gültig *)
					IF 	(gst_tag_data.StateParts[0] = PART_NEW OR gst_tag_data.StateParts[0] = PART_OK) OR
						hublift_links.st_config.b_station_aktiv OR visu.b_inbetriebnahme OR NOT gst_datensatz.st_md.b_wt_transport_aktiv
						THEN
							fb_state_entry.i16_next_step := 130;
					ELSE
						(* Einfach durchschleusen: Wir muessen nicht bearbeiten. z.B. für gst_tag_data.State01 = PART_DUMMY *)
						fb_state_entry.i16_next_step := BEREIT;
					END_IF

				BESTUECKZELLE_1720:
					(* Daten Gültig *)
					IF 	(gst_tag_data.StateParts[0] = PART_NEW AND gst_tag_data.StateParts[1] = PART_NEW) OR
						(gst_tag_data.StateParts[0] = PART_OK AND gst_tag_data.StateParts[1] = PART_OK) OR
						hublift_links.st_config.b_station_aktiv OR visu.b_inbetriebnahme OR NOT gst_datensatz.st_md.b_wt_transport_aktiv
						THEN
							fb_state_entry.i16_next_step := 130;
					ELSE
						(* Einfach durchschleusen: Wir muessen nicht bearbeiten *)
						fb_state_entry.i16_next_step := BEREIT;
					END_IF
			END_CASE
		END_IF

(*=======================================================*)
		130:	(* Prüfe Bandfreigabe *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700:
				IF 	zyl_bawe_querschub.fb.e_sensor1_eingefahren AND
					((gst_barcode_daten.b_band_links_ok AND gst_barcode_daten.b_band_ID_links_ok) OR
					ST_Virtuelle_Masterachse.b_merker_bandende_links) THEN
					fb_state_entry.i16_next_step := 140;
				ELSIF
					zyl_bawe_querschub.fb.e_sensor1_ausgefahren AND
					((gst_barcode_daten.b_band_rechts_ok AND gst_barcode_daten.b_band_ID_rechts_ok) OR
					ST_Virtuelle_Masterachse.b_merker_bandende_rechts) THEN
					fb_state_entry.i16_next_step := 140;
				ELSE
					sm_keine_bandfreigabe := TRUE;
					fb_state_entry.i16_next_step := 180; 	(*Plle mit NOK beschreiben danach FEHLER*)
				END_IF

			BESTUECKZELLE_1720:
				IF 	(gst_barcode_daten.b_band_ok AND gst_barcode_daten.b_band_ID_links_ok AND gst_barcode_daten.b_band_ID_rechts_ok)  OR
					ST_Virtuelle_Masterachse.b_merker_bandende_rechts OR
					ST_Virtuelle_Masterachse.b_merker_bandende_links THEN
					fb_state_entry.i16_next_step := 140;

				ELSE
					sm_keine_bandfreigabe := TRUE;
					fb_state_entry.i16_next_step := 180; 	(*Plle mit NOK beschreiben danach FEHLER*)
				END_IF

			RASTERFOLIE:
				IF 	gst_barcode_daten.b_band_links_ok THEN
					fb_state_entry.i16_next_step := 140;

				ELSE
					sm_keine_bandfreigabe := TRUE;
					fb_state_entry.i16_next_step := 180; 	(*Plle mit NOK beschreiben danach FEHLER*)
				END_IF

		END_CASE

(*=======================================================*)
	140:	(* Muss das Bestückbild neu von Tag ausgelesen werden? *)


		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	s_alte_artikelnummer = gst_datensatz.st_md.s_aktuelle_artikelnummer AND
			gst_datensatz.st_md.b_wt_transport_aktiv AND
			NOT b_kommt_von_init THEN
			fb_state_entry.i16_next_step := 160;
		ELSE
			fb_state_entry.i16_next_step := 150;
		END_IF

(*=======================================================*)
	150:	(* Bestückbild aus DB von Festplatte einlesen. *)
		IF fb_state_entry.E THEN
			b_kommt_von_init := FALSE;
			gi16_bbgen_auftrag := LESE_BESTUECKBILD; (*und ISK*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	gi16_bbgen_auftrag = KEIN_BB_AUFTRAG THEN
			s_alte_artikelnummer := gst_datensatz.st_md.s_aktuelle_artikelnummer;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160:	(* Suche nach "Pruef" in Artikelnummer (nur für Rasterfolie) *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE gst_datensatz.st_md.i16_typ_zelle OF

			BESTUECKZELLE_1700, BESTUECKZELLE_1720:
				fb_state_entry.i16_next_step := 170;

			RASTERFOLIE:
				IF 	(FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer, 'ruef') > 0 OR			(*es wird nur auf ruef abgefragt, weil das P groß oder klein sein kann*)
					FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'erth') > 0)THEN
					fb_state_entry.i16_next_step := 370;	(* nicht Bestücken *)
				ELSE
					fb_state_entry.i16_next_step := 170;
				END_IF

		END_CASE

(*=======================================================*)
	170: (* Prüfe Werkzeugreihenfolge *)
		(* 	3 Fälle:
			1:	- PART_NEW	--->	Wir sind die erste Station
			2:	- PART_OK	--->	Vorgänger hat Station Ok bearbeitet
				-			--->	Prüfe dass diese LastUsedTool in der Liste vor unserer Station steht

			3:	- PART_NOK	-->	Kommt hier gar nicht an, trotzdem Fehler abfangen
				- PART_NO	-->	Kommt hier gar nicht an, trotzdem Fehler abfangen
		*)	
		IF fb_state_entry.E THEN
			CASE gst_datensatz.st_md.i16_typ_zelle OF
				KEINE_ZELLE:
					;

				BESTUECKZELLE_1700, BESTUECKZELLE_1720, RASTERFOLIE:
					IF gst_datensatz.st_md.i16_typ_bestueckmodus<>BESTUECKUNG_MANUAL  AND gst_datensatz.st_md.b_wt_transport_aktiv THEN

						i32_UsedTool:=-1;
						k:=-1;
						FOR k := 0 TO 4 DO      (*Werkzeuggruppen durchsuchen*)
							i:=-1;

							CASE gst_datensatz.st_md.i16_typ_bestueckmodus OF

								BESTUECKUNG_MANUAL:
											;
								BESTUECKUNG_HALBAUTO:

									FOR i := 0 TO MaxNoOfWkz DO
										IF 	gst_bestueckbild_halbauto.s_wkzgruppe[k].s_wkznummer[i] = gst_datensatz.st_md.s_aktuelles_wkz THEN
											i32_UsedTool:=i;
										END_IF
									END_FOR

								BESTUECKUNG_AUTO:

									FOR i := 0 TO MaxNoOfWkz DO
										IF 	gst_bestueckbild.s_wkzgruppe[k].s_wkznummer[i] = gst_datensatz.st_md.s_aktuelles_wkz THEN
											i32_UsedTool:=i;
										END_IF
									END_FOR

								ELSE
									sm_typ_bestueckprogramm_falsch := TRUE;
									fb_state_entry.i16_next_step := FEHLER;
							END_CASE

						END_FOR

						(* ------- Fall 1-------- *)
						IF gst_tag_data.StateParts[0]= PART_NEW THEN
							IF 	i32_UsedTool<>-1 THEN
								gst_tag_data.LastUsedTool := DINT_TO_BYTE(i32_UsedTool);
								fb_state_entry.i16_next_step := 190;
							ELSE
							(* NOk *)
								sm_werkzeugreihenfolge_nicht_io := TRUE;
								fb_state_entry.i16_next_step := 180; 	(*Pille mit NOK beschreiben danach FEHLER*)
							END_IF

						(* ------- Fall 2-------- *)
						ELSIF gst_tag_data.StateParts[0] = PART_OK THEN

							(* Ok *)
							IF 	i32_UsedTool<>-1 AND
							 	gst_tag_data.LastUsedTool < i32_UsedTool AND
								i32_UsedTool < gst_tag_data.LastUsedTool+3 THEN
								gst_tag_data.LastUsedTool := DINT_TO_BYTE(i32_UsedTool);
								fb_state_entry.i16_next_step := 190;
							ELSIF gst_tag_data.LastUsedTool = i32_UsedTool THEN
								fb_state_entry.i16_next_step := BEREIT;	(* nichts tun, ich habe schon bestückt *)
							ELSE
							(* NOk *)
								sm_werkzeugreihenfolge_nicht_io := TRUE;
								fb_state_entry.i16_next_step := 180; 	(*Pille mit NOK beschreiben danach FEHLER*)
							END_IF
						(* ------- Fall 3-------- *)
						ELSE
							sm_werkzeugreihenfolge_nicht_io := TRUE;
							fb_state_entry.i16_next_step := 180; 	(*Pille mit NOK beschreiben danach FEHLER*)
						END_IF
					ELSE
						(* Manuelle BB Anwahl *)
						gst_tag_data.LastUsedTool := 0;
						fb_state_entry.i16_next_step := 190;
					END_IF
			END_CASE
		END_IF

(*=======================================================*)
	180: (* Markiere WT als schlecht, weil Werkzeugreihenfolge nicht passt und Ende mit Fehler. *)
		IF fb_state_entry.E THEN
			ST_Markiere_WT_NIO();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			(* Ok: Daten wurden auf die Pille geschrieben *)
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	190:	(* Werkzeugreihenfolge in Ordnung *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700, RASTERFOLIE:
				IF 	gst_PersDaten.b_Zelle_nicht_in_Betrieb AND (FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'ruef') = 0 AND			(*es wird nur auf ruef abgefragt, weil das P groß oder klein sein kann*)
					FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'erth') = 0) THEN
					fb_state_entry.i16_next_step := 195;
				ELSE
					IF 	gst_datensatz.st_md.b_tagreader_fahrend THEN
						fb_state_entry.i16_next_step := 200;
					ELSE
						fb_state_entry.i16_next_step := 210;
					END_IF
				END_IF


				(*Abbruch wenn kein Pin bestückt wird*)
				IF	gst_datensatz.st_bestueckprogramm.i32_anzahl=0 THEN
					fb_state_entry.i16_next_step := 350;
					bm_kein_Pin_im_BB:= TRUE;
					IF FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'ruef') = 0 AND			(*es wird nur auf ruef abgefragt, weil das P groß oder klein sein kann*)
						FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'erth') = 0THEN
						gst_PersDaten.b_Zelle_nicht_in_Betrieb := TRUE;
					END_IF
				ELSE
					bm_kein_Pin_im_BB:= FALSE;
				END_IF

			BESTUECKZELLE_1720:
				IF 	gst_PersDaten.b_Zelle_nicht_in_Betrieb AND (FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'ruef') = 0 AND			(*es wird nur auf ruef abgefragt, weil das P groß oder klein sein kann*)
					FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'erth') = 0) THEN
					fb_state_entry.i16_next_step := 395;
				ELSE
					IF gst_datensatz.st_md.	b_tagreader_fahrend THEN
						fb_state_entry.i16_next_step := 400;
					ELSE
						fb_state_entry.i16_next_step := 405;
					END_IF
				END_IF

				(*Abbruch wenn kein Pin bestückt wird*)
				IF	gst_datensatz.st_bestueckprogramm.i32_anzahl=0 THEN
					fb_state_entry.i16_next_step := 460;
					bm_kein_Pin_im_BB:= TRUE;
					IF 	FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'ruef') = 0 AND			(*es wird nur auf ruef abgefragt, weil das P groß oder klein sein kann*)
						FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'erth') = 0 THEN
						gst_PersDaten.b_Zelle_nicht_in_Betrieb := TRUE;
					END_IF
				ELSE
					bm_kein_Pin_im_BB:= FALSE;
				END_IF
		END_CASE

(*=======================================================*)
	195: (*Warten bis keine ander Produktions Meldung ansteht *)
		IF	TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			fb_state_entry.i16_next_step := 196;
		END_IF

(*=======================================================*)
	196:  (*Produktions Meldung*)
		Visu.MeldungProduktion.Color_R := 255;
		Visu.MeldungProduktion.Color_G := 0;
		Visu.MeldungProduktion.Color_B := 0;
		IF visu.s_akt_sprache = 'de' THEN
			Visu.MeldungProduktion.Name:='Zelle war nicht in Betrieb, bitte Instandhalter informieren!$R$N$R$NÖler,Bestückposition, Seitenversatz und Biegewinkel kontrollieren$R$NMeldung kann nur eingeloggt quittiert werden';
		ELSIF visu.s_akt_sprache = 'en' THEN
			Visu.MeldungProduktion.Name:='Station has not been used for last order, please inform Maintenance Technician!$R$N$R$Ncheck oiler, stich position, left/right and bending angle$R$Nmessage can only be acknowledged when logged in';
		ELSIF visu.s_akt_sprache = 'cz' THEN
			Visu.MeldungProduktion.Name:='Bunka nebyla v provozu, informujte prosim serizovace. Zkontrolujte olej, nastaveni os a uhel ohybu.$R$NZprávu lze potvrdit jen po prihlaseni ';
		END_IF
		Visu.MeldungProduktion.ShowMessage := TRUE;
		Visu.MeldungProduktion.Button1.sichtbar:=TRUE;	(*OK*)
		Visu.MeldungProduktion.Button1.Text:='Ok';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF visu.b_logon THEN
			IF Visu.MeldungProduktion.Button1.tasten THEN
				IF gst_datensatz.st_md.	b_tagreader_fahrend THEN
					fb_state_entry.i16_next_step := 200;
				ELSE
					fb_state_entry.i16_next_step := 210;
				END_IF
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			gst_PersDaten.b_Zelle_nicht_in_Betrieb := FALSE;
		END_IF

(*=======================================================*)
	200:  (* Fahre Z-Achse bis auf 0-Koordinate des ISK - Y-Achse ist gekoppelt *)
		(* Einfahrhöhe der Y-Achse beachten! *)
		IF fb_state_entry.E THEN
			IF gst_datensatz.st_wkz.bFahreSofortAufUebergabePosition THEN
				fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_auto_max;
			ELSE
				fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_z;
			END_IF
			fb_axis.st_position.r_soll := gst_datensatz.st_isk.lr_pos_z_0 + gst_datensatz.st_wkz.lr_offset_z_pos_0 + gst_datensatz.st_wt.lr_offset_z_pos_0 + gst_datensatz.st_md.lr_offset_z_pos_0 + gst_datensatz.st_bestueckprogramm.lr_z[0];
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
			(*Rasterfolie kann gleich eingezogen werden. Zeitersparnis*)
			IF gst_datensatz.st_md.i16_typ_zelle = RASTERFOLIE THEN
				rasterfolieneinzug.st_ctrl.in.b_start := TRUE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Z-Achse losfahren und währenddessen beschreibt der Tagreader die Pille *)
		(*Rasterfolie kann gleich eingezogen werden. Zeitersparnis*)
		IF gst_datensatz.st_md.i16_typ_zelle = RASTERFOLIE THEN
			IF NOT rasterfolieneinzug.st_ctrl.out.b_fertig THEN
				rasterfolieneinzug.st_ctrl.in.b_start := FALSE;
				fb_state_entry.i16_next_step := 210;
			END_IF
		ELSE
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* WT als schlecht markieren *)
		IF fb_state_entry.E THEN
			ST_Markiere_WT_NIO();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			(* Ok: Daten sind auf der Pille *)
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			IF gst_datensatz.st_md.b_tagreader_fahrend THEN
				(* Auf Z-Achse warten *)
				fb_state_entry.i16_next_step := 220;
			ELSE
				(* Daten geschrieben und erst jetzt die Z-Achse fahren *)
				fb_state_entry.i16_next_step := 230;
			END_IF
		END_IF

(*=======================================================*)
	220:	(* Warte noch auf die Z-Achse, bis sie im Ziel steht. *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF gst_datensatz.st_md.i16_typ_zelle = RASTERFOLIE THEN
				IF rasterfolieneinzug.st_ctrl.out.b_fertig THEN
					fb_state_entry.i16_next_step := 240;
				END_IF
			ELSE
				fb_state_entry.i16_next_step := 240;
			END_IF
		END_IF

(*=======================================================*)
	230:(* Fahre Z-Achse bis auf 0-Koordinate des ISK - Y-Achse ist gekoppelt *)
		(* Einfahrhöhe der Y-Achse beachten! *)
		IF fb_state_entry.E THEN
			(* Z-Achse verfahren*)
			IF gst_datensatz.st_wkz.bFahreSofortAufUebergabePosition THEN
				fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_auto_max;
			ELSE
				fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_z;
			END_IF
			fb_axis.st_position.r_soll := gst_datensatz.st_isk.lr_pos_z_0 + gst_datensatz.st_wkz.lr_offset_z_pos_0 + gst_datensatz.st_wt.lr_offset_z_pos_0 + gst_datensatz.st_md.lr_offset_z_pos_0 + gst_datensatz.st_bestueckprogramm.lr_z[0];
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
			(*Rasterfolie kann gleich eingezogen werden. Zeitersparnis*)
			IF gst_datensatz.st_md.i16_typ_zelle = RASTERFOLIE THEN
				rasterfolieneinzug.st_ctrl.in.b_start := TRUE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Z-Achse losfahren und währenddessen beschreibt der Tagreader die Pille *)
		(*Rasterfolie kann gleich eingezogen werden. Zeitersparnis*)
		IF gst_datensatz.st_md.i16_typ_zelle = RASTERFOLIE THEN
			IF NOT rasterfolieneinzug.st_ctrl.out.b_fertig THEN
				rasterfolieneinzug.st_ctrl.in.b_start := FALSE;
				fb_state_entry.i16_next_step := 235;
			END_IF
		ELSE
			fb_state_entry.i16_next_step := 235;
		END_IF

(*=======================================================*)
	235:	(* Warte noch auf die Z-Achse, bis sie im Ziel steht. *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF gst_datensatz.st_md.i16_typ_zelle = RASTERFOLIE THEN
				IF rasterfolieneinzug.st_ctrl.out.b_fertig THEN
					fb_state_entry.i16_next_step := 240;
				END_IF
			ELSE
				fb_state_entry.i16_next_step := 240;
			END_IF
		END_IF

(*=======================================================*)
	240:	(* Camout Y-Achse *)
		IF fb_state_entry.E THEN
			st_drive_cmd_y_achse.enu_cmd := CAM_OUT_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_y_achse.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 250;
		END_IF

(*=======================================================*)
	250: (* Start Y-Achse positionieren auf  0-Koordinate  des ISK *)
		IF fb_state_entry.E THEN
			axis_y_achse.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_y_achse.st_ctrl.out.b_fertig THEN	(* axis_y_achse.st_ctrl.out.b_busy  THEN *)
			fb_state_entry.i16_next_step := 255;
		END_IF

		IF fb_state_entry.X THEN
			axis_y_achse.st_ctrl.in.b_start := FALSE;
		END_IF

(*=======================================================*)
	255: (* Start Y-Achse positionieren auf  0-Koordinate  des ISK *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	axis_y_achse.st_ctrl.out.b_fertig  THEN
			fb_state_entry.i16_next_step := 260;
		END_IF

(*=======================================================*)
	260:
		IF fb_state_entry.E THEN
			fb_Z_Achse_einfahren(b_start:= FALSE, t_zeit=> t_Z_Achse_einfahren);
			fb_Bestueckung(b_start:= TRUE, t_zeit=> );
		END_IF

		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700:
				(* Führung wird an die Bestückachse abgegeben und die Z-Achse und Y-Achse wird ausschliesslich über Kurvenscheiben-Kopplung verfahren *)
				IF fb_state_entry.E THEN
					axis_virt_master.st_ctrl.in.b_start := TRUE;
				END_IF

				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF NOT axis_virt_master.st_ctrl.out.b_fertig THEN
					axis_virt_master.st_ctrl.in.b_start := FALSE;
					fb_state_entry.i16_next_step := 270;
				END_IF

			RASTERFOLIE:
				(* Starten der Rasterfolienmontagestation *)
				IF fb_state_entry.E THEN
					rasterfolienmontage.st_ctrl.in.b_start := TRUE;
				END_IF

				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF NOT rasterfolienmontage.st_ctrl.out.b_fertig THEN
					rasterfolienmontage.st_ctrl.in.b_start := FALSE;
					fb_state_entry.i16_next_step := 290;
				END_IF
		END_CASE

(*=======================================================*)
	270:	(* Bestückzelle 1700 *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_fertig THEN
			fb_state_entry.i16_next_step := 300;
		END_IF

		IF fb_state_entry.X THEN
			(* Stoppe Bestückzeit *)
			zeit_wt_bestuecken := TIME_TO_DWORD(fb_ton_taktzeitmessung_bestuecken.ET);
			fb_ton_taktzeitmessung_bestuecken.IN := FALSE;

			(* Starte WT Wechselzeit *)
			fb_ton_taktzeitmessung_wt_wechsel.IN := TRUE;
			fb_Bestueckung(b_start:= FALSE, t_zeit=>t_Bestueckung );
			fb_Z_Achse_ausfahren(b_start:= TRUE, t_zeit=> );
		END_IF

(*=======================================================*)
	290:	(* Rasterfolie *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	rasterfolienmontage.st_ctrl.out.b_fertig THEN
			fb_state_entry.i16_next_step := 294;
		END_IF

		IF fb_state_entry.X THEN
			(* Stoppe Bestückzeit *)
			zeit_wt_bestuecken := TIME_TO_DWORD(fb_ton_taktzeitmessung_bestuecken.ET);
			fb_ton_taktzeitmessung_bestuecken.IN := FALSE;
			(* Starte WT Wechselzeit *)
			fb_ton_taktzeitmessung_wt_wechsel.IN := TRUE;
			fb_Bestueckung(b_start:= FALSE, t_zeit=>t_Bestueckung );
			fb_Z_Achse_ausfahren(b_start:= TRUE, t_zeit=> );
		END_IF

(*=======================================================*)
	294:(* Fahre Z-Achse auf  Rasterfolienprüfposition *)
		IF fb_state_entry.E THEN


			(* Z-Achse verfahren*)
			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_z;
			fb_axis.st_position.r_soll := 	gst_datensatz.st_isk.lr_pos_z_0 + gst_datensatz.st_wkz.lr_offset_z_pos_0 + gst_datensatz.st_wt.lr_offset_z_pos_0 + gst_datensatz.st_md.lr_offset_z_pos_0 + gst_datensatz.st_bestueckprogramm.lr_z[i32_anzahl_rasterfolie] +	(*Bestückposition*)
										gst_datensatz.st_wkz.st_rasterfolie.lr_pruefpos_rafo;	(*Abstand zwischen Bestückposition und Prüfposition*)
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd.enu_cmd = NO_COMMAND AND
			ST_Rasterfolienmontage.arr_rafo_schieberegister[i32_anzahl_rasterfolie] THEN (*Folie vorhanden*)
			fb_state_entry.i16_next_step := 296;
		END_IF

(*=======================================================*)
	296:	(* Anzahl der Rasterfolien prüfen*)

		IF 	fb_state_entry.E THEN
			i32_anzahl_rasterfolie:=i32_anzahl_rasterfolie+1;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	i32_anzahl_rasterfolie = gst_datensatz.st_bestueckprogramm.i32_anzahl THEN
			fb_state_entry.i16_next_step := 300;	 (*Ende*)
		ELSE
			fb_state_entry.i16_next_step := 297;	 (*zur nächsten Folie*)
		END_IF

(*=======================================================*)
	297:(* Fahre Z-Achse auf nächste Rasterfolienposition *)
		IF 	fb_state_entry.E THEN
			(* Z-Achse verfahren*)
			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_z;
			fb_axis.st_position.r_soll := gst_datensatz.st_isk.lr_pos_z_0 + gst_datensatz.st_wkz.lr_offset_z_pos_0 + gst_datensatz.st_wt.lr_offset_z_pos_0 + gst_datensatz.st_md.lr_offset_z_pos_0 + gst_datensatz.st_bestueckprogramm.lr_z[i32_anzahl_rasterfolie];
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 298;
		END_IF

(*=======================================================*)
	298:(* Fahre Z-Achse auf nächste Rasterfolienposition *)
		IF 	fb_state_entry.E THEN
			(*Rasterfolie kann gleich eingezogen werden. Zeitersparnis*)
			rasterfolieneinzug.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Z-Achse losfahren und währenddessen beschreibt der Tagreader die Pille *)
		(*Rasterfolie kann gleich eingezogen werden. Zeitersparnis*)
		IF NOT rasterfolieneinzug.st_ctrl.out.b_fertig THEN
			rasterfolieneinzug.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 299;
		END_IF

(*=======================================================*)
	299:	(* Neue Folie eingezogen. *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF rasterfolieneinzug.st_ctrl.out.b_fertig THEN
			fb_state_entry.i16_next_step := 240;	(*zurück zum nächsten Folien setzen*)
		END_IF

(*=======================================================*)
	300: (* Auslesen der Y-Position an der aktuellen Z-Position in der Kurvenscheibe *)
		IF 	fb_state_entry.E THEN
			fb_axis_y_achse.r_master_position := z_achse.NcToPlc.ActPos;
			st_drive_cmd_y_achse.enu_cmd := READ_SLAVE_DYNAMICS;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_drive_cmd_y_achse.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 310;
		END_IF

(*=======================================================*)
	310: (* Start Y-Achse positionieren zurück auf die Kurvenbahn *)
		IF 	fb_state_entry.E THEN
			lr_slave_position := fb_axis_y_achse.mc_read_camtable_slave_dynamics.SlavePosition;
			axis_y_achse.st_ctrl.in.b_start_2 := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_y_achse.st_ctrl.out.b_fertig_2 AND NOT fb_state_entry.E THEN
			axis_y_achse.st_ctrl.in.b_start_2 := FALSE;
			fb_state_entry.i16_next_step := 315;
		END_IF

(*=======================================================*)
	315: (* Abfrage, ob sofort auf Übergabeposition gefahren werden soll *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gst_datensatz.st_wkz.bFahreSofortAufUebergabePosition THEN
			fb_state_entry.i16_next_step := 330;
		ELSE
			fb_state_entry.i16_next_step := 320;
		END_IF

(*=======================================================*)
	320:	(* Fahre Z-Achse bis auf Anfang der Kurvenbahn *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_auto_max;
			IF gst_datensatz.st_wkz.b_variable_einfahrposition THEN
				fb_axis.st_position.r_soll := gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_z;
			ELSE
				fb_axis.st_position.r_soll := ST_MotionFunctionPoints.YZTischMasterPos2;
			END_IF
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 330;
		END_IF

(*=======================================================*)
	330:	(* Camin Y-Achse *)
		IF fb_state_entry.E THEN
			fb_axis_y_achse.st_camscaling_data.SlaveScaling := 1;
			st_drive_cmd_y_achse.enu_cmd := CAM_IN_SLAVE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd_y_achse.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 340;
		END_IF

(*=======================================================*)
	340:	(* Fahre Z-Achse mit gekoppelter Y-Achse bis auf Übergabeposition *)
		IF fb_state_entry.E THEN
			IF gst_datensatz.st_wkz.bFahreSofortAufUebergabePosition THEN
				fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_auto_max;
			ELSE
				fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_z;
			END_IF
			fb_axis.st_position.r_soll := gst_datensatz.st_md.st_md_z_achse.lr_wt_uebergabepos;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*Nach einem Bandwechsel soll nach X-Teilen gestoppt werden.*)
		IF gst_datensatz.st_wkz.i16_anzahl_Teile_autostop_bandwechsel > 0 THEN
			IF gi16_anzahl_Teile_autostop_bandwechsel = gst_datensatz.st_wkz.i16_anzahl_Teile_autostop_bandwechsel THEN
				Teile_nach_Bandwechsel := TRUE;
				gb_nach_bawe_einzelfertigung := TRUE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gb_memEndOfBandMarkNIO THEN
			fb_state_entry.i16_next_step := 370;
		ELSE
			IF gst_datensatz.st_md.b_tagreader_fahrend THEN
				(* Pille sofort beschreiben *)
				fb_state_entry.i16_next_step := 350;
			ELSE
				IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
					(* Warte mit Pille beschreiben, bis der Bestücktisch im Ziel ist *)
					fb_state_entry.i16_next_step := 350;
				END_IF
			END_IF
		END_IF


		IF	gst_datensatz.st_md.b_wt_transport_aktiv =FALSE THEN
			visu.b_merker_vollbestuecken:= FALSE;
			s_alte_artikelnummer := '';
			fb_state_entry.i16_next_step := 360;
		END_IF

		IF fb_state_entry.X THEN
			Teile_nach_Bandwechsel:= FALSE;
			IF gst_datensatz.st_wkz.i16_anzahl_Teile_autostop_bandwechsel <> 0 THEN
				gi16_anzahl_Teile_autostop_bandwechsel := gi16_anzahl_Teile_autostop_bandwechsel + 1;
			END_IF
		END_IF

(*=======================================================*)
	350: (* Schreibe Daten auf Tag *)
		IF fb_state_entry.E THEN
			(* Auswertung der Bestückung (Pins bzw. Rasterplatte) des ISK *)
			ST_Markiere_WT_IO();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := 360;
		END_IF

(*=======================================================*)
	360:	(* Aktualisiere letztes benutzes Werkzeug *)
		IF fb_state_entry.E THEN
			ST_Schreibe_LastUsedTool();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			IF gst_datensatz.st_md.b_tagreader_fahrend THEN
				fb_state_entry.i16_next_step := 370;
			ELSE
				fb_state_entry.i16_next_step := 380;
				fb_Z_Achse_ausfahren(b_start:= FALSE, t_zeit=>t_Z_Achse_ausfahren );
			END_IF
		END_IF

(*=======================================================*)
	370:	(* Warte noch auf die Z-Achse, bis sie auf der Übergabeposition steht. *)

		gb_memEndOfBandMarkNIO := FALSE;

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 380;
			fb_Z_Achse_ausfahren(b_start:= FALSE, t_zeit=>t_Z_Achse_ausfahren );
		END_IF

(*=======================================================*)
	380:

		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700:
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				fb_state_entry.i16_next_step := BEREIT;

			RASTERFOLIE:
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF rasterfolienmontage.st_ctrl.out.b_fertig_2 THEN
					fb_state_entry.i16_next_step := BEREIT;
				END_IF
		END_CASE

		IF fb_state_entry.X THEN
			(* Stoppe Bestückzeit *)
			zeit_wt_bestuecken := TIME_TO_DWORD(fb_ton_taktzeitmessung_bestuecken.ET);
			fb_ton_taktzeitmessung_bestuecken.IN := FALSE;
			(* Starte WT Wechselzeit *)
			fb_ton_taktzeitmessung_wt_wechsel.IN := TRUE;
		END_IF

(*==========================Bestückzelle1720=============================*)
	395: (*Warten bis keine ander Produktions Meldung ansteht *)
		IF	TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			fb_state_entry.i16_next_step := 396;
		END_IF

(*=======================================================*)
	396:  (*Produktions Meldung*)
		Visu.MeldungProduktion.Color_R := 255;
		Visu.MeldungProduktion.Color_G := 0;
		Visu.MeldungProduktion.Color_B := 0;
		IF visu.s_akt_sprache = 'de' THEN
			Visu.MeldungProduktion.Name:='Zelle war nicht in Betrieb, bitte Instandhalter informieren!$R$N$R$NÖler,Bestückposition, Seitenversatz und Biegewinkel kontrollieren$R$NMeldung kann nur eingeloggt quittiert werden';
		ELSIF visu.s_akt_sprache = 'en' THEN
			Visu.MeldungProduktion.Name:='Station has not been used for last order, please inform Maintenance Technician!$R$N$R$Ncheck oiler, stich position, left/right and bending angle$R$Nmessage can only be acknowledged when logged in';
		ELSIF visu.s_akt_sprache = 'cz' THEN
			Visu.MeldungProduktion.Name:='Bunka nebyla v provozu, informujte prosim serizovace. Zkontrolujte olej, nastaveni os a uhel ohybu.$R$NZprávu lze potvrdit jen po prihlaseni ';
		END_IF
		Visu.MeldungProduktion.ShowMessage := TRUE;
		Visu.MeldungProduktion.Button1.sichtbar:=TRUE;	(*OK*)
		Visu.MeldungProduktion.Button1.Text:='Ok';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF visu.b_logon THEN
			IF Visu.MeldungProduktion.Button1.tasten THEN
				IF gst_datensatz.st_md.	b_tagreader_fahrend THEN
					fb_state_entry.i16_next_step := 400;
				ELSE
					fb_state_entry.i16_next_step := 405;
				END_IF
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			gst_PersDaten.b_Zelle_nicht_in_Betrieb := FALSE;
		END_IF

(*=======================================================*)
	400:	(* Fahre Z-Achse bis auf die erste Bestückposition *)
		IF fb_state_entry.E THEN
			(* Z-Achse verfahren *)
			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_z;
			fb_axis.st_position.r_soll := gst_datensatz.st_isk.lr_pos_z_0 + gst_datensatz.st_wkz.lr_offset_z_pos_0 + gst_datensatz.st_wt.lr_offset_z_pos_0 + gst_datensatz.st_md.lr_offset_z_pos_0 + gst_datensatz.st_bestueckprogramm.lr_z[0];
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Z-Achse losfahren und währenddessen beschreibt der Tagreader die Pille *)
		fb_state_entry.i16_next_step := 405;

(*=======================================================*)
	405:	(*  WT als schlecht markieren*)
		IF fb_state_entry.E THEN
			ST_Markiere_WT_NIO();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			(* Ok: Daten sind auf der Pille *)
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			IF gst_datensatz.st_md.b_tagreader_fahrend THEN
				(* Warte auf Z-Achse *)
				fb_state_entry.i16_next_step := 410;
			ELSE
				(* Daten geschrieben und erst jetzt die Z-Achse fahren *)
				fb_state_entry.i16_next_step := 420;
			END_IF
		END_IF

(*=======================================================*)
	410:	(* Warte noch auf die Z-Achse, bis sie im Ziel steht. *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 430;
		END_IF

(*=======================================================*)
	420:	(* Fahre Z-Achse bis auf die erste Bestückposition *)
		IF fb_state_entry.E THEN
			(* Z-Achse verfahren *)
			fb_axis.lr_soll_geschwindigkeit := gst_datensatz.st_wkz.r_auto_z;
			fb_axis.st_position.r_soll := gst_datensatz.st_isk.lr_pos_z_0 + gst_datensatz.st_wkz.lr_offset_z_pos_0 + gst_datensatz.st_wt.lr_offset_z_pos_0 + gst_datensatz.st_md.lr_offset_z_pos_0 + gst_datensatz.st_bestueckprogramm.lr_z[0];
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 430;
		END_IF

(*=======================================================*)
	430:	(* Führung wird an die Bestückachse abgegeben und die Z-Achse wird ausschliesslich über Kurvenscheiben-Kopplung verfahren *)
		IF fb_state_entry.E THEN
			fb_Z_Achse_einfahren(b_start:= FALSE, t_zeit=> t_Z_Achse_einfahren);
			fb_Bestueckung(b_start:= TRUE, t_zeit=> );
			axis_virt_master.st_ctrl.in.b_start := TRUE;

			(* Stoppe WT Wechselzeit *)
			zeit_wt_wechsel := TIME_TO_DWORD(fb_ton_taktzeitmessung_wt_wechsel.ET);
			fb_ton_taktzeitmessung_wt_wechsel.IN := FALSE;

			(* Starte Bestückzeit *)
			fb_ton_taktzeitmessung_bestuecken.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT axis_virt_master.st_ctrl.out.b_fertig THEN
			axis_virt_master.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 440;
		END_IF

		IF fb_state_entry.X THEN
			(* Stoppe Bestückzeit *)
			zeit_wt_bestuecken := TIME_TO_DWORD(fb_ton_taktzeitmessung_bestuecken.ET);
			fb_ton_taktzeitmessung_bestuecken.IN := FALSE;

			(* Starte WT Wechselzeit *)
			fb_ton_taktzeitmessung_wt_wechsel.IN := TRUE;
		END_IF

(*=======================================================*)
	440:	(* Warte auf  Bestückachse fertig mit Pins setzen *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_fertig THEN
			fb_state_entry.i16_next_step := 450;
			fb_Bestueckung(b_start:=FALSE, t_zeit=>t_Bestueckung);
			fb_Z_Achse_ausfahren(b_start:= TRUE, t_zeit=> );
		END_IF

(*=======================================================*)
	450: (* Fahre Z-Achse zurück zur Übergabeposition *)
		IF fb_state_entry.E THEN
			 fb_axis.st_position.r_soll := gst_datensatz.st_md.st_md_z_achse.lr_wt_uebergabepos;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*Nach einem Bandwechsel soll nach X-Teilen gestoppt werden.*)
		IF gst_datensatz.st_wkz.i16_anzahl_Teile_autostop_bandwechsel > 0 THEN
			IF gi16_anzahl_Teile_autostop_bandwechsel = gst_datensatz.st_wkz.i16_anzahl_Teile_autostop_bandwechsel THEN
				gb_nach_bawe_einzelfertigung := TRUE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gst_datensatz.st_md.b_tagreader_fahrend THEN
			(* Pille sofort beschreiben *)
			fb_state_entry.i16_next_step := 460;
		ELSE
			IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
				(* Warte mit Pille beschreiben *)
				fb_state_entry.i16_next_step := 460;
			END_IF
		END_IF

		IF	gst_datensatz.st_md.b_wt_transport_aktiv =FALSE THEN
			visu.b_merker_vollbestuecken:= FALSE;
			s_alte_artikelnummer := '';
			fb_state_entry.i16_next_step := 480;
		END_IF

		IF fb_state_entry.X THEN
			IF gst_datensatz.st_wkz.i16_anzahl_Teile_autostop_bandwechsel <> 0 THEN
				gi16_anzahl_Teile_autostop_bandwechsel := gi16_anzahl_Teile_autostop_bandwechsel + 1;
			END_IF
		END_IF

(*=======================================================*)
	460: (* Schreibe Daten auf Tag *)
		IF fb_state_entry.E THEN
			(* WT Hat die Maschine auf regulärem Weg wieder verlassen *)
			ST_Markiere_WT_IO();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := 470;
		END_IF

(*=======================================================*)
	470:	(* aktualisiere letztes benutzes Werkzeug *)
		IF fb_state_entry.E THEN
			ST_Schreibe_LastUsedTool();
		END_IF

		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			IF gst_datensatz.st_md.b_tagreader_fahrend THEN
				fb_state_entry.i16_next_step := 480;
			ELSE
				fb_Z_Achse_ausfahren(b_start:= FALSE, t_zeit=> );
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	480:	(* Z-Achse ist fertig positioniert *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_Z_Achse_ausfahren(b_start:= FALSE, t_zeit=> );
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_busy:=FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_drive_cmd.enu_cmd := RESET;
			st_drive_cmd_y_achse.enu_cmd := RESET;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF st_ctrl_in.b_stop AND NOT z_achse.Status.HasBeenStopped THEN
			st_drive_cmd.enu_cmd := STOP_AXIS;
		END_IF

		IF st_ctrl_in.b_halt AND z_achse.Status.Moving THEN
			st_drive_cmd.enu_cmd := HALT_AXIS;
			st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_nothalt;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_busy:=FALSE;
			IF z_achse.NcToPlc.CoupleState = 0 THEN
				st_drive_cmd.enu_cmd := STOP_AXIS;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND AND z_achse.Status.NotMoving THEN
			fb_state_entry.i16_next_step := STILLSTAND;
		END_IF

(*=======================================================*)
	STILLSTAND:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HALT:
		IF fb_state_entry.E THEN
			IF z_achse.NcToPlc.CoupleState = 0 THEN
				st_drive_cmd.enu_cmd := HALT_AXIS;
				st_geschwindigkeiten.lr_verzoegerung := lr_decceleration_nothalt;
			END_IF
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	HANDRAD:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_z_achse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 2040;	(* Jogbetrieb *)
			ELSE
				fb_state_entry.i16_next_step := 2010;	(* Reglerfreigabe nehmen und Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	2010:	(* Reglerfreigabe wegnehmen , damit Nullpunktverschiebung geschrieben werden kannt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2020;
		END_IF

(*=======================================================*)
	2020:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
			(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2030;
		END_IF

(*=======================================================*)
	2030:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_z_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2040;
		END_IF

(*=======================================================*)
	2040:	(* Jogbetrieb *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
		END_IF

		IF ST_Euchner_Handbedienpult.i16_Handrad_delta > 0 THEN
			st_drive_cmd.enu_cmd := JOG_VORWAERTS;
		ELSIF ST_Euchner_Handbedienpult.i16_Handrad_delta < 0 THEN
			st_drive_cmd.enu_cmd := JOG_RUECKWAERTS;
		ELSE
			IF z_achse.Status.Moving THEN
				st_drive_cmd.enu_cmd := JOG_STOP;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gi16_betriebsart <> HAND OR NOT b_hand_dialog_aktiv THEN
			fb_state_entry.i16_next_step := 2050;
		END_IF

(*=======================================================*)
	2050:
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := ABORT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2060;
		END_IF

(*=======================================================*)
	2060:	(* Reglerfreigabe wegnehmen *)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	NULLPUNKT_SETZEN:
		(* Aktuellen Jog beenden, sonst Probleme beim Softwareendschalter*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := JOG_STOP;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 2505;
		END_IF

(*=======================================================*)
	2505:
		(* 	Lese aktuelle Nullpunkt verschiebung von der Hardware. Der Benutze könnte einen falschen
			Wert eingetragen haben *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			gst_datensatz.st_md.st_md_z_achse.lr_nullpunktverschiebung := fb_axis.r_wert_nc_read_parameter;
			fb_state_entry.i16_next_step := 2510;
		END_IF

(*=======================================================*)
	2510:	(* Nullpunktverschiebung berechnen *)
		IF fb_state_entry.E THEN
			lr_pos_ohneverschiebung := axis_z_achse.st_visu.lr_position_ist - gst_datensatz.st_md.st_md_z_achse.lr_nullpunktverschiebung;

			gst_datensatz.st_md.st_md_z_achse.lr_nullpunktverschiebung := - lr_pos_ohneverschiebung;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Aktiviere den Wert in die Hardware *)
		fb_state_entry.i16_next_step := HANDRAD;

(*=======================================================*)
	INBETRIEBNAHME:	(* Überprüfe Nullpunktverschiebung des Absolutwertgebers auf Korrektheit *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			st_drive_cmd.enu_cmd := READ_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			IF fb_axis.r_wert_nc_read_parameter = gst_datensatz.st_md.st_md_z_achse.lr_nullpunktverschiebung THEN
				fb_state_entry.i16_next_step := 5100;	(* Reversiersequenz*)
			ELSE
				fb_state_entry.i16_next_step := 5010;	(* Reglerfreigabe nehmen und Nullpunktverschiebung schreiben *)
			END_IF
		END_IF

(*=======================================================*)
	5010:	(* Reglerfreigabe wegnehmen, damit Nullpunktverschiebung geschrieben werden kannt*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_DISABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5020;
		END_IF

(*=======================================================*)
	5020:	(* Nullpunktverschiebung hat sich geändert, deshalb erst Null reinschreiben, um keinen Additionsfehler zu machen, *)
			(* weil der Wert der Verschiebung beim Neustart komplett auf die Achse geschrieben wird *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := 0.0;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5030;
		END_IF

(*=======================================================*)
	5030:	(* Aktuelle Nullpunktverschiebung des Absolutwertgebers an die Achse senden *)
		IF fb_state_entry.E THEN
			fb_axis.i16_nc_parameter_nummer := AxisEncoderOffset;
			fb_axis.r_wert_nc_write_parameter := gst_datensatz.st_md.st_md_z_achse.lr_nullpunktverschiebung;
			st_drive_cmd.enu_cmd := WRITE_NC_PARAMETER;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5100;
		END_IF

(*=======================================================*)
	5100:	(* Verfahren der Achse zwischen zwei Punkten zum Testen verschiedener Achsparameter *)
		IF fb_state_entry.E THEN
			fb_axis.lr_soll_geschwindigkeit := st_geschwindigkeiten.lr_jog;
			fb_axis.st_position.lr_ibn_pos_start := 10.0;
			fb_axis.st_position.lr_ibn_pos_ziel := -10.0;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_ibn_start THEN
			fb_state_entry.i16_next_step := 5110;
		END_IF

(*=======================================================*)
	5110: (* Fahre Z-Achse auf Startposition *)
(*
		IF fb_state_entry.E THEN
			 fb_axis.st_position.r_soll := fb_axis.st_position.lr_ibn_pos_start;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5120;
		END_IF
*)
		IF fb_state_entry.E THEN
			st_drive_cmd.enu_cmd := POWER_ENABLE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			;
		END_IF

(*=======================================================*)
	5120: (* Pause *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#500ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 5130;
		END_IF

(*=======================================================*)
	5130: (* Fahre Z-Achse auf Zielposition *)
		IF fb_state_entry.E THEN
			 fb_axis.st_position.r_soll := fb_axis.st_position.lr_ibn_pos_ziel;
			st_drive_cmd.enu_cmd := MOVE_ABSOLUTE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_state_entry.i16_next_step := 5140;
		END_IF

(*=======================================================*)
	5140: (* Pause *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#500ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 5100;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config_achse.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 0] := st_sm.b_achse_nicht_bb;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 1] := st_sm.b_achse_nicht_referenziert;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 2] := st_sm.b_keine_verfahrfreigabe;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 3] := st_sm.b_achse_nicht_auf_startpos;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 4] := st_sm.b_ende_skalierungs_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 5] := st_sm.b_ende_camming_nocke;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 6] := st_sm.b_skalierung_noch_aktiv;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 10] := sm_positionsueberwachung;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 11] := sm_werkzeugreihenfolge_nicht_io;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 12] := sm_keine_bandfreigabe;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 13] := sm_tagnummer_ungueltig;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 15] := sm_typ_bestueckprogramm_falsch;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 16] := st_drive_cmd.meldungen.sm_write_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 17] := st_drive_cmd.meldungen.sm_read_soe_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 18] := st_drive_cmd.meldungen.sm_write_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 19] := st_drive_cmd.meldungen.sm_read_nc_parameter;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 20] := st_drive_cmd.meldungen.sm_power_enable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 21] := st_drive_cmd.meldungen.sm_power_disable;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 22] := st_drive_cmd.meldungen.sm_reset;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 23] := st_drive_cmd.meldungen.sm_home;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 24] := st_drive_cmd.meldungen.sm_setposition;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 25] := st_drive_cmd.meldungen.sm_jog_vorwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 26] := st_drive_cmd.meldungen.sm_jog_rueckwaerts;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 27] := st_drive_cmd.meldungen.sm_move_absolute;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 28] := st_drive_cmd.meldungen.sm_move_relative;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 29] := st_drive_cmd.meldungen.sm_move_velocity;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 30] := st_drive_cmd.meldungen.sm_move_modulo;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 31] := st_drive_cmd.meldungen.sm_stop_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 32] := st_drive_cmd.meldungen.sm_halt_axis;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 33] := st_drive_cmd.meldungen.sm_motion_command_timeout;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 34] := st_sm.b_achsfehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 35] := st_sm.b_devicefehler;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 36] := st_drive_cmd.meldungen.sm_limit_positiv_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 37] := st_drive_cmd.meldungen.sm_limit_negativ_erreicht;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 38] := st_drive_cmd.meldungen.sm_ec_coe_sdo_write_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 39] := st_drive_cmd.meldungen.sm_ec_coe_sdo_read_ex;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 40] := st_drive_cmd_y_achse.meldungen.sm_gear_in_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 41] := st_drive_cmd_y_achse.meldungen.sm_gear_out_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 42] := st_drive_cmd_y_achse.meldungen.sm_cam_in_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 43] := st_drive_cmd_y_achse.meldungen.sm_cam_out_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 44] := st_drive_cmd_y_achse.meldungen.sm_cam_scaleing_slave;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 45] := st_drive_cmd_y_achse.meldungen.sm_camgear_command_timeout;;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 46] := st_drive_cmd_y_achse.meldungen.sm_read_motion_funktion_point;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 47] := st_drive_cmd_y_achse.meldungen.sm_write_motion_funktion_point;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 48] := st_drive_cmd_y_achse.meldungen.sm_read_camtable_slave_dynamics;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 49] := st_drive_cmd_y_achse.meldungen.sm_read_camtable_charakteristik;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 50] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 51] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 52] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 53] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 54] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 55] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 56] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 57] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 58] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 59] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 60] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 61] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 62] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 63] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 64] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 65] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 66] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 67] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 68] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 69] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 70] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 71] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 72] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 73] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 74] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 75] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 76] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 77] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 78] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 79] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 80] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 81] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 82] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 83] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 84] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 85] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 86] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 87] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 88] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 89] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 90] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 91] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 92] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 93] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 94] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 95] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 96] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 97] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 98] := FALSE;
	garr_stoermeldungen[st_config_achse.i16_meld_startindex + 99] := FALSE;
	
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 0] := bm_kein_Pin_im_BB;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 1] := bm_rastnasen_1_fehlt;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 2] := bm_rastnasen_2_fehlt;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 19] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 20] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 21] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 22] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 23] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 24] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 25] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 26] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 27] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 28] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 29] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 30] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 31] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 32] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 33] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 34] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 35] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 36] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 37] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 38] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 39] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 40] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 41] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 42] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 43] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 44] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 45] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 46] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 47] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 48] := FALSE;
	garr_betriebsmeldungen[st_config_achse.i16_meld_startindex + 49] := FALSE;
END_IF

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Allgemeines' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Betriebsstundenzaehler
VAR_INPUT
	b_eingekuppelt					: BOOL;
	b_reset							: BOOL;
	i32_betriebssekundenzaehler_in		: UDINT;
END_VAR
VAR_OUTPUT
	t_betriebsstunden_neu				: TIME;
	i32_betriebssekundenzaehler 		: UDINT;
	lr_betriebsstundenzaehler 			: LREAL;
END_VAR
VAR
	b_first_cycle						: BOOL := TRUE;
	fb_ton							: TON;
	t_betriebssekunden_Merker			: TIME := t#0ms;
	a_betriebsstundenzaehler 			AT %Q* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
IF b_first_cycle THEN
 	i32_betriebssekundenzaehler := i32_betriebssekundenzaehler_in;
	b_first_cycle := FALSE;
END_IF

(* Hardware-Betriebsstundenzähler *)
a_betriebsstundenzaehler := b_eingekuppelt;

IF NOT b_eingekuppelt  THEN
	t_betriebssekunden_Merker := t_betriebssekunden_Merker + fb_ton.ET;
END_IF

fb_ton(IN:=b_eingekuppelt, PT:= t#24h, Q=> , ET=> );

IF gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET AND NOT b_eingekuppelt THEN
	i32_betriebssekundenzaehler:=i32_betriebssekundenzaehler + (TIME_TO_UDINT(t_betriebssekunden_Merker)/1000);
	t_betriebssekunden_Merker:=t#0ms;
END_IF

lr_betriebsstundenzaehler:=UDINT_TO_LREAL(i32_betriebssekundenzaehler) / 3600;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Allgemeines' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Gesamthubzaehler
VAR
	fb_tp_wz				: TP;
	fb_r_trig				: R_TRIG;
	a_Gesamthubzaehler	 AT %Q* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Erzeugung eines zeitkonstanten Zählersignals *)
fb_tp_wz(IN:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_OT], PT:= t#20ms, Q=> a_Gesamthubzaehler, ET=> );

(* Interner Bestückhubzähler der Maschine*)
fb_r_trig(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_OT], Q=> );

IF fb_r_trig.Q THEN
	gst_datensatz.st_md.i32_bestueckhubzaehler := gst_datensatz.st_md.i32_bestueckhubzaehler + 1;
	gst_datensatz.st_md.i32_werkzeughubzaehler := 	gst_datensatz.st_md.i32_werkzeughubzaehler +1;
END_IF

IF gst_datensatz.st_md.i32_bestueckhubzaehler > (EXPT(2,32)) OR gst_datensatz.st_md.i32_bestueckhubzaehler < 0 THEN
	gst_datensatz.st_md.i32_bestueckhubzaehler := 0;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Allgemeines' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_LampeMaterialMangel
VAR_INPUT
	b_materialmangel		: ARRAY[0..7] OF BOOL;
END_VAR
VAR
	a_Lampe			AT %Q* : BOOL;
	fb_blinker			: ST_Blinker;
END_VAR

(* @END_DECLARATION := '0' *)

(* Blinken *)
(*schnell*)
IF 	b_materialmangel[1] 	THEN	(*Öl leer*)
fb_blinker(
	b_start:= TRUE,
	t_taktzeit_on:=t#500ms,
	t_taktzeit_off:=t#500ms,
	b_blinker_out=> );
END_IF
(*langsam*)
IF 	NOT b_materialmangel[1] AND	(*Öl leer*)
	( b_materialmangel[2] OR b_materialmangel[6] ) THEN	(*Stufe kleiner 10 or Korrektur X-Y zu hoch*)
fb_blinker(
	b_start:= TRUE,
	t_taktzeit_on:=t#1500ms,
	t_taktzeit_off:=t#1500ms,
	b_blinker_out=> );
END_IF


(* Materialmangel ist eingetreten *)
IF 	b_materialmangel[0] OR	(*Band leer*)
	b_materialmangel[1] OR	(*Öl leer*)
	b_materialmangel[2] OR	(*Stufe kleiner 10*)
	b_materialmangel[3] OR	(* Bandwechsel *)
	b_materialmangel[4] OR	(*Schaltschrank Temp*)
	b_materialmangel[5] OR	(* Band nicht abgescannt *)
	b_materialmangel[6] 		(* Korrektur X-Y Wert zu hoch *)
	THEN
		a_Lampe := fb_blinker.b_blinker_out OR b_materialmangel[0] OR b_materialmangel[3];

(* Es liegt kein Materialmangel vor *)
ELSE
	a_Lampe := FALSE;
END_IF


END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Allgemeines' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Scope
VAR
	fb_ton_wz			: TON;
	fb_r_trig_bereit		: R_TRIG;
	fb_state_entry			: ST_StateEntry;

	fb_ScopeStop		: ScopeSetOffline;
	fb_ScopeOnline		: ScopeSetOnline;
	fb_ScopeExport		: ScopeViewExport;

	b_Stop				: BOOL;
	s_file_name			: STRING;
	pos					: INT;
	i					: INT;
	i32_error_id			:UDINT;
END_VAR

VAR CONSTANT
	s_path				: STRING:='C:\TwinCAT\Scope\';
END_VAR
(* @END_DECLARATION := '0' *)
(*===============================================================
   PRG: ST_Scope
  ---------------------------------------------------------------
   Auth: 		Werner Friedl
   Date: 		03.08.2016    						    
   Rev.: 		1.0
   Beschreibung:
	Mit diesem Programm wird das Scope automatisch gestartet und bei einem Fehler 
	ein Scopedatei mit aktueller Zeit im Verzeichnis "C:\TwinCAT\Scope\" abgespeichert. 

	-	zuerst muss ein Scope geöffnet und ein Projekt erstellt werden.
	-	Fehler für Stop eintragen	
	-	ST_ScopeStop startet das Scope bei "Anlage betriebsbereit"
	-	bei Fehler wird die Aufzeichnung nach 2sec gestoppt
	-	Auzeichnung	wird mit aktueller Zeit abgespeichert.	

hier Fehler für Stop einfügen============================================*)
(*b_Stop:=	ST_Bestueckachse.st_ctrl_out.b_fehler  OR
		axis_bestueckachse.st_ctrl.out.b_fehler ;*)

b_Stop:= (gi16_maschinenstatusinfo = STATUS_FEHLER);

(*=======================================================*)
fb_ton_wz(IN:=,PT:=T#2s);
fb_r_trig_bereit(CLK:= gi16_maschinenstatusinfo = STATUS_BETRIEBSBEREIT, Q=> );
fb_ScopeStop(bExecute:= , bBusy=> , bError=> , iErrorId=> );
fb_ScopeOnline(bExecute:= , bBusy=> , bError=> , iErrorId=> );
fb_ScopeExport(bExecute:=, sFilePath:=, tTimeout:=T#5s);

(*=======================================================*)
fb_state_entry(i16_pos:= 1, );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
	INIT:
		IF	fb_state_entry.E THEN
			fb_ScopeOnline.bExecute:=FALSE;
			fb_ScopeStop.bExecute:=FALSE;
			fb_ScopeExport.bExecute:=FALSE;
		END_IF

		fb_state_entry.i16_next_step := BEREIT;


(*=======================================================*)
	BEREIT: (*warten auf betriebsbereit *)
		IF	fb_state_entry.E THEN
			b_Stop:=FALSE;
		END_IF

		IF	fb_r_trig_bereit.Q THEN
			fb_state_entry.i16_next_step := 110;
		END_IF


(*=======================================================*)
	110: (* Scope starten *)
		IF 	fb_state_entry.E THEN
			fb_ScopeOnline.bExecute:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	fb_ScopeOnline.bBusy THEN
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120: (* Scope starten *)

		IF	NOT fb_ScopeOnline.bBusy THEN
			fb_state_entry.i16_next_step := 130;
			fb_ScopeOnline.bExecute:=FALSE;
		END_IF

		IF	fb_ScopeOnline.bError THEN
			i32_error_id:=fb_ScopeOnline.iErrorId;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	130: (* warten auf Fehler *)
		IF	 fb_state_entry.E THEN
			fb_ton_wz.IN:=FALSE;
		END_IF

		fb_ton_wz.IN:=b_Stop ;
		fb_ScopeStop.bExecute:=fb_ton_wz.Q;


		IF	fb_ScopeStop.bBusy THEN
			fb_state_entry.i16_next_step := 140;
		END_IF

		IF	 fb_state_entry.X THEN
			fb_ton_wz.IN:=FALSE;
		END_IF
(*=======================================================*)
	140: (* Scope anhalten *)

		IF	NOT fb_ScopeStop.bBusy THEN
			fb_ScopeStop.bExecute:=FALSE;
			fb_state_entry.i16_next_step := 150;
		END_IF

		IF	fb_ScopeStop.bError THEN
			i32_error_id:=fb_ScopeStop.iErrorId;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	150: (* Scope speichern *)
		IF 	fb_state_entry.E THEN
			s_file_name:=gstr_system_time;
			i:=0;
			FOR i := 1 TO 5  BY 1DO
				pos:=0;
				pos:=FIND(s_file_name,':');
				IF	pos > 0 THEN
					s_file_name:=REPLACE(s_file_name,'-',1,pos);
				END_IF
			END_FOR

			s_file_name:=CONCAT(s_file_name,'_Scope_View');
			s_file_name:=CONCAT(s_file_name,'.svw');

			fb_ScopeExport.sFilePath:=CONCAT(s_path,s_file_name);
			fb_ScopeExport.bExecute:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	fb_ScopeExport.bBusy THEN
			fb_state_entry.i16_next_step := 160;
		END_IF


(*=======================================================*)
	160: (* Scope speichern *)

		IF	NOT fb_ScopeExport.bBusy THEN
			fb_state_entry.i16_next_step := BEREIT;
			fb_ScopeExport.bExecute:=FALSE;
		END_IF

		IF	fb_ScopeExport.bError THEN
			i32_error_id:=fb_ScopeExport.iErrorId;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	FEHLER:	(*bei Fehler einfach weiter*)
		IF 	fb_state_entry.E THEN
			;
		END_IF
			fb_state_entry.i16_next_step := INIT;

END_CASE

fb_state_entry(i16_pos:= 2 );
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Allgemeines' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Tuerverriegelung
VAR_INPUT
	e_quittiertaste						: BOOL;
END_VAR
VAR
	fb_ton_wz						: TON;
	fb_r_trig_quitt						: R_TRIG;
	fb_f_trig_quitt						: F_TRIG;
	fb_blinker						: ST_Blinker;
	a_tuerverriegelung_vorne			AT %Q* : BOOL;
	a_tuerverriegelung_hinten			AT %Q* : BOOL;
	e_kontakt_tuerverriegelung_vorne	AT %I* : BOOL;
	e_kontakt_tuerverriegelung_hinten	AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Blinken *)
fb_blinker(
	b_start:= TRUE,
	t_taktzeit_on:=t#500ms,
	t_taktzeit_off:=t#500ms,
	b_blinker_out=> );

(* Zeiten *)
fb_ton_wz(IN:= , PT:= t#3s, Q=> , ET=> );

(* Flanken *)
fb_r_trig_quitt(CLK:= e_quittiertaste, Q=> );
fb_f_trig_quitt(CLK:= e_quittiertaste, Q=> );

(* Ansteuerung der Türverriegelung vorne und hinten *)
CASE gi16_betriebsart OF
	HAND:
		a_tuerverriegelung_vorne := FALSE;
		a_tuerverriegelung_hinten := FALSE;
	TIPPEN, AUTO:
		IF 	gi16_maschinenstatusinfo = STATUS_BETRIEBSBEREIT OR
			gi16_maschinenstatusinfo = STATUS_FEHLER
			THEN
				(* Türen freigeben *)
				a_tuerverriegelung_vorne := FALSE;
				a_tuerverriegelung_hinten := FALSE;
		ELSE
			(* Türen verriegelt, wenn geschlossen *)
			IF NOT e_kontakt_tuerverriegelung_vorne THEN
				a_tuerverriegelung_vorne := TRUE;
			END_IF
			IF NOT e_kontakt_tuerverriegelung_hinten THEN
				a_tuerverriegelung_hinten := TRUE;
			END_IF
		END_IF
END_CASE
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Bandeinzug' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Anwahl_Bandeinzug
VAR
	b_first_cycle 						: BOOL := TRUE;
	i16_typ_bandeinzug_visu			: enum_typ_bandeinzug_visu := KEIN_BANDEINZUG;
END_VAR
(* @END_DECLARATION := '0' *)
(*======================================================
   PRG: ExportResultString
 ------------------------------------------------------
   Auth: 		Werner Friedl    						 
   Date: 		07.03.2016    						     
   Rev.: 		1.0	
   Desc:		Damit bei unterschiedlichen Zellen (1700 oder 1720) nur die vorhandenen Bandwechsler in der Visu vorne angezeigt werden,
			müssen diese der Struktur "i16_typ_bandeinzug" zugewiesen werden.
   Historie:   1.0

 ========================================================*)
IF 	gi16_bbgen_auftrag = LESE_WKZ THEN
	b_first_cycle:=TRUE;
END_IF



IF	NOT b_first_cycle THEN

	CASE gst_datensatz.st_md.i16_typ_zelle OF
		KEINE_ZELLE:
			;

		BESTUECKZELLE_1700, RASTERFOLIE:
	
			CASE i16_typ_bandeinzug_visu OF

				KEIN_BANDEINZUG :
						gst_datensatz.st_wkz.i16_typ_bandeinzug:=KEIN_EINZUG;					;
				BANDEINZUG_1:
						gst_datensatz.st_wkz.i16_typ_bandeinzug:=BANDWECHSLER_V2;
				BANDEINZUG_2:
						gst_datensatz.st_wkz.i16_typ_bandeinzug:=SERVO;
				BANDEINZUG_3:
					;
			END_CASE

		BESTUECKZELLE_1720:

			CASE i16_typ_bandeinzug_visu OF
	
				KEIN_BANDEINZUG :
						gst_datensatz.st_wkz.i16_typ_bandeinzug:=KEIN_EINZUG;
				BANDEINZUG_1:
						gst_datensatz.st_wkz.i16_typ_bandeinzug:=STANDARD_2FACH_V2;
				BANDEINZUG_2:
					;
				BANDEINZUG_3:
					;
			END_CASE

	END_CASE

ELSIF	 gi16_bbgen_auftrag = KEIN_BB_AUFTRAG AND b_first_cycle THEN

	CASE gst_datensatz.st_md.i16_typ_zelle OF
		KEINE_ZELLE:
			;

		BESTUECKZELLE_1700, RASTERFOLIE:

			CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

				KEIN_EINZUG :
					i16_typ_bandeinzug_visu:=KEIN_BANDEINZUG;
				BANDWECHSLER_V2:
					i16_typ_bandeinzug_visu:=BANDEINZUG_1;
				SERVO:
					i16_typ_bandeinzug_visu:=BANDEINZUG_2;

			END_CASE
			b_first_cycle:=FALSE;

		BESTUECKZELLE_1720:
	
			CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

				KEIN_EINZUG :
					i16_typ_bandeinzug_visu:=KEIN_BANDEINZUG;
				STANDARD_2FACH_V2:
					i16_typ_bandeinzug_visu:=BANDEINZUG_1;

			END_CASE
			b_first_cycle:=FALSE;

	END_CASE


END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Barcode' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Barcode
VAR_INPUT
	st_config					: struct_config;

	b_steuerung_ein				: BOOL;
	b_bandende_links			: BOOL;
	b_bandende_rechts			: BOOL;
	b_bandende_1720			: BOOL;
END_VAR
VAR_IN_OUT
	st_barcode_daten			: struct_barcode_daten;
END_VAR
VAR_OUTPUT
	b_band_nicht_gescannt		: BOOL;
END_VAR
VAR
	fb_state_entry				: ST_StateEntry;
	fb_ton_wz					: TON;

	fb_tof_bandende_li			: TOF;
	fb_tof_bandende_re			: TOF;
	fb_tof_bandende_1720		: TOF;

	fb_trig_LTS_aus				: R_TRIG;
	st_LTS_xml					: struct_LTS_xml;
	i_actuellVPE				: DINT;			(*Verpackungseinheit*)
	s_FileName					: STRING;

	fb_WriteXml					: FB_XmlSrvWriteByName;
	NT_StartProcess 			: NT_StartProcess;
	fb_state_entry2				: ST_StateEntry;
	i_ErrId						: UDINT;

	(* RS232-Schnittstelle *)
	(* Hinweis: Datenpuffer vom Typ ComBuffer werden vom Anwender niemals direkt beschrieben oder gelesen,
	sondern dienen nur als Zwischenspeicher für die Kommunikationsbausteine. *)
	RxBuffer						: ComBuffer;
	TxBuffer						: ComBuffer;
	COM_in_data AT %I* 			: PcComInData; (*EL6inData22B;*)
	COM_out_data AT %Q*  			: PcComOutData; (*EL6outData22B;*)
	fb_com_port_control				: SerialLineControl;
	com_port_control_error			: BOOL := FALSE;
	com_port_control_error_id		: ComError_t;

	(* ReceiveString empfängt eine Zeichenkette von der mit der Eingangsvariablen RxBuffer korrespondierenden Schnittstelle
	und speichert sie in der Ausgangsvariablen ReceivedString. *)
	fb_receive					: ReceiveString;
	fb_trig_new_string			: R_TRIG;
	s_tmp_string					: STRING := '';

	s_start_wkz					: STRING :='';
	s_start_band_links			: STRING :='';
	s_start_band_rechts			: STRING :='';
	s_start_band				: STRING :='';

	sm_fehler_seriel				: BOOL := FALSE;

	fb_tof_bm_neues_band_links		: TOF;
	fb_tof_bm_neues_band_rechts	: TOF;
	fb_tof_bm_neues_band_1720	: TOF;
	fb_tof_bm_neues_wkz			: TOF;
	fb_trig_manuell					: F_TRIG;

	bm_band_nicht_gescannt_links	: BOOL := FALSE;
	bm_band_nicht_gescannt_rechts	: BOOL := FALSE;

	s_band_anwahl_copy			: STRING;
	s_wkz_anwahl_copy				: STRING;

	i								: INT;
	m_WpcNumber_links			: BYTE;
	b_Zaehler_WPC_links			: INT;
	m_WpcNumber_rechts			: BYTE;
	b_Zaehler_WPC_rechts			: INT;
	i16_WT_auf_Band				: INT := 13;

	s_band_ID_linksHelp			: STRING(20) :='';
	s_band_ID_rechtsHelp			: STRING(20) :='';
	fb_ton_band_ID					: TON;
	b_newbatchOk					: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(*
Baustein läuft fast komplett entkoppelt vom Hauptablauf. Es soll nicht der Barcodescanner zum Stop der Anlage führen.
Der restliche Ablauf greift nur über die persistenten Daten auf die "freigaben" und die angewählten Bänder zu

Funktion:
	bei Steuerung aus:
	---------------------------
		Scan Start Werkzeug, Scan Werkzeugcode ==> Anwahl des Werkzeuges
		Scan Start Band, Scan bandcode ==> Anwahl des Bandes

	bei Steuerung ein:
	---------------------------
		Scan Start Werkzeug, Scan Werkzeugcode ==> Keine Reaktion
		Scan Start Band(Links|Rechts), Scan bandcode ==> Stimmt Band mit Angewähltem Band überein, wird Band_x_ok gesetzt.

		Bandende_x = False ==> Band_x_ok wird false gesetzt
*)

fb_trig_manuell(CLK:= gst_datensatz.st_md.i16_typ_bestueckmodus = BESTUECKUNG_MANUAL, Q=> );

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN

	IF com_port_control_error OR fb_receive.Error > 0 THEN
		sm_fehler_seriel := TRUE;
		fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* Abwahl Band ok =======================================================*)
(* Bandende entprellen *)
IF	b_steuerung_ein THEN
	fb_tof_bandende_li(IN:= b_bandende_links , PT:=t#1s , Q=>  , ET=> );
	fb_tof_bandende_re(IN:=b_bandende_rechts  , PT:=t#1s , Q=>  , ET=> );
	fb_tof_bandende_1720(IN:=b_bandende_1720 , PT:=t#1s , Q=>  , ET=> );

	IF NOT fb_tof_bandende_li.Q THEN
		st_barcode_daten.b_band_links_ok := FALSE;
		st_barcode_daten.b_band_ID_links_ok := FALSE;
		st_barcode_daten.s_band_ID_links:='';
		s_band_ID_linksHelp:='';
	END_IF
	IF NOT fb_tof_bandende_re.Q THEN
		st_barcode_daten.b_band_rechts_ok := FALSE;
		st_barcode_daten.b_band_ID_rechts_ok := FALSE;
		st_barcode_daten.s_band_ID_rechts:='';
		s_band_ID_rechtsHelp:='';
	END_IF
	IF NOT fb_tof_bandende_1720.Q AND gst_datensatz.st_md.i16_typ_zelle= BESTUECKZELLE_1720 THEN
		st_barcode_daten.b_band_ok := FALSE;
		st_barcode_daten.b_band_rechts_ok := FALSE;
		st_barcode_daten.b_band_ID_rechts_ok := FALSE;
		st_barcode_daten.s_band_ID_rechts:='';
		s_band_ID_rechtsHelp:='';
		st_barcode_daten.b_band_links_ok := FALSE;
		st_barcode_daten.b_band_ID_links_ok := FALSE;
		st_barcode_daten.s_band_ID_links:='';
		s_band_ID_linksHelp:='';
	END_IF
END_IF

(* Betriebsmeldungen wenn Band eingefädelt ist, aber nicht abgescannt *)
bm_band_nicht_gescannt_links := b_bandende_links AND (NOT st_barcode_daten.b_band_links_ok OR NOT st_barcode_daten.b_band_ID_links_ok);
bm_band_nicht_gescannt_rechts := b_bandende_rechts AND (NOT st_barcode_daten.b_band_rechts_ok OR NOT st_barcode_daten.b_band_ID_rechts_ok);
b_band_nicht_gescannt := bm_band_nicht_gescannt_links OR bm_band_nicht_gescannt_rechts; (* für Lampe Materialmangel *)

IF	gst_datensatz.st_md.b_band_ID_Puffer_aus THEN
	st_barcode_daten.b_band_ID_rechts_ok := TRUE;
	st_barcode_daten.b_band_ID_links_ok := TRUE;
ELSE
	ChargeToLTS();
END_IF

fb_trig_LTS_aus(CLK:=NOT gst_datensatz.st_md.b_band_ID_Puffer_aus);
IF	fb_trig_LTS_aus.Q THEN
	st_barcode_daten.b_band_ID_rechts_ok := FALSE;
	st_barcode_daten.b_band_ID_links_ok := FALSE;
END_IF

(*Anzeige Visu hinten für WZ und Band ================================*)
visu_hinten.in.s_aktuelles_band:=gst_datensatz.st_md.s_aktuelles_band;
visu_hinten.in.s_aktuelles_wkz:=gst_datensatz.st_md.s_aktuelles_wkz;

fb_ton_wz(IN:= , PT:=t#10s , Q=>  , ET=> );
IF	fb_trig_new_string.Q THEN
	fb_ton_wz.IN:=TRUE;
	visu_hinten.in.s_Barcode:=s_tmp_string;
END_IF
IF	fb_ton_wz.Q THEN
	fb_ton_wz.IN:=FALSE;
	visu_hinten.in.s_Barcode:='';
END_IF


(*Band scannen möglich============================================*)
IF	b_bandende_rechts  THEN
	visu_hinten.in.scannen_moeglich[0]:= TRUE;
END_IF
IF	(b_bandende_rechts AND visu_hinten.in.bandfreigabe[0] ) OR
	NOT b_bandende_rechts  OR
	NOT b_steuerung_ein THEN
	visu_hinten.in.scannen_moeglich[0]:= FALSE;
END_IF

IF	b_bandende_links  THEN
	visu_hinten.in.scannen_moeglich[1]:= TRUE;
END_IF
IF	(b_bandende_links AND visu_hinten.in.bandfreigabe[1] ) OR
	NOT b_bandende_links OR
	NOT b_steuerung_ein THEN
	visu_hinten.in.scannen_moeglich[1]:= FALSE;
END_IF

IF 	fb_trig_manuell.Q OR
	s_band_anwahl_copy<>st_barcode_daten.s_band_anwahl OR	(* Bei einer Änderung an der Visu Band OK zurücksetzen*)
	s_wkz_anwahl_copy<>st_barcode_daten.s_wkz_anwahl THEN

	s_band_anwahl_copy :=st_barcode_daten.s_band_anwahl;
	s_wkz_anwahl_copy:=st_barcode_daten.s_wkz_anwahl;
	st_barcode_daten.b_band_links_ok := FALSE;
	st_barcode_daten.b_band_rechts_ok := FALSE;
	st_barcode_daten.b_band_ok := FALSE;
	st_barcode_daten.s_band_ID_links:='';
	st_barcode_daten.b_band_ID_links_ok := FALSE;
	st_barcode_daten.s_band_ID_rechts:='';
	st_barcode_daten.b_band_ID_rechts_ok := FALSE;
	s_band_ID_linksHelp:='';
	s_band_ID_rechtsHelp:='';
END_IF

(* Meldungs TOFs *)
fb_tof_bm_neues_band_links.IN := FALSE;
fb_tof_bm_neues_band_rechts.IN := FALSE;
fb_tof_bm_neues_band_1720.IN := FALSE;
fb_tof_bm_neues_wkz.IN := FALSE;

(* ==================================Schrittkette================================ *)
fb_state_entry(i16_pos:= 1);

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF 	st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF 	fb_state_entry.E THEN
			sm_fehler_seriel := FALSE;

			s_start_wkz			:= 'WKZ';
			s_start_band_links	:= 'BAL';
			s_start_band_rechts	:= 'BAR';
			s_start_band		:= 'BAB';

		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
			(* start verzögerung *)
		IF 	fb_state_entry.fb_ton_Step.ET > t#1s THEN
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:  fb_state_entry.s_debugtext:='Reset Schnittstelle';

		IF 	fb_state_entry.E THEN
			fb_receive.Reset := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	fb_state_entry.fb_ton_Step.ET > t#100ms THEN
			fb_receive.Reset := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:  fb_state_entry.s_debugtext:='Warte Ereigniss';

		IF 	st_barcode_daten.b_band_links_ok AND
			st_barcode_daten.b_band_rechts_ok THEN
			st_barcode_daten.b_band_ok := TRUE;
		ELSE
			st_barcode_daten.b_band_ok := FALSE;
		END_IF

		IF 	st_barcode_daten.s_band_anwahl <> gst_datensatz.st_md.s_aktuelles_band THEN
			(* Anwahl von Hand *)
			st_barcode_daten.s_band_anwahl := gst_datensatz.st_md.s_aktuelles_band ;
		END_IF

		IF 	st_barcode_daten.s_wkz_anwahl <> gst_datensatz.st_md.s_aktuelles_wkz THEN
			(* Anwahl von Hand *)
			 st_barcode_daten.s_wkz_anwahl := gst_datensatz.st_md.s_aktuelles_wkz;
		END_IF

		IF 	fb_trig_new_string.Q THEN
			Anwahl();
		END_IF

		HandeingabeID();

(*=======================================================*)
	200:  fb_state_entry.s_debugtext:='Werkzeug';

		IF 	fb_trig_new_string.Q THEN
			(* 23.02.22 Wunsch von D. Rustler: Barcode soll bei Steuerung aus dasselbe machen wie bei Steuerung Ein
			Also keine Werkzeuganwahl mehr *)

			(* Keine Reaktion *)
			Anwahl()
			(* Wenn nicht verzweigt wurde, wieder nach BEREIT *);
			IF fb_state_entry.i16_next_step = 200 THEN
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

		(* Wartezeit abgelaufen => Wieder bereit *)
		IF 	fb_state_entry.fb_ton_Step.ET > t#5s THEN
 			fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,' => Wartezeit abgelaufen');
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	300:  fb_state_entry.s_debugtext:='Band Links';

		IF 	fb_trig_new_string.Q THEN
			Anwahl();
			IF 	fb_state_entry.i16_next_step = 300  AND
				s_tmp_string = st_barcode_daten.s_band_anwahl AND b_bandende_links THEN
				st_barcode_daten.b_band_links_ok := TRUE;
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

		(* Wartezeit abgelaufen => Wieder bereit *)
		IF 	fb_state_entry.fb_ton_Step.ET > t#5s THEN
 			fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,' => Wartezeit abgelaufen');
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	350:  fb_state_entry.s_debugtext:='Band ID links';

		IF 	fb_trig_new_string.Q AND b_steuerung_ein THEN
			IF	s_tmp_string <> st_barcode_daten.s_band_anwahl AND
				s_tmp_string <> st_barcode_daten.s_band_ID_rechts AND
				b_bandende_links AND
				FIND(s_tmp_string,'-') <> 4 AND
				LEN(s_tmp_string) >8 AND
				(LEN(s_tmp_string) =10 OR gst_datensatz.st_md.i16_typ_zelle <> RASTERFOLIE) THEN
				st_barcode_daten.s_band_ID_links:=s_tmp_string;
				st_barcode_daten.b_band_ID_links_ok := TRUE;
				fb_tof_bm_neues_band_links.IN := TRUE;
				s_band_ID_linksHelp:=st_barcode_daten.s_band_ID_links;
			END_IF
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

		(* Wartezeit abgelaufen => Wieder bereit *)
		IF 	fb_state_entry.fb_ton_Step.ET > t#5s THEN
 			fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,' => Wartezeit abgelaufen');
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	400:  fb_state_entry.s_debugtext:='Band Rechts';

		IF 	fb_trig_new_string.Q THEN
			Anwahl();
			IF  	fb_state_entry.i16_next_step = 400  AND s_tmp_string = st_barcode_daten.s_band_anwahl AND b_bandende_rechts THEN
				st_barcode_daten.b_band_rechts_ok := TRUE;
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

		(* Wartezeit abgelaufen => Wieder bereit *)
		IF 	fb_state_entry.fb_ton_Step.ET > t#5s THEN
 			fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,' => Wartezeit abgelaufen');
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	450:  fb_state_entry.s_debugtext:='Band ID rechts';

		IF 	fb_trig_new_string.Q AND b_steuerung_ein THEN
			IF	s_tmp_string <> st_barcode_daten.s_band_anwahl AND
				s_tmp_string <> st_barcode_daten.s_band_ID_links AND
				b_bandende_rechts AND
				FIND(s_tmp_string,'-') <> 4 AND
				LEN(s_tmp_string) >8 AND
				(LEN(s_tmp_string) =10 OR gst_datensatz.st_md.i16_typ_zelle <> RASTERFOLIE) THEN
				st_barcode_daten.s_band_ID_rechts:=s_tmp_string;
				st_barcode_daten.b_band_ID_rechts_ok := TRUE;
				fb_tof_bm_neues_band_rechts.IN := TRUE;
				s_band_ID_rechtsHelp:=st_barcode_daten.s_band_ID_rechts;
			END_IF
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

		(* Wartezeit abgelaufen => Wieder bereit *)
		IF 	fb_state_entry.fb_ton_Step.ET > t#5s THEN
 			fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,' => Wartezeit abgelaufen');
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	500:  fb_state_entry.s_debugtext:='Band 1720';

		IF 	fb_trig_new_string.Q THEN
			Anwahl();
			IF  	fb_state_entry.i16_next_step = 500  AND s_tmp_string = st_barcode_daten.s_band_anwahl AND b_bandende_1720 THEN
				st_barcode_daten.b_band_ok := TRUE;
				fb_tof_bm_neues_band_1720.IN := TRUE;
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

		(* Wartezeit abgelaufen => Wieder bereit *)
		IF 	fb_state_entry.fb_ton_Step.ET > t#5s THEN
 			fb_state_entry.s_debugtext:=CONCAT(fb_state_entry.s_debugtext,' => Wartezeit abgelaufen');
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	STOP,FEHLER:

		IF	fb_state_entry.fb_ton_Step.ET > t#1s THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

END_CASE

fb_state_entry(i16_pos:= 2 );

(* Aufruf Baustein für serielle Kommunikation *)
fb_com_port_control(
	Mode:= SERIALLINEMODE_PC_COM_PORT,
	pComIn:= ADR(COM_in_data),			(* I/O data; see global variables *)
	pComOut:= ADR(COM_out_data),		(* I/O data; see global variables *)
	SizeComIn:= SIZEOF(COM_in_data),		(* I/O data; see global variables *)
	TxBuffer:= TxBuffer,					(* transmit buffer; see global variables *)
	RxBuffer:= RxBuffer,					(* receive buffer; see global variables *)
	Error=> com_port_control_error,
	ErrorID=> com_port_control_error_id);
(* =================================== *)

(* Routine für Strings empfangen *)
fb_receive(
	Timeout:= t#50ms,
	ReceivedString:= s_tmp_string,
	RXbuffer:= RxBuffer );

fb_trig_new_string(CLK:= fb_receive.StringReceived, Q=> );

(* Meldungs TOFs *)
fb_tof_bm_neues_band_links(IN:= , PT:= t#30s, Q=> , ET=> );
fb_tof_bm_neues_band_rechts(IN:= , PT:= t#30s, Q=> , ET=> );
fb_tof_bm_neues_band_1720(IN:= , PT:= t#30s, Q=> , ET=> );
fb_tof_bm_neues_wkz(IN:= , PT:= t#30s, Q=> , ET=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_seriel;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := fb_tof_bm_neues_band_links.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := fb_tof_bm_neues_band_rechts.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := fb_tof_bm_neues_band_1720.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := fb_tof_bm_neues_wkz.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := bm_band_nicht_gescannt_links;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := bm_band_nicht_gescannt_rechts;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK
ACTION	Anwahl:
(* Prüfe auf Start Werkzeug, Band Links, Band Rechts, Band *)
IF 	s_tmp_string = s_start_wkz THEN
	fb_state_entry.i16_next_step := 200;
ELSIF
	s_tmp_string = s_start_band_links THEN
	IF	NOT st_barcode_daten.b_band_links_ok THEN
		fb_state_entry.i16_next_step := 300;
	ELSIF NOT st_barcode_daten.b_band_ID_links_ok THEN
		fb_state_entry.i16_next_step := 350;
	END_IF
ELSIF
	s_tmp_string = s_start_band_rechts THEN
	IF	NOT st_barcode_daten.b_band_rechts_ok THEN
		fb_state_entry.i16_next_step := 400;
	ELSIF NOT st_barcode_daten.b_band_ID_rechts_ok THEN
		fb_state_entry.i16_next_step := 450;
	END_IF
ELSIF
	s_tmp_string = s_start_band THEN
	fb_state_entry.i16_next_step := 500;
END_IF




END_ACTION

ACTION	ChargeToLTS:
(*	UML Nummer und VPE ermitteln,
	 diese werden mit einer Nummer auf die Pille geschrieben um Zeit zu sparen*)

(*gst_tag_data.UmlNo_VPE = erste Zahl immer 1 + UMl-Nummer max 99   danach max 6 Stellen für VPE => z.B.    1 78 100123 *)
st_LTS_xml.UmlNo:= STRING_TO_DINT(LEFT(DINT_TO_STRING(gst_tag_data.UmlNo_VPE),3))  - 100;		(*Uml Nummer => immer die ersten 3 Stellen -100 *)

i_actuellVPE:=	STRING_TO_DINT(		RIGHT(	DINT_TO_STRING(gst_tag_data.UmlNo_VPE), LEN(	DINT_TO_STRING(gst_tag_data.UmlNo_VPE)	)-3   ) 	);	(*VPE => die ersten 3 Stellen entfernen *)

(* ==================================Schrittkette============================================================================================ *)
fb_state_entry2(i16_pos:= 1);

CASE fb_state_entry2.i16_step OF
(*=======================================================*)
INIT_OBJ:

	IF	ST_BBGen.b_lesen_komplett THEN
		fb_state_entry2.i16_next_step := BEREIT;
	END_IF

(*=======================================================*)
BEREIT:  fb_state_entry2.s_debugtext:='Warte Ereigniss';

	IF	gst_PersDaten.st_LTS.i_tmpVPE <> i_actuellVPE AND
		i_actuellVPE <> 0 AND
		st_LTS_xml.UmlNo <> 0 AND   					  					(*beim Rüsten kann UML Nr. 0 auf die Pille geschrieben werden, dann wird nichts gebucht*)
		gst_datensatz.st_md.b_wt_transport_aktiv AND							(*damit beim Rüsten nicht gebucht wird*)
		gi16_maschinenstatusinfo = STATUS_MASCHINE_ARBEITET AND
		gst_datensatz.st_bestueckprogramm.i32_anzahl>0 AND
		(ST_Virtuelle_Masterachse.fb_state_entry.i16_step > BEREIT OR		(*Es darf nur gebucht werden, wenn auch tatsächlich bestückt wird*)
		ST_Rasterfolienmontage.fb_state_entry.i16_step > BEREIT ) THEN

		CASE gst_datensatz.st_md.i16_typ_zelle OF
		BESTUECKZELLE_1700:

			(*Bei 1700 wird die ID nur auf der linken Seite beschrieben da nur ein Band benutzt wird*)
			st_LTS_xml.newbatch[1]:='';							(*wird nur bei 1720 benutzt*)
			gst_PersDaten.st_LTS.s_tmpNewbatch[1]:='';			(*wird nur bei 1720 benutzt*)

			IF 	st_barcode_daten.b_band_ID_links_ok AND
				zyl_bandeinzuege_verschieben.st_ctrl.out.b_ausgefahren THEN
				st_LTS_xml.newbatch[0]:=st_barcode_daten.s_band_ID_links;
			ELSIF
				st_barcode_daten.b_band_ID_rechts_ok AND
				zyl_bandeinzuege_verschieben.st_ctrl.out.b_eingefahren THEN
				st_LTS_xml.newbatch[0]:=st_barcode_daten.s_band_ID_rechts;
			END_IF
			b_newbatchOk:=	st_LTS_xml.newbatch[0] <>'';								(*es muss ein Band eingescannt sein um eine Datei zu erstelle*)

		 RASTERFOLIE:

			(*Bei RASTERFOLIE wird die ID nur auf der linken Seite beschrieben da nur ein Band benutzt wird*)
			st_LTS_xml.newbatch[1]:='';							(*wird nur bei 1720 benutzt*)
			gst_PersDaten.st_LTS.s_tmpNewbatch[1]:='';			(*wird nur bei 1720 benutzt*)

			IF 	st_barcode_daten.b_band_ID_links_ok THEN
				st_LTS_xml.newbatch[0]:=st_barcode_daten.s_band_ID_links;
			END_IF
			b_newbatchOk:=	st_LTS_xml.newbatch[0] <>'';

		BESTUECKZELLE_1720:
			(*Bei 1720 wird die ID  auf beiden Seiten beschrieben da zwei Bänder gleichzeitig benutzt werden*)
			IF 	st_barcode_daten.b_band_ID_links_ok AND
			 	st_barcode_daten.b_band_ID_rechts_ok THEN
				st_LTS_xml.newbatch[0]:=st_barcode_daten.s_band_ID_links;
				st_LTS_xml.newbatch[1]:=st_barcode_daten.s_band_ID_rechts;
			END_IF
			b_newbatchOk:=st_LTS_xml.newbatch[0] <>'' AND st_LTS_xml.newbatch[1] <>'';		(*es müssen beide eingescannt sein um eine Datei zu erstelle*)

		END_CASE


		(*Trig startet das Erstellen der Xml und das Kopieren zum Server==========================================================*)
		IF 	b_newbatchOk THEN
			IF	(gst_PersDaten.st_LTS.i_tmpVPE > i_actuellVPE ) OR							(* bie einem neuen Auftrag*)
				((gst_PersDaten.st_LTS.s_tmpNewbatch[0] <> st_LTS_xml.newbatch[0]) 	AND st_LTS_xml.newbatch[0] <>'' ) OR	(* bei einer Äderung der Chargen ID*)
				((gst_PersDaten.st_LTS.s_tmpNewbatch[1] <> st_LTS_xml.newbatch[1])	AND st_LTS_xml.newbatch[1] <>'' ) THEN

				fb_state_entry2.i16_next_step := 110;
				gst_PersDaten.st_LTS.s_tmpNewbatch[0]:=st_LTS_xml.newbatch[0];
				gst_PersDaten.st_LTS.s_tmpNewbatch[1]:=st_LTS_xml.newbatch[1];
			END_IF
		END_IF

		gst_PersDaten.st_LTS.i_tmpVPE:=i_actuellVPE;

	END_IF

(*=======================================================*)
110:  fb_state_entry2.s_debugtext:='Dateinamen erstellen + VPE und Zeit in xml eintragen';

	IF	fb_state_entry2.E THEN

		st_LTS_xml.VPE:=i_actuellVPE;
		st_LTS_xml.timestamp:=gstr_system_time;

		s_FileName:='';
		s_FileName:=CONCAT(s_FileName, gst_datensatz.st_md.s_aktuelles_wkz);
		s_FileName:=CONCAT(s_FileName, '_');
		s_FileName:=CONCAT(s_FileName,WORD_TO_STR_LEN(gst_system_time.wDay,2));
		s_FileName:=CONCAT(s_FileName, '-');
		s_FileName:=CONCAT(s_FileName, WORD_TO_STR_LEN(gst_system_time.wMonth,2));
		s_FileName:=CONCAT(s_FileName, '-');
		s_FileName:=CONCAT(s_FileName, WORD_TO_STRING(gst_system_time.wYear));
		s_FileName:=CONCAT(s_FileName, '_');
		s_FileName:=CONCAT(s_FileName, WORD_TO_STR_LEN(gst_system_time.wHour,2));
		s_FileName:=CONCAT(s_FileName, '-');
		s_FileName:=CONCAT(s_FileName, WORD_TO_STR_LEN(gst_system_time.wMinute,2));
		s_FileName:=CONCAT(s_FileName, '-');
		s_FileName:=CONCAT(s_FileName, WORD_TO_STR_LEN(gst_system_time.wSecond,2));
		s_FileName:=CONCAT(s_FileName, '_');
		s_FileName:=CONCAT(s_FileName, st_LTS_xml.newbatch[0]);
		s_FileName:=CONCAT(s_FileName, '_');
		s_FileName:=CONCAT(s_FileName, DINT_TO_STRING(i_actuellVPE));
		s_FileName:=CONCAT(s_FileName, '.xml');
		fb_WriteXml.sFilePath :=CONCAT('D:\BBgen\LTS\',  s_FileName);
		fb_WriteXml.bExecute:=TRUE;

	END_IF

	IF	fb_WriteXml.bBusy THEN
		fb_state_entry2.i16_next_step := 120;
	ELSIF
		fb_WriteXml.bError THEN
		i_ErrId:= fb_WriteXml.nErrId;
		fb_state_entry2.i16_next_step := FEHLER;
	END_IF

	IF	fb_state_entry2.X THEN
		fb_WriteXml.bExecute:=FALSE;
	END_IF

(*=======================================================*)
120:  fb_state_entry2.s_debugtext:='warte auf fertig';

	IF	fb_state_entry2.fb_ton_Step.ET >t#500ms THEN
		IF	NOT fb_WriteXml.bBusy AND
			NOT fb_WriteXml.bError THEN
			fb_state_entry2.i16_next_step := 130;
		ELSIF
			fb_WriteXml.bError THEN
			i_ErrId:= fb_WriteXml.nErrId;
			fb_state_entry2.i16_next_step := FEHLER;
		END_IF
	END_IF

(*=======================================================*)
130:  fb_state_entry2.s_debugtext:='start vbs Skript => kopiert xml zum Server';

	IF	fb_state_entry2.E THEN
		NT_StartProcess.START:=TRUE;
	END_IF

	IF	NT_StartProcess.BUSY THEN
		fb_state_entry2.i16_next_step := 140;
	ELSIF
		NT_StartProcess.ERR THEN
		i_ErrId:= NT_StartProcess.ERRID;
		fb_state_entry2.i16_next_step := FEHLER;
	END_IF

	IF	fb_state_entry2.X THEN
		NT_StartProcess.START:=FALSE;
	END_IF

(*=======================================================*)
140:  fb_state_entry2.s_debugtext:='warte auf fertig';

	IF	NOT NT_StartProcess.BUSY AND
		NOT NT_StartProcess.ERR THEN
		fb_state_entry2.i16_next_step := BEREIT;
	ELSIF
		NT_StartProcess.ERR THEN
		i_ErrId:= NT_StartProcess.ERRID;
		fb_state_entry2.i16_next_step := FEHLER;
	END_IF

(*=======================================================*)
STOP,FEHLER:

	IF 	fb_state_entry2.E THEN
		IF	i_ErrId <> 0 THEN
		 	fb_state_entry2.s_debugtext:=CONCAT('nErrId = ', UDINT_TO_STRING(i_ErrId)	);
		END_IF
		i_ErrId:=0;
	END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	fb_state_entry2.fb_ton_Step.ET > t#1s THEN
		fb_state_entry2.i16_next_step := BEREIT;
	END_IF

END_CASE

fb_state_entry2(i16_pos:= 2 );


fb_WriteXml(
	ePath:= PATH_GENERIC ,
	nMode:= XMLSRV_ADDMISSING,
	sSymName:='.barcode.fb.st_LTS_xml',
	sXPath:=  '/data',
	tTimeout:= t#10s );


NT_StartProcess(
	PATHSTR:= 'C:\Windows\System32\wscript.exe',
	DIRNAME:=s_tools_path,
	COMNDLINE:=CONCAT(visu.s_akt_sprache,'_LTS_nach_server.vbs'),
	TMOUT:= DEFAULT_ADS_TIMEOUT);


END_ACTION

ACTION	HandeingabeID:

fb_ton_band_ID(
	IN:= 	s_band_ID_linksHelp <> st_barcode_daten.s_band_ID_links OR
			s_band_ID_rechtsHelp <> st_barcode_daten.s_band_ID_rechts ,
	PT:=t#500ms , Q=>  , ET=> );


(*Handeingabe links=========================================*)
IF	st_barcode_daten.b_band_links_ok AND
	fb_ton_band_ID.Q THEN

		IF	LEN(st_barcode_daten.s_band_ID_links) < 8 THEN
			st_barcode_daten.s_band_ID_links:=s_band_ID_linksHelp;
		ELSE
			s_band_ID_linksHelp:=st_barcode_daten.s_band_ID_links;
			st_barcode_daten.b_band_ID_links_ok := TRUE;
		END_IF

END_IF



(*Handeingabe rechts=========================================*)
IF	st_barcode_daten.b_band_rechts_ok AND
	fb_ton_band_ID.Q THEN

		IF	LEN(st_barcode_daten.s_band_ID_rechts) < 8 THEN
			st_barcode_daten.s_band_ID_rechts:=s_band_ID_rechtsHelp;

		ELSE
			s_band_ID_rechtsHelp:=st_barcode_daten.s_band_ID_rechts;
			st_barcode_daten.b_band_ID_rechts_ok := TRUE;
		END_IF
END_IF

END_ACTION






(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_BBGen
VAR_INPUT
	st_config							: struct_config;
	st_ctrl_in							: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu								: struct_xml_visu;
	i16_auftrag						: enum_bbgen_auftrag;
END_VAR
VAR_OUTPUT
	st_ctrl_out						: struct_ctrl_out;
END_VAR
VAR
	fb_state_entry						: ST_StateEntry;
	fb_state_entry2					: ST_StateEntry;
	fb_ton_quitt						: TON;
	fb_bbgen_xml_file					: ST_BBGenXMLFile;
	fb_bbgen_write_file				: ST_BBGenWriteFile;
	fb_wkz_band_wt_schreiben			: ST_Export_String;
	s_name_alt_wkz					: STRING;
	s_name_alt_band					: STRING;
	s_name_alt_wt					: STRING;
	fb_xml_srv_read					: FB_XmlSrvReadByName;
	s_PLC_path_name				: STRING(255);
	nErrId							: UDINT;

	(* Pfadnamen für die einzelnen Maschinendaten *)
	s_wkz_path						: STRING(50);
	s_isk_path						: STRING(50);
	s_bestueckbild_path				: STRING(50);
	s_bestueckbild_halbauto_path	: STRING(50);
	s_band_path					: STRING(50);
	s_wt_path						: STRING(50);

	(* BBGen: Step 520 *)
	st_akt_bestueckprogramm			: struct_bestueckprogramm;
	b_ok							: ARRAY[0..4] OF BOOL;
	b_sort_swap						: BOOL;
	tmp_y							: LREAL;
	tmp_z							: LREAL;
	tmp_b							: INT;
	swap_a							: DINT;
	swap_b							: DINT;

	s_md_name						: STRING(50);
	s_md_backup_name				: STRING(50);
	s_bestueckbild_name				: STRING(50);

	(* Temporäre Variable *)
	i								: DINT := 0;
	k								: DINT := 0;
	lr_tmp							: LREAL := 0.0;
	i16_tmp							: INT;
	i32_tmp							: DINT;
	hm_alle_daten_laden				: BOOL := FALSE;
	hm_alle_daten_speichern			: BOOL := FALSE;
	fb_r_trig_taste_wkz_laden			: R_TRIG;
	fb_r_trig_taste_wkz_speichern		: R_TRIG;
	b_first_cycle 						: BOOL := TRUE;
	fb_f_trig_steuerung				: F_TRIG;

	sm_fehler_lesen_wkz				: BOOL;
	sm_fehler_lesen_md				: BOOL;
	sm_fehler_lesen_isk				: BOOL;
	sm_fehler_lesen_band				: BOOL;
	sm_fehler_lesen_bestueckbild		: BOOL;
	sm_fehler_lesen_wt				: BOOL;
	sm_fehler_schreiben_wkz			: BOOL;
	sm_fehler_schreiben_md			: BOOL;
	sm_fehler_schreiben_isk			: BOOL;
	sm_fehler_schreiben_band			: BOOL;
	sm_fehler_schreiben_wt			: BOOL;
	sm_fehler_schreiben_bestueckbild	: BOOL;
	sm_fehler_generieren_bestueckbild	: BOOL;
	sm_fehler_schreiben_bestueckbild_auf_hdd : BOOL;
	sm_fehler_wkz_nicht_vorhanden		: BOOL;
	sm_fehler_falsches_Band			: BOOL;

	bm_kleinster_greifer_groesser_kleinste_pinanzahl_in_bb : BOOL;
	bm_keine_vollbestueck_Artikelnummer : BOOL;

	gst_datensatz_copy				: struct_datensatz;
	b_lesen_komplett					: BOOL:=FALSE;
	j								: INT:=0;
	hm_md_speichern					: BOOL;
	fb_r_trig_taste_bestueckprg_manuell	: R_TRIG;
	fb_ton_end						: TON;
	fb_ton_wz						: TON;

	(*Aktion: Hub_Faktor_ermitteln*)
	s_HelpBand						: ARRAY [0..14] OF STRING(50);
	i32_maxAnzahl					: DINT;
	i32_Anzahl						: ARRAY [0..14] OF DINT;
	m								: DINT;
	n								: DINT;
	lr_min_FaktorHub					: LREAL;
	lr_FaktorHub						: LREAL:=1;
	i32_UsedTool					: DINT := 0;
	fb_r_trig_taste_vollbestuecken		: R_TRIG;

	wkz_Nr							: INT:=-1;
	gst_manuelles_bestueckprogramm_copy	: struct_bestueckprogramm;

	(*wkz_gruppe*) (*nur bei Halbautomatisch: Werkzeuge die mann zusammenfassen kann*)

	st_wkz_gruppe_copy				: ARRAY[0..4] OF  struct_md_wkz;
	i32_neues_Wkz					: DINT;
	state							: INT;
	sm_Wkz_nicht_kompatibel			: BOOL;
	sm_Band_nicht_kompatibel			: BOOL;
	sm_Wkz_Gruppe_nicht_zugeordnet	: BOOL;
	b_Wkz_Gruppe_gebildet			: BOOL;
	i16_anzahl_Wkz_Gruppen			: INT;
	b_Wkz_akt_vorhanden				: BOOL;
	for_begin						: DINT;
	for_end							: DINT;
	st_wkz_leer						: struct_wkz;
	st_band_leer						: struct_banddaten;
	st_wt_leer						: struct_wt;
	st_bestueckprogramm_leer			: struct_bestueckprogramm;
	st_bestueckbild_leer				: struct_bestueckbild;
	st_bestueckbild_halbauto_leer		: struct_bestueckbild_halbauto;
END_VAR
(* @END_DECLARATION := '0' *)
(* Flankenauswertung der Tasten an der Bedienoberfläche *)
fb_r_trig_taste_wkz_laden(CLK:= st_visu .b_taste_daten_laden, Q=> );
fb_r_trig_taste_wkz_speichern(CLK:= st_visu.b_taste_daten_speichern, Q=> );
fb_f_trig_steuerung(CLK:= ST_Safetyprogramm.se_steuerung_ein, Q=> );

fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF	 fb_bbgen_xml_file.bError THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF

END_IF

subr_Wkz_Band_Wt_schreiben();

IF	b_lesen_komplett THEN
	wkz_gruppe_kompatibel();
ELSE
	st_wkz_gruppe_copy:=gst_datensatz.st_md.st_wkz_gruppe;
END_IF

(*mit einem bestimmten Werkzeug eine gaze Reihe bestücken*)
fb_r_trig_taste_vollbestuecken(CLK:=
						visu.b_vollbestuecken AND
						gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET ,
									Q=> );

IF	fb_r_trig_taste_vollbestuecken.Q THEN
	IF	visu.b_merker_vollbestuecken THEN
		visu.b_merker_vollbestuecken:=FALSE;
	ELSE
		visu.b_merker_vollbestuecken:=TRUE;
	END_IF
END_IF

IF	visu.b_merker_vollbestuecken THEN
	gst_datensatz.st_md.b_wt_transport_aktiv:=FALSE;
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(i16_pos:= 1 );

auto_speichern_laden();

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:	(* Init *)
		fb_ton_quitt.IN := FALSE;
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_fehler := FALSE;
		sm_fehler_lesen_wkz := FALSE;
		sm_fehler_lesen_md := FALSE;
		sm_fehler_lesen_isk := FALSE;
		sm_fehler_lesen_band	:= FALSE;
		sm_fehler_lesen_wt := FALSE;
		sm_fehler_lesen_bestueckbild := FALSE;
		sm_fehler_schreiben_wkz := FALSE;
		sm_fehler_schreiben_md := FALSE;
		sm_fehler_schreiben_isk := FALSE;
		sm_fehler_schreiben_band	:= FALSE;
		sm_fehler_schreiben_wt := FALSE;
		sm_fehler_schreiben_bestueckbild := FALSE;
		sm_fehler_generieren_bestueckbild := FALSE;
		sm_fehler_schreiben_bestueckbild_auf_hdd := FALSE;
		sm_fehler_wkz_nicht_vorhanden:=FALSE;
		sm_fehler_falsches_Band:=FALSE;
		sm_Wkz_nicht_kompatibel:=FALSE;
		sm_Wkz_Gruppe_nicht_zugeordnet:=FALSE;
		sm_Band_nicht_kompatibel:=FALSE;
		bm_keine_vollbestueck_Artikelnummer:=FALSE;

		fb_bbgen_xml_file.start_lesen_wkz := FALSE;
		fb_bbgen_xml_file.start_lesen_md := FALSE;
		fb_bbgen_xml_file.start_lesen_isk := FALSE;
		fb_bbgen_xml_file.start_lesen_band := FALSE;
		fb_bbgen_xml_file.start_lesen_bestueckbild := FALSE;
		fb_bbgen_xml_file.start_lesen_bestueckbild_halbauto := FALSE;
		fb_bbgen_xml_file.start_schreiben_wkz := FALSE;
		fb_bbgen_xml_file.start_schreiben_md := FALSE;
		fb_bbgen_xml_file.start_schreiben_isk := FALSE;
		fb_bbgen_xml_file.start_schreiben_band := FALSE;
		fb_bbgen_xml_file.start_schreiben_bestueckbild := FALSE;
		fb_bbgen_xml_file.start_schreiben_bestueckbild_halbauto := FALSE;
		fb_bbgen_xml_file.bQuit := FALSE;
		hm_alle_daten_laden := FALSE;
		hm_alle_daten_speichern := FALSE;
		i16_auftrag := KEIN_BB_AUFTRAG;

		s_wkz_path := 'D:/BBGen/Wkz/';
		s_isk_path := 'D:/BBGen/ISK/';
		s_bestueckbild_path := 'D:/BBGen/Bestueckbild/';
		s_bestueckbild_halbauto_path := 'D:/BBGen/BestueckbildHalbauto/';
		s_band_path := 'D:/BBGen/Band/';
		s_wt_path := 'D:/BBGen/Wt/';

		s_md_name := 'Maschinendaten';
		s_md_backup_name := 'Maschinendaten_Backup';
		s_bestueckbild_name := 'Artikelnummer_Bestueckbild';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF b_first_cycle THEN
			fb_state_entry.i16_next_step := 10;
		ELSE
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	10:	(* PLC Projectpfad mit Projektnamen aus TPY auslesen Achtung!! Bootprojekt muss erstellt sein *)
		(* Unter Projekt >> Optionen >> TwinCAT >> Symbolbeschreibung aus Datei herunterladen muss gesetzt sein *)
		IF fb_state_entry.E THEN
			fb_xml_srv_read.sFilePath:= 'c:\TwinCAT\Boot\CurrentPlc_1.tpy';
			fb_xml_srv_read.sXPath := '/PlcProjectInfo/ProjectInfo/Path';
			fb_xml_srv_read.sSymName:= 'ST_BBGen.s_PLC_path_name';
			fb_xml_srv_read.bExecute:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_xml_srv_read.bBusy THEN
			fb_xml_srv_read.bExecute:= FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Lesevorgang erfolgreich? *)
		IF NOT fb_xml_srv_read.bBusy THEN
			IF NOT fb_xml_srv_read.bError THEN
				fb_state_entry.i16_next_step := 40;
			ELSE	(* Fehler *)
				s_PLC_path_name := '!!! not found !!!';
				nErrId := fb_xml_srv_read.nErrId;
				fb_state_entry.i16_next_step := 40;
			END_IF
		END_IF

		(* PLC Name und Pfad trennen *)
		s_PLC_name := s_PLC_path_name;
		i := 0;
		FOR i := 1 TO 30 DO
			s_PLC_name := DELETE(s_PLC_name, FIND(s_PLC_name,'\'),1);
		END_FOR

		s_PLC_Path := s_PLC_path_name;
		s_PLC_Path := DELETE(s_PLC_Path, LEN(s_PLC_path)-FIND(s_PLC_path, s_PLC_name) + 1, FIND(s_PLC_path, s_PLC_name));
		s_Projekt_path := s_PLC_Path;
		s_Projekt_path := DELETE(s_Projekt_path, LEN(s_Projekt_path)-FIND(s_Projekt_path,'PLC\')+1,FIND(s_Projekt_path, 'PLC\'));

(*=======================================================*)
	40: (* Warte auf Auftrag *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			IF b_first_cycle THEN
				path();
				(* Zuerst müssen die Maschinendaten geladen werden, damit Infos über aktuelles Wkz, Band, Isk, u.s.w. vorhanden sind. *)
				i16_auftrag := LESE_KOMPLETT;
				b_first_cycle := FALSE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF i16_auftrag > KEIN_BB_AUFTRAG THEN
			fb_state_entry.i16_next_step := 50;

(*
			(* gg: fake that we can generate on the PC *)
			fb_state_entry.i16_next_step := 300;
			gst_datensatz.st_md.s_aktuelles_band := '154-20011';
			(* gst_datensatz.st_md.s_aktueller_isk := '154-4002'; muss vom artikel kommen *)
			gst_datensatz.st_md.s_aktuelle_artikelnummer := '154-50021_0';
			hm_alle_daten_laden := TRUE;
			gi16_maschinenstatusinfo := STATUS_MASCHINE_ARBEITET;
*)			
		END_IF

		IF fb_r_trig_taste_wkz_laden.Q THEN
			hm_alle_daten_laden := TRUE;
			b_lesen_komplett:=FALSE;
			i16_auftrag := LESE_WKZ;	(*sonst gehen Maschinenparameter die noch nicht gespeichert wurden verloren *)
		END_IF

		IF fb_r_trig_taste_wkz_speichern.Q OR fb_f_trig_steuerung.Q THEN
			fb_state_entry.i16_next_step := 820;
			hm_alle_daten_speichern := TRUE;
		END_IF

(*=======================================================*)
	50: (* Auftragsauswahl *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE i16_auftrag OF
			LESE_MD:
				fb_state_entry.i16_next_step := 100;

			LESE_WKZ:
				fb_state_entry.i16_next_step := 200;

			LESE_BAND:
				fb_state_entry.i16_next_step := 300;

			LESE_WT:
				fb_state_entry.i16_next_step := 350;

			LESE_BESTUECKBILD:
				fb_state_entry.i16_next_step := 400;

			LESE_ISK:
				fb_state_entry.i16_next_step := 600;

			LESE_KOMPLETT:
				hm_alle_daten_laden := TRUE;
				fb_state_entry.i16_next_step := 100;

			SCHREIBE_ISK:
				fb_state_entry.i16_next_step := 800;

			SCHREIBE_WKZ:
				fb_state_entry.i16_next_step := 820;

			SCHREIBE_BAND:
				fb_state_entry.i16_next_step := 840;

			SCHREIBE_WT:
				fb_state_entry.i16_next_step := 860;

			SCHREIBE_MD:
				fb_state_entry.i16_next_step := 880;

			SCHREIBE_BESTUECKBILD:
				fb_state_entry.i16_next_step := 880;

		END_CASE

(*============================Laden===========================*)
	100:	(* Maschinendaten *)
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_lesen_md:= TRUE;
			fb_bbgen_xml_file.s_path := s_md_path;
			fb_bbgen_xml_file.s_md:= s_md_name;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_lesen  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 110;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_lesen_md := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	110:
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_lesen_md := FALSE;
			gst_datensatz_copy.st_md:= gst_datensatz.st_md ;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF hm_alle_daten_laden THEN
			fb_state_entry.i16_next_step := 200;
		ELSE
			fb_state_entry.i16_next_step := 999;
		END_IF

(*=======================================================*)
	200: (* Wkz daten *)
		IF fb_state_entry.E THEN
			gst_datensatz.st_wkz:=st_wkz_leer;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gst_datensatz.st_md.s_aktuelles_wkz <>'' THEN
			fb_state_entry.i16_next_step := 210;
		ELSIF hm_alle_daten_laden  THEN
				fb_state_entry.i16_next_step := 300;
			ELSE
				fb_state_entry.i16_next_step := 999;
		END_IF

	210:
		IF fb_state_entry.E  THEN
			fb_bbgen_xml_file.start_lesen_wkz := TRUE;
			fb_bbgen_xml_file.s_path := s_wkz_path;
			fb_bbgen_xml_file.s_wkz := gst_datensatz.st_md.s_aktuelles_wkz;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_lesen  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 220;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_lesen_wkz := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	220:
		IF fb_state_entry.E THEN
			gst_datensatz_copy.st_wkz:= gst_datensatz.st_wkz ;
			fb_bbgen_xml_file.start_lesen_wkz := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF hm_alle_daten_laden THEN
			fb_state_entry.i16_next_step := 300;
		ELSE
			IF gst_datensatz_copy.st_md.s_aktuelles_wkz<>gst_datensatz.st_md.s_aktuelles_wkz THEN
				fb_state_entry.i16_next_step := 880;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	300:	(* Band Daten *)
		IF fb_state_entry.E THEN
			gst_datensatz.st_band:=st_band_leer;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	gst_datensatz.st_md.s_aktuelles_band <>'' THEN
			fb_state_entry.i16_next_step := 310;
		ELSIF 	hm_alle_daten_laden  THEN
				fb_state_entry.i16_next_step := 350;
			ELSE
				fb_state_entry.i16_next_step := 999;
		END_IF

	310:
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_lesen_band := TRUE;
			fb_bbgen_xml_file.s_path := s_band_path;
			fb_bbgen_xml_file.s_band := gst_datensatz.st_md.s_aktuelles_band;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_lesen  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 320;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_lesen_band := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	320:
		IF fb_state_entry.E THEN
			gst_datensatz_copy.st_band:= gst_datensatz.st_band ;
			fb_bbgen_xml_file.start_lesen_band := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF hm_alle_daten_laden THEN
			fb_state_entry.i16_next_step := 350;
		ELSE
			IF gst_datensatz_copy.st_md.s_aktuelles_band<>gst_datensatz.st_md.s_aktuelles_band THEN
				fb_state_entry.i16_next_step := 880;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	350:	(* Wt Daten *)
		IF fb_state_entry.E THEN
			gst_datensatz.st_wt:=st_wt_leer;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	gst_datensatz.st_md.s_aktueller_wt <>'' THEN
			fb_state_entry.i16_next_step := 360;
		ELSIF 	hm_alle_daten_laden  THEN
				fb_state_entry.i16_next_step := 400;
			ELSE
				fb_state_entry.i16_next_step := 999;
		END_IF

	360:
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_lesen_wt := TRUE;
			fb_bbgen_xml_file.s_path := s_wt_path;
			fb_bbgen_xml_file.s_wt := gst_datensatz.st_md.s_aktueller_wt;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_lesen  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 370;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_lesen_wt := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	370:
		IF fb_state_entry.E THEN
			gst_datensatz_copy.st_wt:= gst_datensatz.st_wt ;
			fb_bbgen_xml_file.start_lesen_wt := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF hm_alle_daten_laden THEN
			fb_state_entry.i16_next_step := 400;
		ELSE
			IF gst_datensatz_copy.st_md.s_aktueller_wt<>gst_datensatz.st_md.s_aktueller_wt THEN
				fb_state_entry.i16_next_step := 880;
			ELSE
				fb_state_entry.i16_next_step := 999;
			END_IF
		END_IF

(*=======================================================*)
	400:	(* Abfrage auf manuelle Anwahl des Bestückbildes *)
 		CASE gst_datensatz.st_md.i16_typ_bestueckmodus OF

			BESTUECKUNG_MANUAL:
				(* Bei der manuellen Auswahl des Bestückprogrammes werden die Daten direkt über die Visu
				von einem txt-File in die Variable "gst_datensatz" geladen. Ein Einlesen ist somit nicht nötig. *)
				gst_datensatz.st_bestueckprogramm:=gst_manuelles_bestueckprogramm;
				gst_datensatz.st_md.s_aktueller_isk:='ISK_Daten';
				IF hm_alle_daten_laden THEN
					fb_state_entry.i16_next_step := 600;
				ELSE
					fb_state_entry.i16_next_step := 999;
				END_IF

			BESTUECKUNG_HALBAUTO:
				IF gi16_maschinenstatusinfo = STATUS_MASCHINE_ARBEITET THEN
					gst_datensatz.st_md.s_aktueller_isk:='ISK_Daten';
					fb_state_entry.i16_next_step := 500;
				ELSE
					fb_state_entry.i16_next_step := 999;
				END_IF

			BESTUECKUNG_AUTO:
				IF gi16_maschinenstatusinfo = STATUS_MASCHINE_ARBEITET THEN
					fb_state_entry.i16_next_step := 410;
				ELSE
					fb_state_entry.i16_next_step := 999;
				END_IF

		END_CASE

(*=======================================================*)
	410:	(*alle Positonen löschen*)
		IF 	fb_state_entry.E THEN
			gst_bestueckbild := st_bestueckbild_leer;
			gst_datensatz.st_bestueckprogramm:=st_bestueckprogramm_leer;
		END_IF

		fb_state_entry.i16_next_step := 412;

(*=======================================================*)
	412:	(* Bestueckbild lesen und generieren *)
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_lesen_bestueckbild := TRUE;
			fb_bbgen_xml_file.s_path := s_bestueckbild_path;
			fb_bbgen_xml_file.s_bestueckbild := gst_datensatz.st_md.s_aktuelle_artikelnummer;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_lesen  AND NOT fb_state_entry.E THEN
			IF	visu.b_merker_vollbestuecken THEN
				fb_state_entry.i16_next_step := 414;
			ELSE
				fb_state_entry.i16_next_step := 420;
			END_IF
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_lesen_bestueckbild := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	414:	(* Werkzeuggruppen durchsuchen nach benuztem Werkzeug *)
		IF 	fb_state_entry.E THEN
			fb_bbgen_xml_file.start_lesen_bestueckbild := FALSE;
			i32_UsedTool:=-1;
			k:=-1;
			FOR k := 0 TO 4 DO
				i:=-1;

				FOR i := 0 TO MaxNoOfWkz DO
					IF 	gst_bestueckbild.s_wkzgruppe[k].s_wkznummer[i] = gst_datensatz.st_md.s_aktuelles_wkz THEN
						i32_UsedTool:=i;
					END_IF
				END_FOR
			END_FOR
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	i32_UsedTool <> -1 THEN
			fb_state_entry.i16_next_step := 416;
		END_IF

		IF 	gst_bestueckbild.s_Bestueckbild_vollbestueckt[i32_UsedTool] = '' THEN
			fb_state_entry.i16_next_step := 420;
			bm_keine_vollbestueck_Artikelnummer:=TRUE;
		END_IF

(*=======================================================*)
	416:	(* Bestueckbild lesen und generieren *)
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_lesen_bestueckbild := TRUE;
			fb_bbgen_xml_file.s_path := s_bestueckbild_path;
			fb_bbgen_xml_file.s_bestueckbild := gst_bestueckbild.s_Bestueckbild_vollbestueckt[i32_UsedTool] ;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_lesen  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 420;
			fb_bbgen_xml_file.start_lesen_bestueckbild := FALSE;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_lesen_bestueckbild := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	420:	(* Generiere Bestückprogramm *)
		IF fb_state_entry.E THEN
			bm_kleinster_greifer_groesser_kleinste_pinanzahl_in_bb := FALSE;
			generiere_bestueckbild();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 425;

(*=======================================================*)
	425:	(* Hub_Faktor_ermitteln *)
		IF fb_state_entry.E THEN

			IF	gst_datensatz.st_wkz.i16_typ_bandeinzug=STANDARD_2FACH_V2  OR
				gst_datensatz.st_wkz.i16_typ_bandeinzug=BANDWECHSLER_V2 THEN
				Hub_Faktor_ermitteln();
			ELSE
				lr_FaktorHub:=1;
			END_IF

		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 430;

(*=======================================================*)
	430:	(* Schreibe Bestückprogramm auf HDD *)
		IF fb_state_entry.E THEN
			fb_bbgen_write_file.bStart := TRUE;
		END_IF


		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_state_entry.E THEN
			IF fb_bbgen_write_file.bFertig THEN
				fb_state_entry.i16_next_step := 600; (* ISK Daten lesen*)
			END_IF

			IF fb_bbgen_write_file.bError THEN
				fb_state_entry.i16_next_step := FEHLER;
				sm_fehler_schreiben_bestueckbild_auf_hdd := TRUE;
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			fb_bbgen_write_file.bStart := FALSE;
		END_IF


(*=======================================================*)
	500:	(*alle Positonen löschen*)
		IF 	fb_state_entry.E THEN
			gst_bestueckbild_halbauto := st_bestueckbild_halbauto_leer;
		END_IF

		fb_state_entry.i16_next_step := 510;

(*=======================================================*)
	510:	(* halbauto Bestueckbild lesen  *)
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_lesen_bestueckbild_halbauto := TRUE;
			fb_bbgen_xml_file.s_path := s_bestueckbild_halbauto_path;
			fb_bbgen_xml_file.s_bestueckbild := gst_datensatz.st_md.s_aktuelle_artikelnummer;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_lesen  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 515;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_lesen_bestueckbild := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	515:	(* alle Positionen löschen  *)
		fb_bbgen_xml_file.start_lesen_bestueckbild_halbauto := FALSE;
		gst_datensatz.st_bestueckprogramm:=st_bestueckprogramm_leer;

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	b_Wkz_Gruppe_gebildet THEN
			fb_state_entry.i16_next_step := 540;
		ELSE
			fb_state_entry.i16_next_step := 520;
		END_IF

		IF	sm_Wkz_nicht_kompatibel OR
			sm_Wkz_Gruppe_nicht_zugeordnet THEN
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	520:	(* Werkzeuggruppen durchsuchen nach benuztem Werkzeug *)
		IF 	fb_state_entry.E THEN
			i32_UsedTool:=-1;
			k:=-1;
			FOR k := 0 TO 4 DO
				i:=-1;

				FOR i := 0 TO MaxNoOfWkz DO
					IF 	gst_bestueckbild_halbauto.s_wkzgruppe[k].s_wkznummer[i] = gst_datensatz.st_md.s_aktuelles_wkz THEN
						i32_UsedTool:=i;
					END_IF
				END_FOR
			END_FOR

		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	i32_UsedTool <> -1 THEN
			fb_state_entry.i16_next_step := 530;
		ELSE
			sm_fehler_wkz_nicht_vorhanden:=TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	530: (*kopieren des zum WZ passenden Bestückbild*)
		IF 	fb_state_entry.E THEN
			gst_datensatz.st_bestueckprogramm:=gst_bestueckbild_halbauto.Wkz[i32_UsedTool];
			gst_datensatz.st_isk:=gst_bestueckbild_halbauto.Wkz[i32_UsedTool].st_isk;


			(*Offset dazurechnen*)
			k:=-1;
			FOR k := 0 TO (gst_bestueckbild_halbauto.Wkz[i32_UsedTool].i32_anzahl - 1) DO  (*max 511*)
				IF	gst_datensatz.st_bestueckprogramm.i16_b[k] = -1 THEN
					gst_datensatz.st_bestueckprogramm.lr_y[k]:=gst_datensatz.st_bestueckprogramm.lr_y[k] + gst_datensatz.st_bestueckprogramm.lr_y_offset;
					gst_datensatz.st_bestueckprogramm.lr_z[k]:=gst_datensatz.st_bestueckprogramm.lr_z[k] + gst_datensatz.st_bestueckprogramm.lr_z_offset;
				END_IF
			END_FOR

		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	gst_datensatz.st_bestueckprogramm.s_band = gst_datensatz.st_md.s_aktuelles_band  THEN
			fb_state_entry.i16_next_step := 590;
		ELSE
			sm_fehler_falsches_Band:=TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
(*Halbautomatisch mit Gruppen*)
	540:	(* prüfen ob Werkzeuggruppen gleiche Bänder haben *)
		IF 	fb_state_entry.E THEN

			k:=-1;
			FOR k := 0 TO 4 DO
				i:=-1;

				FOR i := 0 TO MaxNoOfWkz DO
					n:=-1;
					FOR n := 0 TO i16_anzahl_Wkz_Gruppen - 1 DO
						IF 	gst_bestueckbild_halbauto.s_wkzgruppe[k].s_wkznummer[i] = gst_datensatz.st_md.st_wkz_gruppe[n].s_wkz THEN
							gst_datensatz.st_md.st_wkz_gruppe[n].s_Band:=gst_bestueckbild_halbauto.Wkz[i].s_band;
							gst_datensatz.st_md.st_wkz_gruppe[n].i32_Anzahl:=gst_bestueckbild_halbauto.Wkz[i].i32_anzahl;
							gst_datensatz.st_md.st_wkz_gruppe[n].i32_Wkz_nr:=i;
						END_IF
					END_FOR

				END_FOR

			END_FOR

		END_IF


		i:=-1;
		b_Wkz_akt_vorhanden:=FALSE;
		FOR i := 0 TO i16_anzahl_Wkz_Gruppen - 1 DO
			IF	gst_datensatz.st_md.st_wkz_gruppe[i].s_Band <> '' AND
				gst_datensatz.st_md.st_wkz_gruppe[0].s_Band <> gst_datensatz.st_md.st_wkz_gruppe[i].s_Band THEN
				sm_Band_nicht_kompatibel:=TRUE;
			END_IF
			IF	gst_datensatz.st_md.s_aktuelles_wkz = gst_datensatz.st_md.st_wkz_gruppe[i].s_wkz THEN
				b_Wkz_akt_vorhanden:=TRUE;
			END_IF
		END_FOR
		sm_fehler_wkz_nicht_vorhanden:=NOT b_Wkz_akt_vorhanden;

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	sm_fehler_wkz_nicht_vorhanden OR
			sm_Band_nicht_kompatibel THEN
			fb_state_entry.i16_next_step := FEHLER;
		ELSE
			fb_state_entry.i16_next_step := 550;
		END_IF

(*=======================================================*)
	550: (*kopieren des zum WZ passenden Bestückbild*)
		IF 	fb_state_entry.E THEN
			i32_UsedTool:=gst_datensatz.st_md.st_wkz_gruppe[0].i32_Wkz_nr;
			gst_datensatz.st_bestueckprogramm:=gst_bestueckbild_halbauto.Wkz[i32_UsedTool];
			gst_datensatz.st_isk:=gst_bestueckbild_halbauto.Wkz[i32_UsedTool].st_isk;
			gst_datensatz.st_bestueckprogramm.i32_anzahl:=0;

			i:=-1;
			for_begin:=0;
			FOR i := 0 TO i16_anzahl_Wkz_Gruppen - 1 DO

				i32_UsedTool:=gst_datensatz.st_md.st_wkz_gruppe[i].i32_Wkz_nr;
				gst_datensatz.st_bestueckprogramm.i32_anzahl:=gst_datensatz.st_md.st_wkz_gruppe[i].i32_Anzahl + gst_datensatz.st_bestueckprogramm.i32_anzahl;

				for_end:=for_begin + gst_bestueckbild_halbauto.Wkz[i32_UsedTool].i32_anzahl - 1;

				FOR k := for_begin TO for_end DO  (*max 511*)
						gst_datensatz.st_bestueckprogramm.lr_y[k]:=		gst_bestueckbild_halbauto.Wkz[i32_UsedTool].lr_y[k - for_begin] + gst_bestueckbild_halbauto.Wkz[i32_UsedTool].lr_y_offset;
						gst_datensatz.st_bestueckprogramm.lr_z[k]:=		gst_bestueckbild_halbauto.Wkz[i32_UsedTool].lr_z[k - for_begin] + gst_bestueckbild_halbauto.Wkz[i32_UsedTool].lr_z_offset;
						gst_datensatz.st_bestueckprogramm.i16_b[k]:=	gst_bestueckbild_halbauto.Wkz[i32_UsedTool].i16_b[k - for_begin];
						gst_datensatz.st_bestueckprogramm.b_podest_verschieben[k]:=	gst_bestueckbild_halbauto.Wkz[i32_UsedTool].b_podest_verschieben[k - for_begin];
				END_FOR
				for_begin:=for_begin + gst_bestueckbild_halbauto.Wkz[i32_UsedTool].i32_anzahl ;

			END_FOR

		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	gst_datensatz.st_bestueckprogramm.s_band = gst_datensatz.st_md.s_aktuelles_band  THEN
			fb_state_entry.i16_next_step := 590;
		ELSE
			sm_fehler_falsches_Band:=TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
(*=======================================================*)
	590:	(* Hub_Faktor_ermitteln *)
		IF fb_state_entry.E THEN

			IF	gst_datensatz.st_wkz.i16_typ_bandeinzug=STANDARD_2FACH_V2 OR
				gst_datensatz.st_wkz.i16_typ_bandeinzug=BANDWECHSLER_V2 OR
				gst_datensatz.st_wkz.i16_typ_bandeinzug=SERVO THEN
				Hub_Faktor_ermitteln_halbauto();
			ELSE
				lr_FaktorHub:=1;
			END_IF

		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 999;

(*ISK Daten lesen===============================================*)
	600:
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_lesen_bestueckbild := FALSE;
			hm_alle_daten_laden:=FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 610;

(*=======================================================*)
	610:(* ISK Daten *)

		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_lesen_isk := TRUE;
			fb_bbgen_xml_file.s_path := s_isk_path;
			fb_bbgen_xml_file.s_isk := gst_datensatz.st_md.s_aktueller_isk;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_lesen  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 620;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_lesen_isk := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	620:
		IF fb_state_entry.E THEN
			gst_datensatz_copy.st_isk:= gst_datensatz.st_isk ;
			fb_bbgen_xml_file.start_lesen_isk := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 999;




(*===========================Speichern============================*)
	(* Alle aktuelle Daten von der Maschine und Werkzeug speichern *)
	800:	(* ISK daten *)
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_schreiben_isk := TRUE;
			fb_bbgen_xml_file.s_path := s_isk_path;
			fb_bbgen_xml_file.s_isk := gst_datensatz.st_md.s_aktueller_isk;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_schreiben AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 810;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_schreiben_isk := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	810:
		IF fb_state_entry.E THEN
			gst_datensatz_copy.st_isk:= gst_datensatz.st_isk ;
			fb_bbgen_xml_file.start_schreiben_isk := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	hm_alle_daten_speichern THEN
			fb_state_entry.i16_next_step := 820;
		ELSE
			fb_state_entry.i16_next_step := 999;
		END_IF

(*=======================================================*)
	820:	(* WKZ Daten *)
		IF (fb_state_entry.E) THEN
			fb_bbgen_xml_file.start_schreiben_wkz := TRUE;
			fb_bbgen_xml_file.s_path := s_wkz_path;
			fb_bbgen_xml_file.s_wkz := gst_datensatz.st_md.s_aktuelles_wkz;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_schreiben  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 830;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_schreiben_wkz := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	830:
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_schreiben_wkz := FALSE;
			gst_datensatz_copy.st_wkz:= gst_datensatz.st_wkz ;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	hm_alle_daten_speichern THEN
			fb_state_entry.i16_next_step := 840;
		ELSE
			fb_state_entry.i16_next_step := 999;
		END_IF

(*=======================================================*)
	840:	(* Band Daten *)
		IF (fb_state_entry.E) THEN
			fb_bbgen_xml_file.start_schreiben_band := TRUE;
			fb_bbgen_xml_file.s_path := s_band_path;
			fb_bbgen_xml_file.s_band := gst_datensatz.st_md.s_aktuelles_band;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_schreiben  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 850;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_schreiben_band := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	850:
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_schreiben_band := FALSE;
			gst_datensatz_copy.st_band:= gst_datensatz.st_band ;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	hm_alle_daten_speichern THEN
			fb_state_entry.i16_next_step := 860;
		ELSE
			fb_state_entry.i16_next_step := 999;
		END_IF

(*=======================================================*)
	860:	(* Wt Daten *)
		IF (fb_state_entry.E) THEN
			fb_bbgen_xml_file.start_schreiben_wt := TRUE;
			fb_bbgen_xml_file.s_path := s_wt_path;
			fb_bbgen_xml_file.s_wt := gst_datensatz.st_md.s_aktueller_wt;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_schreiben  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 870;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_schreiben_wt := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	870:
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_schreiben_wt := FALSE;
			gst_datensatz_copy.st_wt:= gst_datensatz.st_wt ;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	hm_alle_daten_speichern THEN
			fb_state_entry.i16_next_step := 880;
		ELSE
			fb_state_entry.i16_next_step := 999;
		END_IF

(*=======================================================*)
	880:	(* Maschinendaten *)
		IF (fb_state_entry.E) THEN
			fb_bbgen_xml_file.start_schreiben_md := TRUE;
			fb_bbgen_xml_file.s_path := s_md_path;
			fb_bbgen_xml_file.s_md := s_md_name;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_schreiben  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 882;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_schreiben_md := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

	882:
		IF fb_state_entry.E THEN
			gst_datensatz_copy.st_md:= gst_datensatz.st_md ;
			fb_bbgen_xml_file.start_schreiben_md := FALSE;
			fb_state_entry.i16_next_step := 884;
		END_IF

	884:	(* Maschinendaten Backup *)
		IF (fb_state_entry.E) THEN
			fb_bbgen_xml_file.start_schreiben_md_backup := TRUE;
			fb_bbgen_xml_file.s_path := s_md_path;
			fb_bbgen_xml_file.s_md_backup := s_md_backup_name;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_schreiben  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 886;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_schreiben_md := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

	886:
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_schreiben_md_backup := FALSE;
			fb_state_entry.i16_next_step := 999;
		END_IF

(*=======================================================*)
(* manuelle Bestückbilder in halbautomatische XML Dateien umwandeln
	->	PLC resetten (Strukturen leerern)
	->	Artikelnummer in MD eintragen ( Artikelnummer = XML Dateiname)
	->	Schritt 975 forcen
	->	manualle Bestückbilder nacheinader mit Visu vorne öffnen (mit der ersten beginnen)
		die Bestückbilder werden dann in die Struktur (Bestückbild halbauto) eingetragen
	->	Schritt 980 forcen = XML Datei wird erstellt ( D:\BBGen\BestueckbildHalbauto )
	->	in der XML Datei nicht vorhandene WZ löschen, Werkzeuge, Band, Beschreibung, Projekt eintragen
	->	neue XML Datei auf Server kopieren
*)
975:
	IF (fb_state_entry.E) THEN
		gst_manuelles_bestueckprogramm.i32_anzahl:=0;
		gst_manuelles_bestueckprogramm.s_band:='';
		gst_manuelles_bestueckprogramm.lr_y_offset:=0;
		gst_manuelles_bestueckprogramm.lr_z_offset:=0;

		k:=-1;
		FOR k := 0 TO 511 DO
			gst_manuelles_bestueckprogramm.lr_y[k]:=0;
			gst_manuelles_bestueckprogramm.lr_z[k]:=0;
			gst_manuelles_bestueckprogramm.i16_b[k]:=0;
		END_FOR
		gst_manuelles_bestueckprogramm_copy:=gst_manuelles_bestueckprogramm;
		wkz_Nr:=-1;
	END_IF

	fb_ton_wz(IN:= MEMCMP(ADR(gst_manuelles_bestueckprogramm_copy), ADR(gst_manuelles_bestueckprogramm), SIZEOF(gst_manuelles_bestueckprogramm_copy)) <> 0, PT:= t#600ms, Q=> , ET=> );

	IF	fb_ton_wz.Q  THEN
		wkz_Nr:=wkz_Nr+1;
		gst_bestueckbild_halbauto.Wkz[wkz_Nr]:=gst_manuelles_bestueckprogramm;
		gst_bestueckbild_halbauto.Wkz[wkz_Nr].st_isk:=gst_datensatz.st_isk;

		gst_manuelles_bestueckprogramm.i32_anzahl:=0;
		gst_manuelles_bestueckprogramm.s_band:='';
		gst_manuelles_bestueckprogramm.lr_y_offset:=0;
		gst_manuelles_bestueckprogramm.lr_z_offset:=0;

		k:=-1;
		FOR k := 0 TO 511 DO
			gst_manuelles_bestueckprogramm.lr_y[k]:=0;
			gst_manuelles_bestueckprogramm.lr_z[k]:=0;
			gst_manuelles_bestueckprogramm.i16_b[k]:=0;
		END_FOR

		gst_manuelles_bestueckprogramm_copy:=gst_manuelles_bestueckprogramm;
	END_IF

(*=======================================================*)
	980:	(* Bestückbild *)
		IF (fb_state_entry.E) THEN
			fb_bbgen_xml_file.start_schreiben_bestueckbild_halbauto := TRUE;
			fb_bbgen_xml_file.s_path := s_bestueckbild_halbauto_path;
			fb_bbgen_xml_file.s_bestueckbild := gst_datensatz.st_md.s_aktuelle_artikelnummer;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_bbgen_xml_file.fertig_schreiben  AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 990;
		ELSIF fb_bbgen_xml_file.bError THEN
			sm_fehler_schreiben_bestueckbild := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	990:
		IF fb_state_entry.E THEN
			fb_bbgen_xml_file.start_schreiben_bestueckbild_halbauto := FALSE;
			fb_state_entry.i16_next_step := 999;
		END_IF

(*=======================================================*)
	999:	(* Ende - Befehl wurde korrekt abgearbeitet *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig := TRUE;
			i16_auftrag := KEIN_BB_AUFTRAG;

			IF NOT b_lesen_komplett THEN
				gst_datensatz_copy := gst_datensatz;
			END_IF
			b_lesen_komplett:=TRUE;

			fb_state_entry.i16_next_step := 0;
		END_IF

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			fb_bbgen_xml_file.bQuit := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
			fb_bbgen_xml_file.bQuit := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(	i16_pos:= 2 );

(* ======================================Subkomponenten======================================== *)
fb_bbgen_xml_file(
	bQuit:= ,
	start_lesen_isk:= ,
	start_schreiben_isk:= ,
	start_lesen_wkz:= ,
	start_schreiben_wkz:= ,
	start_lesen_bestueckbild:= ,
	start_schreiben_bestueckbild:= ,
	start_lesen_md:= ,
	start_schreiben_md:= ,
	start_lesen_band:= ,
	start_schreiben_band:= ,
	s_path:= ,
	s_bestueckbild:= ,
	s_wkz:= ,
	s_isk:= ,
	s_md:= ,
	s_band:= ,
	fertig_lesen=> ,
	fertig_schreiben=> ,
	bError=> ,
	nErrId=> );

fb_bbgen_write_file(
	bStart:= ,
	bFertig=> ,
	bError=> );

fb_xml_srv_read(
	sNetId:= ,
	ePath:= PATH_GENERIC,
	nMode:= XMLSRV_SKIPMISSING,
	sSymName:= ,
	sFilePath:= ,
	sXPath:= ,
	bExecute:= ,
	tTimeout:= t#20s,
	bBusy=> ,
	bError=> ,
	nErrId=> );

IF st_config.b_config_fertig THEN
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_lesen_band;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_fehler_lesen_bestueckbild;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_fehler_lesen_isk;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_fehler_lesen_md;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_fehler_lesen_wkz;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := sm_fehler_schreiben_band;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := sm_fehler_schreiben_bestueckbild;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := sm_fehler_schreiben_isk;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := sm_fehler_schreiben_md;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := sm_fehler_schreiben_wkz;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := sm_fehler_generieren_bestueckbild;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := sm_fehler_schreiben_bestueckbild_auf_hdd;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := sm_fehler_wkz_nicht_vorhanden;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := sm_fehler_falsches_Band;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := sm_Wkz_nicht_kompatibel;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := sm_Band_nicht_kompatibel;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := sm_Wkz_Gruppe_nicht_zugeordnet;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := sm_fehler_lesen_wt;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := sm_fehler_schreiben_wt;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;

	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_kleinster_greifer_groesser_kleinste_pinanzahl_in_bb;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := bm_keine_vollbestueck_Artikelnummer;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM
ACTION	auto_speichern_laden:
IF 	(MEMCMP(ADR(gst_datensatz_copy.st_md), ADR(gst_datensatz.st_md), SIZEOF(gst_datensatz_copy.st_md)) = 0 ) AND
	(MEMCMP(ADR(gst_datensatz_copy.st_wkz), ADR(gst_datensatz.st_wkz), SIZEOF(gst_datensatz_copy.st_wkz)) = 0 ) AND
	(MEMCMP(ADR(gst_datensatz_copy.st_band), ADR(gst_datensatz.st_band), SIZEOF(gst_datensatz_copy.st_band)) = 0 ) AND
	(MEMCMP(ADR(gst_datensatz_copy.st_wt), ADR(gst_datensatz.st_wt), SIZEOF(gst_datensatz_copy.st_wt)) = 0 ) AND
	(MEMCMP(ADR(gst_datensatz_copy.st_isk), ADR(gst_datensatz.st_isk), SIZEOF(gst_datensatz_copy.st_isk)) = 0 )
THEN
	hm_md_speichern:=FALSE;
END_IF

(*Bei einer Änderung der Wkz, des WT's oder Band Anwahl xml einlesen  *)
IF	b_lesen_komplett AND
	i16_auftrag = KEIN_BB_AUFTRAG AND
	NOT hm_md_speichern AND
	gst_datensatz_copy.st_md.s_aktuelles_wkz<>gst_datensatz.st_md.s_aktuelles_wkz THEN
	i16_auftrag:=LESE_WKZ;
	hm_md_speichern:=TRUE;
END_IF

IF	b_lesen_komplett AND
	i16_auftrag = KEIN_BB_AUFTRAG AND
	NOT hm_md_speichern AND
	gst_datensatz_copy.st_md.s_aktuelles_band<>gst_datensatz.st_md.s_aktuelles_band THEN
	i16_auftrag:=LESE_BAND;
	hm_md_speichern:=TRUE;
END_IF

IF	b_lesen_komplett AND
	i16_auftrag = KEIN_BB_AUFTRAG AND
	NOT hm_md_speichern AND
	gst_datensatz_copy.st_md.s_aktueller_wt<>gst_datensatz.st_md.s_aktueller_wt THEN
	i16_auftrag:=LESE_WT;
	hm_md_speichern:=TRUE;
END_IF

(* Beim Umschalten auf Manuell ISK einlesen und Bestückbild zuweisen  *)
IF	b_lesen_komplett AND
	i16_auftrag = KEIN_BB_AUFTRAG AND
	NOT hm_md_speichern THEN
	fb_r_trig_taste_bestueckprg_manuell(CLK:= gst_datensatz.st_md.i16_typ_bestueckmodus=BESTUECKUNG_MANUAL, Q=> );

	IF	fb_r_trig_taste_bestueckprg_manuell.Q THEN
		gst_datensatz.st_md.s_aktueller_isk:='ISK_Daten';
		gst_datensatz.st_bestueckprogramm:=gst_manuelles_bestueckprogramm;
		i16_auftrag:=SCHREIBE_ISK;
		hm_md_speichern:=TRUE;
	END_IF
END_IF

(*=======================================================================================*)
(*Bei einer Änderung automatisch speichern===================================================*)

(*Ausnahmen*)
IF	b_lesen_komplett AND
	(MEMCMP(ADR(gst_datensatz_copy.st_isk), ADR(gst_datensatz.st_isk), SIZEOF(gst_datensatz_copy.st_isk)) <> 0 )  OR
	gst_datensatz_copy.st_md.i32_bestueckhubzaehler<>gst_datensatz.st_md.i32_bestueckhubzaehler OR
	(MEMCMP(ADR(gst_datensatz_copy.st_stueckzahlen), ADR(gst_datensatz.st_stueckzahlen), SIZEOF(gst_datensatz_copy.st_stueckzahlen)) <> 0 ) THEN
	gst_datensatz_copy.st_stueckzahlen:=gst_datensatz.st_stueckzahlen;
(*	gst_datensatz_copy.st_isk:=gst_datensatz.st_isk*);
END_IF

(*========================================================================================*)
(*ohne Timer wurde nicht immer gespeichert*)
fb_ton_end(
	IN:=  i16_auftrag = KEIN_BB_AUFTRAG AND b_lesen_komplett,
	PT:= t#100ms,
	Q=> ,
	ET=> );


(*Isk Daten speichern*)
IF	fb_ton_end.Q AND
	gst_datensatz.st_md.i16_typ_bestueckmodus=BESTUECKUNG_MANUAL AND
	(MEMCMP(ADR(gst_datensatz_copy.st_isk), ADR(gst_datensatz.st_isk), SIZEOF(gst_datensatz_copy.st_isk)) <> 0 ) THEN
	gst_datensatz_copy.st_isk:= gst_datensatz.st_isk ;
	i16_auftrag:=SCHREIBE_ISK;	(*ISK soll nur vom UML Designer verändert werden*)
END_IF

(*Nocken speichern und Rest ignorieren*)
IF	fb_ton_end.Q AND
	(MEMCMP(ADR(gst_datensatz_copy.st_wkz.nockenschaltwerk_bestueckachse), ADR(gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse), SIZEOF(gst_datensatz_copy.st_wkz.nockenschaltwerk_bestueckachse)) <> 0 ) THEN
	FOR j := 0 TO MAX_NOCKENGERUEST DO	(*nur die Nocken begin und end speichern*)
		IF	gst_datensatz_copy.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[j].r_cam_begin<>gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[j].r_cam_begin OR
			gst_datensatz_copy.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[j].r_cam_end<>gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[j].r_cam_end THEN
			i16_auftrag:=SCHREIBE_WKZ;
		END_IF
	END_FOR
	gst_datensatz_copy.st_wkz.nockenschaltwerk_bestueckachse:=gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse;
END_IF

(*Wkz Daten speichern*)
IF	fb_ton_end.Q AND
	gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET AND
	(MEMCMP(ADR(gst_datensatz_copy.st_wkz), ADR(gst_datensatz.st_wkz), SIZEOF(gst_datensatz_copy.st_wkz)) <> 0 ) THEN
	i16_auftrag:=SCHREIBE_WKZ;
END_IF

(*Band Daten speichern*)
IF	fb_ton_end.Q AND
	gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET AND
	(MEMCMP(ADR(gst_datensatz_copy.st_band), ADR(gst_datensatz.st_band), SIZEOF(gst_datensatz_copy.st_band)) <> 0 ) THEN
	i16_auftrag:=SCHREIBE_BAND;
END_IF

(*Wt Daten speichern*)
IF	fb_ton_end.Q AND
	gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET AND
	(MEMCMP(ADR(gst_datensatz_copy.st_wt), ADR(gst_datensatz.st_wt), SIZEOF(gst_datensatz_copy.st_wt)) <> 0 ) THEN
	i16_auftrag:=SCHREIBE_WT;
END_IF

(*Maschinen Daten speichern*)
IF	fb_ton_end.Q AND
	gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET AND
	(MEMCMP(ADR(gst_datensatz_copy.st_md), ADR(gst_datensatz.st_md), SIZEOF(gst_datensatz_copy.st_md)) <> 0 ) THEN
	i16_auftrag:=SCHREIBE_MD;
	hm_md_speichern:=FALSE;
END_IF
END_ACTION

ACTION	generiere_bestueckbild:
(* Step 1: erzeuge eine Liste mit allen unseren Pins *)
st_akt_bestueckprogramm.i32_anzahl := 0;

FOR i := 0 TO gst_bestueckbild.i32_anzahl_pins - 1 BY 1
DO
	IF (gst_bestueckbild.st_pins[i].typ = gst_datensatz.st_md.s_aktuelles_band) THEN
		st_akt_bestueckprogramm.lr_y[st_akt_bestueckprogramm.i32_anzahl] := gst_bestueckbild.st_pins[i].lr_y;
		st_akt_bestueckprogramm.lr_z[st_akt_bestueckprogramm.i32_anzahl] := gst_bestueckbild.st_pins[i].lr_z;
		st_akt_bestueckprogramm.i16_b[st_akt_bestueckprogramm.i32_anzahl] := 1;

		st_akt_bestueckprogramm.i32_anzahl  := st_akt_bestueckprogramm.i32_anzahl + 1;
	END_IF
END_FOR


(* Step 2: Sortieren: Bubblesort by Z *)
sort_akt();

(* Einragen in die globale Sruktur *)
gst_datensatz.st_bestueckprogramm := st_akt_bestueckprogramm;
gst_datensatz.st_md.s_aktueller_isk := gst_bestueckbild.s_isknummer;

END_ACTION

ACTION	Hub_Faktor_ermitteln:
 (*ermitteln der maximal zu bestückenden Pins eines Bestückbildes=========================*)

FOR n := 0 TO 14 DO
	s_HelpBand[n]:='';
	i32_Anzahl[n]:=0;
END_FOR
i32_maxAnzahl := 0;

FOR n := 0 TO 14 DO
	FOR m := 0 TO gst_bestueckbild.i32_anzahl_pins - 1 DO
		IF	gst_bestueckbild.st_pins[m].typ <> s_HelpBand[0] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[1] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[2] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[3] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[4] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[5] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[6] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[7] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[8] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[9] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[10] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[11] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[12] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[13] AND
			gst_bestueckbild.st_pins[m].typ <> s_HelpBand[14] THEN
			s_HelpBand[n]:=gst_bestueckbild.st_pins[m].typ;
		END_IF
	END_FOR
END_FOR

FOR n := 0 TO 14 DO
	FOR m := 0 TO gst_bestueckbild.i32_anzahl_pins - 1 DO
		IF gst_bestueckbild.st_pins[m].typ = s_HelpBand[n] AND s_HelpBand[n] <>'' THEN
			i32_Anzahl[n]:=i32_Anzahl[n]+1;
		END_IF
	END_FOR
	IF	i32_Anzahl[n]>i32_maxAnzahl THEN
		i32_maxAnzahl:=i32_Anzahl[n];
	END_IF
END_FOR

(* Faktor für die Hubzahl*)
lr_min_FaktorHub:=100/gst_datensatz.st_wkz.r_auto;

IF	i32_maxAnzahl > 0  THEN

	lr_FaktorHub:=(DINT_TO_LREAL(st_akt_bestueckprogramm.i32_anzahl) / DINT_TO_LREAL(i32_maxAnzahl)) * 1.2;
	IF	lr_FaktorHub > 1 THEN
		lr_FaktorHub:=1;
	END_IF
	IF	lr_FaktorHub < lr_min_FaktorHub THEN 	(*Bestückgeschwindigkeit nur um maximal 100Hub verringern*)
		lr_FaktorHub:=lr_min_FaktorHub;
	END_IF
ELSE
	lr_FaktorHub:=1;
END_IF


END_ACTION

ACTION	Hub_Faktor_ermitteln_halbauto:
 (*ermitteln der maximal zu bestückenden Pins eines Bestückbildes=========================*)
n:=-1;
i32_maxAnzahl := 0;
FOR n := 0 TO 14 DO
	i32_Anzahl[n]:=gst_bestueckbild_halbauto.Wkz[n].i32_anzahl;
	IF	i32_Anzahl[n]>i32_maxAnzahl THEN
		i32_maxAnzahl:=i32_Anzahl[n];
	END_IF
END_FOR

(* Faktor für die Hubzahl*)
lr_min_FaktorHub:=100/gst_datensatz.st_wkz.r_auto;

IF	i32_maxAnzahl > 0  THEN

	lr_FaktorHub:=(DINT_TO_LREAL(gst_datensatz.st_bestueckprogramm.i32_anzahl) / DINT_TO_LREAL(i32_maxAnzahl)) * 1.35;
	IF	lr_FaktorHub > 1 THEN
		lr_FaktorHub:=1;
	END_IF
	IF	lr_FaktorHub < lr_min_FaktorHub THEN 	(*Bestückgeschwindigkeit nur um maximal 100Hub verringern*)
		lr_FaktorHub:=lr_min_FaktorHub;
	END_IF
ELSE
	lr_FaktorHub:=1;
END_IF


END_ACTION

ACTION	path:
IF	s_Projekt_path <> '' THEN
	IF	FIND(s_md_path,':') = 0 THEN
		s_md_path 	:= CONCAT(s_Projekt_path,s_md_path);
	END_IF
	IF	FIND(s_tools_path,':') = 0 THEN
		s_tools_path 	:= CONCAT(s_Projekt_path,s_tools_path);
	END_IF
END_IF
END_ACTION

ACTION	sort_akt:
FOR i := st_akt_bestueckprogramm.i32_anzahl -1 TO 1  BY -1
DO
	FOR k := 0 TO i -1 BY 1
	DO
		CASE gst_bestueckbild.enu_richtung OF

			(* Y Spalte Minus nach Plus: Bei gleichem Y: Z minus nach Plus *)
			YMinus_nach_YPlus_ZMinus_nach_ZPlus:
				IF F_Vergleich_LReal(st_akt_bestueckprogramm.lr_y[k+1] , st_akt_bestueckprogramm.lr_y[k]) THEN
					b_sort_swap := st_akt_bestueckprogramm.lr_z[k+1] < st_akt_bestueckprogramm.lr_z[k];
				ELSE
					b_sort_swap := st_akt_bestueckprogramm.lr_y[k+1] < st_akt_bestueckprogramm.lr_y[k];
				END_IF

			(* Y Spalte Minus nach Plus: Bei gleichem Y: Z Plus nach Minus *)
			YMinus_nach_YPlus_ZPlus_nach_ZMinus:
				IF F_Vergleich_LReal(st_akt_bestueckprogramm.lr_y[k+1] , st_akt_bestueckprogramm.lr_y[k]) THEN
					b_sort_swap := st_akt_bestueckprogramm.lr_z[k+1] > st_akt_bestueckprogramm.lr_z[k];
				ELSE
					b_sort_swap := st_akt_bestueckprogramm.lr_y[k+1]< st_akt_bestueckprogramm.lr_y[k];
				END_IF

			(* Y Spalte Plus nach Minus: Bei gleichem Y: Z Minus nach Plus *)
			YPlus_nach_YMinus_ZMinus_nach_ZPlus:
				IF F_Vergleich_LReal(st_akt_bestueckprogramm.lr_y[k+1] , st_akt_bestueckprogramm.lr_y[k]) THEN
					b_sort_swap := st_akt_bestueckprogramm.lr_z[k+1] < st_akt_bestueckprogramm.lr_z[k];
				ELSE
					b_sort_swap := st_akt_bestueckprogramm.lr_y[k+1] > st_akt_bestueckprogramm.lr_y[k];
				END_IF

			(* Y Spalte Plus nach Minus: Bei gleichem Y: Z Plus nach Minus *)
			YPlus_nach_YMinus_ZPlus_nach_ZMinus:
				IF F_Vergleich_LReal(st_akt_bestueckprogramm.lr_y[k+1] , st_akt_bestueckprogramm.lr_y[k]) THEN
					b_sort_swap := st_akt_bestueckprogramm.lr_z[k+1] > st_akt_bestueckprogramm.lr_z[k];
				ELSE
					b_sort_swap := st_akt_bestueckprogramm.lr_y[k+1] > st_akt_bestueckprogramm.lr_y[k];
				END_IF
		END_CASE

		IF b_sort_swap THEN
			(* Tauschen k + 1 <--> k *)
			swap_a := k; swap_b := k+1;	swap_in_akt();
		END_IF

	END_FOR
END_FOR
END_ACTION

ACTION	subr_Wkz_Band_Wt_schreiben:





(* ======================================Schrittkette======================================== *)
fb_state_entry2(	i16_pos:= 1 );

CASE fb_state_entry2.i16_step OF
(*=======================================================*)
	0:

		fb_wkz_band_wt_schreiben.Start := FALSE;

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry2.i16_next_step := BEREIT;

(*=======================================================*)
	BEREIT:	(* Warte auf Änderung *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gst_datensatz.st_md.s_aktuelles_wkz <> s_name_alt_wkz OR
		    gst_datensatz.st_md.s_aktuelles_band <> s_name_alt_band OR
		    gst_datensatz.st_md.s_aktueller_wt <> s_name_alt_wt THEN
			s_name_alt_wkz := gst_datensatz.st_md.s_aktuelles_wkz;
			s_name_alt_band :=gst_datensatz.st_md.s_aktuelles_band;
			s_name_alt_wt := gst_datensatz.st_md.s_aktueller_wt;
			fb_state_entry2.i16_next_step := 200;
		END_IF

(*=======================================================*)
	200: (* Aktuelles WKZ in txt Datei schreiben *)
		IF fb_state_entry2.E THEN
			fb_wkz_band_wt_schreiben.ExportStr := gst_datensatz.st_md.s_aktuelles_wkz;
			fb_wkz_band_wt_schreiben.FileName := 'Aktuelles_Wkz.txt';
			fb_wkz_band_wt_schreiben.Start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_wkz_band_wt_schreiben.Busy THEN
			fb_wkz_band_wt_schreiben.Start := FALSE;
			fb_state_entry2.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210: (* warte auf fertig *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_wkz_band_wt_schreiben.Done THEN
			fb_state_entry2.i16_next_step := 300;
		END_IF

(*=======================================================*)
	300: (* Aktuelles WKZ in txt Datei schreiben *)
		IF fb_state_entry2.E THEN
			fb_wkz_band_wt_schreiben.ExportStr := gst_datensatz.st_md.s_aktuelles_band;
			fb_wkz_band_wt_schreiben.FileName := 'Aktuelles_Band.txt';
			fb_wkz_band_wt_schreiben.Start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_wkz_band_wt_schreiben.Busy THEN
			fb_wkz_band_wt_schreiben.Start := FALSE;
			fb_state_entry2.i16_next_step := 310;
		END_IF

(*=======================================================*)
	310: (* warte auf fertig *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_wkz_band_wt_schreiben.Done THEN
			fb_state_entry2.i16_next_step := 400;
		END_IF

(*=======================================================*)
	400: (* Aktuellen Wt in txt Datei schreiben *)
		IF fb_state_entry2.E THEN
			fb_wkz_band_wt_schreiben.ExportStr := gst_datensatz.st_md.s_aktueller_wt;
			fb_wkz_band_wt_schreiben.FileName := 'Aktueller_Wt.txt';
			fb_wkz_band_wt_schreiben.Start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_wkz_band_wt_schreiben.Busy THEN
			fb_wkz_band_wt_schreiben.Start := FALSE;
			fb_state_entry2.i16_next_step := 410;
		END_IF

(*=======================================================*)
	410: (* warte auf fertig *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_wkz_band_wt_schreiben.Done THEN
			fb_state_entry2.i16_next_step := BEREIT;
		END_IF

END_CASE

fb_state_entry2(i16_pos:= 2 );

fb_wkz_band_wt_schreiben(
	Start:= ,
	ExportStr:= ,
	FileName:= ,
	Path:= 'D:\BBgen\',
	Mode:= 2,
	Ready=> , 
	Busy=> , 
	Done=> ,
	Error=> );
END_ACTION

ACTION	swap_in_akt:
lr_tmp := st_akt_bestueckprogramm.lr_y[swap_a];
st_akt_bestueckprogramm.lr_y[swap_a] := st_akt_bestueckprogramm.lr_y[swap_b];
st_akt_bestueckprogramm.lr_y[swap_b] := lr_tmp;

lr_tmp := st_akt_bestueckprogramm.lr_z[swap_a];
st_akt_bestueckprogramm.lr_z[swap_a] := st_akt_bestueckprogramm.lr_z[swap_b];
st_akt_bestueckprogramm.lr_z[swap_b] := lr_tmp;

i16_tmp := st_akt_bestueckprogramm.i16_b[swap_a];
st_akt_bestueckprogramm.i16_b[swap_a] := st_akt_bestueckprogramm.i16_b[swap_b];
st_akt_bestueckprogramm.i16_b[swap_b] := i16_tmp;
END_ACTION

ACTION	wkz_gruppe_kompatibel:

(*Gruppe löschen wenn ein neues Werkzeug ausgewählt wird*)
IF	gst_datensatz_copy.st_md.s_aktuelles_wkz<>gst_datensatz.st_md.s_aktuelles_wkz THEN
	i:=-1;
	FOR i := 0 TO 4 DO
		gst_datensatz.st_md.st_wkz_gruppe[i].s_wkz := '';
		gst_datensatz.st_md.st_wkz_gruppe[i].i16_wkz_gruppe_kompatibel := 0;
		gst_datensatz.st_md.st_wkz_gruppe[i].s_Band := '';
		gst_datensatz.st_md.st_wkz_gruppe[i].i32_Wkz_nr := -1;
		gst_datensatz.st_md.st_wkz_gruppe[i].i32_Anzahl := -1;
	END_FOR
END_IF

(*Fehler*)
IF	state =0 THEN
	k:=-1;
	sm_Wkz_Gruppe_nicht_zugeordnet:=FALSE;
	sm_Wkz_nicht_kompatibel:=FALSE;
	FOR k := 0 TO 4 DO
		i:=-1;
		FOR i := 0 TO 4 DO
			IF	gst_datensatz.st_md.st_wkz_gruppe[k].s_wkz <> '' AND
				gst_datensatz.st_md.st_wkz_gruppe[i].s_wkz <> '' AND
				gst_datensatz.st_md.st_wkz_gruppe[k].i16_wkz_gruppe_kompatibel <>gst_datensatz.st_md.st_wkz_gruppe[i].i16_wkz_gruppe_kompatibel THEN
				sm_Wkz_nicht_kompatibel:=TRUE;
			END_IF
		END_FOR

		IF	gst_datensatz.st_md.st_wkz_gruppe[k].s_wkz <> '' AND
			gst_datensatz.st_md.st_wkz_gruppe[k].i16_wkz_gruppe_kompatibel = 0 THEN
			sm_Wkz_Gruppe_nicht_zugeordnet:=TRUE;
		END_IF

	END_FOR
END_IF

(*==========================================================================================*)
b_Wkz_Gruppe_gebildet:=
	NOT sm_Wkz_nicht_kompatibel AND
	gst_datensatz.st_md.st_wkz_gruppe[0].s_wkz <> '' AND
	gst_datensatz.st_md.st_wkz_gruppe[1].s_wkz <> '';

i16_anzahl_Wkz_Gruppen:=0;
k:=-1;
FOR k := 0 TO 4 DO
	IF	gst_datensatz.st_md.st_wkz_gruppe[k].s_wkz <> ''	THEN
		i16_anzahl_Wkz_Gruppen:=i16_anzahl_Wkz_Gruppen + 1;
	END_IF
END_FOR

(*==========================================================================================*)
CASE state OF
0:	(* Auslesen wenn ein neues Wkz ausgewählt wird*)
	fb_xml_srv_read.bExecute:= FALSE;
	k:=-1;
	FOR k := 0 TO 4 DO
		IF	state =0 AND
			st_wkz_gruppe_copy[k].s_wkz<>gst_datensatz.st_md.st_wkz_gruppe[k].s_wkz THEN

			IF	gst_datensatz.st_md.st_wkz_gruppe[k].s_wkz='' THEN
				st_wkz_gruppe_copy[k].s_wkz:=gst_datensatz.st_md.st_wkz_gruppe[k].s_wkz;
			ELSE
				i32_neues_Wkz:=k;
				state:=10;
			END_IF

			gst_datensatz.st_md.st_wkz_gruppe[k].i16_wkz_gruppe_kompatibel:=0;
			st_wkz_gruppe_copy[k].i16_wkz_gruppe_kompatibel:=0;
			gst_datensatz.st_md.st_wkz_gruppe[k].s_Band := '';
			gst_datensatz.st_md.st_wkz_gruppe[k].i32_Wkz_nr := -1;
			gst_datensatz.st_md.st_wkz_gruppe[k].i32_Anzahl := -1;

		END_IF
	END_FOR

10:	(*Start auslesen*)
	nErrId := 0;
	fb_xml_srv_read.sFilePath:= 'D:\BBgen\Wkz\';
	fb_xml_srv_read.sFilePath:= CONCAT(fb_xml_srv_read.sFilePath,gst_datensatz.st_md.st_wkz_gruppe[i32_neues_Wkz].s_wkz);
	fb_xml_srv_read.sFilePath:= CONCAT(fb_xml_srv_read.sFilePath,'.xml');
	fb_xml_srv_read.sXPath := '/root/gst_datensatz.st_wkz/I16_WKZ_GRUPPE_KOMPATIBEL';
	fb_xml_srv_read.sSymName:= '.gst_datensatz.st_md.st_wkz_gruppe[';
	fb_xml_srv_read.sSymName:= CONCAT(fb_xml_srv_read.sSymName,DINT_TO_STRING(i32_neues_Wkz));
	fb_xml_srv_read.sSymName:= CONCAT(fb_xml_srv_read.sSymName,'].i16_wkz_gruppe_kompatibel');
	fb_xml_srv_read.bExecute:= TRUE;

	IF fb_xml_srv_read.bBusy THEN
		fb_xml_srv_read.bExecute:= FALSE;
		state := 20;
	END_IF

20:	(* Lesevorgang erfolgreich? *)
	IF NOT fb_xml_srv_read.bBusy THEN
		IF NOT fb_xml_srv_read.bError THEN
			state := 0;
			st_wkz_gruppe_copy[i32_neues_Wkz].s_wkz:=gst_datensatz.st_md.st_wkz_gruppe[i32_neues_Wkz].s_wkz;
			st_wkz_gruppe_copy[i32_neues_Wkz].i16_wkz_gruppe_kompatibel:=gst_datensatz.st_md.st_wkz_gruppe[i32_neues_Wkz].i16_wkz_gruppe_kompatibel;
		ELSE	(* Fehler *)
			nErrId := fb_xml_srv_read.nErrId;
			state := FEHLER;
		END_IF
	END_IF

FEHLER:
	state := 0;
	st_wkz_gruppe_copy[i32_neues_Wkz].s_wkz:=gst_datensatz.st_md.st_wkz_gruppe[i32_neues_Wkz].s_wkz;
END_CASE







END_ACTION












(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_BBGenWriteFile
VAR_INPUT
	bStart		: BOOL;
END_VAR
VAR_OUTPUT
	bFertig	: BOOL;
	bError	: BOOL;
END_VAR
VAR
	fb_state_entry						: ST_StateEntry;
	fb_r_trig_start						: R_TRIG;
	fb_ton_quitt						: TON;
	fb_openfile						: FILEOPEN;
	fb_writefile						: FILEWRITE;
	fb_closefile						: FILECLOSE;

	s_file							: STRING(255);

	nErrId							: DINT;

	tmp								: DINT;
	lo								: DINT;
	ll								: DINT;
	s_line							: STRING(255);
	s_out							: STRING(10000);
	y								: STRING;
	z								: STRING;
	b								: STRING;
	tab								: STRING;
	lineend							: STRING;
END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_quitt(IN:= , PT:= t#50ms, Q=> , ET=> );
fb_r_trig_start(CLK:= bStart, Q=> );
(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );


CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:
		nErrId := 0;

		bFertig := FALSE;
		bError := FALSE;

		s_file := 'D:\BBGen\bbgen.txt';
		fb_state_entry.i16_next_step := 10;
(*=======================================================*)
	10:
		IF fb_r_trig_start.Q THEN
			fb_state_entry.i16_next_step := 100;
		END_IF
(*=======================================================*)
	100:
		(* Öffne Datei *)
		IF fb_state_entry.E THEN
			fb_openfile.OPEN := TRUE;
		END_IF

		IF fb_openfile.ERR THEN
			fb_state_entry.i16_next_step := FEHLER;
			nErrId := fb_openfile.ERRID;
		END_IF

		IF NOT fb_state_entry.E AND NOT fb_openfile.BUSY AND NOT fb_openfile.ERR THEN
			fb_state_entry.i16_next_step := 110;
		END_IF

		IF fb_state_entry.X THEN
			fb_openfile.OPEN := FALSE;
		END_IF
(*=======================================================*)
	110:
		(* Datei ist offen. Schreibe Einträge*)
		IF fb_state_entry.E THEN
			(* Baue Ausgabestring *)
			s_out := '';
			tab := '$T';
			lineend := '$R$N';
			lo := 0;
			ll := 0;
			(* Erste Zeile: Offset und Breite/Höhe*)
			y := LREAL_TO_FMTSTR(gst_datensatz.st_isk.lr_pos_y_0,2,TRUE);	s_line := CONCAT(y,tab);
			z := LREAL_TO_FMTSTR(gst_datensatz.st_isk.lr_pos_z_0,2,TRUE);	s_line := CONCAT(s_line,z);	s_line := CONCAT(s_line,tab);

			y := LREAL_TO_FMTSTR(gst_datensatz.st_isk.lr_breite,2,TRUE);		s_line := CONCAT(s_line,y);	s_line := CONCAT(s_line,tab);
			z := LREAL_TO_FMTSTR(gst_datensatz.st_isk.lr_hoehe,2,TRUE);		s_line := CONCAT(s_line,z);	s_line := CONCAT(s_line,lineend);
			s_out := s_line; lo := LEN(s_out);

			FOR tmp := 0 TO gst_datensatz.st_bestueckprogramm.i32_anzahl-1 BY 1
			DO
				y := LREAL_TO_FMTSTR (gst_datensatz.st_bestueckprogramm.lr_y[tmp],2,TRUE);
				z := LREAL_TO_FMTSTR(gst_datensatz.st_bestueckprogramm.lr_z[tmp],2,TRUE);
				b := INT_TO_STRING(gst_datensatz.st_bestueckprogramm.i16_b[tmp]);
				s_line := y;						ll := LEN(y);
				s_line := CONCAT(s_line, tab);		ll := ll + LEN(tab);
				s_line := CONCAT(s_line, z);			ll := ll + LEN(z);
				s_line := CONCAT(s_line, tab);		ll := ll + LEN(tab);
				s_line := CONCAT(s_line, b);			ll := ll + LEN(b);
				s_line := CONCAT(s_line, lineend);	ll := ll + LEN(lineend);

				(* Da concat und co nur Strings bis 255 Zeichen kann, müssen wir hier memcpy nutzen *)
				MEMCPY(ADR(s_out)+lo,ADR(s_line), ll);
				lo := lo + ll;
			END_FOR
			fb_writefile.BUFADDR := ADR(s_out);
			fb_writefile.COUNT := lo;
			fb_writefile.WRITE := TRUE;
		END_IF

		IF NOT fb_state_entry.E AND fb_writefile.ERR  THEN
			fb_state_entry.i16_next_step := FEHLER;
			nErrId := fb_writefile.ERRID;
		END_IF

		IF NOT fb_state_entry.E AND NOT fb_writefile.BUSY AND NOT fb_writefile.ERR THEN
			(* Erfolgreich geschrieben *)
			fb_state_entry.i16_next_step := 200;
		END_IF

		IF fb_state_entry.X THEN
			fb_writefile.WRITE := FALSE;
		END_IF

(*=======================================================*)
	200:
		(* Schliesse Datei *)
		IF fb_state_entry.E THEN
			fb_closefile.CLOSE := TRUE;
		END_IF

		IF fb_closefile.ERR THEN
			fb_state_entry.i16_next_step := FEHLER;
			nErrId := fb_closefile.ERRID;
		END_IF

		IF NOT fb_state_entry.E AND NOT fb_closefile.BUSY AND NOT fb_closefile.ERR THEN
			fb_state_entry.i16_next_step := 210;
		END_IF

		IF fb_state_entry.X THEN
			fb_closefile.CLOSE := FALSE;
		END_IF

(*=======================================================*)
	210:
		IF fb_state_entry.E THEN
			bFertig := TRUE;
		END_IF

		IF NOT bStart AND NOT fb_state_entry.E THEN
			fb_state_entry.i16_next_step := 10;
		END_IF

		IF fb_state_entry.X THEN
			bFertig := FALSE;
		END_IF

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			bError := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_state_entry.E THEN
			bError := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> ,
	i16_step=> ,
	i16_last_step=> );

(* FILE *)
fb_openfile(
	NETID:= ,
	FPATHNAME:= s_file,
	OPENMODE:= FILE_OPENWRITE, (* Wir wollen eine bestehenede Datei im Falle überschreiben *)
	OPEN:= ,
	TMOUT:= t#2s,
	BUSY=> , 
	ERR=> , 
	ERRID=> , 
	HFILE=> );

fb_writefile(
	NETID:= ,
	HFILE:= fb_openfile.HFILE,
	BUFADDR:= , 
	COUNT:= ,
	WRITE:= ,
	TMOUT:= t#2s,
	BUSY=> ,
	ERR=> ,
	ERRID=> ,
	COUNT_W=> );

fb_closefile(
	NETID:= , 
	HFILE:= fb_openfile.HFILE,
	CLOSE:= , 
	TMOUT:= t#2s,
	BUSY=> ,
	ERR=> , 
	ERRID=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_BBGenXMLFile
VAR_INPUT
	bQuit								: BOOL;
	(* ISK *)
	start_lesen_isk						: BOOL;
	start_schreiben_isk					: BOOL;

	(* Wkz *)
	start_lesen_wkz						: BOOL;
	start_schreiben_wkz					: BOOL;

	(* Bestueckbild wird nur gelesen *)
	start_lesen_bestueckbild				: BOOL;
	start_schreiben_bestueckbild			: BOOL;

	(* Bestueckbild Halbautomatik wird nur gelesen *)
	start_lesen_bestueckbild_halbauto				: BOOL;
	start_schreiben_bestueckbild_halbauto			: BOOL;

	(* Maschinendaten *)
	start_lesen_md						: BOOL;
	start_schreiben_md					: BOOL;
	start_schreiben_md_backup			: BOOL;

	(* Banddaten *)
	start_lesen_band						: BOOL;
	start_schreiben_band					: BOOL;

	(* Wt-Daten *)
	start_lesen_wt						: BOOL;
	start_schreiben_wt						: BOOL;

	(* Wo liegen die Dateien *)
	s_path								: STRING(255);

	(* Welche Dateien? *)
	s_bestueckbild						: STRING(50);
	s_wkz								: STRING(50);
	s_isk								: STRING(50);
	s_md								: STRING(50);
	s_md_backup						: STRING(50);
	s_band								: STRING(50);
	s_wt									: STRING(50);
END_VAR
VAR_OUTPUT
	fertig_lesen							: BOOL;
	fertig_schreiben						: BOOL;

	bError								: BOOL;
	nErrId								: UDINT;
END_VAR
VAR
	fb_state_entry							: ST_StateEntry;
	fb_ton_quitt							: TON;
	fb_xml_srv_write						: FB_XmlSrvWriteByName;
	fb_xml_srv_read						: FB_XmlSrvReadByName;
	s_file								: STRING(255);

END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_quitt(IN:= , PT:= t#50ms, Q=> , ET=> );

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );


CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:
		bError := FALSE;
		nErrId := 0;

		fertig_lesen := FALSE;
		fertig_schreiben := FALSE;

		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Auslesen der Daten aus den XML-Files *)
		(* Daten lesen *)
		IF start_lesen_isk THEN
			s_file := CONCAT(s_path, s_isk);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_read.sSymName := '.gst_datensatz.st_isk';
			fb_xml_srv_read.sXPath := '/root/gst_datensatz.st_isk';
			fb_state_entry.i16_next_step := 100;
		ELSIF start_lesen_bestueckbild THEN
			s_file := CONCAT(s_path, s_bestueckbild);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_read.sSymName := '.gst_bestueckbild';
			fb_xml_srv_read.sXPath := '/root/gst_bestueckbild';
			fb_state_entry.i16_next_step := 100;

		ELSIF start_lesen_bestueckbild_halbauto THEN
			s_file := CONCAT(s_path, s_bestueckbild);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_read.sSymName := '.gst_bestueckbild_halbauto';
			fb_xml_srv_read.sXPath := '/root/gst_bestueckbild_halbauto';
			fb_state_entry.i16_next_step := 100;

		ELSIF start_lesen_wkz THEN
			s_file := CONCAT(s_path, s_wkz);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_read.sSymName := '.gst_datensatz.st_wkz';
			fb_xml_srv_read.sXPath := '/root/gst_datensatz.st_wkz';
			fb_state_entry.i16_next_step := 100;
		ELSIF start_lesen_md THEN
			s_file := CONCAT(s_path, s_md);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_read.sSymName := '.gst_datensatz.st_md';
			fb_xml_srv_read.sXPath := '/root/gst_datensatz.st_md';
			fb_state_entry.i16_next_step := 100;
		ELSIF start_lesen_band THEN
			s_file := CONCAT(s_path, s_band);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_read.sSymName := '.gst_datensatz.st_band';
			fb_xml_srv_read.sXPath := '/root/gst_datensatz.st_band';
			fb_state_entry.i16_next_step := 100;
		ELSIF start_lesen_wt THEN
			s_file := CONCAT(s_path, s_wt);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_read.sSymName := '.gst_datensatz.st_wt';
			fb_xml_srv_read.sXPath := '/root/gst_datensatz.st_wt';
			fb_state_entry.i16_next_step := 100;
		END_IF

		(* Daten schreiben *)
		IF start_schreiben_isk THEN
			s_file := CONCAT(s_path, s_isk);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_write.sSymName := '.gst_datensatz.st_isk';
			fb_xml_srv_write.sXPath := '/root/gst_datensatz.st_isk';
			fb_state_entry.i16_next_step := 200;
		ELSIF start_schreiben_bestueckbild THEN
			s_file := CONCAT(s_path, s_bestueckbild);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_write.sSymName := '.gst_bestueckbild';
			fb_xml_srv_write.sXPath := '/root/gst_bestueckbild';
			fb_state_entry.i16_next_step := 200;
		ELSIF start_schreiben_bestueckbild_halbauto THEN
			s_file := CONCAT(s_path, s_bestueckbild);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_write.sSymName := '.gst_bestueckbild_halbauto';
			fb_xml_srv_write.sXPath := '/root/gst_bestueckbild_halbauto';
			fb_state_entry.i16_next_step := 200;
		ELSIF start_schreiben_wkz THEN
			s_file := CONCAT(s_path, s_wkz);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_write.sSymName := '.gst_datensatz.st_wkz';
			fb_xml_srv_write.sXPath := '/root/gst_datensatz.st_wkz';
			fb_state_entry.i16_next_step := 200;
		ELSIF start_schreiben_md_backup THEN
			s_file := CONCAT(s_path, s_md_backup);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_write.sSymName := '.gst_datensatz.st_md';
			fb_xml_srv_write.sXPath := '/root/gst_datensatz.st_md';
			fb_state_entry.i16_next_step := 200;
		ELSIF start_schreiben_md THEN
			s_file := CONCAT(s_path, s_md);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_write.sSymName := '.gst_datensatz.st_md';
			fb_xml_srv_write.sXPath := '/root/gst_datensatz.st_md';
			fb_state_entry.i16_next_step := 200;
		ELSIF start_schreiben_band THEN
			s_file := CONCAT(s_path, s_band);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_write.sSymName := '.gst_datensatz.st_band';
			fb_xml_srv_write.sXPath := '/root/gst_datensatz.st_band';
			fb_state_entry.i16_next_step := 200;
		ELSIF start_schreiben_wt THEN
			s_file := CONCAT(s_path, s_wt);
			s_file := CONCAT(s_file,'.xml');
			fb_xml_srv_write.sSymName := '.gst_datensatz.st_wt';
			fb_xml_srv_write.sXPath := '/root/gst_datensatz.st_wt';
			fb_state_entry.i16_next_step := 200;
		END_IF

(*=======================================================*)
	100:	(* Starte Daten lesen *)
		IF fb_state_entry.E THEN
			fb_xml_srv_read.bExecute := TRUE;
			fb_xml_srv_read.sFilePath := s_file;
		END_IF

		IF fb_xml_srv_read.bBusy THEN
			fb_xml_srv_read.bExecute := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110:	(* Lesevorgang *)
		IF NOT fb_xml_srv_read.bBusy  THEN
			IF NOT fb_xml_srv_read.bError THEN
				fb_state_entry.i16_next_step := 120;
			ELSE	(* Fehler *)
				nErrId := fb_xml_srv_read.nErrId;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	120:	(* Lesevorgang beendet *)
		IF fb_state_entry.E THEN
			fertig_lesen := TRUE;
		END_IF

		IF 	NOT start_lesen_band AND
			NOT start_lesen_bestueckbild AND
			NOT start_lesen_isk AND
			NOT start_lesen_md AND
			NOT start_lesen_wkz AND
			NOT start_lesen_wt AND
			NOT fb_state_entry.E
			THEN
				fb_state_entry.i16_next_step := 0;
		END_IF

		IF fb_state_entry.X THEN
			fertig_lesen := TRUE;
		END_IF

(*=======================================================*)
	200:	(* Starte Daten schreiben *)
		IF fb_state_entry.E THEN
			fb_xml_srv_write.bExecute := TRUE;
			fb_xml_srv_write.sFilePath := s_file;
		END_IF

		IF fb_xml_srv_write.bBusy THEN
			fb_xml_srv_write.bExecute := FALSE;
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* Schreibvorgang *)
		IF NOT fb_xml_srv_write.bBusy  THEN
			IF NOT fb_xml_srv_write.bError THEN
				fb_state_entry.i16_next_step := 220;
			ELSE	(* Fehler *)
				nErrId := fb_xml_srv_write.nErrId;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	220:	(* Schreibvorgang beendet *)
		IF fb_state_entry.E THEN
			fertig_schreiben := TRUE;
		END_IF

		IF 	NOT start_schreiben_band AND
			NOT start_schreiben_bestueckbild AND
			NOT start_schreiben_isk AND
			NOT start_schreiben_md AND
			NOT start_schreiben_md_backup AND
			NOT start_schreiben_wkz AND
			NOT start_schreiben_wt AND
			NOT fb_state_entry.E
			THEN
				fb_state_entry.i16_next_step := 0;
		END_IF

		IF fb_state_entry.X THEN
			fertig_schreiben := TRUE;
		END_IF

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			bError := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bQuit AND NOT fb_state_entry.E THEN
			bError := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE


fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

(* XML *)
fb_xml_srv_read(
	sNetId:= '',
	ePath:= PATH_GENERIC,
	nMode:= XMLSRV_SKIPMISSING,
	sSymName:= ,
	sFilePath:= ,
	sXPath:= ,
	bExecute:= ,
	tTimeout:= t#10s,
	bBusy=> ,
	bError=> ,
	nErrId=> );

fb_xml_srv_write(
	sNetId:= '',
	ePath:= PATH_GENERIC,
	nMode:= XMLSRV_ADDMISSING,
	sSymName:=  ,
	sFilePath:= ,
	sXPath:= ,
	bExecute:= ,
	tTimeout:= t#10s,
	bBusy=> ,
	bError=> ,
	nErrId=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Bedienen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Euchner_Handbedienpult
VAR
	(* Eingänge von der Hardware *)
	e_Taste_Zustimm			AT %I* : BOOL;
	e_Taste_Plus				AT %I* : BOOL;
	e_Taste_Power			AT %I* : BOOL;
	e_Taste_Minus			AT %I* : BOOL;

	e_i16_Zaehler			AT %I* : INT;

	(* Instanzen *)
	fb_ton					: TON;

	(* Merker *)
	i16_merkpos				: INT := 0;
END_VAR
VAR_OUTPUT
	b_Taste_Zustimm			: BOOL := FALSE;
	b_Taste_Plus				: BOOL := FALSE;
	b_Taste_Power			: BOOL := FALSE;
	b_Taste_Minus			: BOOL := FALSE;

	i16_Handrad_delta		: INT := 0;
END_VAR
(* @END_DECLARATION := '0' *)
(* Tasten *)
b_Taste_Zustimm	:= e_Taste_Zustimm;
b_Taste_Plus	:= e_Taste_Plus;
b_Taste_Power := e_Taste_Power;
b_Taste_Minus := e_Taste_Minus;

(* Generiere Impuls für Delta Zähler *)
fb_ton(IN:= NOT fb_ton.Q , PT:= t#100ms, Q=> , ET=> );

IF fb_ton.Q THEN
	i16_Handrad_delta := e_i16_Zaehler - i16_merkpos;
	i16_merkpos := e_i16_Zaehler;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Bedienen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_TippTasten
VAR_INPUT
	(* Geschwindigkeit / Stufe *)
	i16_akt_stufe						: INT := 0;	(* 0-9 *)
	b_initialisierungsphase				: BOOL := FALSE;
	b_einfaedeln_aktiv				: BOOL := FALSE;
END_VAR
VAR_IN_OUT
	st_visu							: struct_visu;
	st_visu_hinten						: struct_visu_hinten;
END_VAR
VAR
	lr_override						: LREAL := 25;
	lr_override_gestuft					: LREAL := 10;
	r_trig_tippen						: R_TRIG;
	r_trig_tippen_einfaedeln			: R_TRIG;
	r_trig_vorgabe					: R_TRIG;
	b_freigabe_override_auto			: BOOL := FALSE;
	fb_r_trig_quittieren					: R_TRIG;
END_VAR

VAR CONSTANT
	lr_override_init_einfaedel			: LREAL := 25;
END_VAR
(* @END_DECLARATION := '0' *)
(* Mit den zeitlichen Impulsen vom Handrad lässt sich der Override aller Achsen verändern. Die Geschwindigkeit wird im "ST_AxisJobCtrl_Motion" limitiert. *)
(* Tipp-Taste *)

r_trig_tippen(
		CLK:=NOT b_einfaedeln_aktiv AND (st_visu.b_tippen_start OR visu_hinten.out.b_start OR ST_Euchner_Handbedienpult.b_Taste_Power),
		Q=> );
r_trig_tippen_einfaedeln(
		CLK:= b_einfaedeln_aktiv AND (st_visu_hinten.out.b_tippen OR ST_Euchner_Handbedienpult.b_Taste_Power),
		Q=> );
r_trig_vorgabe(
		CLK:= st_visu.b_geschwindigkeit_vorgabe, Q=> );

(* Flanken *)
fb_r_trig_quittieren(CLK:= st_visu.b_quittieren OR st_visu_hinten.out.b_quittieren, Q=> );

CASE gi16_betriebsart OF
	AUTO:
		gb_ba_auto_kontroller := TRUE;

		IF r_trig_tippen.Q OR fb_r_trig_quittieren.Q THEN
			b_freigabe_override_auto := TRUE;
		END_IF

		IF b_einfaedeln_aktiv OR b_initialisierungsphase THEN
			lr_override := lr_override_gestuft := lr_override_init_einfaedel;
		ELSE

			IF r_trig_vorgabe.Q THEN
				i16_akt_stufe := 9;
			END_IF
			IF b_freigabe_override_auto THEN
				(* Override für Achsen mit "Vollgas" im Automatikbetrieb *)
				lr_override := 100;
				(* Override für Achsen, welche in Abstufung gefahren werden *)
				IF  i16_akt_stufe>= 0 AND i16_akt_stufe<= 9 THEN
					(* Overridevorgabe im Automatikbetrieb *)
					lr_override_gestuft := (i16_akt_stufe +1) * 10;
				ELSE
					(* Falls Geschwindigkeitsstufe was anderes als 0-9 enthält: Override auf 0: Keine Achse fährt *)
					lr_override_gestuft := 0;
				END_IF
			ELSE
				lr_override := lr_override_gestuft := 0;
			END_IF
		END_IF

	TIPPEN:
		b_freigabe_override_auto := FALSE;

		IF r_trig_tippen.Q OR lr_override > 0 OR  lr_override_gestuft > 0 THEN
			gb_ba_auto_kontroller := TRUE;
		ELSE
			gb_ba_auto_kontroller := FALSE;
		END_IF

		IF ST_Euchner_Handbedienpult.i16_Handrad_delta > 0 THEN
			lr_override := lr_override_gestuft := ABS(ST_Euchner_Handbedienpult.i16_Handrad_delta) * 0.1;
		ELSE
			lr_override := lr_override_gestuft := 0;
		END_IF

	HAND:
		gb_ba_auto_kontroller := FALSE;
		b_freigabe_override_auto := FALSE;
		lr_override := lr_override_gestuft := ABS(ST_Euchner_Handbedienpult.i16_Handrad_delta)* 0.1;
END_CASE

(* Abfrage maximaler Override grösser 100% *)
IF lr_override > 100 THEN
	lr_override := 100;
END_IF
IF lr_override_gestuft > 100 THEN
	lr_override_gestuft := 100;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Betriebsarten' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Betriebsarten
VAR_INPUT
	st_config					: struct_config;
END_VAR
VAR
	fb_ton_wz				: TON;
	fb_state_entry				: ST_StateEntry;
	i16_betriebsart 			: enum_betriebsarten := KEINE;
	e_ba_automatik			AT %I* : BOOL;
	e_ba_tippen				AT %I* : BOOL;
	e_ba_hand				AT %I* : BOOL;
	e_ba_dummy				AT %I* : BOOL;
	e_ba_pseudo			AT %I* : BOOL;
	a_lampe_ba_automatik	AT %Q* : BOOL;
	a_lampe_ba_tippen		AT %Q* : BOOL;
	a_lampe_ba_hand		AT %Q* : BOOL;
	a_lampe_ba_dummy		AT %Q* : BOOL;
	a_lampe_ba_pseudo		AT %Q* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
gi16_betriebsart := i16_betriebsart;

(* Zeiten *)
fb_ton_wz(IN:= , PT:= t#1s, Q=>  , ET=> );

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:	(* KEINE *)
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := TRUE;
		END_IF
		IF fb_ton_wz.Q THEN
			i16_betriebsart := KEINE;
		END_IF

		a_lampe_ba_automatik := FALSE;
		a_lampe_ba_tippen := FALSE;
		a_lampe_ba_hand := FALSE;
		a_lampe_ba_dummy := FALSE;
		a_lampe_ba_pseudo := FALSE;

		(* Betriebsartenwechsel *)
		IF e_ba_automatik THEN
			fb_state_entry.i16_next_step := 10;	(* AUTO *)
		ELSIF e_ba_tippen THEN
			fb_state_entry.i16_next_step := 20;	(* TIPPEN *)
		ELSIF e_ba_hand THEN
			fb_state_entry.i16_next_step := 30;	(* HAND *)
		ELSIF e_ba_dummy THEN
			fb_state_entry.i16_next_step := 40;	(* DUMMY *)
		ELSIF e_ba_pseudo THEN
			fb_state_entry.i16_next_step := 50;	(* PSEUDO *)
		END_IF

(*=======================================================*)
	10:	(* AUTO *)
		IF fb_state_entry.E THEN
			i16_betriebsart := AUTO;
			a_lampe_ba_automatik := TRUE;
		END_IF

		(* Betriebsartenwechsel *)
		IF NOT e_ba_automatik THEN
			fb_state_entry.i16_next_step := 0;
		END_IF
	
	(*=======================================================*)
	20:	(* TIPPEN *)
		IF fb_state_entry.E THEN
			i16_betriebsart := TIPPEN;
			a_lampe_ba_tippen := TRUE;
		END_IF

		(* Betriebsartenwechsel *)
		IF NOT e_ba_tippen THEN
			fb_state_entry.i16_next_step := 0;
		END_IF

(*=======================================================*)
	30:	(* HAND *)
		IF fb_state_entry.E THEN
			i16_betriebsart := HAND;
			a_lampe_ba_hand := TRUE;
		END_IF

		(* Betriebsartenwechsel *)
		IF NOT e_ba_hand THEN
			fb_state_entry.i16_next_step := 0;
		END_IF

(*=======================================================*)
	40:	(* DUMMY *)
		IF fb_state_entry.E THEN
			i16_betriebsart := DUMMY;
			a_lampe_ba_dummy := TRUE;
		END_IF

		(* Betriebsartenwechsel *)
		IF NOT e_ba_dummy THEN
			fb_state_entry.i16_next_step := 0;
		END_IF

(*=======================================================*)
	50:	(* PSEUDO *)
		IF fb_state_entry.E THEN
			i16_betriebsart := PSEUDO;
			a_lampe_ba_pseudo := TRUE;
		END_IF

		(* Betriebsartenwechsel *)
		IF NOT e_ba_pseudo THEN
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen  *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	(* Betriebsmeldungen *)
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Betriebsfreigaben' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Betriebsfreigaben
VAR_INPUT
	st_config							: struct_config;
	st_ctrl_in							: struct_ctrl_in;
	b_lampe_stoerung				: BOOL;
	b_lampe_produktion				: BOOL;
	e_steuerung_ein					: BOOL;
END_VAR
VAR_OUTPUT
	st_ctrl_out						: struct_ctrl_out;
END_VAR
VAR
	fb_tof_druck						: TOF;
	fb_tof_druck_hublift_links			: TOF;
	fb_ton_ls_schalter_ausgeloest		: TON;
	fb_ton_temperatur_schaltschrank	: TON;
	fb_ton_ueberstrom_haspe			: TON;
	fb_ton_quitt						: TON;
	fb_ton_wz						: TON;
	fb_state_entry						: ST_StateEntry;
	sm_druckwaechter  				: BOOL := FALSE;
	sm_druckwaechter_hublift_links		: BOOL := FALSE;
	sm_schaltschrank 					: BOOL := FALSE;
	sm_ls_schalter 					: BOOL := FALSE;
	sm_haube_offen 					: BOOL := FALSE;
	sm_ueberstrom_haspel			: BOOL := FALSE;

	bm_schaltschrank 					: BOOL := FALSE;

	e_temperatur_schaltschrank 		AT %I* : BOOL;
	e_ls_schalter_ausgeloest 			AT %I* : BOOL;

	e_ueberstrom_haspel				AT %I* : BOOL;
	a_lampe_steuerung 				AT %Q* : BOOL;
	e_druckwaechter					AT %I* : BOOL;
	e_druckwaechter_hublift_links		AT %I* : BOOL;
	a_lampe_stoerung 				AT %Q* : BOOL;
	a_lampe_produktion 				AT %Q* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
fb_tof_druck(IN:=e_druckwaechter , PT:= t#500ms, Q=> , ET=> );
fb_tof_druck_hublift_links(IN:=e_druckwaechter_hublift_links , PT:= t#500ms, Q=> , ET=> );
fb_ton_ls_schalter_ausgeloest(IN:=NOT e_ls_schalter_ausgeloest  , PT:= t#200ms, Q=> , ET=> );
fb_ton_temperatur_schaltschrank(IN:=NOT e_temperatur_schaltschrank  , PT:= t#200ms, Q=> , ET=> );
fb_ton_ueberstrom_haspe(IN:=NOT e_ueberstrom_haspel , PT:= t#200ms, Q=> , ET=> );

fb_ton_wz(IN:= , PT:= t#500ms, Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#50ms, Q=> , ET=> );

a_lampe_steuerung := e_steuerung_ein ;
a_lampe_stoerung := b_lampe_stoerung;
a_lampe_produktion := b_lampe_produktion;

bm_schaltschrank:=fb_ton_temperatur_schaltschrank.Q;
ST_LampeMaterialMangel.b_materialmangel[4]:=bm_schaltschrank;

(*=======================Schrittkette=======================*)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		st_ctrl_out.b_fehler := FALSE;
		st_ctrl_out.b_bereit := FALSE;
		fb_ton_wz.IN := FALSE;
		fb_ton_quitt.IN := FALSE;
		sm_druckwaechter  := FALSE;
		sm_druckwaechter_hublift_links := FALSE;
		sm_schaltschrank  := FALSE;
		sm_ls_schalter  := FALSE;
		sm_haube_offen := FALSE;
		sm_ueberstrom_haspel := FALSE;
		bm_schaltschrank  := FALSE;
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := BEREIT;

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	NOT fb_tof_druck.Q THEN
			sm_druckwaechter := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
		IF	 fb_ton_ls_schalter_ausgeloest.Q THEN
			sm_ls_schalter := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
		(*IF 	fb_ton_ueberstrom_foerderbaender.Q THEN
			sm_ueberstrom_foerderbaender := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF*)
		IF 	fb_ton_ueberstrom_haspe.Q THEN
			sm_ueberstrom_haspel := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
		IF gst_datensatz.st_md.b_hublift_links_aktiv THEN
			IF NOT fb_tof_druck_hublift_links.Q THEN
				sm_druckwaechter_hublift_links := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*		IF 	fb_ton_temperatur_schaltschrank.Q THEN
			sm_schaltschrank := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF*)

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := FALSE;;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_druckwaechter;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_schaltschrank;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_ls_schalter;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_haube_offen;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := sm_ueberstrom_haspel;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := sm_druckwaechter_hublift_links;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	(* Betriebsmeldungen *)
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_schaltschrank;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Haspel\/Einfach' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Einfachhaspelkontroller
VAR_INPUT
	t_wartezeit_bandende			: TIME;
	t_wartezeit_notabschaltung		: TIME;
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
	e_steuerung_ein				: BOOL;
END_VAR
VAR_IN_OUT
	st_visu						: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz					: TON;
	fb_ton_uez					: TON;
	fb_ton_vz					: TON;
	fb_ton_vz_bandende			: TON;
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	sm_haspel_nicht_bb			: BOOL := FALSE;
	sm_haspel_notaus 			: BOOL := FALSE;
	sm_haspel_notabschaltung		: BOOL := FALSE;
	bm_haspel_bandende			: BOOL := FALSE;
	e_haspelmotor_bb			AT %I* : BOOL;
	e_haspel_notaus				AT %I* : BOOL;
	e_haspel_bandende			AT %I* : BOOL;
	e_haspel_einschalten			AT %I* : BOOL;
	e_haspel_ausschalten			AT %I* : BOOL;
	a_motor						AT %Q* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= t_wartezeit_notabschaltung, Q=>  , ET=> );
fb_ton_vz(IN:= , PT:= t#5ms, Q=> , ET=> );
fb_ton_vz_bandende(IN:= e_haspel_bandende, PT:= t_wartezeit_bandende, Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );


(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
	(* Allgemeine Fehler *)
	IF e_haspel_notaus THEN
		sm_haspel_notaus := TRUE;
		fb_state_entry.i16_next_step := FEHLER;
	ELSIF e_steuerung_ein AND NOT e_haspelmotor_bb THEN
		sm_haspel_nicht_bb := TRUE;
		fb_state_entry.i16_next_step := FEHLER;
	END_IF
	(* Bandende am Haspelbandeinzug *)
	IF fb_ton_vz_bandende.Q THEN
		bm_haspel_bandende := TRUE;
		st_ctrl_out.b_bandende := TRUE;
	ELSE
		IF e_haspel_ausschalten THEN
			bm_haspel_bandende := FALSE;
			st_ctrl_out.b_bandende := FALSE;
		END_IF
	END_IF
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_vz.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			sm_haspel_nicht_bb := FALSE;
			sm_haspel_notaus := FALSE;
			sm_haspel_notabschaltung := FALSE;
			bm_haspel_bandende	:= FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_bandende := FALSE;
			a_motor := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT: (* Warte auf Sensor für Motor einschalten *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			a_motor := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_haspel_einschalten THEN
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110: (* Haspelmotor einschalten *)
		IF fb_state_entry.E THEN
			a_motor := TRUE;
			fb_ton_uez.IN := TRUE; (* Notabschaltung, weil etwas nicht stimmen kann *)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_haspel_ausschalten OR fb_ton_vz_bandende.Q THEN
			fb_ton_uez.IN := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		ELSIF fb_ton_uez.Q THEN
			fb_ton_uez.IN := FALSE;
			sm_haspel_notabschaltung := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			a_motor := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

		(* Selbstquittierung, damit der Bediener das Band abspulen kann *)
		IF e_haspel_ausschalten THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := FALSE;
			sm_haspel_nicht_bb := FALSE;
			sm_haspel_notaus := FALSE;
			sm_haspel_notabschaltung := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			a_motor := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_haspel_notaus;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_haspel_nicht_bb;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_haspel_notabschaltung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_haspel_bandende;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Haspel\/Einfach' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Haspel_V2
VAR_INPUT
	t_wartezeit_bandende			: TIME;
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
	b_bandende_Bandeinzug		: BOOL;
	b_band_ok					: BOOL;
END_VAR
VAR_IN_OUT
	st_visu						: struct_visu;
	st_zyl_heben				: struct_st_zylinder;
	st_zyl_abspulen				: struct_st_zylinder;
	st_zyl_sperren				: struct_st_zylinder;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz					: TON;
	fb_ton_wz_bremse				: TON;
	fb_ton_uez					: TON;
	fb_ton_vz_einschalten			: TON;
	fb_ton_vz_bandende			: TON;
	fb_ton_bandende_Bandeinzug	: TON;
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	sm_haspel_notaus 			: BOOL := FALSE;
	sm_haspel_notabschaltung		: BOOL := FALSE;
	bm_haspel_bandende			: BOOL := FALSE;
	e_haspel_notaus				AT %I* : BOOL;
	e_haspel_bandende			AT %I* : BOOL;
	e_haspel_einschalten			AT %I* : BOOL;
	e_haspel_ausschalten			AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_wz_bremse(IN:= , PT:= t#30s, Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= t#15s, Q=>  , ET=> );
fb_ton_vz_einschalten(IN:= e_haspel_einschalten, PT:= t#50ms, Q=> , ET=> );
fb_ton_vz_bandende(IN:= e_haspel_bandende, PT:= t#1000ms, Q=>  , ET=> );
fb_ton_bandende_Bandeinzug(IN:=NOT b_bandende_Bandeinzug, PT:= t#1000ms, Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#50ms, Q=> , ET=> );

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* Allgemeine Fehler *)
	IF e_haspel_notaus AND st_ctrl_in.b_freigabe THEN
		st_zyl_abspulen.st_ctrl.in.b_ausfahren := TRUE;
		sm_haspel_notaus := TRUE;
		fb_state_entry.i16_next_step := FEHLER;
	ELSIF 	st_zyl_heben.st_ctrl.out.b_fehler OR
			st_zyl_abspulen.st_ctrl.out.b_fehler OR
			st_zyl_sperren.st_ctrl.out.b_fehler
			THEN
				fb_state_entry.i16_next_step := FEHLER;
	ELSIF 	((st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = st_zyl_heben.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = st_zyl_abspulen.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = st_zyl_sperren.fb.st_config.i16_identnummer)) AND
			gi16_betriebsart = HAND
			THEN
				fb_state_entry.i16_next_step := FEHLER;
	ELSE
		IF fb_state_entry.i16_next_step < STOP THEN
			IF st_ctrl_in.b_stop THEN
				st_zyl_abspulen.st_ctrl.in.b_ausfahren := TRUE;
				fb_state_entry.i16_next_step := STOP;
			END_IF
		END_IF
	END_IF

	(* Bandende am Haspelbandeinzug *)
	IF	 (gst_datensatz.st_md.i16_typ_zelle=BESTUECKZELLE_1700 OR
		gst_datensatz.st_md.i16_typ_zelle=RASTERFOLIE OR
		gst_datensatz.st_md.i16_typ_zelle=BESTUECKZELLE_1720) AND
		fb_ton_vz_bandende.Q AND st_ctrl_in.b_freigabe THEN
		bm_haspel_bandende := TRUE;
		st_ctrl_out.b_bandende := TRUE;
	ELSE
		bm_haspel_bandende := FALSE;
		st_ctrl_out.b_bandende := FALSE;
	END_IF
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_wz_bremse.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_vz_einschalten.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			sm_haspel_notaus := FALSE;
			sm_haspel_notabschaltung := FALSE;
			bm_haspel_bandende := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_bandende := FALSE;
			st_zyl_heben.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_heben.st_ctrl.in.b_einfahren := FALSE;
			st_zyl_abspulen.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_abspulen.st_ctrl.in.b_einfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_einfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			st_zyl_heben.st_ctrl.in.b_quittieren := FALSE;
			st_zyl_abspulen.st_ctrl.in.b_quittieren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_quittieren := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: (* Sperrzylinder ausfahren *)
		IF fb_state_entry.E THEN
			st_zyl_sperren.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_sperren.st_ctrl.out.b_ausgefahren AND st_ctrl_in.b_freigabe THEN
			fb_state_entry.i16_next_step := 30;
		ELSE
			fb_state_entry.i16_next_step := 40;
		END_IF

		IF fb_state_entry.X THEN
			st_zyl_sperren.st_ctrl.in.b_ausfahren := FALSE;
		END_IF

(*=======================================================*)
	30: (* Abspulzylinder ausfahren *)
		IF fb_state_entry.E THEN
			st_zyl_abspulen.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_abspulen.st_ctrl.out.b_ausgefahren THEN
			st_zyl_abspulen.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40: (* Hebezylinder ausfahren *)
		IF fb_state_entry.E THEN
			st_zyl_heben.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_heben.st_ctrl.out.b_ausgefahren THEN
			st_zyl_heben.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT: (* Spule ist komplett angehoben und gesperrt, warte auf Sensor für einschalten *)
		IF fb_state_entry.E THEN
			sm_haspel_notaus := FALSE;
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		CASE gst_datensatz.st_md.i16_typ_zelle OF

			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700, RASTERFOLIE:
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF st_ctrl_in.b_freigabe THEN(* Variable für aktive Seite, auf der abgespult wird *)
					(*bei Bandende die aktive Spule anheben*)
					IF e_haspel_einschalten THEN
						st_ctrl_out.b_kontroller_start := TRUE;
						fb_state_entry.i16_next_step := 110;
					ELSIF	(fb_ton_vz_bandende.Q OR fb_ton_bandende_Bandeinzug.Q) AND
					NOT st_zyl_abspulen.st_ctrl.out.b_ausgefahren THEN
						fb_state_entry.i16_next_step := 130;
					END_IF
				ELSE
					IF ST_Bandwechsel_Kontroller.b_spulenwechsel THEN
						IF NOT st_zyl_abspulen.st_ctrl.out.b_ausgefahren OR
						     fb_ton_bandende_Bandeinzug.Q THEN
							fb_state_entry.i16_next_step := 130;
						END_IF
					ELSE
						(* die nicht aktive Spule auf Bremse legen, wenn diese gesperrt wurde*)
						IF st_zyl_sperren.fb.e_sensor1_ausgefahren AND
						     NOT st_zyl_abspulen.st_ctrl.out.b_eingefahren THEN
							fb_state_entry.i16_next_step := 400;
						(* die nicht aktive Spule von Bremse heben, wenn diese freigegeben wurde*)
						ELSIF st_zyl_sperren.fb.e_sensor1_eingefahren AND
						     NOT st_zyl_abspulen.st_ctrl.out.b_ausgefahren THEN
							fb_state_entry.i16_next_step := 500;
						END_IF
					END_IF
				END_IF

			BESTUECKZELLE_1720:
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF e_haspel_einschalten THEN
					st_ctrl_out.b_kontroller_start := TRUE;
					fb_state_entry.i16_next_step := 110;
				END_IF

		END_CASE

(*=======================================================*)
	110: (* Spule absenken und einschalten *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_kontroller_start := FALSE;
			bm_haspel_bandende := FALSE;
			st_ctrl_out.b_bandende := FALSE;
			st_zyl_abspulen.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_abspulen.st_ctrl.out.b_eingefahren THEN
			st_zyl_abspulen.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120: (* Spule ist abgesenkt, warte auf Sensor für ausschalten *)
		IF fb_state_entry.E THEN
			fb_ton_uez.IN := TRUE; (* Notabschaltung, weil etwas nicht stimmen kann *)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_haspel_ausschalten OR
			gi16_betriebsart = HAND THEN	(* Wunsch von D. Rustler 07.04.22 dass auch im Handbetrieb der Haspel aufhört abzuspulen *)
			fb_ton_uez.IN := FALSE;
			fb_state_entry.i16_next_step := 130;
		ELSIF fb_ton_uez.Q THEN
			fb_ton_uez.IN := FALSE;
			sm_haspel_notabschaltung := TRUE;
			fb_state_entry.i16_next_step := 150;(* Spule anheben und dann in Fehler gehen *)
		END_IF

(*=======================================================*)
	130: (* Spule anheben *)
		IF fb_state_entry.E THEN
			st_zyl_abspulen.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_abspulen.st_ctrl.out.b_ausgefahren THEN
			st_zyl_abspulen.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		ELSIF e_haspel_einschalten THEN
			st_zyl_abspulen.st_ctrl.in.b_ausfahren := FALSE;
			st_ctrl_out.b_kontroller_start := TRUE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	150: (* Spule anheben und gehe in Fehler *)
		IF fb_state_entry.E THEN
			st_zyl_abspulen.st_ctrl.in.b_ausfahren := TRUE;
			fb_ton_wz.IN := TRUE;
			fb_ton_wz.PT := T#500ms;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_abspulen.st_ctrl.out.b_ausgefahren OR fb_ton_wz.Q THEN
			st_zyl_abspulen.st_ctrl.in.b_ausfahren := FALSE;
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	400: (* Haspelspule auf Bremse legen 30 sek Wartezeit *)
		IF fb_state_entry.E THEN
			fb_ton_wz_bremse.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz_bremse.Q THEN
			fb_state_entry.i16_next_step := 410;
		END_IF

		IF fb_state_entry.X THEN
			fb_ton_wz_bremse.IN := FALSE;
		END_IF

(*=======================================================*)
	410: (* Haspelspule auf Bremse legen *)
		IF fb_state_entry.E THEN
			st_zyl_abspulen.st_ctrl.in.b_einfahren:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_abspulen.st_ctrl.out.b_eingefahren THEN
			st_zyl_abspulen.st_ctrl.in.b_einfahren:=FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	500: (* Haspelspule von Bremse heben *)
		IF fb_state_entry.E THEN
			st_zyl_abspulen.st_ctrl.in.b_ausfahren:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_abspulen.st_ctrl.out.b_ausgefahren THEN
			st_zyl_abspulen.st_ctrl.in.b_ausfahren:=FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			st_zyl_heben.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_heben.st_ctrl.in.b_einfahren := FALSE;
			st_zyl_abspulen.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_abspulen.st_ctrl.in.b_einfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_einfahren := FALSE;
		END_IF

		(*Der Fehler Haspel Notaus, darf nur quittiert werden, wenn das Band ausgefädelt wurde*)
		IF sm_haspel_notaus AND NOT b_bandende_Bandeinzug THEN
			(*-----------------------Weiterschaltbedingungen----------------------------*)
			IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
				st_ctrl_out.b_fehler := FALSE;
				st_zyl_heben.st_ctrl.in.b_quittieren := TRUE;
				st_zyl_abspulen.st_ctrl.in.b_quittieren := TRUE;
				st_zyl_sperren.st_ctrl.in.b_quittieren := TRUE;
				fb_ton_quitt.IN := TRUE;
			END_IF
		ELSIF NOT sm_haspel_notaus THEN
			(*-----------------------Weiterschaltbedingungen----------------------------*)
			IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
				st_ctrl_out.b_fehler := FALSE;
				st_zyl_heben.st_ctrl.in.b_quittieren := TRUE;
				st_zyl_abspulen.st_ctrl.in.b_quittieren := TRUE;
				st_zyl_sperren.st_ctrl.in.b_quittieren := TRUE;
				fb_ton_quitt.IN := TRUE;
			END_IF
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_zyl_heben.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_heben.st_ctrl.in.b_einfahren := FALSE;
			st_zyl_abspulen.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_abspulen.st_ctrl.in.b_einfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_einfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_haspel_notaus;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_haspel_notabschaltung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_haspel_bandende;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Haspel\/Mehrfach' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Haspel_Kontroller_2H
VAR_INPUT
	t_abschaltzeit_motor			: TIME;
	b_drehrichtung_antrieb_links	: BOOL;
	st_config						: struct_config;
	e_druckwaechter				: BOOL;
	e_steuerung_ein				: BOOL;
	st_ctrl_in						: struct_ctrl_in;
	haspel1_ctrl_in				: struct_ctrl_out;
	haspel2_ctrl_in				: struct_ctrl_out;
END_VAR
VAR_IN_OUT
	st_visu						: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
	haspel1_ctrl_out				: struct_ctrl_in;
	haspel2_ctrl_out				: struct_ctrl_in;
	b_materialmangel_bandende	: BOOL := FALSE;
END_VAR
VAR
	fb_ton_wz					: TON;
	fb_ton_uez					: TON;
	fb_ton_vz					: TON;
	fb_tof_motor					: TOF;
	fb_ton_quitt					: TON;
	fb_r_trig_start					: R_TRIG;
	fb_state_entry					: ST_StateEntry;
	sm_haspel_nicht_bb			: BOOL := FALSE;
	e_haspelmotor_bb			AT %I* : BOOL;
	a_motor_drehrichtung_rechts	AT %Q* : BOOL;
	a_motor_drehrichtung_links		AT %Q* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_vz(IN:= , PT:= , Q=>  , ET=> );
fb_tof_motor(IN:= , PT:= t_abschaltzeit_motor, Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );

(* Haspelmotor *)
IF 	e_steuerung_ein AND
	e_druckwaechter AND
	fb_tof_motor.Q AND
	fb_state_entry.i16_next_step <> FEHLER THEN
		a_motor_drehrichtung_links 	:= b_drehrichtung_antrieb_links;
		a_motor_drehrichtung_rechts := NOT b_drehrichtung_antrieb_links;
ELSE
	a_motor_drehrichtung_links 	:= FALSE;
	a_motor_drehrichtung_rechts := FALSE;
END_IF

(* Freigabe für die jeweils benutzte Haspel setzen. Wird für Bandende benötigt (ST_Haspel_V2)*)
CASE gst_datensatz.st_md.i16_typ_zelle OF

KEINE_ZELLE:
		;

BESTUECKZELLE_1700:
	IF zyl_bandeinzuege_verschieben.st_ctrl.out.b_ausgefahren THEN
		haspel1_ctrl_out.b_freigabe := TRUE;
		haspel2_ctrl_out.b_freigabe := FALSE;
	ELSIF zyl_bandeinzuege_verschieben.st_ctrl.out.b_eingefahren THEN
		haspel1_ctrl_out.b_freigabe := FALSE;
		haspel2_ctrl_out.b_freigabe := TRUE;
	END_IF

RASTERFOLIE:
	haspel1_ctrl_out.b_freigabe := TRUE;
	haspel2_ctrl_out.b_freigabe := FALSE;

BESTUECKZELLE_1720:
	haspel1_ctrl_out.b_freigabe := TRUE;
	haspel2_ctrl_out.b_freigabe := TRUE;

END_CASE

(* Bandende von Haspel rechts bzw. links *)
IF	(gi16_betriebsart = AUTO OR gi16_betriebsart = TIPPEN) AND
	(haspel1_ctrl_in.b_bandende OR haspel2_ctrl_in.b_bandende )
	THEN
		st_ctrl_out.b_bandende := b_materialmangel_bandende := TRUE;
ELSE
		st_ctrl_out.b_bandende := b_materialmangel_bandende := FALSE;
END_IF

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
	(* Allgemeine Fehler *)
	IF haspel1_ctrl_in.b_fehler OR haspel2_ctrl_in.b_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF


(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_vz.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			a_motor_drehrichtung_links := FALSE;
			a_motor_drehrichtung_rechts := FALSE;
			sm_haspel_nicht_bb := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			haspel1_ctrl_out.b_stop := FALSE;
			haspel2_ctrl_out.b_stop := FALSE;
			haspel1_ctrl_out.b_init := FALSE;
			haspel2_ctrl_out.b_init := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			haspel1_ctrl_out.b_quitt := FALSE;
			haspel2_ctrl_out.b_quitt := FALSE;
			fb_state_entry.i16_next_step :=20;
		END_IF

(*=======================================================*)
	20:	(* Haspeln initialisieren *)
		IF fb_state_entry.E THEN
			haspel1_ctrl_out.b_init := TRUE;
			haspel2_ctrl_out.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  haspel1_ctrl_in.b_bereit AND haspel2_ctrl_in.b_bereit THEN
			haspel1_ctrl_out.b_init := FALSE;
			haspel2_ctrl_out.b_init := FALSE;
			fb_tof_motor.IN := TRUE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT: (* Haspelmotor läuft *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
		END_IF

		IF haspel1_ctrl_in.b_kontroller_start OR haspel2_ctrl_in.b_kontroller_start THEN	(* Abschaltzeit für Haspelmotor nachtriggern*)
			fb_tof_motor.IN := TRUE;
		ELSE
			fb_tof_motor.IN := FALSE;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_tof_motor.IN := FALSE;
			haspel1_ctrl_out.b_quitt := FALSE;
			haspel2_ctrl_out.b_quitt := FALSE;
			haspel1_ctrl_out.b_stop := FALSE;
			haspel2_ctrl_out.b_stop := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			haspel1_ctrl_out.b_quitt := TRUE;
			haspel2_ctrl_out.b_quitt := TRUE;
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_tof_motor.IN := FALSE;
			haspel1_ctrl_out.b_stop := TRUE;
			haspel2_ctrl_out.b_stop := TRUE;
			haspel1_ctrl_out.b_quitt := FALSE;
			haspel2_ctrl_out.b_quitt := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			haspel1_ctrl_out.b_stop := FALSE;
			haspel2_ctrl_out.b_stop := FALSE;
			haspel1_ctrl_out.b_quitt := TRUE;
			haspel2_ctrl_out.b_quitt := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_haspel_nicht_bb;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Haspel\/Mehrfach' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Haspel_Kontroller_4H
VAR_INPUT
	t_abschaltzeit_motor			: TIME;
	b_drehrichtung_antrieb_links	: BOOL;
	st_config						: struct_config;
	e_druckwaechter				: BOOL;
	e_steuerung_ein				: BOOL;
	st_ctrl_in						: struct_ctrl_in;
	haspel1_ctrl_in				: struct_ctrl_out;
	haspel2_ctrl_in				: struct_ctrl_out;
	haspel3_ctrl_in				: struct_ctrl_out;
	haspel4_ctrl_in				: struct_ctrl_out;
END_VAR
VAR_IN_OUT
	st_visu						: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
	haspel1_ctrl_out				: struct_ctrl_in;
	haspel2_ctrl_out				: struct_ctrl_in;
	haspel3_ctrl_out				: struct_ctrl_in;
	haspel4_ctrl_out				: struct_ctrl_in;
END_VAR
VAR
	fb_ton_wz					: TON;
	fb_ton_uez					: TON;
	fb_ton_vz					: TON;
	fb_ton_quitt					: TON;
	fb_tof_motor					: TOF;
	b_motor_laeuft				: BOOL := FALSE;
	fb_state_entry					: ST_StateEntry;
	a_motor_drehrichtung_rechts	AT %Q* : BOOL;
	a_motor_drehrichtung_links		AT %Q* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_vz(IN:= , PT:= , Q=>  , ET=> );
fb_tof_motor(IN:= , PT:= t_abschaltzeit_motor, Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

b_motor_laeuft := a_motor_drehrichtung_links OR a_motor_drehrichtung_rechts;

(* Bandende von Haspel rechts bzw. links *)
IF	(gi16_betriebsart = AUTO OR gi16_betriebsart = TIPPEN) AND
 	(haspel1_ctrl_in.b_bandende OR
	haspel2_ctrl_in.b_bandende OR
	haspel3_ctrl_in.b_bandende OR
	haspel4_ctrl_in.b_bandende)
	THEN
		st_ctrl_out.b_bandende := TRUE;
ELSE
		st_ctrl_out.b_bandende := FALSE;
END_IF

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
	IF 	haspel1_ctrl_in.b_fehler OR
		haspel2_ctrl_in.b_fehler OR
		haspel3_ctrl_in.b_fehler OR
		haspel4_ctrl_in.b_fehler
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_vz.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			a_motor_drehrichtung_links 	:= FALSE;
			a_motor_drehrichtung_rechts := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			haspel1_ctrl_out.b_init := FALSE;
			haspel2_ctrl_out.b_init := FALSE;
			haspel3_ctrl_out.b_init := FALSE;
			haspel4_ctrl_out.b_init := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			haspel1_ctrl_out.b_quitt := FALSE;
			haspel2_ctrl_out.b_quitt := FALSE;
			haspel3_ctrl_out.b_quitt := FALSE;
			haspel4_ctrl_out.b_quitt := FALSE;
			fb_state_entry.i16_next_step :=20;
		END_IF

(*=======================================================*)
	20:
		IF fb_state_entry.E THEN
			haspel1_ctrl_out.b_init := TRUE;
			haspel2_ctrl_out.b_init := TRUE;
			haspel3_ctrl_out.b_init := TRUE;
			haspel4_ctrl_out.b_init := TRUE;
		END_IF
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  	haspel1_ctrl_in.b_bereit AND
			haspel2_ctrl_in.b_bereit AND
			haspel3_ctrl_in.b_bereit AND
			haspel4_ctrl_in.b_bereit
			THEN
				haspel1_ctrl_out.b_init := FALSE;
				haspel2_ctrl_out.b_init := FALSE;
				haspel3_ctrl_out.b_init := FALSE;
				haspel4_ctrl_out.b_init := FALSE;
				fb_tof_motor.IN := TRUE;
				fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT: (* Haspelmotor läuft *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		a_motor_drehrichtung_links 	:= e_druckwaechter AND fb_tof_motor.Q AND b_drehrichtung_antrieb_links;
		a_motor_drehrichtung_rechts := e_druckwaechter AND fb_tof_motor.Q AND NOT b_drehrichtung_antrieb_links;

		(* Abschaltzeit für Haspelmotor nachtriggern*)
		IF 	haspel1_ctrl_in.b_kontroller_start OR
			haspel2_ctrl_in.b_kontroller_start OR
			haspel3_ctrl_in.b_kontroller_start OR
			haspel4_ctrl_in.b_kontroller_start
			THEN
				fb_tof_motor.IN := TRUE;
		ELSE
			fb_tof_motor.IN := FALSE;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := TRUE;
			haspel1_ctrl_out.b_stop := FALSE;
			haspel2_ctrl_out.b_stop := FALSE;
			haspel3_ctrl_out.b_stop := FALSE;
			haspel4_ctrl_out.b_stop := FALSE;
			haspel1_ctrl_out.b_quitt := FALSE;
			haspel2_ctrl_out.b_quitt := FALSE;
			haspel3_ctrl_out.b_quitt := FALSE;
			haspel4_ctrl_out.b_quitt := FALSE;
			a_motor_drehrichtung_links 	:= FALSE;
			a_motor_drehrichtung_rechts := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			haspel1_ctrl_out.b_quitt := TRUE;
			haspel2_ctrl_out.b_quitt := TRUE;
			haspel3_ctrl_out.b_quitt := TRUE;
			haspel4_ctrl_out.b_quitt := TRUE;
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			a_motor_drehrichtung_links 	:= FALSE;
			a_motor_drehrichtung_rechts := FALSE;
			haspel1_ctrl_out.b_stop := TRUE;
			haspel2_ctrl_out.b_stop := TRUE;
			haspel3_ctrl_out.b_stop := TRUE;
			haspel4_ctrl_out.b_stop := TRUE;
			haspel1_ctrl_out.b_quitt := FALSE;
			haspel2_ctrl_out.b_quitt := FALSE;
			haspel3_ctrl_out.b_quitt := FALSE;
			haspel4_ctrl_out.b_quitt := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			haspel1_ctrl_out.b_stop := FALSE;
			haspel2_ctrl_out.b_stop := FALSE;
			haspel3_ctrl_out.b_stop := FALSE;
			haspel4_ctrl_out.b_stop := FALSE;
			haspel1_ctrl_out.b_quitt := TRUE;
			haspel2_ctrl_out.b_quitt := TRUE;
			haspel3_ctrl_out.b_quitt := TRUE;
			haspel4_ctrl_out.b_quitt := TRUE;

			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Haspel' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Haspel_st_zylinder
VAR_INPUT
	t_wartezeit_bandende			: TIME;
	e_druckwaechter				: BOOL;
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu						: struct_visu;
	st_zyl_heben					: struct_st_zylinder;
	st_zyl_sperren				: struct_st_zylinder;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz					: TON;
	fb_ton_uez					: TON;
	fb_ton_vz					: TON;
	fb_ton_vz_bandende			: TON;
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	sm_haspel_notaus 			: BOOL := FALSE;
	sm_haspel_notabschaltung		: BOOL := FALSE;
	bm_haspel_bandende			: BOOL := FALSE;
	e_haspel_notaus				AT %I* : BOOL;
	e_haspel_bandende			AT %I* : BOOL;
	e_haspel_einschalten			AT %I* : BOOL;
	e_haspel_ausschalten			AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= t#60s, Q=>  , ET=> );
fb_ton_vz(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_vz_bandende(IN:= e_haspel_bandende, PT:= t_wartezeit_bandende, Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#50ms, Q=> , ET=> );

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			st_zyl_heben.st_ctrl.in.b_ausfahren := TRUE;
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
	(* Allgemeine Fehler *)
	IF e_haspel_notaus THEN
		st_zyl_heben.st_ctrl.in.b_ausfahren := TRUE;
		sm_haspel_notaus := TRUE;
		fb_state_entry.i16_next_step := FEHLER;
	ELSIF st_zyl_heben.st_ctrl.out.b_fehler OR st_zyl_sperren.st_ctrl.out.b_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;
	ELSIF 	((st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = st_zyl_heben.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = st_zyl_sperren.fb.st_config.i16_identnummer)) AND
			gi16_betriebsart = HAND
			THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF

	(* Bandende am Haspelbandeinzug *)
	IF fb_ton_vz_bandende.Q THEN
		bm_haspel_bandende := st_ctrl_out.b_bandende := TRUE;
	ELSE
		bm_haspel_bandende := st_ctrl_out.b_bandende := FALSE;
	END_IF
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_vz.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			sm_haspel_notaus := FALSE;
			sm_haspel_notabschaltung := FALSE;
			bm_haspel_bandende	:= FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_bandende := FALSE;
			st_zyl_heben.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_heben.st_ctrl.in.b_einfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_einfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			st_zyl_heben.st_ctrl.in.b_quittieren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_quittieren := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: (* Hebezylinder ausfahren *)
		IF fb_state_entry.E THEN
			st_zyl_heben.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_heben.st_ctrl.out.b_ausgefahren THEN
			st_zyl_heben.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30: (* Sperrzylinder ausfahren *)
		IF fb_state_entry.E THEN
			st_zyl_sperren.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_sperren.st_ctrl.out.b_ausgefahren THEN
			st_zyl_sperren.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT: (* Spule ist angehoben und gesperrt, warte auf Sensor für einschalten *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_kontroller_start := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_haspel_einschalten THEN
			st_ctrl_out.b_kontroller_start := TRUE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110: (* Spule absenken und einschalten *)
		IF fb_state_entry.E THEN
			st_zyl_heben.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_heben.st_ctrl.out.b_eingefahren THEN
			st_zyl_heben.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120: (* Spule ist abgesenkt, warte auf Sensor für ausschalten *)
		IF fb_state_entry.E THEN
			fb_ton_uez.IN := TRUE; (* Notabschaltung, weil etwas nicht stimmen kann *)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_haspel_ausschalten THEN
			fb_ton_uez.IN := FALSE;
			fb_state_entry.i16_next_step := 130;
		ELSIF fb_ton_uez.Q THEN
			fb_ton_uez.IN := FALSE;
			sm_haspel_notabschaltung := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	130: (* Spule anheben und ausschalten *)
		IF fb_state_entry.E THEN
			st_zyl_heben.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_zyl_heben.st_ctrl.out.b_ausgefahren THEN
			st_zyl_heben.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			st_zyl_heben.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_heben.st_ctrl.in.b_einfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_einfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_zyl_heben.st_ctrl.in.b_quittieren := TRUE;
			st_zyl_sperren.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			st_zyl_heben.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_heben.st_ctrl.in.b_einfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_ausfahren := FALSE;
			st_zyl_sperren.st_ctrl.in.b_einfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_haspel_notaus;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_haspel_notabschaltung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_haspel_bandende;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Initialisierung/Startup' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Datainit_Achsen
VAR
	b_config_fertig			: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
IF	NOT axis_bestueckachse.st_config.b_config_fertig OR
	NOT axis_virt_master.st_config.b_config_fertig OR
	NOT axis_z_achse.st_config.b_config_fertig OR
	NOT axis_y_achse.st_config.b_config_fertig OR
	NOT axis_bandeinzug_achse.st_config.b_config_fertig OR
	NOT axis_transport_wt_achse.st_config.b_config_fertig
	THEN
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;
			BESTUECKZELLE_1700:
				(* Virtuelle Masterachse *)
				axis_virt_master.st_config.b_config_fertig := FALSE;
				axis_virt_master.st_config.b_limitsensor_negativ_vorhanden := FALSE;
				axis_virt_master.st_config.b_limitsensor_positiv_vorhanden := FALSE;
				axis_virt_master.st_config.b_refsensor_vorhanden := FALSE;
				axis_virt_master.st_config.r_getriebefaktor := 1.0;
				axis_virt_master.st_config.i16_achstyp := RUND_VIRTUELL;
				axis_virt_master.st_config.i16_meld_startindex := 1400;
				axis_virt_master.st_config.s_beschreibung := ' ';
				axis_virt_master.st_config.s_instanz_name := 'Virtuelle Masterachse';
				axis_virt_master.st_config.ui16_ethercat_slave_id := 0;
				axis_virt_master.st_config.ui16_ethercat_adr := 0;
				axis_virt_master.st_config.b_config_fertig := TRUE;
				(* Bestueckachse *)
				axis_bestueckachse.st_config.b_config_fertig := FALSE;
				axis_bestueckachse.st_config.b_limitsensor_negativ_vorhanden := FALSE;
				axis_bestueckachse.st_config.b_limitsensor_positiv_vorhanden := FALSE;
				axis_bestueckachse.st_config.b_refsensor_vorhanden := FALSE;
				axis_bestueckachse.st_config.r_getriebefaktor := 1.0;
				axis_bestueckachse.st_config.i16_achstyp := RUND;
				axis_bestueckachse.st_config.i16_meld_startindex := 1000;
				axis_bestueckachse.st_config.s_beschreibung := ' ';
				axis_bestueckachse.st_config.s_instanz_name := 'Bestückachse';
				axis_bestueckachse.st_config.ui16_ethercat_slave_id := 42;
				axis_bestueckachse.st_config.ui16_ethercat_adr := 1024;
				axis_bestueckachse.st_config.b_config_fertig := TRUE;
				(* Servobandeinzug *)
				axis_bandeinzug_achse.st_config.b_config_fertig := FALSE;
				axis_bandeinzug_achse.st_config.b_limitsensor_negativ_vorhanden := FALSE;
				axis_bandeinzug_achse.st_config.b_limitsensor_positiv_vorhanden := FALSE;
				axis_bandeinzug_achse.st_config.b_refsensor_vorhanden := FALSE;
				axis_bandeinzug_achse.st_config.r_getriebefaktor := 1.0;
				axis_bandeinzug_achse.st_config.i16_achstyp := RUND;
				axis_bandeinzug_achse.st_config.i16_meld_startindex := 1300;
				axis_bandeinzug_achse.st_config.s_beschreibung := ' ';
				axis_bandeinzug_achse.st_config.s_instanz_name := 'Servobandeinzug';
				axis_bandeinzug_achse.st_config.ui16_ethercat_slave_id := 42;
				axis_bandeinzug_achse.st_config.ui16_ethercat_adr := 1024;
				(* Z-Achse *)
				axis_z_achse.st_config.b_config_fertig := FALSE;
				axis_z_achse.st_config.b_limitsensor_negativ_vorhanden := FALSE;
				axis_z_achse.st_config.b_limitsensor_positiv_vorhanden := FALSE;
				axis_z_achse.st_config.b_refsensor_vorhanden := FALSE;
				axis_z_achse.st_config.r_getriebefaktor := 1.0;
				axis_z_achse.st_config.i16_achstyp := LINEAR;
				axis_z_achse.st_config.i16_meld_startindex := 1100;
				axis_z_achse.st_config.s_beschreibung := ' ';
				axis_z_achse.st_config.s_instanz_name := 'Z-Achse';
				axis_z_achse.st_config.ui16_ethercat_slave_id := 43;
				axis_z_achse.st_config.ui16_ethercat_adr := 1026;
				axis_z_achse.st_config.b_config_fertig := TRUE;
				(* Y-Achse *)
				axis_y_achse.st_config.b_config_fertig := FALSE;
				axis_y_achse.st_config.b_limitsensor_negativ_vorhanden := FALSE;
				axis_y_achse.st_config.b_limitsensor_positiv_vorhanden := FALSE;
				axis_y_achse.st_config.b_refsensor_vorhanden := FALSE;
				axis_y_achse.st_config.r_getriebefaktor := 1.0;
				axis_y_achse.st_config.i16_achstyp := LINEAR;
				axis_y_achse.st_config.i16_meld_startindex := 1200;
				axis_y_achse.st_config.s_beschreibung := ' ';
				axis_y_achse.st_config.s_instanz_name := 'Y-Achse';
				axis_y_achse.st_config.ui16_ethercat_slave_id := 43;
				axis_y_achse.st_config.ui16_ethercat_adr := 1026;
				axis_y_achse.st_config.b_config_fertig := TRUE;
				(* Transport WT Achse *)
				axis_transport_wt_achse.st_config.b_config_fertig := FALSE;
				axis_transport_wt_achse.st_config.b_limitsensor_negativ_vorhanden := FALSE;
				axis_transport_wt_achse.st_config.b_limitsensor_positiv_vorhanden := FALSE;
				axis_transport_wt_achse.st_config.b_refsensor_vorhanden := FALSE;
				axis_transport_wt_achse.st_config.r_getriebefaktor := 1.0;
				axis_transport_wt_achse.st_config.i16_achstyp := LINEAR;
				axis_transport_wt_achse.st_config.i16_meld_startindex := 1500;
				axis_transport_wt_achse.st_config.s_beschreibung := ' ';
				axis_transport_wt_achse.st_config.s_instanz_name := 'Transport_WT_Achse';
				axis_transport_wt_achse.st_config.ui16_ethercat_slave_id :=43;
				axis_transport_wt_achse.st_config.ui16_ethercat_adr :=1026;
				axis_transport_wt_achse.st_config.b_config_fertig := TRUE;

				axis_bandeinzug_achse.st_config.b_config_fertig := TRUE;

			BESTUECKZELLE_1720:
				(* Virtuelle Masterachse *)
				axis_virt_master.st_config.b_config_fertig := FALSE;
				axis_virt_master.st_config.b_limitsensor_negativ_vorhanden := FALSE;
				axis_virt_master.st_config.b_limitsensor_positiv_vorhanden := FALSE;
				axis_virt_master.st_config.b_refsensor_vorhanden := FALSE;
				axis_virt_master.st_config.r_getriebefaktor := 1.0;
				axis_virt_master.st_config.i16_achstyp := RUND_VIRTUELL;
				axis_virt_master.st_config.i16_meld_startindex := 1400;
				axis_virt_master.st_config.s_beschreibung := ' ';
				axis_virt_master.st_config.s_instanz_name := 'Virtuelle Masterachse';
				axis_virt_master.st_config.ui16_ethercat_slave_id := 0;
				axis_virt_master.st_config.ui16_ethercat_adr := 0;
				axis_virt_master.st_config.b_config_fertig := TRUE;
				(* Bestueckachse *)
				axis_bestueckachse.st_config.b_config_fertig := FALSE;
				axis_bestueckachse.st_config.b_limitsensor_negativ_vorhanden := FALSE;
				axis_bestueckachse.st_config.b_limitsensor_positiv_vorhanden := FALSE;
				axis_bestueckachse.st_config.b_refsensor_vorhanden := FALSE;
				axis_bestueckachse.st_config.r_getriebefaktor := 1.0;
				axis_bestueckachse.st_config.i16_achstyp := RUND;
				axis_bestueckachse.st_config.i16_meld_startindex := 1000;
				axis_bestueckachse.st_config.s_beschreibung := ' ';
				axis_bestueckachse.st_config.s_instanz_name := 'Bestückachse';
				axis_bestueckachse.st_config.ui16_ethercat_slave_id := 40;
				axis_bestueckachse.st_config.ui16_ethercat_adr := 1010;
				axis_bestueckachse.st_config.b_config_fertig := TRUE;
				(* Z-Achse *)
				axis_z_achse.st_config.b_config_fertig := FALSE;
				axis_z_achse.st_config.b_limitsensor_negativ_vorhanden := TRUE;
				axis_z_achse.st_config.b_limitsensor_positiv_vorhanden := TRUE;
				axis_z_achse.st_config.b_refsensor_vorhanden := FALSE;
				axis_z_achse.st_config.r_getriebefaktor := 1.0;
				axis_z_achse.st_config.i16_achstyp := LINEAR;
				axis_z_achse.st_config.i16_meld_startindex := 1100;
				axis_z_achse.st_config.s_beschreibung := ' ';
				axis_z_achse.st_config.s_instanz_name := 'Z-Achse';
				axis_z_achse.st_config.ui16_ethercat_slave_id := 7;
				axis_z_achse.st_config.ui16_ethercat_adr := 1012;
				axis_z_achse.st_config.b_config_fertig := TRUE;

			RASTERFOLIE:
				(* Virtuelle Masterachse *)
				axis_virt_master.st_config.b_config_fertig := FALSE;
				axis_virt_master.st_config.b_limitsensor_negativ_vorhanden := FALSE;
				axis_virt_master.st_config.b_limitsensor_positiv_vorhanden := FALSE;
				axis_virt_master.st_config.b_refsensor_vorhanden := FALSE;
				axis_virt_master.st_config.r_getriebefaktor := 1.0;
				axis_virt_master.st_config.i16_achstyp := RUND_VIRTUELL;
				axis_virt_master.st_config.i16_meld_startindex := 1400;
				axis_virt_master.st_config.s_beschreibung := ' ';
				axis_virt_master.st_config.s_instanz_name := 'Virtuelle Masterachse';
				axis_virt_master.st_config.ui16_ethercat_slave_id := 0;
				axis_virt_master.st_config.ui16_ethercat_adr := 0;
				axis_virt_master.st_config.b_config_fertig := TRUE;
				(* Bestueckachse *)
				axis_bestueckachse.st_config.b_config_fertig := FALSE;
				axis_bestueckachse.st_config.b_limitsensor_negativ_vorhanden := FALSE;
				axis_bestueckachse.st_config.b_limitsensor_positiv_vorhanden := FALSE;
				axis_bestueckachse.st_config.b_refsensor_vorhanden := FALSE;
				axis_bestueckachse.st_config.r_getriebefaktor := 1.0;
				axis_bestueckachse.st_config.i16_achstyp := RUND;
				axis_bestueckachse.st_config.i16_meld_startindex := 1000;
				axis_bestueckachse.st_config.s_beschreibung := ' ';
				axis_bestueckachse.st_config.s_instanz_name := 'Bestückachse';
				axis_bestueckachse.st_config.ui16_ethercat_slave_id := 2;
				axis_bestueckachse.st_config.ui16_ethercat_adr := 1010;
				axis_bestueckachse.st_config.b_config_fertig := TRUE;
				(* Z-Achse *)
				axis_z_achse.st_config.b_config_fertig := FALSE;
				axis_z_achse.st_config.b_limitsensor_negativ_vorhanden := TRUE;
				axis_z_achse.st_config.b_limitsensor_positiv_vorhanden := TRUE;
				axis_z_achse.st_config.b_refsensor_vorhanden := FALSE;
				axis_z_achse.st_config.r_getriebefaktor := 1.0;
				axis_z_achse.st_config.i16_achstyp := LINEAR;
				axis_z_achse.st_config.i16_meld_startindex := 1100;
				axis_z_achse.st_config.s_beschreibung := ' ';
				axis_z_achse.st_config.s_instanz_name := 'Z-Achse';
				axis_z_achse.st_config.ui16_ethercat_slave_id := 2;
				axis_z_achse.st_config.ui16_ethercat_adr := 1012;
				axis_z_achse.st_config.b_config_fertig := TRUE;
				(* Y-Achse *)
				axis_y_achse.st_config.b_config_fertig := FALSE;
				axis_y_achse.st_config.b_limitsensor_negativ_vorhanden := TRUE;
				axis_y_achse.st_config.b_limitsensor_positiv_vorhanden := TRUE;
				axis_y_achse.st_config.b_refsensor_vorhanden := FALSE;
				axis_y_achse.st_config.r_getriebefaktor := 1.0;
				axis_y_achse.st_config.i16_achstyp := LINEAR;
				axis_y_achse.st_config.i16_meld_startindex := 1200;
				axis_y_achse.st_config.s_beschreibung := ' ';
				axis_y_achse.st_config.s_instanz_name := 'Y-Achse';
				axis_y_achse.st_config.ui16_ethercat_slave_id := 2;
				axis_y_achse.st_config.ui16_ethercat_adr := 1012;
				axis_y_achse.st_config.b_config_fertig := TRUE;

		END_CASE
ELSE
	b_config_fertig := TRUE;
END_IF

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Initialisierung/Startup' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Datainit_Fast_Zylinder
VAR
	b_config_fertig			: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
CASE gst_datensatz.st_md.i16_typ_zelle OF
	KEINE_ZELLE:
 		;
	BESTUECKZELLE_1700:
		IF 	NOT zyl_bandfaenger.fb.st_config.b_config_fertig OR
			NOT zyl_bandklemmen.fb.st_config.b_config_fertig OR
			NOT zyl_oelen_unten.fb.st_config.b_config_fertig OR
			NOT zyl_oelen_oben.fb.st_config.b_config_fertig THEN


					(*Banölen unten*)
					zyl_oelen_unten.fb.st_config.b_config_fertig := FALSE;
					zyl_oelen_unten.fb.st_config.b_endlage1_aktiv := FALSE;
					zyl_oelen_unten.fb.st_config.b_endlage2_aktiv := FALSE;
					zyl_oelen_unten.fb.st_config.b_sensor1_aktiv := FALSE;
					zyl_oelen_unten.fb.st_config.b_sensor2_aktiv := FALSE;
					zyl_oelen_unten.fb.st_config.i16_gruppe := 1;
					zyl_oelen_unten.fb.st_config.i16_identnummer :=45;
					zyl_oelen_unten.fb.st_config.i16_meld_startindex := 2880;
					zyl_oelen_unten.fb.st_config.str_beschreibung := ' ';
					zyl_oelen_unten.fb.st_config.str_instanz_name := 'Bandoelen unten';
					zyl_oelen_unten.fb.st_config.str_zylinder_typ := '1V2E_EIN_AUS'; (*1V2E_EIN_AUS*)
					zyl_oelen_unten.fb.st_config.t_ein_aus_fahrzeit := t#100ms;
					zyl_oelen_unten.fb.st_config.t_ueberwachungszeit := t#1500ms;
					zyl_oelen_unten.fb.st_config.i16_tzk_faktor_ausfahren := 100;
					zyl_oelen_unten.fb.st_config.i16_tzk_faktor_einfahren := 100;
					zyl_oelen_unten.fb.st_config.b_config_fertig := TRUE;

					(*Banölen oben*)
					zyl_oelen_oben.fb.st_config.b_config_fertig := FALSE;
					zyl_oelen_oben.fb.st_config.b_endlage1_aktiv := FALSE;
					zyl_oelen_oben.fb.st_config.b_endlage2_aktiv := FALSE;
					zyl_oelen_oben.fb.st_config.b_sensor1_aktiv := FALSE;
					zyl_oelen_oben.fb.st_config.b_sensor2_aktiv := FALSE;
					zyl_oelen_oben.fb.st_config.i16_gruppe := 1;
					zyl_oelen_oben.fb.st_config.i16_identnummer :=46 ;
					zyl_oelen_oben.fb.st_config.i16_meld_startindex := 2900;
					zyl_oelen_oben.fb.st_config.str_beschreibung := ' ';
					zyl_oelen_oben.fb.st_config.str_instanz_name := 'Bandoelen oben';
					zyl_oelen_oben.fb.st_config.str_zylinder_typ := '1V2E_EIN_AUS'; (*1V2E_EIN_AUS*)
					zyl_oelen_oben.fb.st_config.t_ein_aus_fahrzeit := t#100ms;
					zyl_oelen_oben.fb.st_config.t_ueberwachungszeit := t#1500ms;
					zyl_oelen_oben.fb.st_config.i16_tzk_faktor_ausfahren := 100;
					zyl_oelen_oben.fb.st_config.i16_tzk_faktor_einfahren := 100;
					zyl_oelen_oben.fb.st_config.b_config_fertig := TRUE;

				(* Abhängig vom Bandwechseltyp *)
				CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
					KEIN_EINZUG:
						;

					STANDARD_2FACH_V2:
						;

					BANDWECHSLER_V2:
						(* 1700: Bandfaenger *)
						zyl_bandfaenger.fb.st_config.b_config_fertig := FALSE;
						zyl_bandfaenger.fb.st_config.b_endlage1_aktiv := FALSE;
						zyl_bandfaenger.fb.st_config.b_endlage2_aktiv := FALSE;
						zyl_bandfaenger.fb.st_config.b_sensor1_aktiv := FALSE;
						zyl_bandfaenger.fb.st_config.b_sensor2_aktiv := FALSE;
						zyl_bandfaenger.fb.st_config.i16_gruppe := 1;
						zyl_bandfaenger.fb.st_config.i16_identnummer := 5;
						zyl_bandfaenger.fb.st_config.i16_meld_startindex := 2080;
						zyl_bandfaenger.fb.st_config.str_beschreibung := ' ';
						zyl_bandfaenger.fb.st_config.str_instanz_name := 'Bandfänger';
						zyl_bandfaenger.fb.st_config.str_zylinder_typ := '1V0E_NO';
						zyl_bandfaenger.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
						zyl_bandfaenger.fb.st_config.t_ueberwachungszeit := t#500ms;
						zyl_bandfaenger.fb.st_config.i16_tzk_faktor_ausfahren := 100;
						zyl_bandfaenger.fb.st_config.i16_tzk_faktor_einfahren := 100;
						zyl_bandfaenger.fb.st_config.b_config_fertig := TRUE;
						(* 1700: Bandklemmen *)
						zyl_bandklemmen.fb.st_config.b_config_fertig := FALSE;
						zyl_bandklemmen.fb.st_config.b_endlage1_aktiv := FALSE;
						zyl_bandklemmen.fb.st_config.b_endlage2_aktiv := FALSE;
						zyl_bandklemmen.fb.st_config.b_sensor1_aktiv := FALSE;
						zyl_bandklemmen.fb.st_config.b_sensor2_aktiv := FALSE;
						zyl_bandklemmen.fb.st_config.i16_gruppe := 1;
						zyl_bandklemmen.fb.st_config.i16_identnummer := 6;
						zyl_bandklemmen.fb.st_config.i16_meld_startindex := 2100;
						zyl_bandklemmen.fb.st_config.str_beschreibung := ' ';
						zyl_bandklemmen.fb.st_config.str_instanz_name := 'Bandklemmen';
						zyl_bandklemmen.fb.st_config.str_zylinder_typ := '1V0E_NO';
						zyl_bandklemmen.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
						zyl_bandklemmen.fb.st_config.t_ueberwachungszeit := t#500ms;
						zyl_bandklemmen.fb.st_config.i16_tzk_faktor_ausfahren := 100;
						zyl_bandklemmen.fb.st_config.i16_tzk_faktor_einfahren := 100;
						zyl_bandklemmen.fb.st_config.b_config_fertig := TRUE;

					SERVO:
						;
				END_CASE
		ELSE
			b_config_fertig := FALSE;
		END_IF

	BESTUECKZELLE_1720:
		IF 	NOT zyl_bandfaenger_li.fb.st_config.b_config_fertig OR
			NOT zyl_bandfaenger_re.fb.st_config.b_config_fertig OR
			NOT zyl_bandklemmen_li.fb.st_config.b_config_fertig OR
			NOT zyl_bandklemmen_re.fb.st_config.b_config_fertig
			THEN
				(* Abhängig vom Bandwechseltyp *)
				CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
					KEIN_EINZUG:
						;

					STANDARD_2FACH_V2:
						(* 1720: Bandfaenger links *)
						zyl_bandfaenger_li.fb.st_config.b_config_fertig := FALSE;
						zyl_bandfaenger_li.fb.st_config.b_endlage1_aktiv := FALSE;
						zyl_bandfaenger_li.fb.st_config.b_endlage2_aktiv := FALSE;
						zyl_bandfaenger_li.fb.st_config.b_sensor1_aktiv := FALSE;
						zyl_bandfaenger_li.fb.st_config.b_sensor2_aktiv := FALSE;
						zyl_bandfaenger_li.fb.st_config.i16_gruppe := 1;
						zyl_bandfaenger_li.fb.st_config.i16_identnummer := 1;
						zyl_bandfaenger_li.fb.st_config.i16_meld_startindex := 2000;
						zyl_bandfaenger_li.fb.st_config.str_beschreibung := ' ';
						zyl_bandfaenger_li.fb.st_config.str_instanz_name := 'Bandfänger links';
						zyl_bandfaenger_li.fb.st_config.str_zylinder_typ := '1V0E_NO';
						zyl_bandfaenger_li.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
						zyl_bandfaenger_li.fb.st_config.t_ueberwachungszeit := t#500ms;
						zyl_bandfaenger_li.fb.st_config.i16_tzk_faktor_ausfahren := 100;
						zyl_bandfaenger_li.fb.st_config.i16_tzk_faktor_einfahren := 100;
						zyl_bandfaenger_li.fb.st_config.b_config_fertig := TRUE;
						(* 1720: Bandfaenger rechts *)
						zyl_bandfaenger_re.fb.st_config.b_config_fertig := FALSE;
						zyl_bandfaenger_re.fb.st_config.b_endlage1_aktiv := FALSE;
						zyl_bandfaenger_re.fb.st_config.b_endlage2_aktiv := FALSE;
						zyl_bandfaenger_re.fb.st_config.b_sensor1_aktiv := FALSE;
						zyl_bandfaenger_re.fb.st_config.b_sensor2_aktiv := FALSE;
						zyl_bandfaenger_re.fb.st_config.i16_gruppe := 1;
						zyl_bandfaenger_re.fb.st_config.i16_identnummer := 2;
						zyl_bandfaenger_re.fb.st_config.i16_meld_startindex := 2020;
						zyl_bandfaenger_re.fb.st_config.str_beschreibung := ' ';
						zyl_bandfaenger_re.fb.st_config.str_instanz_name := 'Bandfänger rechts';
						zyl_bandfaenger_re.fb.st_config.str_zylinder_typ := '1V0E_NO';
						zyl_bandfaenger_re.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
						zyl_bandfaenger_re.fb.st_config.t_ueberwachungszeit := t#500ms;
						zyl_bandfaenger_re.fb.st_config.i16_tzk_faktor_ausfahren := 100;
						zyl_bandfaenger_re.fb.st_config.i16_tzk_faktor_einfahren := 100;
						zyl_bandfaenger_re.fb.st_config.b_config_fertig := TRUE;
						
						(* 1720: Bandklemmen links *)
						zyl_bandklemmen_li.fb.st_config.b_config_fertig := FALSE;
						zyl_bandklemmen_li.fb.st_config.b_endlage1_aktiv := FALSE;
						zyl_bandklemmen_li.fb.st_config.b_endlage2_aktiv := FALSE;
						zyl_bandklemmen_li.fb.st_config.b_sensor1_aktiv := FALSE;
						zyl_bandklemmen_li.fb.st_config.b_sensor2_aktiv := FALSE;
						zyl_bandklemmen_li.fb.st_config.i16_gruppe := 1;
						zyl_bandklemmen_li.fb.st_config.i16_identnummer := 3;
						zyl_bandklemmen_li.fb.st_config.i16_meld_startindex := 2040;
						zyl_bandklemmen_li.fb.st_config.str_beschreibung := ' ';
						zyl_bandklemmen_li.fb.st_config.str_instanz_name := 'Bandklemmen links';
						zyl_bandklemmen_li.fb.st_config.str_zylinder_typ := '1V0E_NO';
						zyl_bandklemmen_li.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
						zyl_bandklemmen_li.fb.st_config.t_ueberwachungszeit := t#500ms;
						zyl_bandklemmen_li.fb.st_config.i16_tzk_faktor_ausfahren := 100;
						zyl_bandklemmen_li.fb.st_config.i16_tzk_faktor_einfahren := 100;
						zyl_bandklemmen_li.fb.st_config.b_config_fertig := TRUE;
						(* 1720: Bandklemmen rechts *)
						zyl_bandklemmen_re.fb.st_config.b_config_fertig := FALSE;
						zyl_bandklemmen_re.fb.st_config.b_endlage1_aktiv := FALSE;
						zyl_bandklemmen_re.fb.st_config.b_endlage2_aktiv := FALSE;
						zyl_bandklemmen_re.fb.st_config.b_sensor1_aktiv := FALSE;
						zyl_bandklemmen_re.fb.st_config.b_sensor2_aktiv := FALSE;
						zyl_bandklemmen_re.fb.st_config.i16_gruppe := 1;
						zyl_bandklemmen_re.fb.st_config.i16_identnummer := 4;
						zyl_bandklemmen_re.fb.st_config.i16_meld_startindex := 2060;
						zyl_bandklemmen_re.fb.st_config.str_beschreibung := ' ';
						zyl_bandklemmen_re.fb.st_config.str_instanz_name := 'Bandklemmen rechts';
						zyl_bandklemmen_re.fb.st_config.str_zylinder_typ := '1V0E_NO';
						zyl_bandklemmen_re.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
						zyl_bandklemmen_re.fb.st_config.t_ueberwachungszeit := t#500ms;
						zyl_bandklemmen_re.fb.st_config.i16_tzk_faktor_ausfahren := 100;
						zyl_bandklemmen_re.fb.st_config.i16_tzk_faktor_einfahren := 100;
						zyl_bandklemmen_re.fb.st_config.b_config_fertig := TRUE;
				
					BANDWECHSLER_V2:
						;

					SERVO:
						;
				END_CASE;
		ELSE
			b_config_fertig := FALSE;
		END_IF

	RASTERFOLIE:
		;
END_CASE




END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Initialisierung/Startup' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Datainit_Stationen
VAR
	b_config_fertig			: BOOL := FALSE;
	i						: INT := 0;
	Index					: INT := 0;
END_VAR
(* @END_DECLARATION := '0' *)
IF	NOT betriebsarten.st_config.b_config_fertig OR
	NOT betriebsfreigaben.st_config.b_config_fertig OR
	NOT stoerungen_quittieren.st_config.b_config_fertig OR
	NOT bandeinzug_kontroller.st_config.b_config_fertig OR
	NOT wt_transport_kontroller.st_config.b_config_fertig OR
	NOT wt_transport_beladen.st_config.b_config_fertig OR
	NOT wt_transport_abgabe.st_config.b_config_fertig OR
	NOT routing_backpanel.st_config.b_config_fertig OR
	NOT routing_nachbarpc.st_config.b_config_fertig OR
	NOT UPS.st_config.b_config_fertig OR
	NOT haspel_kontroller.st_config.b_config_fertig OR
	NOT haspel_li.fb.st_config.b_config_fertig OR
	NOT haspel_re.fb.st_config.b_config_fertig OR
	NOT hublift_links.st_config.b_config_fertig OR
	NOT hublift_rechts.st_config.b_config_fertig OR
	NOT wkz_absicherung.st_config.b_config_fertig OR
	NOT stueckzahlen.fb.st_config.b_config_fertig OR
	NOT bandwechsel_kontroller.st_config.b_config_fertig OR
	NOT bandspruehoeler.st_config.b_config_fertig OR
	NOT einpresskraft_kontroller.st_config.b_config_fertig OR
	NOT kraftmessdose.fb.st_config.b_config_fertig OR
	NOT nockenschaltwerk_bestueckachse.st_config.b_config_fertig OR
	NOT safety.st_config.b_config_fertig OR
	NOT xml_server.st_config.b_config_fertig OR
	NOT fb_edit_mfps_bestuecken_z.st_config.b_config_fertig OR
	NOT fb_edit_mfps_bestuecken_y.st_config.b_config_fertig OR
	NOT fb_edit_mfps_yz_tisch.st_config.b_config_fertig OR
	NOT fb_camtable_bestueckachse.st_config.b_config_fertig OR
	NOT fb_edit_mfps_bestuecken_b.st_config.b_config_fertig OR
	NOT bbgen.st_config.b_config_fertig OR
	NOT barcode.fb.st_config.b_config_fertig OR
	NOT balluff_tag_reader.fb.st_config.b_config_fertig OR
	NOT wt_transport_warteposition_1720.st_config.b_config_fertig OR
	NOT wt_transport_beladen_1720.st_config.b_config_fertig OR
	NOT rasterfolienmontage.st_config.b_config_fertig OR
	NOT rasterfolieneinzug.st_config.b_config_fertig OR
	NOT Lesen_Schreiben_Tag.st_config.b_config_fertig OR
	NOT Service.st_config.b_config_fertig OR
	NOT ST_TouchProbe.st_config.b_config_fertig OR
	NOT wt_transport_warteposition_1700.st_config.b_config_fertig OR
	NOT wt_transport_beladen_achse_1700.st_config.b_config_fertig OR
	NOT EtherCatDiag[1].st_config.b_config_fertig
	THEN
		(* Betriebsarten *)
		betriebsarten.st_config.b_config_fertig := FALSE;
		betriebsarten.st_config.b_station_aktiv := TRUE;
		betriebsarten.st_config.i16_meld_startindex := 20;
		betriebsarten.st_config.str_beschreibung := ' ';
		betriebsarten.st_config.str_instanz_name := 'Betriebsarten';
		betriebsarten.st_config.b_config_fertig := TRUE;
		
		(* Betriebsfreigaben *)
		betriebsfreigaben.st_config.b_config_fertig := FALSE;
		betriebsfreigaben.st_config.b_station_aktiv := TRUE;
		betriebsfreigaben.st_config.i16_meld_startindex := 40;
		betriebsfreigaben.st_config.str_beschreibung := ' ';
		betriebsfreigaben.st_config.str_instanz_name := 'Betriebsfeigaben';
		betriebsfreigaben.st_config.b_config_fertig := TRUE;
		
		(* Störungen quittieren *)
		stoerungen_quittieren.st_config.b_config_fertig := FALSE;
		stoerungen_quittieren.st_config.b_station_aktiv := TRUE;
		stoerungen_quittieren.st_config.i16_meld_startindex := 60;
		stoerungen_quittieren.st_config.str_beschreibung := ' ';
		stoerungen_quittieren.st_config.str_instanz_name := 'Störungen quittieren';
		stoerungen_quittieren.st_config.b_config_fertig := TRUE;

		(* Bandeinzugskontroller *)
		bandeinzug_kontroller.st_config.b_config_fertig := FALSE;
		bandeinzug_kontroller.st_config.b_station_aktiv := TRUE;
		bandeinzug_kontroller.st_config.i16_meld_startindex := 80;
		bandeinzug_kontroller.st_config.str_beschreibung := ' ';
		bandeinzug_kontroller.st_config.str_instanz_name := 'Bandeinzugkontroller';
		bandeinzug_kontroller.st_config.b_config_fertig := TRUE;
		
		(* WT-Transport Kontroller *)
		wt_transport_kontroller.st_config.b_config_fertig := FALSE;
		wt_transport_kontroller.st_config.i16_meld_startindex := 100;
		wt_transport_kontroller.st_config.str_beschreibung := ' ';
		wt_transport_kontroller.st_config.str_instanz_name := 'WT-Transport Kontroller';
		wt_transport_kontroller.st_config.b_config_fertig := TRUE;
		
		(* WT-Transport Beladestation*)
		wt_transport_beladen.st_config.b_config_fertig := FALSE;
		wt_transport_beladen.st_config.i16_meld_startindex := 120;
		wt_transport_beladen.st_config.str_beschreibung := ' ';
		wt_transport_beladen.st_config.str_instanz_name := 'WT-Transport Beladestation';
		wt_transport_beladen.st_config.b_config_fertig := TRUE;
		
		(* WT-Transport Abgabestation *)
		wt_transport_abgabe.st_config.b_config_fertig := FALSE;
		wt_transport_abgabe.st_config.i16_meld_startindex := 140;
		wt_transport_abgabe.st_config.str_beschreibung := ' ';
		wt_transport_abgabe.st_config.str_instanz_name := 'WT-Transport Abgabestation';
		wt_transport_abgabe.st_config.b_config_fertig := TRUE;
		
		(* Routing Backpanel *)
		routing_backpanel.st_config.b_config_fertig := FALSE;
		routing_backpanel.st_config.i16_meld_startindex := 160;
		routing_backpanel.st_config.str_beschreibung := ' ';
		routing_backpanel.st_config.str_instanz_name := 'Routing Backpanel';
		routing_backpanel.st_config.b_config_fertig := TRUE;
		
		(* Routing Nachbar-PCs *)
		routing_nachbarpc.st_config.b_config_fertig := FALSE;
		routing_nachbarpc.st_config.i16_meld_startindex := 180;
		routing_nachbarpc.st_config.str_beschreibung := ' ';
		routing_nachbarpc.st_config.str_instanz_name := 'Routing Nachbar-PCs';
		routing_nachbarpc.st_config.b_config_fertig := TRUE;
		
		(* Haspelkontroller *)
		haspel_kontroller.st_config.b_config_fertig := FALSE;
		haspel_kontroller.st_config.b_station_aktiv := TRUE;
		haspel_kontroller.st_config.i16_meld_startindex := 200;
		haspel_kontroller.st_config.str_beschreibung := ' ';
		haspel_kontroller.st_config.str_instanz_name := 'Haspelkontroller';
		haspel_kontroller.t_abschaltzeit_motor := t#60s;
		haspel_kontroller.b_drehrichtung_antrieb_links := FALSE;
		haspel_kontroller.st_config.b_config_fertig := TRUE;

		(* Haspel links *)
		haspel_li.fb.st_config.b_config_fertig := FALSE;
		haspel_li.fb.st_config.b_station_aktiv := TRUE;
		haspel_li.fb.st_config.i16_meld_startindex := 220;
		haspel_li.fb.st_config.str_beschreibung := ' ';
		haspel_li.fb.st_config.str_instanz_name := 'Haspel links';
		haspel_li.fb.t_wartezeit_bandende := t#2s;
		haspel_li.fb.st_config.b_config_fertig := TRUE;
		
		(* Haspel rechts *)
		haspel_re.fb.st_config.b_config_fertig := FALSE;
		haspel_re.fb.st_config.b_station_aktiv := TRUE;
		haspel_re.fb.st_config.i16_meld_startindex := 240;
		haspel_re.fb.st_config.str_beschreibung := ' ';
		haspel_re.fb.st_config.str_instanz_name := 'Haspel rechts';
		haspel_re.fb.t_wartezeit_bandende := t#2s;
		haspel_re.fb.st_config.b_config_fertig := TRUE;
		
		(* Hublift links *)
		hublift_links.st_config.b_config_fertig := FALSE;
		hublift_links.st_config.i16_meld_startindex := 280;
		hublift_links.st_config.str_beschreibung := ' ';
		hublift_links.st_config.str_instanz_name := 'Hublift links';
		hublift_links.st_config.b_config_fertig := TRUE;
		
		(* Hublift rechts *)
		hublift_rechts.st_config.b_config_fertig := FALSE;
		hublift_rechts.st_config.i16_meld_startindex := 300;
		hublift_rechts.st_config.str_beschreibung := ' ';
		hublift_rechts.st_config.str_instanz_name := 'Hublift rechts';
		hublift_rechts.st_config.b_config_fertig := TRUE;
		
		(* Werkzeugabsicherung *)
		wkz_absicherung.st_config.b_config_fertig := FALSE;
		wkz_absicherung.st_config.b_station_aktiv := TRUE;
		wkz_absicherung.st_config.i16_meld_startindex := 320;
		wkz_absicherung.st_config.str_beschreibung := ' ';
		wkz_absicherung.st_config.str_instanz_name := 'Werkzeugabsicherung';
		wkz_absicherung.st_config.b_config_fertig := TRUE;
		
		(* Stückzahlen *)
		stueckzahlen.fb.st_config.b_config_fertig := FALSE;
		stueckzahlen.fb.st_config.b_station_aktiv := TRUE;
		stueckzahlen.fb.st_config.i16_meld_startindex := 340;
		stueckzahlen.fb.st_config.str_beschreibung := ' ';
		stueckzahlen.fb.st_config.str_instanz_name := 'Stueckzahlen';
		stueckzahlen.fb.st_config.b_config_fertig := TRUE;
		
		(* Bandwechselkontroller *)
		bandwechsel_kontroller.st_config.b_config_fertig := FALSE;
		bandwechsel_kontroller.st_config.b_station_aktiv := TRUE;
		bandwechsel_kontroller.st_config.i16_meld_startindex := 360;
		bandwechsel_kontroller.st_config.str_beschreibung := ' ';
		bandwechsel_kontroller.st_config.str_instanz_name := 'Bandwechselkontroller';
		bandwechsel_kontroller.st_config.b_config_fertig := TRUE;
		
		(* Bandsprühöler *)
		bandspruehoeler.st_config.b_config_fertig := FALSE;
		bandspruehoeler.st_config.b_station_aktiv := TRUE;
		bandspruehoeler.st_config.i16_meld_startindex := 380;
		bandspruehoeler.st_config.str_beschreibung := ' ';
		bandspruehoeler.st_config.str_instanz_name := 'Bandsprühöler';
		bandspruehoeler.st_config.b_config_fertig := TRUE;

		(* UPS Überwachung *)
		UPS.st_config.b_config_fertig := FALSE;
		UPS.st_config.b_station_aktiv := TRUE;
		UPS.st_config.i16_meld_startindex := 440;		(*-445*)
		UPS.st_config.str_beschreibung := ' ';
		UPS.st_config.str_instanz_name := 'UPS Überwachung';
		UPS.st_config.b_config_fertig := TRUE;

		(*Einpresskraftkontroller *)
		einpresskraft_kontroller.st_config.b_config_fertig := FALSE;
		einpresskraft_kontroller.st_config.b_station_aktiv := TRUE;
		einpresskraft_kontroller.st_config.i16_meld_startindex := 460;
		einpresskraft_kontroller.st_config.str_beschreibung := ' ';
		einpresskraft_kontroller.st_config.str_instanz_name := 'Einpresskraftkontroller';

		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				gst_datensatz.st_band.st_einpressen.st_einstellungen.enu_modus := KEIN_MODUS;
			BESTUECKZELLE_1700:
				gst_datensatz.st_band.st_einpressen.st_einstellungen.enu_modus := F_MAXWERT;
			BESTUECKZELLE_1720:
				gst_datensatz.st_band.st_einpressen.st_einstellungen.enu_modus := F_MAXWERT;
			RASTERFOLIE:
				gst_datensatz.st_band.st_einpressen.st_einstellungen.enu_modus := KEIN_MODUS;
		END_CASE

		einpresskraft_kontroller.st_config.b_config_fertig := TRUE;
		
		(* Kraftmessdose Kanal 1*)
		kraftmessdose.fb.st_config.b_config_fertig := FALSE;
		kraftmessdose.fb.st_config.b_station_aktiv := TRUE;
		kraftmessdose.fb.st_config.i16_meld_startindex := 480;
		kraftmessdose.fb.st_config.str_beschreibung := ' ';
		kraftmessdose.fb.st_config.str_instanz_name := 'Kraftmessdose Kanal 1';
		kraftmessdose.fb.st_config.b_config_fertig := TRUE;
		
		(* Nockenschaltwerk Bestückachse *)
		nockenschaltwerk_bestueckachse.st_config.b_config_fertig := FALSE;
		nockenschaltwerk_bestueckachse.st_config.b_station_aktiv := TRUE;
		nockenschaltwerk_bestueckachse.st_config.i16_meld_startindex := 500;
		nockenschaltwerk_bestueckachse.st_config.str_beschreibung := ' ';
		nockenschaltwerk_bestueckachse.st_config.str_instanz_name := 'Nockenschaltwerk Bestückachse';
		nockenschaltwerk_bestueckachse.st_config.b_config_fertig := TRUE;
		
		(* Nockenschaltwerk Z-Achse *)
		(* 520 *)
		
		(* Nockenschaltwerk Y-Achse *)
		(* 540 *)
		
		(* Frei *)
		(* 560 *)

		(* Safety *)
		safety.st_config.b_config_fertig := FALSE;
		safety.st_config.b_station_aktiv := TRUE;
		safety.st_config.i16_meld_startindex := 580;
		safety.st_config.str_beschreibung := ' ';
		safety.st_config.str_instanz_name := 'Safety';
		safety.st_config.b_config_fertig := TRUE;
		
		(* XML-Server *)
		xml_server.st_config.b_config_fertig := FALSE;
		xml_server.st_config.b_station_aktiv := TRUE;
		xml_server.st_config.i16_meld_startindex := 620;
		xml_server.st_config.str_beschreibung := ' ';
		xml_server.st_config.str_instanz_name := 'XML-Server';
		xml_server.st_config.b_config_fertig := TRUE;

		(* Kurvenscheibeneditor *)
		fb_edit_mfps_bestuecken_z.st_config.b_config_fertig := FALSE;
		fb_edit_mfps_bestuecken_z.st_config.b_station_aktiv := TRUE;
		fb_edit_mfps_bestuecken_z.st_config.i16_meld_startindex := 640;
		fb_edit_mfps_bestuecken_z.st_config.str_beschreibung := ' ';
		fb_edit_mfps_bestuecken_z.st_config.str_instanz_name := 'Kurvenscheibeneditor Bestücken Z-Achse';
		fb_edit_mfps_bestuecken_z.st_config.b_config_fertig := TRUE;
		
		fb_edit_mfps_bestuecken_y.st_config.b_config_fertig := FALSE;
		fb_edit_mfps_bestuecken_y.st_config.b_station_aktiv := TRUE;
		fb_edit_mfps_bestuecken_y.st_config.i16_meld_startindex := 660;
		fb_edit_mfps_bestuecken_y.st_config.str_beschreibung := ' ';
		fb_edit_mfps_bestuecken_y.st_config.str_instanz_name := 'Kurvenscheibeneditor Bestücken Y-Achse';
		fb_edit_mfps_bestuecken_y.st_config.b_config_fertig := TRUE;
		
		fb_edit_mfps_yz_tisch.st_config.b_config_fertig := FALSE;
		fb_edit_mfps_yz_tisch.st_config.b_station_aktiv := TRUE;
		fb_edit_mfps_yz_tisch.st_config.i16_meld_startindex := 680;
		fb_edit_mfps_yz_tisch.st_config.str_beschreibung := ' ';
		fb_edit_mfps_yz_tisch.st_config.str_instanz_name := 'Kurvenscheibeneditor YZ-Tisch';
		fb_edit_mfps_yz_tisch.st_config.b_config_fertig := TRUE;

		fb_edit_mfps_bestuecken_b.st_config.b_config_fertig := FALSE;
		fb_edit_mfps_bestuecken_b.st_config.b_station_aktiv := TRUE;
		fb_edit_mfps_bestuecken_b.st_config.i16_meld_startindex := 860;
		fb_edit_mfps_bestuecken_b.st_config.str_beschreibung := ' ';
		fb_edit_mfps_bestuecken_b.st_config.str_instanz_name := 'Kurvenscheibeneditor Bestücken B-Achse';
		fb_edit_mfps_bestuecken_b.st_config.b_config_fertig := TRUE;

		fb_camtable_bestueckachse.st_config.b_config_fertig := FALSE;
		fb_camtable_bestueckachse.st_config.b_station_aktiv := TRUE;
		fb_camtable_bestueckachse.st_config.i16_meld_startindex := 880;
		fb_camtable_bestueckachse.st_config.str_beschreibung := ' ';
		fb_camtable_bestueckachse.st_config.str_instanz_name := 'Kurvenscheibeneditor Bestückachse';
		fb_camtable_bestueckachse.st_config.b_config_fertig := TRUE;

		(* Bestückbildgenerierung *)
		bbgen.st_config.b_config_fertig := FALSE;
		bbgen.st_config.b_station_aktiv := TRUE;
		bbgen.st_config.i16_meld_startindex := 700;
		bbgen.st_config.str_beschreibung := ' ';
		bbgen.st_config.str_instanz_name := 'Bestückbildgenerierung';
		bbgen.st_config.b_config_fertig := TRUE;
		
		(* Barcodereader *)
		barcode.fb.st_config.b_config_fertig := FALSE;
		barcode.fb.st_config.b_station_aktiv := TRUE;
		barcode.fb.st_config.i16_meld_startindex := 720;
		barcode.fb.st_config.str_beschreibung := ' ';
		barcode.fb.st_config.str_instanz_name := 'Barcodereader';
		barcode.fb.st_config.b_config_fertig := TRUE;
		
		(* Ballufftagreader *)
		balluff_tag_reader.fb.st_config.b_config_fertig := FALSE;
		balluff_tag_reader.fb.st_config.b_station_aktiv := TRUE;
		balluff_tag_reader.fb.st_config.i16_meld_startindex := 740;
		balluff_tag_reader.fb.st_config.str_beschreibung := ' ';
		balluff_tag_reader.fb.st_config.str_instanz_name := 'Ballufftagreader';
		balluff_tag_reader.fb.st_config.b_config_fertig := TRUE;

		(* WT-Transport Warteposition 1720 *)
		wt_transport_warteposition_1720.st_config.b_config_fertig := FALSE;
		wt_transport_warteposition_1720.st_config.i16_meld_startindex := 760;
		wt_transport_warteposition_1720.st_config.str_beschreibung := ' ';
		wt_transport_warteposition_1720.st_config.str_instanz_name := 'WT-Transport Warteposition 1720';
		wt_transport_warteposition_1720.st_config.b_config_fertig := TRUE;
		
		(* WT-Transport Beladestation 1720 *)
		wt_transport_beladen_1720.st_config.b_config_fertig := FALSE;
		wt_transport_beladen_1720.st_config.i16_meld_startindex := 780;
		wt_transport_beladen_1720.st_config.str_beschreibung := ' ';
		wt_transport_beladen_1720.st_config.str_instanz_name := 'WT-Transport Beladestation 1720';
		wt_transport_beladen_1720.st_config.b_config_fertig := TRUE;
		
		(* Rasterfolienmontge *)
		rasterfolienmontage.st_config.b_config_fertig := FALSE;
		rasterfolienmontage.st_config.b_station_aktiv := TRUE;
		rasterfolienmontage.st_config.i16_meld_startindex := 800;
		rasterfolienmontage.st_config.str_beschreibung := ' ';
		rasterfolienmontage.st_config.str_instanz_name := 'Rasterfolienmontge';
		rasterfolienmontage.st_config.b_config_fertig := TRUE;
		
		(* Rasterfolieneinzug *)
		rasterfolieneinzug.st_config.b_config_fertig := FALSE;
		rasterfolieneinzug.st_config.b_station_aktiv := TRUE;
		rasterfolieneinzug.st_config.i16_meld_startindex := 820;
		rasterfolieneinzug.st_config.str_beschreibung := ' ';
		rasterfolieneinzug.st_config.str_instanz_name := 'Rasterfolieneinzug';
		rasterfolieneinzug.st_config.b_config_fertig := TRUE;

		(*Tag lesen und schreiben *)
		Lesen_Schreiben_Tag.st_config.b_config_fertig := FALSE;
		Lesen_Schreiben_Tag.st_config.b_station_aktiv := TRUE;
		Lesen_Schreiben_Tag.st_config.i16_meld_startindex := 840;
		Lesen_Schreiben_Tag.st_config.str_beschreibung := ' ';
		Lesen_Schreiben_Tag.st_config.str_instanz_name := 'Tag lesen und schreiben';
		Lesen_Schreiben_Tag.st_config.b_config_fertig := TRUE;

		(* Wartung *)
		wartung.st_config.b_config_fertig := FALSE;
		wartung.st_config.b_station_aktiv := TRUE;
		wartung.st_config.i16_meld_startindex := 920;
		wartung.st_config.str_beschreibung := ' ';
		wartung.st_config.str_instanz_name := 'Wartung';
		wartung.st_config.b_config_fertig := TRUE;

		(*Service *)
		Service.st_config.b_config_fertig := FALSE;
		Service.st_config.b_station_aktiv := TRUE;
		Service.st_config.i16_meld_startindex := 900;
		Service.st_config.str_beschreibung := ' ';
		Service.st_config.str_instanz_name := 'Service';
		Service.st_config.b_config_fertig := TRUE;

		(*TouchProbe *)
		ST_TouchProbe.st_config.b_config_fertig := FALSE;
		ST_TouchProbe.st_config.b_station_aktiv := TRUE;
		ST_TouchProbe.st_config.i16_meld_startindex := 940;
		ST_TouchProbe.st_config.str_beschreibung := ' ';
		ST_TouchProbe.st_config.str_instanz_name := 'TouchProbe';
		ST_TouchProbe.st_config.b_config_fertig := TRUE;

		(*AutocheckinDaten *)
		ST_AutoCheckIn.fb_AutocheckinDaten.st_config.b_config_fertig:= FALSE;
		ST_AutoCheckIn.fb_AutocheckinDaten.st_config.b_station_aktiv:= TRUE;
		ST_AutoCheckIn.fb_AutocheckinDaten.st_config.i16_meld_startindex:=	960;
		ST_AutoCheckIn.fb_AutocheckinDaten.st_config.str_beschreibung:= ' ';
		ST_AutoCheckIn.fb_AutocheckinDaten.st_config.str_instanz_name:=	'AutoCheckInDaten';
		ST_AutoCheckIn.fb_AutocheckinDaten.st_config.b_config_fertig:= TRUE;

		(* WT-Transport Warteposition Achse 1700 *)
		wt_transport_warteposition_1700.st_config.b_config_fertig := FALSE;
		wt_transport_warteposition_1700.st_config.i16_meld_startindex := 400;
		wt_transport_warteposition_1700.st_config.str_beschreibung := ' ';
		wt_transport_warteposition_1700.st_config.str_instanz_name := 'WT-Transport Warteposition 1700';
		wt_transport_warteposition_1700.st_config.b_config_fertig := TRUE;
		
		(* WT-Transport Beladestation Achse 1700 *)
		wt_transport_beladen_achse_1700.st_config.b_config_fertig := FALSE;
		wt_transport_beladen_achse_1700.st_config.i16_meld_startindex := 420;
		wt_transport_beladen_achse_1700.st_config.str_beschreibung := ' ';
		wt_transport_beladen_achse_1700.st_config.str_instanz_name := 'WT-Transport Beladestation Achse 1700';
		wt_transport_beladen_achse_1700.st_config.b_config_fertig := TRUE;

		(* EtherCAT Diagnose *)
		Index:=1;
		EtherCatDiag[Index].st_config.b_config_fertig := FALSE;
		EtherCatDiag[Index].st_config.b_station_aktiv := TRUE;
		EtherCatDiag[Index].st_config.i16_meld_startindex := 980;
		EtherCatDiag[Index].st_config.str_beschreibung := ' ';
		EtherCatDiag[Index].st_config.str_instanz_name := 'Grundmaschine';
		EtherCatDiag[Index].st_config.b_config_fertig := TRUE;

		(* EtherCAT Diagnose *)
		Index:=2;
		EtherCatDiag[Index].st_config.b_config_fertig := FALSE;
		EtherCatDiag[Index].st_config.b_station_aktiv := TRUE;
		EtherCatDiag[Index].st_config.i16_meld_startindex := 985;
		EtherCatDiag[Index].st_config.str_beschreibung := ' ';
		EtherCatDiag[Index].st_config.str_instanz_name := 'Hublift links';
		EtherCatDiag[Index].st_config.b_config_fertig := TRUE;

		(* EtherCAT Diagnose *)
		Index:=3;
		EtherCatDiag[Index].st_config.b_config_fertig := FALSE;
		EtherCatDiag[Index].st_config.b_station_aktiv := TRUE;
		EtherCatDiag[Index].st_config.i16_meld_startindex := 990;
		EtherCatDiag[Index].st_config.str_beschreibung := ' ';
		EtherCatDiag[Index].st_config.str_instanz_name := 'Hublift rechts';
		EtherCatDiag[Index].st_config.b_config_fertig := TRUE;

		(* EtherCAT Diagnose *)
		Index:=4;
		EtherCatDiag[Index].st_config.b_config_fertig := FALSE;
		EtherCatDiag[Index].st_config.b_station_aktiv := TRUE;
		EtherCatDiag[Index].st_config.i16_meld_startindex := 995;
		EtherCatDiag[Index].st_config.str_beschreibung := ' ';
		EtherCatDiag[Index].st_config.str_instanz_name := 'Bandeinzug';
		EtherCatDiag[Index].st_config.b_config_fertig := TRUE;

		(* Melde-Arrays rücksetzen *)
		FOR i := 0 TO SIZEOF (garr_stoermeldungen) / SIZEOF (garr_stoermeldungen[0]) - 1 BY 1 DO
			garr_stoermeldungen[i] := 0;
		END_FOR
		FOR i := 0 TO SIZEOF (garr_betriebsmeldungen) / SIZEOF (garr_betriebsmeldungen[0]) - 1 BY 1 DO
			garr_betriebsmeldungen[i] := 0;
		END_FOR
ELSE
	b_config_fertig := TRUE;
END_IF

		
		






END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Initialisierung/Startup' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Datainit_Zylinder
VAR
	b_config_fertig			: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
IF	NOT zyl_wt_zentrierer_tisch.fb.st_config.b_config_fertig OR
	NOT zyl_wt_stopper_tisch.fb.st_config.b_config_fertig OR
	NOT zyl_wt_stopper_auslauf.fb.st_config.b_config_fertig OR
	NOT zyl_hublift_rechts_lift.fb.st_config.b_config_fertig OR
	NOT zyl_hublift_rechts_wt_einzug.fb.st_config.b_config_fertig OR
	NOT zyl_hublift_rechts_wt_klinke.fb.st_config.b_config_fertig OR
	NOT zyl_hublift_links_lift.fb.st_config.b_config_fertig OR
	NOT zyl_hublift_links_wt_einzug.fb.st_config.b_config_fertig OR
	NOT zyl_hublift_links_wt_klinke.fb.st_config.b_config_fertig OR
	NOT zyl_hublift_links_stopper.fb.st_config.b_config_fertig OR
	NOT zyl_hublift_links_eingriffschutz.fb.st_config.b_config_fertig OR
	NOT zyl_haspel_li_heben.fb.st_config.b_config_fertig OR
	NOT zyl_haspel_li_abspulen.fb.st_config.b_config_fertig OR
	NOT zyl_haspel_li_sperren.fb.st_config.b_config_fertig OR
	NOT zyl_haspel_re_heben.fb.st_config.b_config_fertig OR
	NOT zyl_haspel_re_abspulen.fb.st_config.b_config_fertig OR
	NOT zyl_haspel_re_sperren.fb.st_config.b_config_fertig OR
	NOT zyl_haspel_verschieben.fb.st_config.b_config_fertig OR
	NOT zyl_bandeinzuege_verschieben.fb.st_config.b_config_fertig OR
	NOT zyl_bawe_vorschub.fb.st_config.b_config_fertig OR
	NOT zyl_bawe_querschub.fb.st_config.b_config_fertig OR
	NOT zyl_bawe_faenger_li.fb.st_config.b_config_fertig OR
	NOT zyl_bawe_faenger_re.fb.st_config.b_config_fertig OR
	NOT zyl_bawe_halter_li.fb.st_config.b_config_fertig OR
	NOT zyl_bawe_halter_re.fb.st_config.b_config_fertig OR
	NOT zyl_wt_stopper_einlauf.fb.st_config.b_config_fertig OR
	NOT zyl_rafo_faenger.fb.st_config.b_config_fertig OR
	NOT zyl_rafo_klemmen.fb.st_config.b_config_fertig OR
	NOT zyl_rafo_vorschub.fb.st_config.b_config_fertig OR
	NOT zyl_rafo_kamm.fb.st_config.b_config_fertig OR
	NOT zyl_rafo_vorzentrierer.fb.st_config.b_config_fertig OR
	NOT zyl_Indexier_Bestueckpos.fb.st_config.b_config_fertig OR
	NOT zyl_Indexier_Einlauf.fb.st_config.b_config_fertig
	THEN

		(* WT Zentrierzylinder am Tisch *)
		zyl_wt_zentrierer_tisch.fb.st_config.b_config_fertig := FALSE;
		zyl_wt_zentrierer_tisch.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_wt_zentrierer_tisch.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_wt_zentrierer_tisch.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_wt_zentrierer_tisch.fb.st_config.b_sensor2_aktiv := TRUE;
		zyl_wt_zentrierer_tisch.fb.st_config.i16_gruppe := 3;
		zyl_wt_zentrierer_tisch.fb.st_config.i16_identnummer := 15;
		zyl_wt_zentrierer_tisch.fb.st_config.i16_meld_startindex := 2280;
		zyl_wt_zentrierer_tisch.fb.st_config.str_beschreibung := ' ';
		zyl_wt_zentrierer_tisch.fb.st_config.str_instanz_name := 'WT Zentrierzylinder am Tisch';
		zyl_wt_zentrierer_tisch.fb.st_config.str_zylinder_typ := '2V4E_EIN_AUS';
		zyl_wt_zentrierer_tisch.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_wt_zentrierer_tisch.fb.st_config.t_ueberwachungszeit := t#1000ms;
		zyl_wt_zentrierer_tisch.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_wt_zentrierer_tisch.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_wt_zentrierer_tisch.fb.st_config.b_config_fertig := TRUE;
		
		(* WT Stoppzylinder am Tisch *)
		zyl_wt_stopper_tisch.fb.st_config.b_config_fertig := FALSE;
		zyl_wt_stopper_tisch.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_wt_stopper_tisch.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_wt_stopper_tisch.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_wt_stopper_tisch.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_wt_stopper_tisch.fb.st_config.i16_gruppe := 3;
		zyl_wt_stopper_tisch.fb.st_config.i16_identnummer := 16;
		zyl_wt_stopper_tisch.fb.st_config.i16_meld_startindex := 2300;
		zyl_wt_stopper_tisch.fb.st_config.str_beschreibung := ' ';
		zyl_wt_stopper_tisch.fb.st_config.str_instanz_name := 'WT Stoppzylinder am Tisch';

		zyl_wt_stopper_tisch.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_wt_stopper_tisch.fb.st_config.t_ueberwachungszeit := t#1000ms;
		zyl_wt_stopper_tisch.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_wt_stopper_tisch.fb.st_config.i16_tzk_faktor_einfahren := 100;


		IF gst_Datensatz.st_md.b_anwahl_transport_achse THEN
			zyl_wt_stopper_tisch.fb.st_config.str_zylinder_typ := '1V0E_NO';
		ELSE
			zyl_wt_stopper_tisch.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		END_IF

		zyl_wt_stopper_tisch.fb.st_config.b_config_fertig := TRUE;

		(* WT Stopperzylinder am Auslauf *)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;
			BESTUECKZELLE_1700, RASTERFOLIE:
				zyl_wt_stopper_auslauf.fb.st_config.b_config_fertig := FALSE;
				zyl_wt_stopper_auslauf.fb.st_config.b_endlage1_aktiv := FALSE;
				zyl_wt_stopper_auslauf.fb.st_config.b_endlage2_aktiv := FALSE;
				zyl_wt_stopper_auslauf.fb.st_config.b_sensor1_aktiv := FALSE;
				zyl_wt_stopper_auslauf.fb.st_config.b_sensor2_aktiv := FALSE;
				zyl_wt_stopper_auslauf.fb.st_config.i16_gruppe := 3;
				zyl_wt_stopper_auslauf.fb.st_config.i16_identnummer := 17;
				zyl_wt_stopper_auslauf.fb.st_config.i16_meld_startindex := 2320;
				zyl_wt_stopper_auslauf.fb.st_config.str_beschreibung := ' ';
				zyl_wt_stopper_auslauf.fb.st_config.str_instanz_name := 'WT Stopperzylinder am Auslauf';
				zyl_wt_stopper_auslauf.fb.st_config.str_zylinder_typ := '2V0E';
				zyl_wt_stopper_auslauf.fb.st_config.t_ein_aus_fahrzeit := t#150ms;
				zyl_wt_stopper_auslauf.fb.st_config.t_ueberwachungszeit := t#1000ms;
				zyl_wt_stopper_auslauf.fb.st_config.i16_tzk_faktor_ausfahren := 100;
				zyl_wt_stopper_auslauf.fb.st_config.i16_tzk_faktor_einfahren := 100;
				zyl_wt_stopper_auslauf.fb.st_config.b_config_fertig := TRUE;

			BESTUECKZELLE_1720:
				zyl_wt_stopper_auslauf.fb.st_config.b_config_fertig := FALSE;
				zyl_wt_stopper_auslauf.fb.st_config.b_endlage1_aktiv := FALSE;
				zyl_wt_stopper_auslauf.fb.st_config.b_endlage2_aktiv := FALSE;
				zyl_wt_stopper_auslauf.fb.st_config.b_sensor1_aktiv := FALSE;
				zyl_wt_stopper_auslauf.fb.st_config.b_sensor2_aktiv := FALSE;
				zyl_wt_stopper_auslauf.fb.st_config.i16_gruppe := 3;
				zyl_wt_stopper_auslauf.fb.st_config.i16_identnummer := 17;
				zyl_wt_stopper_auslauf.fb.st_config.i16_meld_startindex := 2320;
				zyl_wt_stopper_auslauf.fb.st_config.str_beschreibung := ' ';
				zyl_wt_stopper_auslauf.fb.st_config.str_instanz_name := 'WT Stopperzylinder am Auslauf';
				zyl_wt_stopper_auslauf.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
				zyl_wt_stopper_auslauf.fb.st_config.t_ein_aus_fahrzeit := t#150ms;
				zyl_wt_stopper_auslauf.fb.st_config.t_ueberwachungszeit := t#1000ms;
				zyl_wt_stopper_auslauf.fb.st_config.i16_tzk_faktor_ausfahren := 100;
				zyl_wt_stopper_auslauf.fb.st_config.i16_tzk_faktor_einfahren := 100;
				zyl_wt_stopper_auslauf.fb.st_config.b_config_fertig := TRUE;
		END_CASE

		(* Hublift-Lift rechts *)
		zyl_hublift_rechts_lift.fb.st_config.b_config_fertig := FALSE;
		zyl_hublift_rechts_lift.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_hublift_rechts_lift.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_hublift_rechts_lift.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_hublift_rechts_lift.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_hublift_rechts_lift.fb.st_config.i16_gruppe := 4;
		zyl_hublift_rechts_lift.fb.st_config.i16_identnummer := 18;
		zyl_hublift_rechts_lift.fb.st_config.i16_meld_startindex := 2340;
		zyl_hublift_rechts_lift.fb.st_config.str_beschreibung := ' ';
		zyl_hublift_rechts_lift.fb.st_config.str_instanz_name := 'Hublift-Lift rechts';
		zyl_hublift_rechts_lift.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_hublift_rechts_lift.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_hublift_rechts_lift.fb.st_config.t_ueberwachungszeit := t#3500ms;
		zyl_hublift_rechts_lift.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_hublift_rechts_lift.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_hublift_rechts_lift.fb.st_config.b_config_fertig := TRUE;
		
		(* Hublift-WT-Einzug rechts *)
		zyl_hublift_rechts_wt_einzug.fb.st_config.b_config_fertig := FALSE;
		zyl_hublift_rechts_wt_einzug.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_hublift_rechts_wt_einzug.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_hublift_rechts_wt_einzug.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_hublift_rechts_wt_einzug.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_hublift_rechts_wt_einzug.fb.st_config.i16_gruppe := 4;
		zyl_hublift_rechts_wt_einzug.fb.st_config.i16_identnummer := 19;
		zyl_hublift_rechts_wt_einzug.fb.st_config.i16_meld_startindex := 2360;
		zyl_hublift_rechts_wt_einzug.fb.st_config.str_beschreibung := ' ';
		zyl_hublift_rechts_wt_einzug.fb.st_config.str_instanz_name := 'Hublift-WT-Einzug rechts';
		zyl_hublift_rechts_wt_einzug.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_hublift_rechts_wt_einzug.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_hublift_rechts_wt_einzug.fb.st_config.t_ueberwachungszeit := t#2500ms;
		zyl_hublift_rechts_wt_einzug.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_hublift_rechts_wt_einzug.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_hublift_rechts_wt_einzug.fb.st_config.b_config_fertig := TRUE;
		
		(* Hublift-WT-Klinke rechts *)
		zyl_hublift_rechts_wt_klinke.fb.st_config.b_config_fertig := FALSE;
		zyl_hublift_rechts_wt_klinke.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_hublift_rechts_wt_klinke.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_hublift_rechts_wt_klinke.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_hublift_rechts_wt_klinke.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_hublift_rechts_wt_klinke.fb.st_config.i16_gruppe := 4;
		zyl_hublift_rechts_wt_klinke.fb.st_config.i16_identnummer := 20;
		zyl_hublift_rechts_wt_klinke.fb.st_config.i16_meld_startindex := 2380;
		zyl_hublift_rechts_wt_klinke.fb.st_config.str_beschreibung := ' ';
		zyl_hublift_rechts_wt_klinke.fb.st_config.str_instanz_name := 'Hublift-WT-Klinke rechts';
		zyl_hublift_rechts_wt_klinke.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_hublift_rechts_wt_klinke.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_hublift_rechts_wt_klinke.fb.st_config.t_ueberwachungszeit := t#1500ms;
		zyl_hublift_rechts_wt_klinke.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_hublift_rechts_wt_klinke.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_hublift_rechts_wt_klinke.fb.st_config.b_config_fertig := TRUE;
		
		(* Hublift-Lift links *)
		zyl_hublift_links_lift.fb.st_config.b_config_fertig := FALSE;
		zyl_hublift_links_lift.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_hublift_links_lift.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_hublift_links_lift.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_hublift_links_lift.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_hublift_links_lift.fb.st_config.i16_gruppe := 4;
		zyl_hublift_links_lift.fb.st_config.i16_identnummer := 21;
		zyl_hublift_links_lift.fb.st_config.i16_meld_startindex := 2400;
		zyl_hublift_links_lift.fb.st_config.str_beschreibung := ' ';
		zyl_hublift_links_lift.fb.st_config.str_instanz_name := 'Hublift-Lift links';
		zyl_hublift_links_lift.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_hublift_links_lift.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_hublift_links_lift.fb.st_config.t_ueberwachungszeit := t#3500ms;
		zyl_hublift_links_lift.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_hublift_links_lift.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_hublift_links_lift.fb.st_config.b_config_fertig := TRUE;
		
		(* Hublift-WT-Einzug links *)
		zyl_hublift_links_wt_einzug.fb.st_config.b_config_fertig := FALSE;
		zyl_hublift_links_wt_einzug.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_hublift_links_wt_einzug.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_hublift_links_wt_einzug.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_hublift_links_wt_einzug.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_hublift_links_wt_einzug.fb.st_config.i16_gruppe := 4;
		zyl_hublift_links_wt_einzug.fb.st_config.i16_identnummer := 22;
		zyl_hublift_links_wt_einzug.fb.st_config.i16_meld_startindex := 2420;
		zyl_hublift_links_wt_einzug.fb.st_config.str_beschreibung := ' ';
		zyl_hublift_links_wt_einzug.fb.st_config.str_instanz_name := 'Hublift-WT-Einzug links';
		zyl_hublift_links_wt_einzug.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_hublift_links_wt_einzug.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_hublift_links_wt_einzug.fb.st_config.t_ueberwachungszeit := t#2500ms;
		zyl_hublift_links_wt_einzug.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_hublift_links_wt_einzug.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_hublift_links_wt_einzug.fb.st_config.b_config_fertig := TRUE;

		(* Hublift-WT-Klinke links *)
		zyl_hublift_links_wt_klinke.fb.st_config.b_config_fertig := FALSE;
		zyl_hublift_links_wt_klinke.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_hublift_links_wt_klinke.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_hublift_links_wt_klinke.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_hublift_links_wt_klinke.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_hublift_links_wt_klinke.fb.st_config.i16_gruppe := 4;
		zyl_hublift_links_wt_klinke.fb.st_config.i16_identnummer := 23;
		zyl_hublift_links_wt_klinke.fb.st_config.i16_meld_startindex := 2440;
		zyl_hublift_links_wt_klinke.fb.st_config.str_beschreibung := ' ';
		zyl_hublift_links_wt_klinke.fb.st_config.str_instanz_name := 'Hublift-WT-Klinke links';
		zyl_hublift_links_wt_klinke.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_hublift_links_wt_klinke.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_hublift_links_wt_klinke.fb.st_config.t_ueberwachungszeit := t#1500ms;
		zyl_hublift_links_wt_klinke.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_hublift_links_wt_klinke.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_hublift_links_wt_klinke.fb.st_config.b_config_fertig := TRUE;

		(* Hublift-Stopper links *)
		zyl_hublift_links_stopper.fb.st_config.b_config_fertig := FALSE;
		zyl_hublift_links_stopper.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_hublift_links_stopper.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_hublift_links_stopper.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_hublift_links_stopper.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_hublift_links_stopper.fb.st_config.i16_gruppe := 4;
		zyl_hublift_links_stopper.fb.st_config.i16_identnummer := 24;
		zyl_hublift_links_stopper.fb.st_config.i16_meld_startindex := 2460;
		zyl_hublift_links_stopper.fb.st_config.str_beschreibung := ' ';
		zyl_hublift_links_stopper.fb.st_config.str_instanz_name := 'Hublift-Stopper links';
		zyl_hublift_links_stopper.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_hublift_links_stopper.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_hublift_links_stopper.fb.st_config.t_ueberwachungszeit := t#2000ms;
		zyl_hublift_links_stopper.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_hublift_links_stopper.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_hublift_links_stopper.fb.st_config.b_config_fertig := TRUE;

		(* zyl_hublift_links_eingriffschutz *)
		zyl_hublift_links_eingriffschutz.fb.st_config.b_config_fertig := FALSE;
		zyl_hublift_links_eingriffschutz.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_hublift_links_eingriffschutz.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_hublift_links_eingriffschutz.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_hublift_links_eingriffschutz.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_hublift_links_eingriffschutz.fb.st_config.i16_gruppe := 4;
		zyl_hublift_links_eingriffschutz.fb.st_config.i16_identnummer := 44;
		zyl_hublift_links_eingriffschutz.fb.st_config.i16_meld_startindex := 2860;
		zyl_hublift_links_eingriffschutz.fb.st_config.str_beschreibung := ' ';
		zyl_hublift_links_eingriffschutz.fb.st_config.str_instanz_name := 'Hublift links Eingriffschutz';
		zyl_hublift_links_eingriffschutz.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_hublift_links_eingriffschutz.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_hublift_links_eingriffschutz.fb.st_config.t_ueberwachungszeit := t#4000ms;
		zyl_hublift_links_eingriffschutz.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_hublift_links_eingriffschutz.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_hublift_links_eingriffschutz.fb.st_config.b_config_fertig := TRUE;
		
		(* Haspel links heben *)
		zyl_haspel_li_heben.fb.st_config.b_config_fertig := FALSE;
		zyl_haspel_li_heben.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_haspel_li_heben.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_haspel_li_heben.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_haspel_li_heben.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_haspel_li_heben.fb.st_config.i16_gruppe := 2;
		zyl_haspel_li_heben.fb.st_config.i16_identnummer := 7;
		zyl_haspel_li_heben.fb.st_config.i16_meld_startindex := 2120;
		zyl_haspel_li_heben.fb.st_config.str_beschreibung := ' ';
		zyl_haspel_li_heben.fb.st_config.str_instanz_name := 'Haspel links heben';
		zyl_haspel_li_heben.fb.st_config.str_zylinder_typ := '2V1E_AUS';
		zyl_haspel_li_heben.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_haspel_li_heben.fb.st_config.t_ueberwachungszeit := t#8s;
		zyl_haspel_li_heben.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_haspel_li_heben.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_haspel_li_heben.fb.st_config.b_config_fertig := TRUE;
		
		(* Haspel links abspulen *)
		zyl_haspel_li_abspulen.fb.st_config.b_config_fertig := FALSE;
		zyl_haspel_li_abspulen.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_haspel_li_abspulen.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_haspel_li_abspulen.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_haspel_li_abspulen.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_haspel_li_abspulen.fb.st_config.i16_gruppe := 2;
		zyl_haspel_li_abspulen.fb.st_config.i16_identnummer := 8;
		zyl_haspel_li_abspulen.fb.st_config.i16_meld_startindex := 2140;
		zyl_haspel_li_abspulen.fb.st_config.str_beschreibung := ' ';
		zyl_haspel_li_abspulen.fb.st_config.str_instanz_name := 'Haspel links abspulen';
		zyl_haspel_li_abspulen.fb.st_config.str_zylinder_typ := '2V1E_AUS';
		zyl_haspel_li_abspulen.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_haspel_li_abspulen.fb.st_config.t_ueberwachungszeit := t#3s;
		zyl_haspel_li_abspulen.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_haspel_li_abspulen.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_haspel_li_abspulen.fb.st_config.b_config_fertig := TRUE;
		
		(* Haspel links sperren *)
		zyl_haspel_li_sperren.fb.st_config.b_config_fertig := FALSE;
		zyl_haspel_li_sperren.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_haspel_li_sperren.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_haspel_li_sperren.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_haspel_li_sperren.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_haspel_li_sperren.fb.st_config.i16_gruppe := 2;
		zyl_haspel_li_sperren.fb.st_config.i16_identnummer := 9;
		zyl_haspel_li_sperren.fb.st_config.i16_meld_startindex := 2160;
		zyl_haspel_li_sperren.fb.st_config.str_beschreibung := ' ';
		zyl_haspel_li_sperren.fb.st_config.str_instanz_name := 'Haspel links sperren';
		zyl_haspel_li_sperren.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_haspel_li_sperren.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_haspel_li_sperren.fb.st_config.t_ueberwachungszeit := t#1000ms;
		zyl_haspel_li_sperren.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_haspel_li_sperren.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_haspel_li_sperren.fb.st_config.b_config_fertig := TRUE;
		
		(* Haspel rechts heben *)
		zyl_haspel_re_heben.fb.st_config.b_config_fertig := FALSE;
		zyl_haspel_re_heben.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_haspel_re_heben.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_haspel_re_heben.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_haspel_re_heben.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_haspel_re_heben.fb.st_config.i16_gruppe := 2;
		zyl_haspel_re_heben.fb.st_config.i16_identnummer := 10;
		zyl_haspel_re_heben.fb.st_config.i16_meld_startindex := 2180;
		zyl_haspel_re_heben.fb.st_config.str_beschreibung := ' ';
		zyl_haspel_re_heben.fb.st_config.str_instanz_name := 'Haspel rechts heben';
		zyl_haspel_re_heben.fb.st_config.str_zylinder_typ := '2V1E_AUS';
		zyl_haspel_re_heben.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_haspel_re_heben.fb.st_config.t_ueberwachungszeit := t#8s;
		zyl_haspel_re_heben.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_haspel_re_heben.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_haspel_re_heben.fb.st_config.b_config_fertig := TRUE;
		
		(* Haspel rechts abspulen *)
		zyl_haspel_re_abspulen.fb.st_config.b_config_fertig := FALSE;
		zyl_haspel_re_abspulen.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_haspel_re_abspulen.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_haspel_re_abspulen.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_haspel_re_abspulen.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_haspel_re_abspulen.fb.st_config.i16_gruppe := 2;
		zyl_haspel_re_abspulen.fb.st_config.i16_identnummer := 11;
		zyl_haspel_re_abspulen.fb.st_config.i16_meld_startindex := 2200;
		zyl_haspel_re_abspulen.fb.st_config.str_beschreibung := ' ';
		zyl_haspel_re_abspulen.fb.st_config.str_instanz_name := 'Haspel rechts abspulen';
		zyl_haspel_re_abspulen.fb.st_config.str_zylinder_typ := '2V1E_AUS';
		zyl_haspel_re_abspulen.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_haspel_re_abspulen.fb.st_config.t_ueberwachungszeit := t#3s;
		zyl_haspel_re_abspulen.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_haspel_re_abspulen.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_haspel_re_abspulen.fb.st_config.b_config_fertig := TRUE;
		
		(* Haspel rechts sperren *)
		zyl_haspel_re_sperren.fb.st_config.b_config_fertig := FALSE;
		zyl_haspel_re_sperren.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_haspel_re_sperren.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_haspel_re_sperren.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_haspel_re_sperren.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_haspel_re_sperren.fb.st_config.i16_gruppe := 2;
		zyl_haspel_re_sperren.fb.st_config.i16_identnummer := 12;
		zyl_haspel_re_sperren.fb.st_config.i16_meld_startindex := 2220;
		zyl_haspel_re_sperren.fb.st_config.str_beschreibung := ' ';
		zyl_haspel_re_sperren.fb.st_config.str_instanz_name := 'Haspel rechts sperren';
		zyl_haspel_re_sperren.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_haspel_re_sperren.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_haspel_re_sperren.fb.st_config.t_ueberwachungszeit := t#1000ms;
		zyl_haspel_re_sperren.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_haspel_re_sperren.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_haspel_re_sperren.fb.st_config.b_config_fertig := TRUE;
		
		(* Haspel verschieben *)
		zyl_haspel_verschieben.fb.st_config.b_config_fertig := FALSE;
		zyl_haspel_verschieben.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_haspel_verschieben.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_haspel_verschieben.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_haspel_verschieben.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_haspel_verschieben.fb.st_config.i16_gruppe := 2;
		zyl_haspel_verschieben.fb.st_config.i16_identnummer := 13;
		zyl_haspel_verschieben.fb.st_config.i16_meld_startindex := 2240;
		zyl_haspel_verschieben.fb.st_config.str_beschreibung := ' ';
		zyl_haspel_verschieben.fb.st_config.str_instanz_name := 'Haspel verschieben';
		zyl_haspel_verschieben.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_haspel_verschieben.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_haspel_verschieben.fb.st_config.t_ueberwachungszeit := t#8s;
		zyl_haspel_verschieben.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_haspel_verschieben.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_haspel_verschieben.fb.st_config.b_config_fertig := TRUE;
		
		(* Bandeinzüge verschieben *)
		zyl_bandeinzuege_verschieben.fb.st_config.b_config_fertig := FALSE;
		zyl_bandeinzuege_verschieben.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_bandeinzuege_verschieben.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_bandeinzuege_verschieben.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_bandeinzuege_verschieben.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_bandeinzuege_verschieben.fb.st_config.i16_gruppe := 2;
		zyl_bandeinzuege_verschieben.fb.st_config.i16_identnummer := 14;
		zyl_bandeinzuege_verschieben.fb.st_config.i16_meld_startindex := 2260;
		zyl_bandeinzuege_verschieben.fb.st_config.str_beschreibung := ' ';
		zyl_bandeinzuege_verschieben.fb.st_config.str_instanz_name := 'Bandeinzüge verschieben';
		zyl_bandeinzuege_verschieben.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_bandeinzuege_verschieben.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_bandeinzuege_verschieben.fb.st_config.t_ueberwachungszeit := t#8000ms;
		zyl_bandeinzuege_verschieben.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_bandeinzuege_verschieben.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_bandeinzuege_verschieben.fb.st_config.b_config_fertig := TRUE;
		
		(* Bandwechselvorschub *)
		zyl_bawe_vorschub.fb.st_config.b_config_fertig := FALSE;
		zyl_bawe_vorschub.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_bawe_vorschub.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_bawe_vorschub.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_bawe_vorschub.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_bawe_vorschub.fb.st_config.i16_gruppe := 5;
		zyl_bawe_vorschub.fb.st_config.i16_identnummer := 25;
		zyl_bawe_vorschub.fb.st_config.i16_meld_startindex := 2480;
		zyl_bawe_vorschub.fb.st_config.str_beschreibung := ' ';
		zyl_bawe_vorschub.fb.st_config.str_instanz_name := 'Bandwechselvorschub';
		zyl_bawe_vorschub.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_bawe_vorschub.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_bawe_vorschub.fb.st_config.t_ueberwachungszeit := t#2000ms;
		zyl_bawe_vorschub.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_bawe_vorschub.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_bawe_vorschub.fb.st_config.b_config_fertig := TRUE;
		
		(* Bandwechselquerschub *)
		zyl_bawe_querschub.fb.st_config.b_config_fertig := FALSE;
		zyl_bawe_querschub.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_bawe_querschub.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_bawe_querschub.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_bawe_querschub.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_bawe_querschub.fb.st_config.i16_gruppe := 5;
		zyl_bawe_querschub.fb.st_config.i16_identnummer := 26;
		zyl_bawe_querschub.fb.st_config.i16_meld_startindex := 2500;
		zyl_bawe_querschub.fb.st_config.str_beschreibung := ' ';
		zyl_bawe_querschub.fb.st_config.str_instanz_name := 'Bandwechselquerschub';
		zyl_bawe_querschub.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_bawe_querschub.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_bawe_querschub.fb.st_config.t_ueberwachungszeit := t#8000ms;
		zyl_bawe_querschub.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_bawe_querschub.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_bawe_querschub.fb.st_config.b_config_fertig := TRUE;
		
		(* Bandwechselfänger links *)
		zyl_bawe_faenger_li.fb.st_config.b_config_fertig := FALSE;
		zyl_bawe_faenger_li.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_bawe_faenger_li.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_bawe_faenger_li.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_bawe_faenger_li.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_bawe_faenger_li.fb.st_config.i16_gruppe := 5;
		zyl_bawe_faenger_li.fb.st_config.i16_identnummer := 27;
		zyl_bawe_faenger_li.fb.st_config.i16_meld_startindex := 2520;
		zyl_bawe_faenger_li.fb.st_config.str_beschreibung := ' ';
		zyl_bawe_faenger_li.fb.st_config.str_instanz_name := 'Bandwechselfaenger links';
		zyl_bawe_faenger_li.fb.st_config.str_zylinder_typ := '2V0E';
		zyl_bawe_faenger_li.fb.st_config.t_ein_aus_fahrzeit := t#200ms;
		zyl_bawe_faenger_li.fb.st_config.t_ueberwachungszeit := t#500ms;
		zyl_bawe_faenger_li.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_bawe_faenger_li.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_bawe_faenger_li.fb.st_config.b_config_fertig := TRUE;
		
		(* Bandwechselfänger rechts *)
		zyl_bawe_faenger_re.fb.st_config.b_config_fertig := FALSE;
		zyl_bawe_faenger_re.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_bawe_faenger_re.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_bawe_faenger_re.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_bawe_faenger_re.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_bawe_faenger_re.fb.st_config.i16_gruppe := 5;
		zyl_bawe_faenger_re.fb.st_config.i16_identnummer := 28;
		zyl_bawe_faenger_re.fb.st_config.i16_meld_startindex := 2540;
		zyl_bawe_faenger_re.fb.st_config.str_beschreibung := ' ';
		zyl_bawe_faenger_re.fb.st_config.str_instanz_name := 'Bandwechselfaenger rechts';
		zyl_bawe_faenger_re.fb.st_config.str_zylinder_typ := '2V0E';
		zyl_bawe_faenger_re.fb.st_config.t_ein_aus_fahrzeit := t#200ms;
		zyl_bawe_faenger_re.fb.st_config.t_ueberwachungszeit := t#500ms;
		zyl_bawe_faenger_re.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_bawe_faenger_re.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_bawe_faenger_re.fb.st_config.b_config_fertig := TRUE;
		
		(* Bandwechselhalter links *)
		zyl_bawe_halter_li.fb.st_config.b_config_fertig := FALSE;
		zyl_bawe_halter_li.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_bawe_halter_li.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_bawe_halter_li.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_bawe_halter_li.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_bawe_halter_li.fb.st_config.i16_gruppe := 5;
		zyl_bawe_halter_li.fb.st_config.i16_identnummer := 29;
		zyl_bawe_halter_li.fb.st_config.i16_meld_startindex := 2560;
		zyl_bawe_halter_li.fb.st_config.str_beschreibung := ' ';
		zyl_bawe_halter_li.fb.st_config.str_instanz_name := 'Bandwechselhalter links';
		zyl_bawe_halter_li.fb.st_config.str_zylinder_typ := '2V0E';
		zyl_bawe_halter_li.fb.st_config.t_ein_aus_fahrzeit := t#200ms;
		zyl_bawe_halter_li.fb.st_config.t_ueberwachungszeit := t#500ms;
		zyl_bawe_halter_li.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_bawe_halter_li.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_bawe_halter_li.fb.st_config.b_config_fertig := TRUE;
		
		(* Bandwechselhalter rechts *)
		zyl_bawe_halter_re.fb.st_config.b_config_fertig := FALSE;
		zyl_bawe_halter_re.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_bawe_halter_re.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_bawe_halter_re.fb.st_config.b_sensor1_aktiv := FALSE;
		zyl_bawe_halter_re.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_bawe_halter_re.fb.st_config.i16_gruppe := 5;
		zyl_bawe_halter_re.fb.st_config.i16_identnummer := 30;
		zyl_bawe_halter_re.fb.st_config.i16_meld_startindex := 2580;
		zyl_bawe_halter_re.fb.st_config.str_beschreibung := ' ';
		zyl_bawe_halter_re.fb.st_config.str_instanz_name := 'Bandwechselhalter rechts';
		zyl_bawe_halter_re.fb.st_config.str_zylinder_typ := '2V0E';
		zyl_bawe_halter_re.fb.st_config.t_ein_aus_fahrzeit := t#200ms;
		zyl_bawe_halter_re.fb.st_config.t_ueberwachungszeit := t#500ms;
		zyl_bawe_halter_re.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_bawe_halter_re.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_bawe_halter_re.fb.st_config.b_config_fertig := TRUE;

		(* WT Stopperzylinder am Einlauf *)
		zyl_wt_stopper_einlauf.fb.st_config.b_config_fertig := FALSE;
		zyl_wt_stopper_einlauf.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_wt_stopper_einlauf.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_wt_stopper_einlauf.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_wt_stopper_einlauf.fb.st_config.b_sensor2_aktiv := TRUE;
		zyl_wt_stopper_einlauf.fb.st_config.i16_gruppe := 3;
		zyl_wt_stopper_einlauf.fb.st_config.i16_identnummer := 36;
		zyl_wt_stopper_einlauf.fb.st_config.i16_meld_startindex := 2700;
		zyl_wt_stopper_einlauf.fb.st_config.str_beschreibung := ' ';
		zyl_wt_stopper_einlauf.fb.st_config.str_instanz_name := 'WT Stopperzylinder am Einlauf';
		zyl_wt_stopper_einlauf.fb.st_config.str_zylinder_typ := '1V2E_EIN_AUS';
		zyl_wt_stopper_einlauf.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_wt_stopper_einlauf.fb.st_config.t_ueberwachungszeit := t#1000ms;
		zyl_wt_stopper_einlauf.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_wt_stopper_einlauf.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_wt_stopper_einlauf.fb.st_config.b_config_fertig := TRUE;

		(* Rasterfolien Fänger *)
		zyl_rafo_faenger.fb.st_config.b_config_fertig := FALSE;
		zyl_rafo_faenger.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_rafo_faenger.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_rafo_faenger.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_rafo_faenger.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_rafo_faenger.fb.st_config.i16_gruppe := 7;
		zyl_rafo_faenger.fb.st_config.i16_identnummer := 37;
		zyl_rafo_faenger.fb.st_config.i16_meld_startindex := 2720;
		zyl_rafo_faenger.fb.st_config.str_beschreibung := ' ';
		zyl_rafo_faenger.fb.st_config.str_instanz_name := 'Rasterfolien Fänger';
		zyl_rafo_faenger.fb.st_config.str_zylinder_typ := '2V1E_AUS';
		zyl_rafo_faenger.fb.st_config.t_ein_aus_fahrzeit := t#100ms;
		zyl_rafo_faenger.fb.st_config.t_ueberwachungszeit := t#500ms;
		zyl_rafo_faenger.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_rafo_faenger.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_rafo_faenger.fb.st_config.b_config_fertig := TRUE;
		
		(* Rasterfolie Klemmen *)
		zyl_rafo_klemmen.fb.st_config.b_config_fertig := FALSE;
		zyl_rafo_klemmen.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_rafo_klemmen.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_rafo_klemmen.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_rafo_klemmen.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_rafo_klemmen.fb.st_config.i16_gruppe := 7;
		zyl_rafo_klemmen.fb.st_config.i16_identnummer := 38;
		zyl_rafo_klemmen.fb.st_config.i16_meld_startindex := 2740;
		zyl_rafo_klemmen.fb.st_config.str_beschreibung := ' ';
		zyl_rafo_klemmen.fb.st_config.str_instanz_name := 'Rasterfolie Klemmen';
		zyl_rafo_klemmen.fb.st_config.str_zylinder_typ := '2V1E_AUS';
		zyl_rafo_klemmen.fb.st_config.t_ein_aus_fahrzeit := t#100ms;
		zyl_rafo_klemmen.fb.st_config.t_ueberwachungszeit := t#500ms;
		zyl_rafo_klemmen.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_rafo_klemmen.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_rafo_klemmen.fb.st_config.b_config_fertig := TRUE;
		
		(* Rasterfolien Vorschub *)
		zyl_rafo_vorschub.fb.st_config.b_config_fertig := FALSE;
		zyl_rafo_vorschub.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_rafo_vorschub.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_rafo_vorschub.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_rafo_vorschub.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_rafo_vorschub.fb.st_config.i16_gruppe := 7;
		zyl_rafo_vorschub.fb.st_config.i16_identnummer := 39;
		zyl_rafo_vorschub.fb.st_config.i16_meld_startindex := 2760;
		zyl_rafo_vorschub.fb.st_config.str_beschreibung := ' ';
		zyl_rafo_vorschub.fb.st_config.str_instanz_name := 'Rasterplatte Wenden';
		zyl_rafo_vorschub.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_rafo_vorschub.fb.st_config.t_ein_aus_fahrzeit := t#100ms;
		zyl_rafo_vorschub.fb.st_config.t_ueberwachungszeit := t#2000ms;
		zyl_rafo_vorschub.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_rafo_vorschub.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_rafo_vorschub.fb.st_config.b_config_fertig := TRUE;
		
		(* Rasterfolien Kamm *)
		zyl_rafo_kamm.fb.st_config.b_config_fertig := FALSE;
		zyl_rafo_kamm.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_rafo_kamm.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_rafo_kamm.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_rafo_kamm.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_rafo_kamm.fb.st_config.i16_gruppe := 7;
		zyl_rafo_kamm.fb.st_config.i16_identnummer := 40;
		zyl_rafo_kamm.fb.st_config.i16_meld_startindex := 2780;
		zyl_rafo_kamm.fb.st_config.str_beschreibung := ' ';
		zyl_rafo_kamm.fb.st_config.str_instanz_name := 'Rasterfolien Kamm';
		zyl_rafo_kamm.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_rafo_kamm.fb.st_config.t_ein_aus_fahrzeit := t#100ms;
		zyl_rafo_kamm.fb.st_config.t_ueberwachungszeit := t#1500ms;
		zyl_rafo_kamm.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_rafo_kamm.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_rafo_kamm.fb.st_config.b_config_fertig := TRUE;

		(* Rasterfolien Vorzentrierer *)
		zyl_rafo_vorzentrierer.fb.st_config.b_config_fertig := FALSE;
		zyl_rafo_vorzentrierer.fb.st_config.b_endlage1_aktiv := TRUE;
		zyl_rafo_vorzentrierer.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_rafo_vorzentrierer.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_rafo_vorzentrierer.fb.st_config.b_sensor2_aktiv := FALSE;
		zyl_rafo_vorzentrierer.fb.st_config.i16_gruppe := 7;
		zyl_rafo_vorzentrierer.fb.st_config.i16_identnummer := 43;
		zyl_rafo_vorzentrierer.fb.st_config.i16_meld_startindex := 2840;
		zyl_rafo_vorzentrierer.fb.st_config.str_beschreibung := ' ';
		zyl_rafo_vorzentrierer.fb.st_config.str_instanz_name := 'Rasterfolien Vorzentrierer';
		zyl_rafo_vorzentrierer.fb.st_config.str_zylinder_typ := '2V2E_EIN_AUS';
		zyl_rafo_vorzentrierer.fb.st_config.t_ein_aus_fahrzeit := t#100ms;
		zyl_rafo_vorzentrierer.fb.st_config.t_ueberwachungszeit := t#1500ms;
		zyl_rafo_vorzentrierer.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_rafo_vorzentrierer.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_rafo_vorzentrierer.fb.st_config.b_config_fertig := TRUE;

		(* Indexierzylinder Bestückposition *)
		zyl_Indexier_Bestueckpos.fb.st_config.b_config_fertig := FALSE;
		zyl_Indexier_Bestueckpos.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_Indexier_Bestueckpos.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_Indexier_Bestueckpos.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_Indexier_Bestueckpos.fb.st_config.b_sensor2_aktiv := TRUE;
		zyl_Indexier_Bestueckpos.fb.st_config.i16_gruppe := 3;
		zyl_Indexier_Bestueckpos.fb.st_config.i16_identnummer := 48;
		zyl_Indexier_Bestueckpos.fb.st_config.i16_meld_startindex := 2920;
		zyl_Indexier_Bestueckpos.fb.st_config.str_beschreibung := ' ';
		zyl_Indexier_Bestueckpos.fb.st_config.str_instanz_name := 'Indexierzylinder Bestückposition';
		zyl_Indexier_Bestueckpos.fb.st_config.str_zylinder_typ := '1V2E_EIN_AUS';
		zyl_Indexier_Bestueckpos.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_Indexier_Bestueckpos.fb.st_config.t_ueberwachungszeit := t#1000ms;
		zyl_Indexier_Bestueckpos.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_Indexier_Bestueckpos.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_Indexier_Bestueckpos.fb.st_config.b_config_fertig := TRUE;

		(* Indexierzylinder Einlauf *)
		zyl_Indexier_Einlauf.fb.st_config.b_config_fertig := FALSE;
		zyl_Indexier_Einlauf.fb.st_config.b_endlage1_aktiv := FALSE;
		zyl_Indexier_Einlauf.fb.st_config.b_endlage2_aktiv := FALSE;
		zyl_Indexier_Einlauf.fb.st_config.b_sensor1_aktiv := TRUE;
		zyl_Indexier_Einlauf.fb.st_config.b_sensor2_aktiv := TRUE;
		zyl_Indexier_Einlauf.fb.st_config.i16_gruppe := 3;
		zyl_Indexier_Einlauf.fb.st_config.i16_identnummer := 49;
		zyl_Indexier_Einlauf.fb.st_config.i16_meld_startindex := 2940;
		zyl_Indexier_Einlauf.fb.st_config.str_beschreibung := ' ';
		zyl_Indexier_Einlauf.fb.st_config.str_instanz_name := ' Indexierzylinder Einlauf ';
		zyl_Indexier_Einlauf.fb.st_config.str_zylinder_typ := '1V2E_EIN_AUS';
		zyl_Indexier_Einlauf.fb.st_config.t_ein_aus_fahrzeit := t#0ms;
		zyl_Indexier_Einlauf.fb.st_config.t_ueberwachungszeit := t#1000ms;
		zyl_Indexier_Einlauf.fb.st_config.i16_tzk_faktor_ausfahren := 100;
		zyl_Indexier_Einlauf.fb.st_config.i16_tzk_faktor_einfahren := 100;
		zyl_Indexier_Einlauf.fb.st_config.b_config_fertig := TRUE;
ELSE
	b_config_fertig := FALSE;
END_IF

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Bandoeler
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
	b_ot_spur					: BOOL;
END_VAR
VAR_IN_OUT
	st_daten						: struct_oeler_daten;
	st_visu						: struct_oeler_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_ton_quitt					: TON;
	dt_datum_uhrzeit_letzte_oelung	: DT;
	fb_state_entry					: ST_StateEntry;
	t_delta_zeitraum				: TIME := t#5h;
	t_blaszeit					: TIME := t#500ms;
	fb_ton_oelzeit					: TON;
	fb_ton_blaszeit				: TON;
	fb_r_trig_start_oelen			: R_TRIG;
	fb_r_trig_hubimpuls			: R_TRIG;
	i32_default_wert_intervall		: INT := 1000;

	fb_r_trig_ibn_handoelen		: R_TRIG;
	fb_ton_ibn_handoelen			: TON;
	b_ibn_handoelen				: BOOL := FALSE;

	a_ventil_oel		 			AT %Q* : BOOL;
	a_ventil_luft		 			AT %Q* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Bandöler mit Zwangs- und Stillstandsölung *)
(* Oeler Impuls generieren *)
fb_ton_oelzeit(IN:= , PT:= , Q=> , ET=> );
fb_ton_blaszeit(IN:= , PT:= t_blaszeit, Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Hubimpuls *)
fb_r_trig_hubimpuls(CLK:= b_ot_spur, Q=> );

(* Inbetriebnahme *)
fb_r_trig_ibn_handoelen(CLK:= b_ibn_handoelen, Q=> );
fb_ton_ibn_handoelen(IN:= , PT:= t#1s, Q=> , ET=> );
IF fb_r_trig_ibn_handoelen.Q THEN
	fb_ton_ibn_handoelen.IN := TRUE;
ELSE
	IF fb_ton_ibn_handoelen.Q THEN
		b_ibn_handoelen := FALSE;
	 	fb_ton_ibn_handoelen.IN := FALSE;
	END_IF
END_IF

(* =======================================Toplevel========================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
END_IF

(* Prüfe auf neue Intervalvorgabe *)
IF st_config.b_station_aktiv AND st_daten.i32_neue_intervallvorgabe <> st_daten.i32_alte_intervallvorgabe THEN
	st_daten.i32_alte_intervallvorgabe := st_daten.i32_neue_intervallvorgabe;
	st_daten.i32_aktueller_stand := st_daten.i32_neue_intervallvorgabe;
END_IF

(* Zähle Hübe *)
IF st_config.b_station_aktiv AND fb_r_trig_hubimpuls.Q THEN
	(* Von der Intervallvorgabe wird runter gezählt bis Null. Dann kommt der Ölimpuls *)
	st_daten.i32_aktueller_stand := st_daten.i32_aktueller_stand - 1;
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF
		
(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_blaszeit.IN := FALSE;
			fb_ton_oelzeit.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			a_ventil_oel := FALSE;
			a_ventil_luft := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			IF st_config.b_station_aktiv THEN
				fb_state_entry.i16_next_step := 20;
			ELSE
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	20: (* Abfrage Datum / Uhrzeit wegen Ölen nach Stillstand*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF (gdt_system_time - dt_datum_uhrzeit_letzte_oelung) > t_delta_zeitraum THEN
			fb_ton_oelzeit.PT := st_daten.t_oelzeit_nach_stillstand;
			fb_state_entry.i16_next_step := 110;
		ELSE
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  st_config.b_station_aktiv AND (st_daten.i32_aktueller_stand <= 0 OR st_visu.b_handoelen OR fb_r_trig_ibn_handoelen.Q) THEN
			st_visu.b_handoelen := FALSE;
			fb_ton_oelzeit.PT := st_daten.t_ventiloeffnungszeit;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110: (* Luft einschalten *)
		IF fb_state_entry.E THEN
			fb_ton_blaszeit.IN := TRUE;
			a_ventil_luft := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_ton_blaszeit.Q THEN
			fb_ton_blaszeit.IN := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120: (* Ölen *)
		IF fb_state_entry.E THEN
			dt_datum_uhrzeit_letzte_oelung := gdt_system_time;	(* Merken wann das letze mal geölt wurde *)
			IF st_daten.i32_neue_intervallvorgabe <= 0 THEN
				 st_daten.i32_neue_intervallvorgabe := i32_default_wert_intervall;	(* Verhindere Dauerölung, wenn in den WKZ-Ölerdaten noch 0 drin steht *)
			END_IF
			st_daten.i32_aktueller_stand := st_daten.i32_neue_intervallvorgabe;
			fb_ton_oelzeit.IN := TRUE;
			a_ventil_oel := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_ton_oelzeit.Q THEN
			fb_ton_oelzeit.IN := FALSE;
			a_ventil_oel := FALSE;
			a_ventil_luft := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			a_ventil_oel := FALSE;
			a_ventil_luft := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			a_ventil_oel := FALSE;
			a_ventil_luft := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_BandoelerZylinder
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
	lr_achse_position				: LREAL;
	e_steuerung_ein				: BOOL;
	e_druckwaechter				: BOOL;

END_VAR
(*VAR_IN_OUT
	st_visu						: struct_oeler_visu;
END_VAR*)
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
	b_oelmangel					: BOOL;
	st_oelerdaten					: struct_oeler_daten;
END_VAR
VAR
	fb_ton_uez					: TON;
	fb_ton_uez_fuellstand			: TON;
	fb_ton_quitt					: TON;
	fb_ton_speichern			: TON;
	fb_state_entry				: ST_StateEntry;
	fb_winkeltrigger				: ST_Winkeltrigger;
	b_hand_dialog_aktiv			: BOOL := FALSE;
	a_ventil_oben			 			AT %Q* : BOOL;
	a_ventil_unten			 			AT %Q* : BOOL;
	e_fuellstand					AT %I* : BOOL;
	e_druck_oelbehaelter			AT %I* : BOOL;
	sm_fuellstand_oeler			: BOOL := FALSE;
	sm_druckueberwachung		: BOOL := FALSE;
	bm_fuellstand_oeler			: BOOL := FALSE;
	b_ibn_handoelen				: BOOL := FALSE;
	fb_betriebsartenwechsel		: ST_Betriebsartenwechsel;
	fb_r_trig_bestueckhub			: R_TRIG;
	i16_hubzaehler				: INT := 0;
	fb_ton_oelen					: TON;
	b_zyl_unten					: BOOL;
	b_zyl_oben					: BOOL;
	dt_datum_uhrzeit_letzte_oelung	: DT;
	t_delta_zeitraum				: TIME := t#5h;
	fb_ton_oelzeit					: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(*Mindestwerte eintragen damit nicht trocken gefahren werden kann*)
fb_ton_speichern(IN:= gst_datensatz.st_wkz.st_oeler.t_ventiloeffnungszeit<500 OR gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen<1, PT:= t#20ms, Q=> , ET=> );
IF	fb_ton_speichern.Q THEN
	IF	gst_datensatz.st_wkz.st_oeler.t_ventiloeffnungszeit<50 THEN
		gst_datensatz.st_wkz.st_oeler.t_ventiloeffnungszeit:=500;
	END_IF

	IF	gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen<1 THEN
		gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen:=0;
	END_IF
END_IF

(* Bandöler mit Füllstandsabfrage *)
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_uez(IN:= NOT e_druck_oelbehaelter AND e_druckwaechter, PT:= t#60s, Q=> , ET=> );
fb_ton_uez_fuellstand(IN:= bm_fuellstand_oeler, PT:= t#1h, Q=> , ET=> );
fb_ton_oelen(IN:= , PT:= , Q=> , ET=> );

IF fb_state_entry.i16_step >= BEREIT AND fb_state_entry.i16_step < FEHLER THEN
	fb_winkeltrigger(IN:= LREAL_TO_INT(lr_achse_position), PT:= T#300ms, Q=> );
END_IF

(* Flanken *)
fb_r_trig_bestueckhub(CLK:= (gi16_betriebsart = AUTO OR gi16_betriebsart = TIPPEN) AND nockenschaltwerk_bestueckachse.fb.arr_spur[SP_OT], Q=> );

(* Hubzähler wird durch Nocke OT erhöht >> wenn der Zähler größer gleich dem Intervall ist wird a_ventil gesetzt *)
IF fb_r_trig_bestueckhub.Q THEN
	i16_hubzaehler := i16_hubzaehler + 1;
END_IF


(* Bandöler von Hand betätigen *)
IF gi16_betriebsart = HAND THEN
	a_ventil_oben :=  b_ibn_handoelen OR visu.b_handoelen ;
	a_ventil_unten :=  b_ibn_handoelen OR visu.b_handoelen ;
END_IF


(* Allgemeine Fehler *)

IF zyl_oelen_unten.st_ctrl.out.b_fehler OR
	zyl_oelen_oben.st_ctrl.out.b_fehler THEN
	fb_state_entry.i16_next_step := FEHLER;
END_IF

fb_betriebsartenwechsel(
	i16_akt_betriebsart:= gi16_betriebsart,
	b_wechsel_auto=> , 
	b_wechsel_tippen=> ,
	b_wechsel_hand=> , 
	b_wechsel_dummy=> , 
	b_wechsel_pseudo=> , 
	b_wechsel_allgemein=> );
(*
IF fb_betriebsartenwechsel.b_merker_ba_auto OR fb_betriebsartenwechsel.b_merker_ba_tippen THEN
	a_ventil := FALSE;
END_IF
*)

(* =======================================Toplevel========================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
END_IF

(* Orangene Lampe an Ampel leuchtet bei Ölbehälter leer *)
b_oelmangel := bm_fuellstand_oeler;

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF
		
(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			fb_ton_quitt.IN := FALSE;
			fb_ton_uez_fuellstand.IN := FALSE;
			a_ventil_oben := FALSE;
			a_ventil_unten := FALSE;
			sm_fuellstand_oeler := FALSE;
			sm_druckueberwachung := FALSE;
			bm_fuellstand_oeler := FALSE;
			st_ctrl_out.b_einzelfertigung := FALSE;
			fb_ton_oelen.IN := FALSE;
			b_zyl_unten:= FALSE;
			b_zyl_oben:= FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_oelen_oben.st_ctrl.in.b_quittieren := FALSE;
			zyl_oelen_unten.st_ctrl.in.b_quittieren := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: (* Abfrage Datum / Uhrzeit wegen Ölen nach Stillstand*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF (gdt_system_time - dt_datum_uhrzeit_letzte_oelung) > t_delta_zeitraum THEN
			fb_ton_oelzeit.PT := st_oelerdaten.t_oelzeit_nach_stillstand;
			fb_state_entry.i16_next_step := 30;
		ELSE
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	30: (* Ölen nach Stillstand *)
		IF fb_state_entry.E THEN
			dt_datum_uhrzeit_letzte_oelung := gdt_system_time;	(* Merken, dass geölt wurde *)
			fb_ton_oelzeit.IN := TRUE;
			a_ventil_oben := TRUE;
			a_ventil_unten := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_ton_oelzeit.Q THEN
			fb_ton_oelzeit.IN := FALSE;
			a_ventil_oben := FALSE;
			a_ventil_unten := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================
	40: (* Bandölen, abhängig von WKZ-Daten Zylinder ausfahren *)


	(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_oelen_unten.fb.e_sensor1_ausgefahren AND
			 zyl_oelen_oben.fb.e_sensor1_ausgefahren THEN
			b_zyl_unten:= FALSE;
			b_zyl_oben:= FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50: (* Bandölen, abhängig von WKZ-Daten Zylinder ausfahren *)


	(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_oelen_unten.fb.e_sensor1_eingefahren AND
			 zyl_oelen_oben.fb.e_sensor1_eingefahren THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF
=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		IF st_config.b_station_aktiv THEN
			(* Ölen *)
		(*	IF (gi16_betriebsart = AUTO OR gi16_betriebsart = TIPPEN) THEN
				IF	gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen =0 THEN  (*bei Intervall 0 Dauerölen*)
					a_ventil_oben :=  fb_winkeltrigger.Q OR visu.b_handoelen OR b_ibn_handoelen;
					a_ventil_unten :=  fb_winkeltrigger.Q OR visu.b_handoelen OR b_ibn_handoelen;
				ELSE
					a_ventil_oben :=  visu.b_handoelen OR b_ibn_handoelen;
					a_ventil_unten :=  visu.b_handoelen OR b_ibn_handoelen;
				END_IF
			END_IF *)
			(* Überwachung Füllstand Betriebsmeldung*)
			IF NOT e_fuellstand AND e_steuerung_ein THEN
				bm_fuellstand_oeler := TRUE;
			ELSE
				bm_fuellstand_oeler := FALSE;
			END_IF
			(* Überwachung Füllstand Störmeldung *)
			IF fb_ton_uez_fuellstand.Q OR sm_fuellstand_oeler THEN
				sm_fuellstand_oeler := TRUE;
				st_ctrl_out.b_einzelfertigung:=TRUE;

				IF 	gi16_maschinenstatusinfo = STATUS_BETRIEBSBEREIT THEN
					fb_state_entry.i16_next_step := FEHLER;
				END_IF

			END_IF
			(* Überwachung Druck im Ölbehälter *)
			IF fb_ton_uez.Q OR sm_druckueberwachung THEN
				sm_druckueberwachung := TRUE;
				st_ctrl_out.b_einzelfertigung:=TRUE;

				IF 	gi16_maschinenstatusinfo = STATUS_BETRIEBSBEREIT THEN
					fb_state_entry.i16_next_step := FEHLER;
				END_IF
			END_IF

			(*-----------------------Weiterschaltbedingungen----------------------------*)
			IF	 i16_hubzaehler >= gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen AND
				gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen <>0 THEN (*bei Intervall 0 Dauerölen*)
				fb_state_entry.i16_next_step := 110;
			END_IF

		END_IF

(*=======================================================*)
	110: (* Bandölen, abhängig von WKZ-Daten Zylinder ausfahren *)
		IF fb_state_entry.E THEN
			dt_datum_uhrzeit_letzte_oelung := gdt_system_time;	(* Merken wann das letze mal geölt wurde *)
			i16_hubzaehler := 0;
			fb_ton_oelen.IN := TRUE;
			fb_ton_oelen.PT := DINT_TO_TIME(gst_datensatz.st_wkz.st_oeler.t_ventiloeffnungszeit);
			a_ventil_oben:= TRUE;
			a_ventil_unten:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_oelen.Q THEN
			fb_ton_oelen.IN := FALSE;
			a_ventil_oben := FALSE;
			a_ventil_unten := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF
(*=======================================================
	120: (* Bandölen, abhängig von WKZ-Daten Zylinder ausfahren *)


	(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_oelen_unten.fb.e_sensor1_ausgefahren AND
			 zyl_oelen_oben.fb.e_sensor1_ausgefahren THEN
			b_zyl_unten:= FALSE;
			b_zyl_oben:= FALSE;
			fb_state_entry.i16_next_step := 130;
		END_IF

(*=======================================================*)
	130: (* Bandölen, abhängig von WKZ-Daten Zylinder ausfahren *)


	(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_oelen_unten.fb.e_sensor1_eingefahren AND
			 zyl_oelen_oben.fb.e_sensor1_eingefahren THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF
=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			a_ventil_oben := FALSE;
			a_ventil_unten := FALSE;
			fb_ton_quitt.IN := FALSE;
			zyl_oelen_oben.st_ctrl.in.b_quittieren := FALSE;
			zyl_oelen_unten.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
			zyl_oelen_oben.st_ctrl.in.b_quittieren := TRUE;
			zyl_oelen_unten.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			a_ventil_oben := FALSE;
			a_ventil_unten := FALSE;
			fb_ton_quitt.IN := FALSE;
			zyl_oelen_oben.st_ctrl.in.b_quittieren := FALSE;
			zyl_oelen_unten.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_oelen_oben.st_ctrl.in.b_quittieren := TRUE;
			zyl_oelen_unten.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fuellstand_oeler;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_druckueberwachung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_fuellstand_oeler;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Doppelrollenbandoeler
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
	b_ot_spur					: BOOL;
END_VAR
VAR_IN_OUT
	st_visu						: struct_oeler_visu;
	st_oelerdaten					: struct_oeler_daten;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
	b_oelmangel					: BOOL;
END_VAR
VAR
	fb_ton_quitt					: TON;
	dt_datum_uhrzeit_letzte_oelung	: DT;
	fb_state_entry					: ST_StateEntry;
	t_delta_zeitraum				: TIME := t#5h;
	sm_fuellstand_oeler			: BOOL := FALSE;
	fb_ton_oelzeit					: TON;
	fb_r_trig_start_oelen			: R_TRIG;
	fb_r_trig_hubimpuls			: R_TRIG;
	b_ibn_handoelen				: BOOL := FALSE;
	bm_fuellstand_oeler			: BOOL := FALSE;
	a_ventil_rolle_li	 			AT %Q* : BOOL;
	a_ventil_rolle_re	 			AT %Q* : BOOL;
	e_fuellstand					AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Bandöler mit Füllstandsabfrage und Zwangs- und Stillstandsölung *)
(* Oeler Impuls generieren *)
fb_ton_oelzeit(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Hubimpuls *)
fb_r_trig_hubimpuls(CLK:= b_ot_spur, Q=> );

(* =======================================Toplevel========================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
END_IF

(* Orangene Lampe an Ampel leuchtet bei Ölbehälter leer *)
b_oelmangel := bm_fuellstand_oeler;

(* =======================================Toplevel========================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
END_IF

(* Prüfe auf neue Intervalvorgabe *)
IF st_config.b_station_aktiv AND st_oelerdaten.i32_neue_intervallvorgabe <> st_oelerdaten.i32_alte_intervallvorgabe THEN
	st_oelerdaten.i32_alte_intervallvorgabe := st_oelerdaten.i32_neue_intervallvorgabe;
	st_oelerdaten.i32_aktueller_stand := st_oelerdaten.i32_neue_intervallvorgabe;
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF
		
(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			fb_ton_oelzeit.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			a_ventil_rolle_li := FALSE;
			a_ventil_rolle_re := FALSE;
			sm_fuellstand_oeler := FALSE;
			bm_fuellstand_oeler := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			IF st_config.b_station_aktiv THEN
				fb_state_entry.i16_next_step := 20;
			ELSE
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	20: (* Abfrage Datum / Uhrzeit wegen Ölen nach Stillstand*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF (gdt_system_time - dt_datum_uhrzeit_letzte_oelung) > t_delta_zeitraum THEN
			fb_ton_oelzeit.PT := st_oelerdaten.t_oelzeit_nach_stillstand;
			fb_state_entry.i16_next_step := 30;
		ELSE
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	30: (* Ölen nach Stillstand *)
		IF fb_state_entry.E THEN
			dt_datum_uhrzeit_letzte_oelung := gdt_system_time;	(* Merken, dass geölt wurde *)
			fb_ton_oelzeit.IN := TRUE;
			a_ventil_rolle_li := TRUE;
			a_ventil_rolle_re := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_ton_oelzeit.Q THEN
			fb_ton_oelzeit.IN := FALSE;
			a_ventil_rolle_li := FALSE;
			a_ventil_rolle_re := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		IF st_config.b_station_aktiv THEN
			(* Zähle Hübe *)
			IF fb_r_trig_hubimpuls.Q THEN
				(* Von der Intervallvorgabe wird runter gezählt bis Null. Dann kommt der Ölimpuls *)
				st_oelerdaten.i32_aktueller_stand := st_oelerdaten.i32_aktueller_stand - 1;
			END_IF
			(* Überwachung Füllstand *)
			IF NOT e_fuellstand THEN
				sm_fuellstand_oeler := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF

			(*-----------------------Weiterschaltbedingungen----------------------------*)
			IF  st_oelerdaten.i32_aktueller_stand <= 0 OR st_visu.b_handoelen OR b_ibn_handoelen THEN
				st_visu.b_handoelen := FALSE;
				fb_ton_oelzeit.PT := st_oelerdaten.t_ventiloeffnungszeit;
				fb_state_entry.i16_next_step := 110;
			END_IF
		END_IF

(*=======================================================*)
	110: (* Ölen *)
		IF fb_state_entry.E THEN
			dt_datum_uhrzeit_letzte_oelung := gdt_system_time;	(* Merken wann das letze mal geölt wurde *)
			IF st_oelerdaten.i32_neue_intervallvorgabe <= 0 THEN
				 st_oelerdaten.i32_neue_intervallvorgabe := 100;	(* Verhindere Dauerölung, wenn in den WKZ-Ölerdaten noch 0 drin steht *)
			END_IF
			st_oelerdaten.i32_aktueller_stand := st_oelerdaten.i32_neue_intervallvorgabe;
			fb_ton_oelzeit.IN := TRUE;
			a_ventil_rolle_li := TRUE;
			a_ventil_rolle_re := TRUE;
		END_IF

		(* Zähle Hübe *)
		IF fb_r_trig_hubimpuls.Q THEN
			(* Von der Intervallvorgabe wird runter gezählt bis Null. Dann kommt der Ölimpuls *)
			st_oelerdaten.i32_aktueller_stand := st_oelerdaten.i32_aktueller_stand - 1;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_ton_oelzeit.Q THEN
			fb_ton_oelzeit.IN := FALSE;
			a_ventil_rolle_li := FALSE;
			a_ventil_rolle_re := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			a_ventil_rolle_li := FALSE;
			a_ventil_rolle_re := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			a_ventil_rolle_li := FALSE;
			a_ventil_rolle_re := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fuellstand_oeler;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_fuellstand_oeler;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Einzelbandoeler
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
	b_ot_spur					: BOOL;
END_VAR
VAR_IN_OUT
	st_visu						: struct_oeler_visu;
	st_oelerdaten					: struct_oeler_retain;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_ton_quitt					: TON;
	dt_datum_uhrzeit_letzte_oelung	: DT;
	fb_state_entry					: ST_StateEntry;
	t_delta_zeitraum				: TIME := t#5h;
	a_ventil			 			AT %Q* : BOOL;
	e_fuellstand					AT %I* : BOOL;
	sm_fuellstand_oeler			: BOOL := FALSE;
	fb_ton_oelzeit					: TON;
	fb_r_trig_start_oelen			: R_TRIG;
	fb_r_trig_hubimpuls			: R_TRIG;

	fb_r_trig_ibn_handoelen		: R_TRIG;
	fb_ton_ibn_handoelen			: TON;
	b_ibn_handoelen				: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
(* Bandöler mit Füllstandsabfrage und Zwangs- und Stillstandsölung *)
(* Oeler Impuls generieren *)
fb_ton_oelzeit(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Hubimpuls *)
fb_r_trig_hubimpuls(CLK:= b_ot_spur, Q=> );

(* Inbetriebnahme *)
fb_r_trig_ibn_handoelen(CLK:= b_ibn_handoelen, Q=> );
fb_ton_ibn_handoelen(IN:= , PT:= t#1s, Q=> , ET=> );
IF fb_r_trig_ibn_handoelen.Q THEN
	fb_ton_ibn_handoelen.IN := TRUE;
ELSE
	IF fb_ton_ibn_handoelen.Q THEN
		b_ibn_handoelen := FALSE;
	 	fb_ton_ibn_handoelen.IN := FALSE;
	END_IF
END_IF

(* =======================================Toplevel========================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
END_IF

(* Prüfe auf neue Intervalvorgabe *)
IF st_config.b_station_aktiv AND st_oelerdaten.i32_neue_intervallvorgabe <> st_oelerdaten.i32_alte_intervallvorgabe THEN
	st_oelerdaten.i32_alte_intervallvorgabe := st_oelerdaten.i32_neue_intervallvorgabe;
	st_oelerdaten.i32_aktueller_stand := st_oelerdaten.i32_neue_intervallvorgabe;
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF
		
(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			fb_ton_oelzeit.IN := FALSE;
			fb_ton_ibn_handoelen.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			a_ventil := FALSE;
			sm_fuellstand_oeler := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			IF st_config.b_station_aktiv THEN
				fb_state_entry.i16_next_step := 20;
			ELSE
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	20: (* Abfrage Datum / Uhrzeit wegen Ölen nach Stillstand*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF (gdt_system_time - dt_datum_uhrzeit_letzte_oelung) > t_delta_zeitraum THEN
			fb_ton_oelzeit.PT := st_oelerdaten.t_oelzeit_nach_stillstand;
			fb_state_entry.i16_next_step := 30;
		ELSE
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	30: (* Ölen nach Stillstand *)
		IF fb_state_entry.E THEN
			dt_datum_uhrzeit_letzte_oelung := gdt_system_time;	(* Merken, dass geölt wurde *)
			fb_ton_oelzeit.IN := TRUE;
			a_ventil := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_ton_oelzeit.Q THEN
			fb_ton_oelzeit.IN := FALSE;
			a_ventil := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		IF st_config.b_station_aktiv THEN
			(* Zähle Hübe *)
			IF fb_r_trig_hubimpuls.Q THEN
				(* Von der Intervallvorgabe wird runter gezählt bis Null. Dann kommt der Ölimpuls *)
				st_oelerdaten.i32_aktueller_stand := st_oelerdaten.i32_aktueller_stand - 1;
			END_IF
			(* Überwachung Füllstand *)
			IF NOT e_fuellstand THEN
				sm_fuellstand_oeler := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF

			(*-----------------------Weiterschaltbedingungen----------------------------*)
			IF  st_oelerdaten.i32_aktueller_stand <= 0 OR st_visu.b_handoelen OR fb_r_trig_ibn_handoelen.Q THEN
				st_visu.b_handoelen := FALSE;
				fb_ton_oelzeit.PT := st_oelerdaten.t_ventiloeffnungszeit;
				fb_state_entry.i16_next_step := 110;
			END_IF
		END_IF

(*=======================================================*)
	110: (* Ölen *)
		IF fb_state_entry.E THEN
			dt_datum_uhrzeit_letzte_oelung := gdt_system_time;	(* Merken wann das letze mal geölt wurde *)
			IF st_oelerdaten.i32_neue_intervallvorgabe <= 0 THEN
				 st_oelerdaten.i32_neue_intervallvorgabe := 100;	(* Verhindere Dauerölung, wenn in den WKZ-Ölerdaten noch 0 drin steht *)
			END_IF
			st_oelerdaten.i32_aktueller_stand := st_oelerdaten.i32_neue_intervallvorgabe;
			fb_ton_oelzeit.IN := TRUE;
			a_ventil := TRUE;
		END_IF

		(* Zähle Hübe *)
		IF fb_r_trig_hubimpuls.Q THEN
			(* Von der Intervallvorgabe wird runter gezählt bis Null. Dann kommt der Ölimpuls *)
			st_oelerdaten.i32_aktueller_stand := st_oelerdaten.i32_aktueller_stand - 1;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_ton_oelzeit.Q THEN
			fb_ton_oelzeit.IN := FALSE;
			a_ventil := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			a_ventil := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			a_ventil := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fuellstand_oeler;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Menzel_Spruehoeler
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
	lr_achse_position				: LREAL;
	e_steuerung_ein				: BOOL;
	e_druckwaechter				: BOOL;
END_VAR
(*VAR_IN_OUT
	st_visu						: struct_oeler_visu;
END_VAR*)
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
	b_oelmangel					: BOOL;
END_VAR
VAR
	fb_ton_uez					: TON;
	fb_ton_uez_fuellstand			: TON;
	fb_ton_quitt					: TON;
	fb_ton_speichern			: TON;
	fb_state_entry				: ST_StateEntry;
	fb_winkeltrigger				: ST_Winkeltrigger;
	b_hand_dialog_aktiv			: BOOL := FALSE;
	a_ventil			 			AT %Q* : BOOL;
	e_fuellstand					AT %I* : BOOL;
	e_druck_oelbehaelter			AT %I* : BOOL;
	sm_fuellstand_oeler			: BOOL := FALSE;
	sm_druckueberwachung		: BOOL := FALSE;
	bm_fuellstand_oeler			: BOOL := FALSE;
	b_ibn_handoelen				: BOOL := FALSE;
	fb_betriebsartenwechsel		: ST_Betriebsartenwechsel;
	fb_r_trig_bestueckhub			: R_TRIG;
	i16_hubzaehler				: INT := 0;
	fb_ton_oelen					: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(*Intervalllölen wird beim Sprühöler nicht mehr benötigt, darum wird der Wert auf Null geforced*)
gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen:=0;

(*Mindestwerte eintragen damit nicht trocken gefahren werden kann*)
fb_ton_speichern(IN:= gst_datensatz.st_wkz.st_oeler.t_ventiloeffnungszeit<500 OR gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen<1, PT:= t#20ms, Q=> , ET=> );
IF	fb_ton_speichern.Q THEN
	IF	gst_datensatz.st_wkz.st_oeler.t_ventiloeffnungszeit<500 THEN
		gst_datensatz.st_wkz.st_oeler.t_ventiloeffnungszeit:=500;
	END_IF

	IF	gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen<1 THEN
		gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen:=0;
	END_IF
END_IF

(* Bandöler mit Füllstandsabfrage *)
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_uez(IN:= NOT e_druck_oelbehaelter AND e_druckwaechter, PT:= t#60s, Q=> , ET=> );
fb_ton_uez_fuellstand(IN:= bm_fuellstand_oeler, PT:= t#1h, Q=> , ET=> );
fb_ton_oelen(IN:= , PT:= , Q=> , ET=> );

IF fb_state_entry.i16_step >= BEREIT AND fb_state_entry.i16_step < FEHLER THEN
	fb_winkeltrigger(IN:= LREAL_TO_INT(lr_achse_position), PT:= T#300ms, Q=> );
END_IF

(* Flanken *)
fb_r_trig_bestueckhub(CLK:= (gi16_betriebsart = AUTO OR gi16_betriebsart = TIPPEN) AND nockenschaltwerk_bestueckachse.fb.arr_spur[SP_OT], Q=> );

(* Hubzähler wird durch Nocke OT erhöht >> wenn der Zähler größer gleich dem Intervall ist wird a_ventil gesetzt *)
IF fb_r_trig_bestueckhub.Q THEN
	i16_hubzaehler := i16_hubzaehler + 1;
END_IF

(* Bandöler von Hand betätigen *)
IF gi16_betriebsart = HAND THEN
	a_ventil :=  b_ibn_handoelen OR (b_hand_dialog_aktiv AND (visu.b_handoelen OR ST_Euchner_Handbedienpult.b_Taste_Power));
END_IF

fb_betriebsartenwechsel(
	i16_akt_betriebsart:= gi16_betriebsart,
	b_wechsel_auto=> , 
	b_wechsel_tippen=> ,
	b_wechsel_hand=> , 
	b_wechsel_dummy=> , 
	b_wechsel_pseudo=> , 
	b_wechsel_allgemein=> );
(*
IF fb_betriebsartenwechsel.b_merker_ba_auto OR fb_betriebsartenwechsel.b_merker_ba_tippen THEN
	a_ventil := FALSE;
END_IF
*)

(* =======================================Toplevel========================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
END_IF

(* Orangene Lampe an Ampel leuchtet bei Ölbehälter leer *)
b_oelmangel := bm_fuellstand_oeler;

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF
		
(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			fb_ton_quitt.IN := FALSE;
			fb_ton_uez_fuellstand.IN := FALSE;
			a_ventil := FALSE;
			sm_fuellstand_oeler := FALSE;
			sm_druckueberwachung := FALSE;
			bm_fuellstand_oeler := FALSE;
			st_ctrl_out.b_einzelfertigung := FALSE;
			fb_ton_oelen.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		IF st_config.b_station_aktiv THEN
			(* Ölen *)
			IF (gi16_betriebsart = AUTO OR gi16_betriebsart = TIPPEN) THEN
				IF	gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen =0 THEN  (*bei Intervall 0 Dauerölen*)
					a_ventil :=  fb_winkeltrigger.Q OR visu.b_handoelen OR b_ibn_handoelen;
				ELSE
					a_ventil :=  visu.b_handoelen OR b_ibn_handoelen;
				END_IF
			END_IF
			(* Überwachung Füllstand Betriebsmeldung*)
			IF NOT e_fuellstand AND e_steuerung_ein THEN
				bm_fuellstand_oeler := TRUE;
			ELSE
				bm_fuellstand_oeler := FALSE;
			END_IF
			(* Überwachung Füllstand Störmeldung *)
			IF fb_ton_uez_fuellstand.Q OR sm_fuellstand_oeler THEN
				sm_fuellstand_oeler := TRUE;
				st_ctrl_out.b_einzelfertigung:=TRUE;

				IF 	gi16_maschinenstatusinfo = STATUS_BETRIEBSBEREIT THEN
					fb_state_entry.i16_next_step := FEHLER;
				END_IF

			END_IF
			(* Überwachung Druck im Ölbehälter *)
			IF fb_ton_uez.Q OR sm_druckueberwachung THEN
				sm_druckueberwachung := TRUE;
				st_ctrl_out.b_einzelfertigung:=TRUE;

				IF 	gi16_maschinenstatusinfo = STATUS_BETRIEBSBEREIT THEN
					fb_state_entry.i16_next_step := FEHLER;
				END_IF
			END_IF

			(*-----------------------Weiterschaltbedingungen----------------------------*)
			IF	 i16_hubzaehler >= gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen AND
				gst_datensatz.st_wkz.st_oeler.i16_intervall_bandoelen <>0 THEN (*bei Intervall 0 Dauerölen*)
				fb_state_entry.i16_next_step := 110;
			END_IF

		END_IF

(*=======================================================*)
	110: (* Bandölen, abhängig von WKZ-Daten *)
		IF fb_state_entry.E THEN
			i16_hubzaehler := 0;
			fb_ton_oelen.IN := TRUE;
			fb_ton_oelen.PT := DINT_TO_TIME(gst_datensatz.st_wkz.st_oeler.t_ventiloeffnungszeit);
			a_ventil := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_oelen.Q THEN
			fb_ton_oelen.IN := FALSE;
			a_ventil := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			a_ventil := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			a_ventil := FALSE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fuellstand_oeler;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_druckueberwachung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_fuellstand_oeler;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Programmbausteine' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Schreibe_Persistente_Daten
VAR_INPUT
	bExecute			: BOOL;
	bQuit				: BOOL;
	t_schreibintervall		: TIME;
	b_steuerung_ein		: BOOL;
END_VAR
VAR_OUTPUT
	bBusy				: BOOL;
	bError				: BOOL;
	nErrId				: UDINT;
END_VAR
VAR
	fb_write_persistent_data		: FB_WritePersistentData;
	fb_ton_quitt					: TON;
	fb_state_entry				: ST_StateEntry;
	fb_ton_schreiben			: TON;
	fb_get_local_ams_netid		: ST_GetLocalAMSNetID;
	fb_r_trig_execute			: R_TRIG;
	fb_f_trig_steuerung			: F_TRIG;
	sm_fehler_daten_schreiben	: BOOL := FALSE;
	sm_fehler_netid				: BOOL := FALSE;

	gst_manuelles_bestueckprogramm_copy	: struct_bestueckprogramm;
	gst_PersDaten_Copy					: struct_PD;
END_VAR
(* @END_DECLARATION := '0' *)
(* Die Persistenten Daten der Maschine werden in einem wiederkehrenden Zeitintervall in eine Datei im TwinCAT Boot-Ordner geschrieben *)
fb_ton_quitt(IN:= , PT:= t#30s, Q=> , ET=> );
fb_ton_schreiben(IN:= , PT:= t_schreibintervall, Q=> , ET=> );

fb_r_trig_execute(CLK:= bExecute, Q=> );
fb_f_trig_steuerung(CLK:= b_steuerung_ein, Q=> );


fb_state_entry(	i16_pos:= 1 );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			bBusy := FALSE;
			bError := FALSE;
			fb_write_persistent_data.START := FALSE;
			fb_ton_schreiben.IN := FALSE;
			fb_get_local_ams_netid.bExecute := FALSE;
			fb_get_local_ams_netid .bQuit := FALSE;
			sm_fehler_daten_schreiben := FALSE;
			sm_fehler_netid := FALSE;
		END_IF

		fb_state_entry.i16_next_step := 20;

(*=======================================================*)
	20:	(* Die AMS-NetID des lokalen PC ermitteln *)
		IF fb_state_entry.E THEN
			fb_get_local_ams_netid.bExecute := TRUE;
		END_IF

		IF fb_get_local_ams_netid.bBusy THEN
			fb_get_local_ams_netid.bExecute := FALSE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:
		IF NOT fb_get_local_ams_netid.bBusy  THEN
			IF NOT fb_get_local_ams_netid.bError THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSE	(* Fehler *)
				sm_fehler_netid := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	BEREIT:	(* Warte auf Freigabeflanke für zyklisches Schreiben der Daten /  Daten sichern, wenn Maschine ausgeschaltet wird *)
		IF 	fb_r_trig_execute.Q OR fb_f_trig_steuerung.Q THEN
			fb_state_entry.i16_next_step := 110;
		END_IF

		(*Schreibe bei einer Änderung*)
		IF	gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET AND (
			(MEMCMP(ADR(gst_manuelles_bestueckprogramm_copy), ADR(gst_manuelles_bestueckprogramm), SIZEOF(gst_manuelles_bestueckprogramm_copy)) <> 0 ) OR
			(MEMCMP(ADR(gst_PersDaten_Copy), ADR(gst_PersDaten), SIZEOF(gst_PersDaten_Copy)) <> 0 ) 	) THEN
			gst_PersDaten_Copy:=gst_PersDaten;
			gst_manuelles_bestueckprogramm_copy:=gst_manuelles_bestueckprogramm;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110:	(* Schreibe Persistente Daten *)
		IF fb_state_entry.E THEN
			bBusy := TRUE;
			fb_write_persistent_data.START := TRUE;
		END_IF

		IF fb_write_persistent_data.BUSY THEN
			fb_write_persistent_data.START := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120:	(* Daten wurden geschrieben *)
		IF NOT fb_write_persistent_data.BUSY  THEN
			IF NOT fb_write_persistent_data.ERR THEN
				bBusy := FALSE;
				fb_state_entry.i16_next_step := 100;
			ELSE
				sm_fehler_daten_schreiben := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			fb_get_local_ams_netid.bExecute := FALSE;
			fb_get_local_ams_netid.bQuit := FALSE;
			bError := TRUE;
		END_IF

		IF  fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_get_local_ams_netid .bQuit := TRUE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

END_CASE

fb_state_entry(i16_pos:= 2 );

fb_get_local_ams_netid(
	bExecute:= ,
	bQuit:= , 
	bBusy=> , 
	bReady=> , 
	bError=> , 
	nErrId=> , 
	s_ams_netid=> );

fb_write_persistent_data(
	NETID:= '',
	PORT:= 801,
	START:= , 
	TMOUT:= DEFAULT_ADS_TIMEOUT,
	MODE:= SPDM_2PASS,
	BUSY=> , 
	ERR=> , 
	ERRID=> );
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Safety' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Safetyprogramm
VAR_INPUT
	st_config							: struct_config;
	st_ctrl_in							: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu							: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out						: struct_ctrl_out;
END_VAR
VAR
	ack_step							: ST_StateEntry;
	fb_ton_wz						: TON;
	fb_ton_quitt						: TON;
	fb_ton_taste_steuerung_ein				: TON;
	fb_ton_taste_steuerung_aus				: TON;
	fb_ton_taste_stoerung_quitt				: TON;
	fb_r_trig_quittieren					: R_TRIG;
	fb_state_entry						: ST_StateEntry;
	i32_fb_error_counter_gruppe1		: DINT := 0;
	i32_fb_error_counter_gruppe2		: DINT := 0;
	i32_fb_error_counter_gruppe3		: DINT := 0;
	i32_fb_error_counter_gruppe4		: DINT := 0;
	i32_com_error_counter_gruppe1		: DINT := 0;
	i32_com_error_counter_gruppe2		: DINT := 0;
	i32_com_error_counter_gruppe3		: DINT := 0;
	i32_com_error_counter_gruppe4		: DINT := 0;

	sm_steuerung_aus				: BOOL := FALSE;
	sm_not_halt_intern					: BOOL := FALSE;
	sm_not_halt_frontseite				: BOOL := FALSE;
	sm_not_halt_rueckseite			: BOOL := FALSE;
	sm_not_halt_bediengeraet			: BOOL := FALSE;
	sm_not_halt_extern				: BOOL := FALSE;
	sm_tuere_vorne_offen				: BOOL := FALSE;
	sm_tuere_hinten_offen				: BOOL := FALSE;
	sm_tuere_vorne_diskrepanz		: BOOL := FALSE;
	sm_tuere_hinten_diskrepanz		: BOOL := FALSE;
	sm_bestueckachse_sto			: BOOL := FALSE;
	sm_bestueckachse_sls			: BOOL := FALSE;
	sm_z_achse_sto					: BOOL := FALSE;
	sm_z_achse_sls					: BOOL := FALSE;
	sm_y_achse_sto					: BOOL := FALSE;
	sm_y_achse_sls					: BOOL := FALSE;
	sm_b_achse_sto					: BOOL := FALSE;
	sm_b_achse_sls					: BOOL := FALSE;
	sm_transport_achse_sto				: BOOL := FALSE;
	sm_transport_achse_sls			: BOOL := FALSE;

	bm_taste_steuerung_ein_verhaengt		: BOOL := FALSE;
	bm_taste_steuerung_aus_verhaengt		: BOOL := FALSE;
	bm_taste_stoerung_quitt_verhaengt		: BOOL := FALSE;

	sm_fehler_fb1_opmode					: BOOL := FALSE;
	sm_fehler_fb9_estop_nothalt_front			: BOOL := FALSE;
	sm_fehler_fb10_estop_nothalt_ext			: BOOL := FALSE;
	sm_fehler_fb15_edm_nothalt_ext				: BOOL := FALSE;
	sm_fehler_fb16_edm_nothalt_schuetz			: BOOL := FALSE;
	sm_fehler_fb17_edm_ventilinsel				: BOOL := FALSE;
	sm_fehler_fb28_edm_foerderband			: BOOL := FALSE;
	sm_fehler_fb30_estop_rueck				: BOOL := FALSE;
	sm_fehler_fb31_estop_bedien				: BOOL := FALSE;
	sm_fehler_fb35_mon_tuere_vo				: BOOL := FALSE;
	sm_fehler_fb36_mon_tuere_hi				: BOOL := FALSE;
	sm_fehler_fb37_mon_tuere_disk_vo			: BOOL := FALSE;
	sm_fehler_fb38_mon_tuere_disk_hi			: BOOL := FALSE;
	sm_fehler_fb39_mon_tuere_meld_vo			: BOOL := FALSE;
	sm_fehler_fb40_mon_tuere_meld_hi			: BOOL := FALSE;
	sm_not_halt_hublift_links					: BOOL := FALSE;

	a_quitt_pilz_hublift_links			AT %Q* : BOOL;

	a_lampe_quitt_schutztuere_vorne	AT %Q* : BOOL;
	a_lampe_quitt_schutztuere_hinten	AT %Q* : BOOL;

	(* Eingänge von Twinsafe FBs *)
	se_quittiertaste					AT %I* : BOOL;
	se_taste_steuerung_ein				AT %I* : BOOL;
	se_taste_steuerung_aus				AT %I* : BOOL;
	se_steuerung_ein					AT %I* : BOOL;
	se_ba_mit_bedingungen				AT %I* : BOOL;
	se_nothalt_gesamt_ok				AT %I* : BOOL;
	se_tuere_vorne_diskrepanz			AT %I* : BOOL;
	se_tuere_hinten_diskrepanz			AT %I* : BOOL;
	se_not_halt_intern					AT %I* : BOOL;
	se_not_halt_frontseite				AT %I* : BOOL;
	se_not_halt_rueckseite				AT %I* : BOOL;
	se_not_halt_bediengeraet			AT %I* : BOOL;
	se_not_halt_extern					AT %I* : BOOL;
	se_tuere_vorne_offen				AT %I* : BOOL;
	se_tuere_hinten_offen				AT %I* : BOOL;
	se_tuere_zustimm_vorne_offen		AT %I* : BOOL;
	se_tuere_zustimm_hinten_offen		AT %I* : BOOL;
	se_bestueckachse_sto				AT %I* : BOOL;
	se_bestueckachse_sls				AT %I* : BOOL;
	se_z_achse_sto					AT %I* : BOOL;
	se_z_achse_sls					AT %I* : BOOL;
	se_y_achse_sto					AT %I* : BOOL;
	se_y_achse_sls					AT %I* : BOOL;
	se_b_achse_sto					AT %I* : BOOL;
	se_b_achse_sls					AT %I* : BOOL;
	se_transport_achse_sto			AT %I* : BOOL;
	se_transport_achse_sls			AT %I* : BOOL;

	e_not_halt_hublift_links_ok				AT %I* : BOOL;	(* Not Halt OK Signal von Pilz Hublift links *)

	se_fehler_fb1_opmode						AT %I* : BOOL;
	se_fehler_fb9_estop_nothalt_front			AT %I* : BOOL;
	se_fehler_fb10_estop_nothalt_ext			AT %I* : BOOL;
	se_fehler_fb15_edm_nothalt_ext				AT %I* : BOOL;
	se_fehler_fb16_edm_nothalt_schuetz			AT %I* : BOOL;
	se_fehler_fb17_edm_ventilinsel				AT %I* : BOOL;
	se_fehler_fb28_edm_foerderband			AT %I* : BOOL;
	se_fehler_fb30_estop_rueck				AT %I* : BOOL;
	se_fehler_fb31_estop_bedien				AT %I* : BOOL;
	se_fehler_fb35_mon_tuere_vo				AT %I* : BOOL;
	se_fehler_fb36_mon_tuere_hi				AT %I* : BOOL;
	se_fehler_fb37_mon_tuere_disk_vo			AT %I* : BOOL;
	se_fehler_fb38_mon_tuere_disk_hi			AT %I* : BOOL;
	se_fehler_fb39_mon_tuere_meld_vo			AT %I* : BOOL;
	se_fehler_fb40_mon_tuere_meld_hi			AT %I* : BOOL;

	(* Betriebsarten *)
	sa_run_stop_gruppe1				AT %Q* : BOOL;
	sa_err_ack_gruppe1				AT %Q* : BOOL;
	se_fb_error_gruppe1				AT %I* : BOOL;
	se_com_error_gruppe1			AT %I* : BOOL;
	se_out_error_gruppe1				AT %I* : BOOL;
	(* Notaus *)
	sa_run_stop_gruppe2				AT %Q* : BOOL;
	sa_err_ack_gruppe2				AT %Q* : BOOL;
	se_fb_error_gruppe2				AT %I* : BOOL;
	se_com_error_gruppe2			AT %I* : BOOL;
	se_out_error_gruppe2				AT %I* : BOOL;
	(* Türen *)
	sa_run_stop_gruppe3				AT %Q* : BOOL;
	sa_err_ack_gruppe3				AT %Q* : BOOL;
	se_fb_error_gruppe3				AT %I* : BOOL;
	se_com_error_gruppe3			AT %I* : BOOL;
	se_out_error_gruppe3				AT %I* : BOOL;
	(* Safety AX5000 *)
	sa_run_stop_gruppe4				AT %Q* : BOOL;
	sa_err_ack_gruppe4				AT %Q* : BOOL;
	se_fb_error_gruppe4				AT %I* : BOOL;
	se_com_error_gruppe4			AT %I* : BOOL;
	se_out_error_gruppe4				AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= T#100ms, Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#20ms, Q=> , ET=> );
fb_ton_taste_steuerung_ein(IN:= se_taste_steuerung_ein, PT:= t#60s, Q=> bm_taste_steuerung_ein_verhaengt, ET=> );
fb_ton_taste_steuerung_aus(IN:= NOT se_taste_steuerung_aus, PT:= t#60s, Q=> bm_taste_steuerung_aus_verhaengt, ET=> );
fb_ton_taste_stoerung_quitt(IN:= se_quittiertaste, PT:= t#60s, Q=> bm_taste_stoerung_quitt_verhaengt, ET=> );

(* Flanken *)
fb_r_trig_quittieren(CLK:= visu.b_quittieren, Q=> );

(* Startsignal für die Safety-Gruppen *)
sa_run_stop_gruppe1 := TRUE;
sa_run_stop_gruppe2 := TRUE;
sa_run_stop_gruppe3 := TRUE;
sa_run_stop_gruppe4 := TRUE;

(* Automatische Quittierung von Errors in den TwinSafe-Gruppen *)
ack_step(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE ack_step.i16_step OF
	0:	(* Nach Startup automatische Quittierung von FB- und COM-Fehlern *)
		IF 	se_fb_error_gruppe1 OR
			se_com_error_gruppe1 OR
			se_fb_error_gruppe2 OR
			se_com_error_gruppe2 OR
			se_fb_error_gruppe3 OR
			se_com_error_gruppe3 OR
			se_fb_error_gruppe4 OR
			se_com_error_gruppe4
			THEN
				sa_err_ack_gruppe1 := FALSE;
				sa_err_ack_gruppe2 := FALSE;
				sa_err_ack_gruppe3 := FALSE;
				sa_err_ack_gruppe4 := FALSE;
				fb_ton_wz.IN := TRUE;
				IF fb_ton_wz.Q THEN
					fb_ton_wz.IN := FALSE;
					ack_step.i16_next_step := 10;
				END_IF
		END_IF

	10:
		sa_err_ack_gruppe1 := TRUE;
		sa_err_ack_gruppe2 := TRUE;
		sa_err_ack_gruppe3 := TRUE;
		sa_err_ack_gruppe4 := TRUE;
		fb_ton_wz.IN := TRUE;
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			ack_step.i16_next_step := 20;
		END_IF

	20:
		sa_err_ack_gruppe1 := FALSE;
		sa_err_ack_gruppe2 := FALSE;
		sa_err_ack_gruppe3 := FALSE;
		sa_err_ack_gruppe4 := FALSE;
		fb_ton_wz.IN := TRUE;
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			ack_step.i16_next_step := 100;
		END_IF

	100:	(* FB- und COM-Fehler  *)
		IF 	se_fb_error_gruppe1 OR
			se_com_error_gruppe1 OR
			se_fb_error_gruppe2 OR
			se_com_error_gruppe2 OR
			se_fb_error_gruppe3 OR
			se_com_error_gruppe3 OR
			se_fb_error_gruppe4 OR
			se_com_error_gruppe4
			THEN
				sa_err_ack_gruppe1 := FALSE;
				sa_err_ack_gruppe2 := FALSE;
				sa_err_ack_gruppe3 := FALSE;
				sa_err_ack_gruppe4 := FALSE;
				ack_step.i16_next_step := 110;
		END_IF

	110:
		IF ack_step.E THEN
			IF se_fb_error_gruppe1 THEN
				i32_fb_error_counter_gruppe1 := i32_fb_error_counter_gruppe1 + 1;
			END_IF
			IF se_fb_error_gruppe2 THEN
				i32_fb_error_counter_gruppe2 := i32_fb_error_counter_gruppe2 + 1;
			END_IF
			IF se_fb_error_gruppe3 THEN
				i32_fb_error_counter_gruppe3 := i32_fb_error_counter_gruppe3 + 1;
			END_IF
			IF se_fb_error_gruppe4 THEN
				i32_fb_error_counter_gruppe4 := i32_fb_error_counter_gruppe4 + 1;
			END_IF
			IF se_com_error_gruppe1 THEN
				i32_com_error_counter_gruppe1 := i32_com_error_counter_gruppe1 + 1;
			END_IF
			IF se_com_error_gruppe2 THEN
				i32_com_error_counter_gruppe2 := i32_com_error_counter_gruppe2 + 1;
			END_IF
			IF se_com_error_gruppe3 THEN
				i32_com_error_counter_gruppe3 := i32_com_error_counter_gruppe3 + 1;
			END_IF
			IF se_com_error_gruppe4 THEN
				i32_com_error_counter_gruppe4 := i32_com_error_counter_gruppe4 + 1;
			END_IF
		END_IF
		ack_step.i16_next_step := 120;

	120:
		sa_err_ack_gruppe1 := TRUE;
		sa_err_ack_gruppe2 := TRUE;
		sa_err_ack_gruppe3 := TRUE;
		sa_err_ack_gruppe4 := TRUE;
		fb_ton_wz.IN := TRUE;
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			ack_step.i16_next_step := 130;
		END_IF

	130:
		sa_err_ack_gruppe1 := FALSE;
		sa_err_ack_gruppe2 := FALSE;
		sa_err_ack_gruppe3 := FALSE;
		sa_err_ack_gruppe4 := FALSE;
		fb_ton_wz.IN := TRUE;
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			ack_step.i16_next_step := 100;
		END_IF
END_CASE

ack_step(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );


(* Lampen für Schutztüren *)
a_lampe_quitt_schutztuere_hinten := NOT se_tuere_hinten_offen;
a_lampe_quitt_schutztuere_vorne := 	NOT se_tuere_vorne_offen OR
								NOT se_tuere_hinten_offen OR
								NOT se_not_halt_intern;

(* Quittierung Pilz Hublift links *)
a_quitt_pilz_hublift_links := se_quittiertaste;

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF	st_config.b_config_fertig AND
			NOT se_fb_error_gruppe1 AND
			NOT se_com_error_gruppe1 AND
			NOT se_fb_error_gruppe2 AND
			NOT se_com_error_gruppe2 AND
			NOT se_fb_error_gruppe3 AND
			NOT se_com_error_gruppe3 AND
			NOT se_fb_error_gruppe4 AND
			NOT se_com_error_gruppe4
			THEN
				fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		st_ctrl_out.b_fehler := FALSE;
		st_ctrl_out.b_bereit := FALSE;
		fb_ton_quitt.IN := FALSE;
		sm_steuerung_aus := FALSE;
		sm_not_halt_intern := FALSE;
		sm_not_halt_frontseite := FALSE;
		sm_not_halt_rueckseite := FALSE;
		sm_not_halt_bediengeraet := FALSE;
		sm_not_halt_extern := FALSE;
		sm_tuere_vorne_offen := FALSE;
		sm_tuere_hinten_offen := FALSE;
		sm_tuere_vorne_diskrepanz := FALSE;
		sm_tuere_hinten_diskrepanz := FALSE;
		sm_bestueckachse_sto := FALSE;
		sm_bestueckachse_sls := FALSE;
		sm_z_achse_sto := FALSE;
		sm_z_achse_sls := FALSE;
		sm_y_achse_sto := FALSE;
		sm_y_achse_sls := FALSE;
		sm_b_achse_sto := FALSE;
		sm_b_achse_sls := FALSE;
		sm_transport_achse_sto := FALSE;
		sm_transport_achse_sls := FALSE;
		sm_fehler_fb1_opmode := FALSE;
		sm_fehler_fb9_estop_nothalt_front := FALSE;
		sm_fehler_fb10_estop_nothalt_ext := FALSE;
		sm_fehler_fb15_edm_nothalt_ext	 := FALSE;
		sm_fehler_fb16_edm_nothalt_schuetz := FALSE;
		sm_fehler_fb17_edm_ventilinsel := FALSE;
		sm_fehler_fb28_edm_foerderband := FALSE;
		sm_fehler_fb30_estop_rueck := FALSE;
		sm_fehler_fb31_estop_bedien := FALSE;
		sm_fehler_fb35_mon_tuere_vo := FALSE;
		sm_fehler_fb36_mon_tuere_hi := FALSE;
		sm_fehler_fb37_mon_tuere_disk_vo := FALSE;
		sm_fehler_fb38_mon_tuere_disk_hi := FALSE;
		sm_fehler_fb39_mon_tuere_meld_vo := FALSE;
		sm_fehler_fb40_mon_tuere_meld_hi := FALSE;
		sm_not_halt_hublift_links := FALSE;

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := BEREIT;

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(* Hinweis: SLS der Achsen endet immer bei STO, deshalb wird nur STO abgefragt *)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700, RASTERFOLIE:
				IF	se_steuerung_ein AND
					se_not_halt_intern AND
					se_not_halt_extern AND
					se_tuere_zustimm_vorne_offen AND
					se_tuere_zustimm_hinten_offen AND
					(*se_tuere_vorne_offen AND
					se_tuere_hinten_offen AND*)
					NOT se_bestueckachse_sto AND
					NOT se_z_achse_sto AND
					NOT se_y_achse_sto AND
					NOT se_tuere_vorne_diskrepanz AND
					NOT se_tuere_hinten_diskrepanz AND
					(e_not_halt_hublift_links_ok OR NOT gst_datensatz.st_md.b_hublift_links_aktiv)
					THEN
						;
				ELSE
					fb_state_entry.i16_next_step := FEHLER;
				END_IF

			BESTUECKZELLE_1720:
				IF	se_steuerung_ein AND
					se_not_halt_intern AND
					se_not_halt_extern AND
					se_tuere_zustimm_vorne_offen AND
					se_tuere_zustimm_hinten_offen AND
					(*se_tuere_vorne_offen AND
					se_tuere_hinten_offen AND*)
					NOT se_bestueckachse_sto AND
					NOT se_z_achse_sto AND
					NOT se_tuere_vorne_diskrepanz AND
					NOT se_tuere_hinten_diskrepanz AND
					(e_not_halt_hublift_links_ok OR NOT gst_datensatz.st_md.b_hublift_links_aktiv)
					THEN
						;
				ELSE
					fb_state_entry.i16_next_step := FEHLER;
				END_IF
		END_CASE

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(* Gruppe NOT-AUS *)
		sm_not_halt_frontseite := NOT se_not_halt_frontseite;
		sm_not_halt_rueckseite := NOT se_not_halt_rueckseite;
		sm_not_halt_bediengeraet := NOT se_not_halt_bediengeraet;
		sm_steuerung_aus := NOT se_steuerung_ein AND se_not_halt_frontseite AND se_not_halt_rueckseite AND se_not_halt_bediengeraet AND se_tuere_vorne_offen AND se_tuere_hinten_offen;
		sm_not_halt_extern := NOT se_not_halt_extern;

		IF se_steuerung_ein AND se_not_halt_frontseite AND se_not_halt_rueckseite AND se_not_halt_bediengeraet THEN
			(* Gruppe Achsen *)
			sm_bestueckachse_sto := 	se_bestueckachse_sto AND
									(gst_datensatz.st_md.i16_typ_zelle = BESTUECKZELLE_1700 OR gst_datensatz.st_md.i16_typ_zelle = BESTUECKZELLE_1720);
			sm_z_achse_sto := se_z_achse_sto;
			sm_y_achse_sto := se_y_achse_sto AND
								gst_datensatz.st_md.i16_typ_zelle = BESTUECKZELLE_1700 ;
			sm_b_achse_sto := se_b_achse_sto AND
							(gst_datensatz.st_wkz.i16_typ_bandeinzug = SERVO);
			sm_transport_achse_sto := se_transport_achse_sto AND
							(gst_datensatz.st_md.b_anwahl_transport_achse);
		END_IF

		(* Gruppe Schutzeinrichtungen *)
		(* Schutztüren Bestückautomat vorne *)
		sm_tuere_vorne_offen :=  NOT se_tuere_vorne_offen;
		sm_tuere_vorne_diskrepanz := se_tuere_vorne_diskrepanz;
		(* Schutztüren Bestückautomat hinten *)
		sm_tuere_hinten_offen := NOT se_tuere_hinten_offen;
		sm_tuere_hinten_diskrepanz := se_tuere_hinten_diskrepanz;

		(* SAFETY- FB-Fehler *)
		sm_fehler_fb1_opmode := se_fehler_fb1_opmode;
		sm_fehler_fb9_estop_nothalt_front := se_fehler_fb9_estop_nothalt_front;
		sm_fehler_fb10_estop_nothalt_ext := se_fehler_fb10_estop_nothalt_ext;
		sm_fehler_fb15_edm_nothalt_ext := se_fehler_fb15_edm_nothalt_ext;
		sm_fehler_fb16_edm_nothalt_schuetz := se_fehler_fb16_edm_nothalt_schuetz;
		sm_fehler_fb17_edm_ventilinsel := se_fehler_fb17_edm_ventilinsel;
		sm_fehler_fb28_edm_foerderband := se_fehler_fb28_edm_foerderband;
		sm_fehler_fb30_estop_rueck := se_fehler_fb30_estop_rueck;
		sm_fehler_fb31_estop_bedien := se_fehler_fb31_estop_bedien;
		sm_fehler_fb35_mon_tuere_vo := se_fehler_fb35_mon_tuere_vo;
		sm_fehler_fb36_mon_tuere_hi := se_fehler_fb36_mon_tuere_hi;
		sm_fehler_fb37_mon_tuere_disk_vo := se_fehler_fb37_mon_tuere_disk_vo;
		sm_fehler_fb38_mon_tuere_disk_hi := se_fehler_fb38_mon_tuere_disk_hi;
		sm_fehler_fb39_mon_tuere_meld_vo := se_fehler_fb39_mon_tuere_meld_vo;
		sm_fehler_fb40_mon_tuere_meld_hi := se_fehler_fb40_mon_tuere_meld_hi;

		IF gst_datensatz.st_md.b_hublift_links_aktiv THEN
			sm_not_halt_hublift_links := NOT e_not_halt_hublift_links_ok;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_steuerung_aus;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_not_halt_intern;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_not_halt_extern;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_tuere_vorne_offen;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_tuere_hinten_offen;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := sm_tuere_vorne_diskrepanz;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := sm_tuere_hinten_diskrepanz;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := sm_bestueckachse_sto;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := sm_bestueckachse_sls;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := sm_z_achse_sto;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := sm_z_achse_sls;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := sm_y_achse_sto;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := sm_y_achse_sls;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := sm_not_halt_frontseite;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := sm_not_halt_rueckseite;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := sm_not_halt_bediengeraet;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := sm_b_achse_sto;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := sm_b_achse_sls;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := sm_transport_achse_sto;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := sm_transport_achse_sls;
	garr_stoermeldungen[st_config.i16_meld_startindex + 20] := sm_fehler_fb1_opmode;
	garr_stoermeldungen[st_config.i16_meld_startindex + 21] := sm_fehler_fb9_estop_nothalt_front;
	garr_stoermeldungen[st_config.i16_meld_startindex + 22] := sm_fehler_fb10_estop_nothalt_ext;
	garr_stoermeldungen[st_config.i16_meld_startindex + 23] := sm_fehler_fb15_edm_nothalt_ext	;
	garr_stoermeldungen[st_config.i16_meld_startindex + 24] := sm_fehler_fb16_edm_nothalt_schuetz;
	garr_stoermeldungen[st_config.i16_meld_startindex + 25] := sm_fehler_fb17_edm_ventilinsel;
	garr_stoermeldungen[st_config.i16_meld_startindex + 26] := sm_fehler_fb28_edm_foerderband;
	garr_stoermeldungen[st_config.i16_meld_startindex + 27] := sm_fehler_fb30_estop_rueck;
	garr_stoermeldungen[st_config.i16_meld_startindex + 28] := sm_fehler_fb31_estop_bedien;
	garr_stoermeldungen[st_config.i16_meld_startindex + 29] := sm_fehler_fb35_mon_tuere_vo;
	garr_stoermeldungen[st_config.i16_meld_startindex + 30] := sm_fehler_fb36_mon_tuere_hi;
	garr_stoermeldungen[st_config.i16_meld_startindex + 31] := sm_fehler_fb37_mon_tuere_disk_vo;
	garr_stoermeldungen[st_config.i16_meld_startindex + 32] := sm_fehler_fb38_mon_tuere_disk_hi;
	garr_stoermeldungen[st_config.i16_meld_startindex + 33] := sm_fehler_fb39_mon_tuere_meld_vo;
	garr_stoermeldungen[st_config.i16_meld_startindex + 34] := sm_fehler_fb40_mon_tuere_meld_hi;
	garr_stoermeldungen[st_config.i16_meld_startindex + 35] := sm_not_halt_hublift_links;
	garr_stoermeldungen[st_config.i16_meld_startindex + 36] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 37] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 38] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 39] := FALSE;

	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_taste_steuerung_ein_verhaengt;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := bm_taste_steuerung_aus_verhaengt;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := bm_taste_stoerung_quitt_verhaengt;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Stueckzahlen' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ST_Stueckzahl
VAR_INPUT
	b_wkz_zweifachfallend			: BOOL;
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz					: TON;
	fb_ton_uez					: TON;
	fb_ton_quitt					: TON;
	fb_r_trig_gutteil				: R_TRIG;
	fb_r_trig_schlechtteil			: R_TRIG;
	fb_state_entry					: ST_StateEntry;
	i							: INT;
	sm_auftrag_voll				: BOOL := FALSE;
	sm_verpackungseinheit_voll	: BOOL := FALSE;
	i16_faktor_wkz				: INT := 1;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_gutteil(CLK:= st_ctrl_in.b_gutteil_produziert, Q=> );
fb_r_trig_schlechtteil(CLK:= st_ctrl_in.b_schlechtteil_produziert, Q=> );


IF b_wkz_zweifachfallend THEN
	i16_faktor_wkz := 2;
ELSE
	i16_faktor_wkz := 1;
END_IF

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF

	(* Zählerstände rücksetzen *)
	FOR i := 0 TO (SIZEOF (gst_datensatz.st_stueckzahlen.st_teilezaehler) / SIZEOF (gst_datensatz.st_stueckzahlen.st_teilezaehler[0])) - 1  BY 1 DO
		IF gst_datensatz.st_stueckzahlen.st_teilezaehler[i].b_reset_gutteile THEN
			gst_datensatz.st_stueckzahlen.st_teilezaehler[i].i32_aktuelle_gutteile := 0;
		END_IF
		IF gst_datensatz.st_stueckzahlen.st_teilezaehler[i].b_reset_schlechtteile THEN
			gst_datensatz.st_stueckzahlen.st_teilezaehler[i].i32_aktuelle_schlechtteile := 0;
		END_IF
	END_FOR
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			sm_auftrag_voll := FALSE;
			sm_verpackungseinheit_voll := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(* Zähler hochzählen *)
		IF fb_r_trig_gutteil.Q THEN
			gst_datensatz.st_stueckzahlen.st_teilezaehler[JAHR].i32_aktuelle_gutteile := gst_datensatz.st_stueckzahlen.st_teilezaehler[JAHR].i32_aktuelle_gutteile + i16_faktor_wkz;
			gst_datensatz.st_stueckzahlen.st_teilezaehler[VPE].i32_aktuelle_gutteile := gst_datensatz.st_stueckzahlen.st_teilezaehler[VPE].i32_aktuelle_gutteile + i16_faktor_wkz;
		END_IF

		IF fb_r_trig_schlechtteil.Q THEN
			gst_datensatz.st_stueckzahlen.st_teilezaehler[JAHR].i32_aktuelle_schlechtteile := gst_datensatz.st_stueckzahlen.st_teilezaehler[JAHR].i32_aktuelle_schlechtteile + i16_faktor_wkz;
			gst_datensatz.st_stueckzahlen.st_teilezaehler[VPE].i32_aktuelle_schlechtteile := gst_datensatz.st_stueckzahlen.st_teilezaehler[VPE].i32_aktuelle_schlechtteile + i16_faktor_wkz;
		END_IF

		(* Eine Verpackungseinheit ist voll *)
		IF 	gst_datensatz.st_stueckzahlen.st_teilezaehler[VPE].i32_aktuelle_gutteile >= gst_datensatz.st_stueckzahlen.st_teilezaehler[VPE].i32_vorgabe_gutteile AND
			fb_state_entry.i16_next_step <> FEHLER
			THEN
				gst_datensatz.st_stueckzahlen.st_teilezaehler[AUFTRAG].i32_aktuelle_gutteile := gst_datensatz.st_stueckzahlen.st_teilezaehler[AUFTRAG].i32_aktuelle_gutteile + 1;
				sm_verpackungseinheit_voll := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
		END_IF
		(* Gesamter Auftrag ist voll *)
		IF 	gst_datensatz.st_stueckzahlen.st_teilezaehler[AUFTRAG].i32_aktuelle_gutteile >= gst_datensatz.st_stueckzahlen.st_teilezaehler[AUFTRAG].i32_vorgabe_gutteile AND
			fb_state_entry.i16_next_step <> FEHLER
			THEN
				sm_auftrag_voll := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;

			IF gst_datensatz.st_stueckzahlen.st_teilezaehler[VPE].i32_aktuelle_gutteile >= gst_datensatz.st_stueckzahlen.st_teilezaehler[VPE].i32_vorgabe_gutteile THEN
				gst_datensatz.st_stueckzahlen.st_teilezaehler[VPE].i32_aktuelle_gutteile := 0;
				sm_verpackungseinheit_voll := FALSE;
			END_IF
			IF gst_datensatz.st_stueckzahlen.st_teilezaehler[AUFTRAG].i32_aktuelle_gutteile >= gst_datensatz.st_stueckzahlen.st_teilezaehler[AUFTRAG].i32_vorgabe_gutteile THEN
				gst_datensatz.st_stueckzahlen.st_teilezaehler[AUFTRAG].i32_aktuelle_gutteile := 0;
				sm_auftrag_voll := FALSE;
			END_IF
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_verpackungseinheit_voll;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_auftrag_voll;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/TagReader' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Konvertiere_gelese_TagData
VAR
	i : INT := 0;
END_VAR
(* @END_DECLARATION := '0' *)
IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
	gst_tag_data.WpcNumber := balluff_tag_reader.fb.s_lese_daten[0];
	gst_tag_data.StateParts[0] := balluff_tag_reader.fb.s_lese_daten[1];
	gst_tag_data.StateParts[1] := balluff_tag_reader.fb.s_lese_daten[2];

	MEMCPY( ADR(gst_tag_data.Articelnumber), ADR(balluff_tag_reader.fb.s_lese_daten[3]), 50);
	gst_tag_data.LastUsedTool := balluff_tag_reader.fb.s_lese_daten[54];
	MEMCPY( ADR(gst_tag_data.UmlNo_VPE), ADR(balluff_tag_reader.fb.s_lese_daten[55]), 4);
	gst_datensatz.st_md.s_aktuelle_artikelnummer := gst_tag_data.Articelnumber;
ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
	gst_tag_data.WpcNumber := balluff_tag_reader.fb.s_lese_daten[0];
	FOR i:= 0 TO 7 BY 1 DO
		gst_tag_data.StateParts[i] := balluff_tag_reader.fb.s_lese_daten[i + 1];
	END_FOR
	gst_tag_data.AmountPartsOnWpc := balluff_tag_reader.fb.s_lese_daten[10];
	gst_tag_data.LastUsedTool := balluff_tag_reader.fb.s_lese_daten[15];
	MEMCPY( ADR(gst_tag_data.Articelnumber), ADR(balluff_tag_reader.fb.s_lese_daten[20]), 50);
	MEMCPY( ADR(gst_tag_data.UmlNo_VPE), ADR(balluff_tag_reader.fb.s_lese_daten[71]), 4);
	gst_datensatz.st_md.s_aktuelle_artikelnummer := gst_tag_data.Articelnumber;
END_IF

(* Wenn Haken in Visu gesetzt ist dann BESTUECKUNG_MANUAL *)
(* Sonst kommt Info von der WT-XML *)
IF gst_datensatz.st_md.b_bestueckprogramm_manuell THEN
	gst_datensatz.st_md.i16_typ_bestueckmodus := BESTUECKUNG_MANUAL;
ELSE
	gst_datensatz.st_md.i16_typ_bestueckmodus := gst_datensatz.st_wt.i16_typ_bestueckmodus;
END_IF

(* Wenn Hublift links aktiv ist, soll Zelle Last Used Tool auf 0 zurücksetzen *)
(* Damit wird UML simuliert. Diese Funktion ermöglicht Kleinserien mit Hublift links *)
IF gst_datensatz.st_md.b_hublift_links_aktiv THEN
	gst_tag_data.StateParts[0] := PART_NEW;
	gst_tag_data.StateParts[1] := PART_NEW;
	gst_tag_data.LastUsedTool := 0;
END_IF

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/TagReader' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Lesen_Schreiben_Tag
VAR_INPUT
	st_config					: struct_config;
	st_ctrl_in					: struct_ctrl_in;
END_VAR
VAR_OUTPUT
	st_ctrl_out				: struct_ctrl_out;
END_VAR
VAR
	fb_r_trig_lesen			: R_TRIG;
	fb_r_trig_schreiben		: R_TRIG;
	fb_r_trig_WT_ruecksetzen	: R_TRIG;
	fb_r_trig_auto_lesen		: R_TRIG;
	fb_ton_lesen				: TON;
	fb_ton_auto_lesen				: TON;
	fb_ton_Timeout				: TON;

	fb_state_entry				: ST_StateEntry;
	fb_ton_quitt				: TON;
	fb_r_trig_quittieren			: R_TRIG;
	fb_ton_uez				: TON;

	sm_WT_Nummer_ungueltig				: BOOL := FALSE;
	sm_wt_hat_kein_tag					: BOOL := FALSE;
	bm_kein_WT_im_Aktionsfeld			: BOOL := FALSE;
	bm_Wert_nicht_erlaubt					: BOOL := FALSE;

	i									: INT;

	i16_betriebsart: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
fb_ton_quitt(IN:= , PT:= t#500ms, Q=> , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );

fb_ton_lesen(IN:= , PT:= t#500ms, Q=> , ET=> );
fb_r_trig_lesen(CLK:=visu.st_tagreader.b_start_lesen , Q=>);
fb_ton_auto_lesen(IN:=balluff_tag_reader.fb.e_tag_im_aktionsfeld   AND gi16_betriebsart = HAND , PT:= t#500ms, Q=> , ET=> );
fb_r_trig_auto_lesen(CLK:= fb_ton_auto_lesen.Q , Q=>);


fb_r_trig_schreiben(CLK:=visu.st_tagreader.b_start_schreiben , Q=>);
fb_r_trig_WT_ruecksetzen(CLK:=visu.st_tagreader.b_WT_ruecksetzen , Q=>);

visu.st_tagreader.b_tag_im_Aktionsfeld:=balluff_tag_reader.fb.e_tag_im_aktionsfeld;

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

(*wenn Tagreader nicht bereit ist stoppen*)
IF	Balluff_Tag_Reader.fb.fb_state_entry.i16_step<BEREIT OR
	Balluff_Tag_Reader.fb.fb_state_entry.i16_step>=STOP THEN
	fb_state_entry.i16_next_step := STOP;
END_IF

fb_ton_Timeout(IN:= fb_state_entry.i16_step>BEREIT AND fb_state_entry.i16_step<FEHLER, PT:= t#35s, Q=> , ET=> );
IF	fb_ton_Timeout.Q THEN
	fb_state_entry.i16_next_step := FEHLER;
END_IF

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:

		fb_state_entry.i16_next_step := INIT;

(*=======================================================*)
	INIT:
		IF 	fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_lesen := FALSE;
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;

			sm_WT_Nummer_ungueltig:=FALSE;
			sm_wt_hat_kein_tag:=FALSE;

			visu.st_tagreader.b_WT_ruecksetzen:=FALSE;
			visu.st_tagreader.b_start_schreiben:=FALSE;
			visu.st_tagreader.b_start_lesen:=FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := BEREIT;

(*=======================================================*)
	BEREIT:	(* Warte auf Start von Kontroller *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	balluff_tag_reader.fb.e_tag_im_aktionsfeld   AND gi16_betriebsart = HAND THEN
			IF	fb_r_trig_lesen.Q  OR fb_r_trig_auto_lesen.Q THEN
				fb_state_entry.i16_next_step := 120;
			END_IF

			IF	fb_r_trig_schreiben.Q THEN
				fb_state_entry.i16_next_step := 150;
			END_IF

			IF	fb_r_trig_WT_ruecksetzen.Q THEN
				fb_state_entry.i16_next_step := 200;
			END_IF
		ELSE
			IF	fb_r_trig_WT_ruecksetzen.Q OR
				fb_r_trig_schreiben.Q OR
				fb_r_trig_lesen.Q THEN
				fb_state_entry.i16_next_step := 110;
			END_IF
		END_IF

(*=======================================================*)
	110:
		IF 	fb_state_entry.E THEN
			fb_ton_uez.PT:=t#2000ms ;
			fb_ton_uez.IN:=TRUE ;
			bm_kein_WT_im_Aktionsfeld:=TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	fb_ton_uez.Q THEN
			fb_state_entry.i16_next_step := INIT;
			fb_ton_uez.IN:=FALSE ;
			bm_kein_WT_im_Aktionsfeld:=FALSE;
		END_IF

(*=======================================================*)
	120:
		IF 	fb_state_entry.E THEN
			gst_tag_data.Articelnumber:='LESEN';
			gst_tag_data.LastUsedTool:=0;
			IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
				gst_tag_data.StateParts[0]:=100;
				gst_tag_data.StateParts[1]:=100;
			ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
				FOR i:= 0 TO 7 BY 1 DO
					gst_tag_data.StateParts[i] := 100;
				END_FOR
			END_IF
			gst_tag_data.WpcNumber:=0;
			fb_ton_lesen.IN:=TRUE;
		END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
	IF	fb_ton_lesen.Q THEN
		fb_ton_lesen.IN:=FALSE;
		fb_state_entry.i16_next_step := 130;
	END_IF

(*=======================================================*)
	130: (* WT-Tag mit RFID-Lesegerät auslesen *)
		IF 	fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_lesen := TRUE;
			balluff_tag_reader.fb.i16_addresse := 0;
			balluff_tag_reader.fb.i16_anzahl_byte := SIZEOF(gst_tag_data);
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
				gst_tag_data.WpcNumber := balluff_tag_reader.fb.s_lese_daten[0];
				gst_tag_data.StateParts[0] := balluff_tag_reader.fb.s_lese_daten[1];
				gst_tag_data.StateParts[1] := balluff_tag_reader.fb.s_lese_daten[2];

				MEMCPY( ADR(gst_tag_data.Articelnumber), ADR(balluff_tag_reader.fb.s_lese_daten[3]), 50);
				gst_tag_data.LastUsedTool := balluff_tag_reader.fb.s_lese_daten[54];
				MEMCPY( ADR(gst_tag_data.UmlNo_VPE), ADR(balluff_tag_reader.fb.s_lese_daten[55]), 4);

				(*gst_datensatz.st_md.s_aktuelle_artikelnummer := gst_tag_data.Articelnumber;*)
			ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
				gst_tag_data.WpcNumber := balluff_tag_reader.fb.s_lese_daten[0];
				FOR i:= 0 TO 7 BY 1 DO
					gst_tag_data.StateParts[i] := balluff_tag_reader.fb.s_lese_daten[i + 1];
				END_FOR
				gst_tag_data.AmountPartsOnWpc := balluff_tag_reader.fb.s_lese_daten[10];
				gst_tag_data.LastUsedTool := balluff_tag_reader.fb.s_lese_daten[15];
				MEMCPY( ADR(gst_tag_data.Articelnumber), ADR(balluff_tag_reader.fb.s_lese_daten[20]), 50);
				MEMCPY( ADR(gst_tag_data.UmlNo_VPE), ADR(balluff_tag_reader.fb.s_lese_daten[71]), 4);
			END_IF

			IF 	gst_tag_data.WpcNumber >= 0 AND gst_tag_data.WpcNumber <=50 THEN
				balluff_tag_reader.st_ctrl.in.b_start_lesen := FALSE;
				fb_state_entry.i16_next_step := INIT;
			ELSE
				(* Fehler: Tagnummer ist nicht im gültigem Bereich *)
				balluff_tag_reader.st_ctrl.in.b_start_lesen := FALSE;
				sm_WT_Nummer_ungueltig := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	150:	(*Artikelnummer schreiben*)
		IF 	fb_state_entry.E THEN
			IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
	
				balluff_tag_reader.fb.i16_addresse := 3;
				balluff_tag_reader.fb.i16_anzahl_byte := SIZEOF(gst_tag_data.Articelnumber);
				MEMCPY(ADR(balluff_tag_reader.fb.s_schreib_daten),ADR(gst_tag_data.Articelnumber),  50);
			ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
	
				balluff_tag_reader.fb.i16_addresse := 20;
				balluff_tag_reader.fb.i16_anzahl_byte := SIZEOF(gst_tag_data.Articelnumber);
				MEMCPY(ADR(balluff_tag_reader.fb.s_schreib_daten),ADR(gst_tag_data.Articelnumber),  50);
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			(* Ok: Daten sind auf dem Tag *)
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := 155;
		END_IF

(*=======================================================*)
	155:	(*UML_Stueckzaehler schreiben*)
		IF 	fb_state_entry.E THEN
			IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;

				balluff_tag_reader.fb.i16_addresse := 55;
				balluff_tag_reader.fb.i16_anzahl_byte := SIZEOF(gst_tag_data.UmlNo_VPE);
				MEMCPY( ADR(balluff_tag_reader.fb.s_schreib_daten), ADR(gst_tag_data.UmlNo_VPE), 4);

			ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;

				balluff_tag_reader.fb.i16_addresse := 71;
				balluff_tag_reader.fb.i16_anzahl_byte := SIZEOF(gst_tag_data.UmlNo_VPE);
				MEMCPY(ADR(balluff_tag_reader.fb.s_schreib_daten),ADR(gst_tag_data.UmlNo_VPE),  4);
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			(* Ok: Daten sind auf dem Tag *)
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160:	(*States schreiben*)
		IF 	fb_state_entry.E THEN
			IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
	
				balluff_tag_reader.fb.i16_addresse := 1;
				balluff_tag_reader.fb.i16_anzahl_byte := 2;
				balluff_tag_reader.fb.s_schreib_daten[0] := DINT_TO_BYTE(gst_tag_data.StateParts[0]);
				balluff_tag_reader.fb.s_schreib_daten[1] := DINT_TO_BYTE(gst_tag_data.StateParts[1]);
			ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
	
				balluff_tag_reader.fb.i16_addresse := 1;
				balluff_tag_reader.fb.i16_anzahl_byte := 8;
				FOR i:= 0 TO 7 BY 1 DO
					balluff_tag_reader.fb.s_schreib_daten[i] := DINT_TO_BYTE(gst_tag_data.StateParts[i]);
				END_FOR
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			(* Ok: Daten sind auf dem Tag *)
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := 170;
		END_IF

(*=======================================================*)
	170:	(* WT Nummer schreiben *)
		IF	 fb_state_entry.E THEN
			(* Starte Schreib Prozess *)
			balluff_tag_reader.fb.i16_addresse := 0;
			balluff_tag_reader.fb.i16_anzahl_byte := 1;
			balluff_tag_reader.fb.s_schreib_daten[0] := gst_tag_data.WpcNumber;
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := 180;
		END_IF

(*=======================================================*)
	180:	(* letztes benutzes Werkzeug schreiben*)
		IF 	fb_state_entry.E THEN
			(* Starte Schreib Prozess *)
			IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
				balluff_tag_reader.fb.i16_addresse := 54;
				balluff_tag_reader.fb.i16_anzahl_byte := 1;
				balluff_tag_reader.fb.s_schreib_daten[0] := gst_tag_data.LastUsedTool;
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
			ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
				balluff_tag_reader.fb.i16_addresse := 15;
				balluff_tag_reader.fb.i16_anzahl_byte := 1;
				balluff_tag_reader.fb.s_schreib_daten[0] := gst_tag_data.LastUsedTool;
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
				fb_state_entry.i16_next_step := 120;
			ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
				fb_state_entry.i16_next_step := 190;
			END_IF
		END_IF

(*=======================================================*)
	190:	(* Anzahl ISK auf WT *)
		IF 	fb_state_entry.E THEN
			(* Starte Schreib Prozess *)
			balluff_tag_reader.fb.i16_addresse := 10;
			balluff_tag_reader.fb.i16_anzahl_byte := 1;
			balluff_tag_reader.fb.s_schreib_daten[0] := gst_tag_data.AmountPartsOnWpc;
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	200:	(*WT zurücksetzen*)
		IF	 fb_state_entry.E THEN
			IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
				gst_tag_data.StateParts[0] := PART_NO;
				gst_tag_data.StateParts[1] := PART_NO;

				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
				balluff_tag_reader.fb.i16_addresse := 1;
				balluff_tag_reader.fb.i16_anzahl_byte := 2;
				balluff_tag_reader.fb.s_schreib_daten[0] := DINT_TO_BYTE(gst_tag_data.StateParts[0]);
				balluff_tag_reader.fb.s_schreib_daten[1] := DINT_TO_BYTE(gst_tag_data.StateParts[1]);
			ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
				FOR i:= 0 TO 7 BY 1 DO
					gst_tag_data.StateParts[i] := PART_NO;
				END_FOR
	
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
				balluff_tag_reader.fb.i16_addresse := 1;
				balluff_tag_reader.fb.i16_anzahl_byte := 8;
				FOR i:= 0 TO 7 BY 1 DO
					balluff_tag_reader.fb.s_schreib_daten[i] := DINT_TO_BYTE(gst_tag_data.StateParts[i]);
				END_FOR
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			(* Ok: Daten sind auf dem Tag *)
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* letztes benutzes Werkzeug schreiben*)
		IF 	fb_state_entry.E THEN
			gst_tag_data.LastUsedTool := 0;
			(* Starte Schreib Prozess *)
			IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
				balluff_tag_reader.fb.i16_addresse := 54;
				balluff_tag_reader.fb.i16_anzahl_byte := 1;
				balluff_tag_reader.fb.s_schreib_daten[0] := 0;
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
			ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
				balluff_tag_reader.fb.i16_addresse := 15;
				balluff_tag_reader.fb.i16_anzahl_byte := 1;
				balluff_tag_reader.fb.s_schreib_daten[0] := 0;
				balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF 	fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF 	fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF 	fb_state_entry.E THEN
			;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	Balluff_Tag_Reader.fb.fb_state_entry.i16_step=BEREIT THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_WT_Nummer_ungueltig;
garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_wt_hat_kein_tag;
garr_stoermeldungen[st_config.i16_meld_startindex + 2] :=FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;

garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_kein_WT_im_Aktionsfeld;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := bm_Wert_nicht_erlaubt;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/TagReader' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Markiere_WT_IO
VAR
	i 						:INT := 0;
	b_Rasterfolie_montiert	:BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Auswertung der Bestückung (Pins bzw. Rasterplatte) des ISK *)
CASE gst_datensatz.st_md.i16_typ_zelle OF
	KEINE_ZELLE:
		;

	BESTUECKZELLE_1700:
		(* WT Hat die Maschine auf regulärem Weg wieder verlassen *)
		(* --> Teil ist Ok *)
		IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
			gst_tag_data.StateParts[0] := PART_OK;
			gst_tag_data.StateParts[1] := PART_OK;	(* Damit die Stuktur nicht umgestellt werden muss, bei 2 ISO auf einem WT *)
		ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
			FOR i:= 0 TO gst_tag_data.AmountPartsOnWpc - 1 BY 1 DO
				gst_tag_data.StateParts[i] := PART_OK;
			END_FOR
			FOR i:= gst_tag_data.AmountPartsOnWpc TO 7 BY 1 DO
				gst_tag_data.StateParts[i] := PART_NO;
			END_FOR
		END_IF

	BESTUECKZELLE_1720:
		(* WT Hat die Maschine auf regulärem Weg wieder verlassen *)
		(* --> Teil ist Ok *)
		IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
			gst_tag_data.StateParts[0] := PART_OK;
			gst_tag_data.StateParts[1] := PART_OK;
		ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
			FOR i:= 0 TO gst_tag_data.AmountPartsOnWpc - 1 BY 1 DO
				gst_tag_data.StateParts[i] := PART_OK;
			END_FOR
			FOR i:= gst_tag_data.AmountPartsOnWpc TO 7 BY 1 DO
				gst_tag_data.StateParts[i] := PART_NO;
			END_FOR
		END_IF

	RASTERFOLIE:
			b_Rasterfolie_montiert:=	TRUE;
			FOR i := 0 TO DINT_TO_INT(gst_datensatz.st_bestueckprogramm.i32_anzahl) - 1 BY 1 DO
				IF	NOT ST_Rasterfolienmontage.arr_rafo_schieberegister[i]THEN
					b_Rasterfolie_montiert:=	FALSE;
				END_IF
			END_FOR

		IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
			IF b_Rasterfolie_montiert THEN
				gst_tag_data.StateParts[0] := PART_OK;
				gst_tag_data.StateParts[1] := PART_OK;	(* Damit die Stuktur nicht umgestellt werden muss, bei 2 ISO auf einem WT *)
			ELSE
				gst_tag_data.StateParts[0] := PART_NOK;
				gst_tag_data.StateParts[1] := PART_NOK;
			END_IF
		ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
			IF b_Rasterfolie_montiert THEN
				FOR i:= 0 TO gst_tag_data.AmountPartsOnWpc - 1 BY 1 DO
					gst_tag_data.StateParts[i] := PART_OK;
				END_FOR
				FOR i:= gst_tag_data.AmountPartsOnWpc TO 7 BY 1 DO
					gst_tag_data.StateParts[i] := PART_NO;
				END_FOR
			ELSE
				FOR i:= 0 TO gst_tag_data.AmountPartsOnWpc - 1 BY 1 DO
					gst_tag_data.StateParts[i] := PART_NOK;
				END_FOR
				FOR i:= gst_tag_data.AmountPartsOnWpc TO 7 BY 1 DO
					gst_tag_data.StateParts[i] := PART_NO;
				END_FOR
			END_IF
		END_IF
END_CASE
(* Starte Schreib Prozess *)
IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
	balluff_tag_reader.fb.i16_addresse := 1;
	balluff_tag_reader.fb.i16_anzahl_byte := 2;
	balluff_tag_reader.fb.s_schreib_daten[0] := DINT_TO_BYTE(gst_tag_data.StateParts[0]);
	balluff_tag_reader.fb.s_schreib_daten[1] := DINT_TO_BYTE(gst_tag_data.StateParts[1]);
	balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1THEN
	balluff_tag_reader.fb.i16_addresse := 1;
	balluff_tag_reader.fb.i16_anzahl_byte := 8;
	FOR i:= 0 TO 7 BY 1 DO
		balluff_tag_reader.fb.s_schreib_daten[i] := DINT_TO_BYTE(gst_tag_data.StateParts[i]);
	END_FOR
	balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/TagReader' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Markiere_WT_NIO
VAR
	i : INT := 0;
END_VAR
(* @END_DECLARATION := '0' *)
IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
	gst_tag_data.StateParts[0] := PART_NOK;
	gst_tag_data.StateParts[1] := PART_NOK;

	(* Starte Schreib Prozess *)
	balluff_tag_reader.fb.i16_addresse := 1;
	balluff_tag_reader.fb.i16_anzahl_byte := 2;
	balluff_tag_reader.fb.s_schreib_daten[0] := DINT_TO_BYTE(gst_tag_data.StateParts[0]);
	balluff_tag_reader.fb.s_schreib_daten[1] := DINT_TO_BYTE(gst_tag_data.StateParts[1]);
	balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
	balluff_tag_reader.fb.i16_addresse := 1;
	balluff_tag_reader.fb.i16_anzahl_byte := 8;
	FOR i:= 0 TO gst_tag_data.AmountPartsOnWpc - 1 BY 1 DO
		gst_tag_data.StateParts[i] := PART_NOK;
	END_FOR
	FOR i:= gst_tag_data.AmountPartsOnWpc TO 7 BY 1 DO
		gst_tag_data.StateParts[i] := PART_NO;
	END_FOR
	FOR i:= 0 TO 7 BY 1 DO
		balluff_tag_reader.fb.s_schreib_daten[i] := DINT_TO_BYTE(gst_tag_data.StateParts[i]);
	END_FOR
	balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/TagReader' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Schreibe_LastUsedTool
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(* Starte Schreib Prozess *)
IF gst_datensatz.st_md.i16_tag_data_structur_version = 0 THEN
	balluff_tag_reader.fb.i16_addresse := 54;
	balluff_tag_reader.fb.i16_anzahl_byte := 1;
	balluff_tag_reader.fb.s_schreib_daten[0] := gst_tag_data.LastUsedTool;
	balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
ELSIF gst_datensatz.st_md.i16_tag_data_structur_version = 1 THEN
	balluff_tag_reader.fb.i16_addresse := 15;
	balluff_tag_reader.fb.i16_anzahl_byte := 1;
	balluff_tag_reader.fb.s_schreib_daten[0] := gst_tag_data.LastUsedTool;
	balluff_tag_reader.st_ctrl.in.b_start_schreiben := TRUE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Message_Produktion
VAR_INPUT
	b_PM_Quitt		:BOOL:=FALSE;
END_VAR
VAR
	LockFlag				: BOOL := FALSE;	(* Ganz wichtig, wenn diese Variable TRUE ist, dann kann die Struktur "Visu.MeldungProduktion" nicht verändert werden *)
	b_init					: BOOL:=FALSE;

	fb_r_trig_LockFree		: R_TRIG;
	fb_f_trig_Button1		: F_TRIG;
	fb_f_trig_Button2		: F_TRIG;
	fb_ton_quitt			: TON;
	fb_ton_autoquitt		: TON;

	i						: INT;
END_VAR
(* @END_DECLARATION := '0' *)
IF NOT b_init THEN
	b_init:=TRUE;
END_IF


(*Zeiten*)
fb_ton_quitt(IN:= b_PM_Quitt, PT:= T#100ms, Q=> , ET=> );
fb_ton_autoquitt(IN:= Visu.MeldungProduktion.Name='' AND LockFlag , PT:= T#5000ms, Q=> , ET=> );

(*Flanken*)
fb_f_trig_Button1(CLK:= Visu.MeldungProduktion.Button1.tasten, Q=> );	(* OK *)
fb_f_trig_Button2(CLK:= Visu.MeldungProduktion.Button2.tasten, Q=> );	(* Cancel *)

fb_r_trig_LockFree(CLK:= fb_f_trig_Button1.Q OR	(* OK *)
						fb_f_trig_Button2.Q OR	(* Cancel *)
						fb_ton_quitt.Q, Q=> );

IF fb_r_trig_LockFree.Q OR
	fb_ton_autoquitt.Q THEN
	Visu.MeldungProduktion.Color_R:=0;
	Visu.MeldungProduktion.Color_G:=0;
	Visu.MeldungProduktion.Color_B:=0;
	Visu.MeldungProduktion.Name:='';
	Visu.MeldungProduktion.Button1.sichtbar:=FALSE;
	Visu.MeldungProduktion.Button1.Text:='';
	Visu.MeldungProduktion.Button2.sichtbar:=FALSE;
	Visu.MeldungProduktion.Button2.Text:='';
	ClearMessageLines();
	visu.MeldungProduktion.ShowMessage:=FALSE;
	b_PM_Quitt:=FALSE;
	LockFree();
END_IF


(* wenn etwas in Name drin steht, dann soll Meldung angezeigt werden *)
IF	Visu.MeldungProduktion.Name <> '' THEN
	visu.MeldungProduktion.ShowMessage:=TRUE;
END_IF

(*
Beispiel Aufruf

(*=======================================================*)
	900:	(*Warten bis keine andere Produktions Meldung ansteht *)
	
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			fb_state_entry.i16_next_step := 910;
		END_IF
		
(*=======================================================*)
	910:  (*Produktions Meldung *)
		IF fb_state_entry.E THEN
			Visu.MeldungProduktion.Color:=Color.yellow;
			Visu.MeldungProduktion.Name:='';
			Visu.MeldungProduktion.Text:='PM100';
	
			Visu.MeldungProduktion.Button1.unsichtbar:=FALSE;	(*OK*)
			Visu.MeldungProduktion.Button2.unsichtbar:=FALSE;	(*Cancel*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_Message_Produktion.fb_f_trig_Button1.Q THEN
			fb_state_entry.i16_next_step:=920;
		ELSIF ST_Message_Produktion.fb_f_trig_Button2.Q THEN
			fb_state_entry.i16_next_step:=FEHLER;
		ELSIF b_Help THEN
			ST_Message_Produktion.b_PM_Quitt := TRUE;
			fb_state_entry_2.i16_next_step:=BEREIT;
		END_IF

		---WICHTIG---
		Die Variable "ST_Message_Produktion.b_PM_Quitt" darf nicht auf FALSE gesetzt werden.
		Das wird im Baustein ST_Message_Produktion gemacht.

*)
END_PROGRAM
ACTION	ClearMessageLines:
FOR i:=0 TO 9 DO
	Visu.MeldungProduktion.Text[i]:='';
END_FOR;
END_ACTION

ACTION	LockFree:
LockFlag := FALSE;	(* wieder freigeben *)
END_ACTION





(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_VisuRouter
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(*Anzeige der aktuellen Betriebsart*)
CASE gi16_betriebsart OF
	KEINE:
		visu_hinten.in.betriebsart := visu_hinten.in.texte.txt_variabel[8];

	AUTO:
		visu_hinten.in.betriebsart := visu_hinten.in.texte.txt_variabel[5];

	TIPPEN:
		visu_hinten.in.betriebsart := visu_hinten.in.texte.txt_variabel[6];

	HAND:
		visu_hinten.in.betriebsart := visu_hinten.in.texte.txt_variabel[7];
END_CASE

(*Anzeige des Maschinenstatus*)
CASE gi16_maschinenstatusinfo OF
	KEIN_STATUS:
		visu_hinten.in.s_maschinenstatusinfo := visu_hinten.in.texte.txt_variabel[0];

	STATUS_FEHLER:
		visu_hinten.in.s_maschinenstatusinfo := visu_hinten.in.texte.txt_variabel[1];

	STATUS_FEHLER_QUITTIERT:
		visu_hinten.in.s_maschinenstatusinfo := visu_hinten.in.texte.txt_variabel[2];

	STATUS_BETRIEBSBEREIT:
		visu_hinten.in.s_maschinenstatusinfo := visu_hinten.in.texte.txt_variabel[3];

	STATUS_MASCHINE_ARBEITET:
		visu_hinten.in.s_maschinenstatusinfo := visu_hinten.in.texte.txt_variabel[4];
END_CASE

visu_hinten.in.i16_maschinenstatusinfo := gi16_maschinenstatusinfo;
visu_hinten.in.s_betriebsmeldung := ST_Virtuelle_Masterachse.bm_an_visu_hinten;
visu_hinten.in.i16_position_ist := LREAL_TO_INT(bestueckachse.NcToPlc.ModuloActPos);
visu_hinten.in.i16_typ_zelle := gst_datensatz.st_md.i16_typ_zelle;
visu_hinten.in.i16_typ_bandeinzug:=gst_datensatz.st_wkz.i16_typ_bandeinzug;
visu_hinten.in.band_ID_Puffer_aus:=gst_datensatz.st_md.b_band_ID_Puffer_aus;


visu_hinten.in.texte.txt_zylindernamen[2].s_einfahren:=visu_hinten.in.texte.txt_zylindernamen[0].s_einfahren;
visu_hinten.in.texte.txt_zylindernamen[2].s_ausfahren:=visu_hinten.in.texte.txt_zylindernamen[0].s_ausfahren;
visu_hinten.in.texte.txt_zylindernamen[3].s_einfahren:=visu_hinten.in.texte.txt_zylindernamen[1].s_einfahren;
visu_hinten.in.texte.txt_zylindernamen[3].s_ausfahren:=visu_hinten.in.texte.txt_zylindernamen[1].s_ausfahren;

CASE gst_datensatz.st_md.i16_typ_zelle OF
	KEINE_ZELLE:
		;

	BESTUECKZELLE_1700:

		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			KEIN_EINZUG:
				;

			STANDARD_2FACH_V2:
				;

			 SERVO:
				(* Die Seitenbezeichnungen (links, rechts) beziehen sich auf die Maschinenvorderseite *)
				(* Haspel Links Heben *)
				zyl_haspel_li_heben.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[0].b_ausfahren;
				zyl_haspel_li_heben.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[0].b_einfahren;
				visu_hinten.in.zylinder_sensoren[0].b_eingefahren := zyl_haspel_li_heben.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[0].b_ausgefahren := zyl_haspel_li_heben.fb.e_sensor1_ausgefahren;

				(* Haspel Links Sperren *)
				zyl_haspel_li_sperren.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[1].b_ausfahren;
				zyl_haspel_li_sperren.fb.b_direkttaste_einfahren :=  visu_hinten.out.zylinder_direkttasten[1].b_einfahren;
				zyl_haspel_li_abspulen.fb.b_direkttaste_ausfahren:=visu_hinten.out.zylinder_direkttasten[1].b_einfahren; (*Abspulzylinder beim Entriegeln anheben*)
				visu_hinten.in.zylinder_sensoren[1].b_eingefahren := zyl_haspel_li_sperren.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[1].b_ausgefahren := zyl_haspel_li_sperren.fb.e_sensor1_ausgefahren;
		
				(* Haspel Rechts Heben *)
				zyl_haspel_re_heben.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[2].b_ausfahren;
				zyl_haspel_re_heben.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[2].b_einfahren;
				visu_hinten.in.zylinder_sensoren[2].b_eingefahren := zyl_haspel_re_heben.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[2].b_ausgefahren := zyl_haspel_re_heben.fb.e_sensor1_ausgefahren;
		
				(* Haspel Rechts Sperren *)
				zyl_haspel_re_sperren.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[3].b_ausfahren;
				zyl_haspel_re_sperren.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[3].b_einfahren;
				zyl_haspel_re_abspulen.fb.b_direkttaste_ausfahren:=visu_hinten.out.zylinder_direkttasten[3].b_einfahren; (*Abspulzylinder beim Entriegeln anheben*)
				visu_hinten.in.zylinder_sensoren[3].b_eingefahren := zyl_haspel_re_sperren.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[3].b_ausgefahren := zyl_haspel_re_sperren.fb.e_sensor1_ausgefahren;
		
				(* Bandfänger *)
				zyl_bandfaenger.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[4].b_ausfahren;
				zyl_bandfaenger.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[4].b_einfahren;
				visu_hinten.in.zylinder_sensoren[4].b_eingefahren := zyl_bandfaenger.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[4].b_ausgefahren := zyl_bandfaenger.fb.e_sensor1_ausgefahren;
		
				(* Bandklemmen *)
				zyl_bandklemmen.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[5].b_ausfahren;
				zyl_bandklemmen.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[5].b_einfahren;
				visu_hinten.in.zylinder_sensoren[5].b_eingefahren := zyl_bandklemmen.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[5].b_ausgefahren := zyl_bandklemmen.fb.e_sensor1_ausgefahren;
		
				(* Bandwechselhalter links *)
				zyl_bawe_halter_li.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[6].b_ausfahren;
				zyl_bawe_halter_li.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[6].b_einfahren;
				visu_hinten.in.zylinder_sensoren[6].b_eingefahren := zyl_bawe_halter_li.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[6].b_ausgefahren := zyl_bawe_halter_li.fb.e_sensor1_ausgefahren;
		
				(* Bandwechselhalter rechts *)
				zyl_bawe_halter_re.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[7].b_ausfahren;
				zyl_bawe_halter_re.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[7].b_einfahren;
				visu_hinten.in.zylinder_sensoren[7].b_eingefahren := zyl_bawe_halter_re.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[7].b_ausgefahren := zyl_bawe_halter_re.fb.e_sensor1_ausgefahren;
		
				(* Bandwechselfänger links *)
				zyl_bawe_faenger_li.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[8].b_ausfahren;
				zyl_bawe_faenger_li.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[8].b_einfahren;
				visu_hinten.in.zylinder_sensoren[8].b_eingefahren := zyl_bawe_faenger_li.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[8].b_ausgefahren := zyl_bawe_faenger_li.fb.e_sensor1_ausgefahren;
		
				(* Bandwechselfänger rechts *)
				zyl_bawe_faenger_re.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[9].b_ausfahren;
				zyl_bawe_faenger_re.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[9].b_einfahren;
				visu_hinten.in.zylinder_sensoren[9].b_eingefahren := zyl_bawe_faenger_re.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[9].b_ausgefahren := zyl_bawe_faenger_re.fb.e_sensor1_ausgefahren;

				(*Spulenwechsel bie 1700======================*)
				(*Quervorschub*)
				zyl_bawe_querschub.st_ctrl.in.b_ausfahren := visu_hinten.out.zylinder_direkttasten[12].b_ausfahren;
				zyl_bawe_querschub.st_ctrl.in.b_einfahren := visu_hinten.out.zylinder_direkttasten[12].b_einfahren;

				visu_hinten.in.zylinder_sensoren[12].b_eingefahren := zyl_bawe_querschub.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[12].b_ausgefahren := zyl_bawe_querschub.fb.e_sensor1_ausgefahren;

				(*Haspel verschieben*)
				zyl_haspel_verschieben.st_ctrl.in.b_ausfahren := visu_hinten.out.zylinder_direkttasten[13].b_ausfahren;
				zyl_haspel_verschieben.st_ctrl.in.b_einfahren := visu_hinten.out.zylinder_direkttasten[13].b_einfahren;

				visu_hinten.in.zylinder_sensoren[13].b_eingefahren := zyl_haspel_verschieben.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[13].b_ausgefahren := zyl_haspel_verschieben.fb.e_sensor1_ausgefahren;

				(*Bandeinzug verschieben*)
				zyl_bandeinzuege_verschieben.st_ctrl.in.b_ausfahren := visu_hinten.out.zylinder_direkttasten[14].b_ausfahren;
				zyl_bandeinzuege_verschieben.st_ctrl.in.b_einfahren := visu_hinten.out.zylinder_direkttasten[14].b_einfahren;

				visu_hinten.in.zylinder_sensoren[14].b_eingefahren := zyl_bandeinzuege_verschieben.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[14].b_ausgefahren := zyl_bandeinzuege_verschieben.fb.e_sensor1_ausgefahren;

				(* Haspel Links abspulen *)
				zyl_haspel_li_abspulen.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[15].b_ausfahren;
				zyl_haspel_li_abspulen.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[15].b_einfahren;
				visu_hinten.in.zylinder_sensoren[15].b_eingefahren := NOT zyl_haspel_li_abspulen.fb.e_sensor1_ausgefahren;
				visu_hinten.in.zylinder_sensoren[15].b_ausgefahren := zyl_haspel_li_abspulen.fb.e_sensor1_ausgefahren;

				(* Haspel Rechts abspulen *)
				zyl_haspel_re_abspulen.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[16].b_ausfahren;
				zyl_haspel_re_abspulen.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[16].b_einfahren;
				visu_hinten.in.zylinder_sensoren[16].b_eingefahren := NOT zyl_haspel_re_abspulen.fb.e_sensor1_ausgefahren;
				visu_hinten.in.zylinder_sensoren[16].b_ausgefahren := zyl_haspel_re_abspulen.fb.e_sensor1_ausgefahren;


			BANDWECHSLER_V2:(*noch anpassen*)
				(* Die Seitenbezeichnungen (links, rechts) beziehen sich auf die Maschinenvorderseite *)
				(* Haspel Links Heben *)
				zyl_haspel_li_heben.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[0].b_ausfahren;
				zyl_haspel_li_heben.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[0].b_einfahren;
				visu_hinten.in.zylinder_sensoren[0].b_eingefahren := NOT zyl_haspel_li_heben.fb.e_sensor1_ausgefahren;
				visu_hinten.in.zylinder_sensoren[0].b_ausgefahren := zyl_haspel_li_heben.fb.e_sensor1_ausgefahren;

				(* Haspel Links Sperren *)
				zyl_haspel_li_sperren.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[1].b_ausfahren;
				zyl_haspel_li_sperren.fb.b_direkttaste_einfahren :=  visu_hinten.out.zylinder_direkttasten[1].b_einfahren;
				zyl_haspel_li_abspulen.fb.b_direkttaste_ausfahren:=visu_hinten.out.zylinder_direkttasten[1].b_einfahren; (*Abspulzylinder beim Entriegeln anheben*)
				visu_hinten.in.zylinder_sensoren[1].b_eingefahren := zyl_haspel_li_sperren.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[1].b_ausgefahren := zyl_haspel_li_sperren.fb.e_sensor1_ausgefahren;

				(* Haspel Rechts Heben *)
				zyl_haspel_re_heben.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[2].b_ausfahren;
				zyl_haspel_re_heben.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[2].b_einfahren;
				visu_hinten.in.zylinder_sensoren[2].b_eingefahren := NOT zyl_haspel_re_heben.fb.e_sensor1_ausgefahren;
				visu_hinten.in.zylinder_sensoren[2].b_ausgefahren := zyl_haspel_re_heben.fb.e_sensor1_ausgefahren;

				(* Haspel Rechts Sperren *)
				zyl_haspel_re_sperren.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[3].b_ausfahren;
				zyl_haspel_re_sperren.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[3].b_einfahren;
				zyl_haspel_re_abspulen.fb.b_direkttaste_ausfahren:=visu_hinten.out.zylinder_direkttasten[3].b_einfahren; (*Abspulzylinder beim Entriegeln anheben*)
				visu_hinten.in.zylinder_sensoren[3].b_eingefahren := zyl_haspel_re_sperren.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[3].b_ausgefahren := zyl_haspel_re_sperren.fb.e_sensor1_ausgefahren;

				(* Bandfänger *)
				zyl_bandfaenger.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[4].b_ausfahren;
				zyl_bandfaenger.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[4].b_einfahren;
				visu_hinten.in.zylinder_sensoren[4].b_eingefahren := zyl_bandfaenger.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[4].b_ausgefahren := zyl_bandfaenger.fb.a_ventil_ausfahren;
		
				(* Bandklemmen *)
				zyl_bandklemmen.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[5].b_ausfahren;
				zyl_bandklemmen.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[5].b_einfahren;
				visu_hinten.in.zylinder_sensoren[5].b_eingefahren := zyl_bandklemmen.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[5].b_ausgefahren := zyl_bandklemmen.fb.a_ventil_ausfahren;
		
				(* Bandwechselhalter links *)
				zyl_bawe_halter_li.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[6].b_ausfahren;
				zyl_bawe_halter_li.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[6].b_einfahren;
				visu_hinten.in.zylinder_sensoren[6].b_eingefahren := zyl_bawe_halter_li.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[6].b_ausgefahren := zyl_bawe_halter_li.fb.a_ventil_ausfahren;
		
				(* Bandwechselhalter rechts *)
				zyl_bawe_halter_re.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[7].b_ausfahren;
				zyl_bawe_halter_re.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[7].b_einfahren;
				visu_hinten.in.zylinder_sensoren[7].b_eingefahren := zyl_bawe_halter_re.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[7].b_ausgefahren := zyl_bawe_halter_re.fb.a_ventil_ausfahren;
		
				(* Bandwechselfänger links *)
				zyl_bawe_faenger_li.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[8].b_ausfahren;
				zyl_bawe_faenger_li.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[8].b_einfahren;
				visu_hinten.in.zylinder_sensoren[8].b_eingefahren := zyl_bawe_faenger_li.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[8].b_ausgefahren := zyl_bawe_faenger_li.fb.a_ventil_ausfahren;
		
				(* Bandwechselfänger rechts *)
				zyl_bawe_faenger_re.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[9].b_ausfahren;
				zyl_bawe_faenger_re.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[9].b_einfahren;
				visu_hinten.in.zylinder_sensoren[9].b_eingefahren := zyl_bawe_faenger_re.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[9].b_ausgefahren := zyl_bawe_faenger_re.fb.a_ventil_ausfahren;

				(*Spulenwechsel bie 1700======================*)
				(*Quervorschub*)
				zyl_bawe_querschub.st_ctrl.in.b_ausfahren := visu_hinten.out.zylinder_direkttasten[12].b_ausfahren;
				zyl_bawe_querschub.st_ctrl.in.b_einfahren := visu_hinten.out.zylinder_direkttasten[12].b_einfahren;

				visu_hinten.in.zylinder_sensoren[12].b_eingefahren := zyl_bawe_querschub.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[12].b_ausgefahren := zyl_bawe_querschub.fb.e_sensor1_ausgefahren;

				(*Haspel verschieben*)
				zyl_haspel_verschieben.st_ctrl.in.b_ausfahren := visu_hinten.out.zylinder_direkttasten[13].b_ausfahren;
				zyl_haspel_verschieben.st_ctrl.in.b_einfahren := visu_hinten.out.zylinder_direkttasten[13].b_einfahren;

				visu_hinten.in.zylinder_sensoren[13].b_eingefahren := zyl_haspel_verschieben.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[13].b_ausgefahren := zyl_haspel_verschieben.fb.e_sensor1_ausgefahren;

				(*Bandeinzug verschieben*)
				zyl_bandeinzuege_verschieben.st_ctrl.in.b_ausfahren := visu_hinten.out.zylinder_direkttasten[14].b_ausfahren;
				zyl_bandeinzuege_verschieben.st_ctrl.in.b_einfahren := visu_hinten.out.zylinder_direkttasten[14].b_einfahren;

				visu_hinten.in.zylinder_sensoren[14].b_eingefahren := zyl_bandeinzuege_verschieben.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[14].b_ausgefahren := zyl_bandeinzuege_verschieben.fb.e_sensor1_ausgefahren;

				(* Haspel Links abspulen *)
				zyl_haspel_li_abspulen.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[15].b_ausfahren;
				zyl_haspel_li_abspulen.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[15].b_einfahren;
				visu_hinten.in.zylinder_sensoren[15].b_eingefahren := NOT zyl_haspel_li_abspulen.fb.e_sensor1_ausgefahren;
				visu_hinten.in.zylinder_sensoren[15].b_ausgefahren := zyl_haspel_li_abspulen.fb.e_sensor1_ausgefahren;

				(* Haspel Rechts abspulen *)
				zyl_haspel_re_abspulen.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[16].b_ausfahren;
				zyl_haspel_re_abspulen.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[16].b_einfahren;
				visu_hinten.in.zylinder_sensoren[16].b_eingefahren := NOT zyl_haspel_re_abspulen.fb.e_sensor1_ausgefahren;
				visu_hinten.in.zylinder_sensoren[16].b_ausgefahren := zyl_haspel_re_abspulen.fb.e_sensor1_ausgefahren;


		END_CASE

	BESTUECKZELLE_1720:

		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			KEIN_EINZUG:
				;

			STANDARD_2FACH_V2:(*noch anpassen*)
				(* Die Seitenbezeichnungen (links, rechts) beziehen sich auf die Maschinenvorderseite *)
				(* Haspel Links Heben *)
				zyl_haspel_li_heben.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[0].b_ausfahren;
				zyl_haspel_li_heben.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[0].b_einfahren;
				visu_hinten.in.zylinder_sensoren[0].b_eingefahren := zyl_haspel_li_heben.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[0].b_ausgefahren := zyl_haspel_li_heben.fb.a_ventil_ausfahren;

				(* Haspel Links Sperren *)
				zyl_haspel_li_sperren.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[1].b_ausfahren;
				zyl_haspel_li_sperren.fb.b_direkttaste_einfahren :=  visu_hinten.out.zylinder_direkttasten[1].b_einfahren;
				zyl_haspel_li_abspulen.fb.b_direkttaste_ausfahren:=visu_hinten.out.zylinder_direkttasten[1].b_einfahren; (*Abspulzylinder beim Entriegeln anheben*)
				visu_hinten.in.zylinder_sensoren[1].b_eingefahren := zyl_haspel_li_sperren.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[1].b_ausgefahren := zyl_haspel_li_sperren.fb.a_ventil_ausfahren;

				(* Haspel Rechts Heben *)
				zyl_haspel_re_heben.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[2].b_ausfahren;
				zyl_haspel_re_heben.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[2].b_einfahren;
				visu_hinten.in.zylinder_sensoren[2].b_eingefahren := zyl_haspel_re_heben.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[2].b_ausgefahren := zyl_haspel_re_heben.fb.a_ventil_ausfahren;
		
				(* Haspel Rechts Sperren *)
				zyl_haspel_re_sperren.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[3].b_ausfahren;
				zyl_haspel_re_sperren.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[3].b_einfahren;
				zyl_haspel_re_abspulen.fb.b_direkttaste_ausfahren:=visu_hinten.out.zylinder_direkttasten[3].b_einfahren; (*Abspulzylinder beim Entriegeln anheben*)
				visu_hinten.in.zylinder_sensoren[3].b_eingefahren := zyl_haspel_re_sperren.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[3].b_ausgefahren := zyl_haspel_re_sperren.fb.a_ventil_ausfahren;
		
					(* Bandeinzug links: Bandfänger *)
				zyl_bandfaenger_li.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[9].b_ausfahren;
				zyl_bandfaenger_li.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[9].b_einfahren;
				visu_hinten.in.zylinder_sensoren[9].b_eingefahren := zyl_bandfaenger_li.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[9].b_ausgefahren := zyl_bandfaenger_li.fb.a_ventil_ausfahren;

				(* Bandeinzug links: Bandklemmen *)
				zyl_bandklemmen_li.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[11].b_ausfahren;
				zyl_bandklemmen_li.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[11].b_einfahren;
				visu_hinten.in.zylinder_sensoren[11].b_eingefahren := zyl_bandklemmen_li.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[11].b_ausgefahren := zyl_bandklemmen_li.fb.a_ventil_ausfahren;
		
				(* Bandeinzug rechts: Bandfänger *)
				zyl_bandfaenger_re.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[8].b_ausfahren;
				zyl_bandfaenger_re.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[8].b_einfahren;
				visu_hinten.in.zylinder_sensoren[8].b_eingefahren := zyl_bandfaenger_re.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[8].b_ausgefahren := zyl_bandfaenger_re.fb.a_ventil_ausfahren;
		
				(* Bandeinzug rechts: Bandklemmen *)
				zyl_bandklemmen_re.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[10].b_ausfahren;
				zyl_bandklemmen_re.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[10].b_einfahren;
				visu_hinten.in.zylinder_sensoren[10].b_eingefahren := zyl_bandklemmen_re.fb.a_ventil_einfahren;
				visu_hinten.in.zylinder_sensoren[10].b_ausgefahren := zyl_bandklemmen_re.fb.a_ventil_ausfahren;

				(* Bandwechselhalter links *)
				zyl_bawe_halter_li.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[7].b_ausfahren;
				zyl_bawe_halter_li.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[7].b_einfahren;
				visu_hinten.in.zylinder_sensoren[7].b_eingefahren := zyl_bawe_halter_li.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[7].b_ausgefahren := zyl_bawe_halter_li.fb.e_sensor1_ausgefahren;
		
				(* Bandwechselhalter rechts *)
				zyl_bawe_halter_re.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[6].b_ausfahren;
				zyl_bawe_halter_re.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[6].b_einfahren;
				visu_hinten.in.zylinder_sensoren[6].b_eingefahren := zyl_bawe_halter_re.fb.e_sensor1_eingefahren;
				visu_hinten.in.zylinder_sensoren[6].b_ausgefahren := zyl_bawe_halter_re.fb.e_sensor1_ausgefahren;

				(* Haspel Links abspulen *)
				zyl_haspel_li_abspulen.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[15].b_ausfahren;
				zyl_haspel_li_abspulen.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[15].b_einfahren;
				visu_hinten.in.zylinder_sensoren[15].b_eingefahren := NOT zyl_haspel_li_abspulen.fb.e_sensor1_ausgefahren;
				visu_hinten.in.zylinder_sensoren[15].b_ausgefahren := zyl_haspel_li_abspulen.fb.e_sensor1_ausgefahren;

				(* Haspel Rechts abspulen *)
				zyl_haspel_re_abspulen.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[16].b_ausfahren;
				zyl_haspel_re_abspulen.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[16].b_einfahren;
				visu_hinten.in.zylinder_sensoren[16].b_eingefahren := NOT zyl_haspel_re_abspulen.fb.e_sensor1_ausgefahren;
				visu_hinten.in.zylinder_sensoren[16].b_ausgefahren := zyl_haspel_re_abspulen.fb.e_sensor1_ausgefahren;

			BANDWECHSLER_V2:
				;

			SERVO:
				;
		END_CASE




	RASTERFOLIE:
		(* Die Seitenbezeichnungen (links, rechts) beziehen sich auf die Maschinenvorderseite *)
		(* Haspel Links Heben *)
		zyl_haspel_li_heben.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[0].b_ausfahren;
		zyl_haspel_li_heben.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[0].b_einfahren;
		visu_hinten.in.zylinder_sensoren[0].b_eingefahren := zyl_haspel_li_heben.fb.e_sensor1_eingefahren;
		visu_hinten.in.zylinder_sensoren[0].b_ausgefahren := zyl_haspel_li_heben.fb.e_sensor1_ausgefahren;

		(* Haspel Links Sperren *)
		zyl_haspel_li_sperren.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[1].b_ausfahren;
		zyl_haspel_li_sperren.fb.b_direkttaste_einfahren :=  visu_hinten.out.zylinder_direkttasten[1].b_einfahren;
		zyl_haspel_li_abspulen.fb.b_direkttaste_ausfahren:=visu_hinten.out.zylinder_direkttasten[1].b_einfahren; (*Abspulzylinder beim Entriegeln anheben*)
		visu_hinten.in.zylinder_sensoren[1].b_eingefahren := zyl_haspel_li_sperren.fb.e_sensor1_eingefahren;
		visu_hinten.in.zylinder_sensoren[1].b_ausgefahren := zyl_haspel_li_sperren.fb.e_sensor1_ausgefahren;

		(* Haspel Rechts Heben *)
		zyl_haspel_re_heben.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[2].b_ausfahren;
		zyl_haspel_re_heben.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[2].b_einfahren;
		visu_hinten.in.zylinder_sensoren[2].b_eingefahren := zyl_haspel_re_heben.fb.e_sensor1_eingefahren;
		visu_hinten.in.zylinder_sensoren[2].b_ausgefahren := zyl_haspel_re_heben.fb.e_sensor1_ausgefahren;

		(* Haspel Rechts Sperren *)
		zyl_haspel_re_sperren.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[3].b_ausfahren;
		zyl_haspel_re_sperren.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[3].b_einfahren;
		zyl_haspel_re_abspulen.fb.b_direkttaste_ausfahren:=visu_hinten.out.zylinder_direkttasten[3].b_einfahren; (*Abspulzylinder beim Entriegeln anheben*)
		visu_hinten.in.zylinder_sensoren[3].b_eingefahren := zyl_haspel_re_sperren.fb.e_sensor1_eingefahren;
		visu_hinten.in.zylinder_sensoren[3].b_ausgefahren := zyl_haspel_re_sperren.fb.e_sensor1_ausgefahren;

		(* Folienfänger *)
		zyl_rafo_faenger.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[4].b_ausfahren;
		zyl_rafo_faenger.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[4].b_einfahren;
		visu_hinten.in.zylinder_sensoren[4].b_eingefahren := zyl_rafo_faenger.fb.e_sensor1_eingefahren;
		visu_hinten.in.zylinder_sensoren[4].b_ausgefahren := zyl_rafo_faenger.fb.e_sensor1_ausgefahren;

		(* Folienklemmen *)
		zyl_rafo_klemmen.fb.b_direkttaste_ausfahren := visu_hinten.out.zylinder_direkttasten[5].b_ausfahren;
		zyl_rafo_klemmen.fb.b_direkttaste_einfahren := visu_hinten.out.zylinder_direkttasten[5].b_einfahren;
		visu_hinten.in.zylinder_sensoren[5].b_eingefahren := zyl_rafo_klemmen.fb.e_sensor1_eingefahren;
		visu_hinten.in.zylinder_sensoren[5].b_ausgefahren := zyl_rafo_klemmen.fb.e_sensor1_ausgefahren;
END_CASE
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Wartung' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Wartung
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	i16_auftrag							: enum_wartung_auftrag;
END_VAR
VAR_OUTPUT
	st_ctrl_out								: struct_ctrl_out;
END_VAR
VAR
	(*Bausteinaufrufe*)
	fb_state_entry					: ST_StateEntry;
	fb_ton_quitt						: TON;
	fb_xml_srv_read					: FB_XmlSrvReadByName;
	fb_xml_srv_write					: FB_XmlSrvWriteByName;
	fbFindFiles						: FB_EnumFindFileList;
	file								: ST_FindFileEntry;
	FB_GetHostName				: FB_GetHostName;
	fb_nt_start_process				: NT_StartProcess;

	(*Flanken*)
	fb_r_trig_autosafe				: R_TRIG;
	fb_r_trig_reset_wkz			: R_TRIG;

	(*Zeiten*)
	fb_ton_wz									: TON;
	fb_ton_wz_wartung				: TON;
	fb_ton_end								: TON;
	fb_ton_autosafe					: TON;


	(* Dateiname *)
	sFileName_md							: STRING;
	sFileName_wkz						: STRING;
	sHelpName							: STRING;
	sHelpPos							: INT;

	(* Dateipfad *)
	sPathName								: STRING;

	(* Temporäre Variable *)
	b_init											: BOOL;
	b_lesen_komplett					: BOOL := TRUE;
	b_datei_vorhanden				: BOOL;
	b_auto_speichern_auf_server		: BOOL ;
	nErrId											: UDINT;
	sm_fehler_schreiben_Wartungsprotokoll			: BOOL;
	sm_fehler_lesen_Wartungsprotokoll					: BOOL;
	sm_fehler_speichern_Wartungsprotokoll			: BOOL;

	s_aktuelles_wkz_copy											: STRING;
	i																					: INT:=0;

	st_wartungsprotokoll_md_copy							: struct_Wartungsprotokoll;
	st_wartungsprotokoll_wkz_copy							: struct_Wartungsprotokoll;
	i32_bestueckhubzaehler_md_copy					: UDINT := 0;
	i32_bestueckhubzaehler_wkz_copy				: UDINT := 0;
END_VAR

VAR CONSTANT
	st_wartungsprotokoll_leer			: struct_Wartungsprotokoll;
	s_wartung_path_wkz					: STRING(50):='D:\BBgen\Wartung\Werkzeug\';
	s_wartung_path_md						: STRING(50):='D:\BBgen\Wartung\Maschine\';
	s_Trennstelle									: STRING(2):='#';
END_VAR
(* @END_DECLARATION := '0' *)
FileName_erstellen ();
fb_Aufrufe ();
auto_speichern_laden ();

IF NOT b_init AND gst_datensatz.st_md.s_aktuelles_wkz <>''  THEN
	i16_auftrag:= LESE_WARTUNGSPROTOKOLL_KOMPLETT;
	s_aktuelles_wkz_copy:=gst_datensatz.st_md.s_aktuelles_wkz;
	i32_bestueckhubzaehler_md_copy:=gst_datensatz.st_md.i32_bestueckhubzaehler;
	FB_GetHostName.bExecute := TRUE;
	b_init := TRUE;
ELSIF b_init AND gst_datensatz.st_md.s_aktuelles_wkz <> s_aktuelles_wkz_copy AND gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET THEN
	i16_auftrag:=LESE_WARTUNGSPROTOKOLL_WKZ;
	i32_bestueckhubzaehler_md_copy:=gst_datensatz.st_md.i32_bestueckhubzaehler;
	s_aktuelles_wkz_copy:=gst_datensatz.st_md.s_aktuelles_wkz;
ELSE
	Zaehler();
END_IF


(*Zellennummer aus dem Computernamen filtern*)
sHelpName := FB_GetHostName.sHostName;
sHelpPos := FIND(sHelpName,'-');
sHelpName := DELETE(sHelpName,sHelpPos,1);
sHelpPos := FIND(sHelpName,'-');
sHelpName := LEFT(sHelpName,sHelpPos-1);
sHelpName := CONCAT('T#',sHelpName);
sHelpName := CONCAT(sHelpName,'s');

(* Flanken *)
fb_r_trig_reset_wkz(CLK:= visu.b_reset_wartung_wkz, Q=> );
fb_r_trig_autosafe(CLK:= gstr_uhrzeit = '01:00:00', Q=> );
fb_ton_autosafe(IN:= , PT:= STRING_TO_TIME(sHelpName), Q=> , ET=> );

IF fb_r_trig_autosafe.Q THEN
	fb_ton_autosafe.IN := TRUE;
END_IF

(*Um 1 Uhr + Zellennummer in Sek. früh werden die Wartungsprotokolle an den Server geschickt*)
IF fb_ton_autosafe.Q THEN
	b_auto_speichern_auf_server := TRUE;
	fb_ton_autosafe.IN := FALSE;
END_IF

IF b_auto_speichern_auf_server AND i16_auftrag = KEIN_WARTUNG_AUFTRAG THEN
	b_auto_speichern_auf_server := FALSE;
	IF visu.s_akt_sprache = 'de' THEN
		i16_auftrag:=SPEICHERN_WARTUNGSPROTOKOLL;
	END_IF
END_IF


(*
IF visu.b_reset_wartung_maschine THEN
	gst_datensatz.st_md.produzierte_stecker := 0;
END_IF
*)

(*Zeiten*)
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* ======================================Schrittkette======================================== *)
fb_state_entry(i16_pos:= 1);


CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF FB_GetHostName.bBusy OR FB_GetHostName.sHostName <> '' THEN
			fb_state_entry.i16_next_step := 5;
		END_IF

		IF fb_state_entry.X THEN
			FB_GetHostName.bExecute := FALSE;
		END_IF

(*=======================================================*)
	5:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT FB_GetHostName.bBusy THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:	(*initialisieren*)
		st_ctrl_out.b_fehler := FALSE;
		st_ctrl_out.b_bereit := FALSE;
		st_ctrl_out.b_busy := FALSE;
		st_ctrl_out.b_fertig := FALSE;
		sm_fehler_schreiben_Wartungsprotokoll	 := FALSE;
		sm_fehler_lesen_Wartungsprotokoll	:= FALSE;
		sm_fehler_speichern_Wartungsprotokoll := FALSE;
		fbFindFiles.bExecute := FALSE;
		fb_xml_srv_write.bExecute := FALSE;
		fb_xml_srv_read.bExecute := FALSE;
		fb_ton_wz.IN := FALSE;

		fb_nt_start_process.START := FALSE;
		fbFindFiles.eCmd := 0;
		nErrId := 0;
		sPathName := '';
		b_datei_vorhanden := FALSE;
		fb_xml_srv_write.sSymName := '';
		fb_xml_srv_write.sXPath := '';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step:=BEREIT;


(*=======================================================*)
	BEREIT:(*Start*)
		IF 	fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		CASE i16_auftrag OF
			LESE_WARTUNGSPROTOKOLL_KOMPLETT:
				b_lesen_komplett := TRUE;
				fb_state_entry.i16_next_step:=110;

			LESE_WARTUNGSPROTOKOLL_WKZ:
				fb_state_entry.i16_next_step:=110;

			LESE_WARTUNGSPROTOKOLL_MD:
				fb_state_entry.i16_next_step:=150;

			SCHREIBE_WARTUNGSPROTOKOLL_WKZ:
				fb_state_entry.i16_next_step:=200;

			SCHREIBE_WARTUNGSPROTOKOLL_MD:
				fb_state_entry.i16_next_step:=250;

			SPEICHERN_WARTUNGSPROTOKOLL:
				fb_state_entry.i16_next_step:=300;

			SCHREIBE_WARTUNGSPROTOKOLL_WKZ_RESET:
				fb_state_entry.i16_next_step:=400;
		END_CASE

		IF fb_state_entry.X THEN
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_busy := TRUE;
		END_IF

(*=======================================================*)
	110:(*Prüfe, ob Werkzeug Datei vorhanden ist*)
		IF fb_state_entry.E THEN
			sPathName := CONCAT(s_wartung_path_wkz,sFileName_wkz);
			sPathName:=CONCAT(sPathName,'.xml');
			(*Erste Datei im Verzeichnis kontrollieren*)
			IF fb_state_entry.i16_last_step <> 120 THEN
				fbFindFiles.eCmd := 0;
			(*Dateien im Verzeichnis durchzählen*)
			ELSE
				fbFindFiles.eCmd := 1;
			END_IF
			fbFindFiles.bExecute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbFindFiles.bBusy THEN
			fb_state_entry.i16_next_step:=120;
		END_IF

		IF fb_state_entry.X THEN
			fbFindFiles.bExecute := FALSE;
		END_IF

(*=======================================================*)
	120:(*Prüfe, ob Werkzeug Datei vorhanden ist*)
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(*letzte Datei im Verzeichnis erreicht*)
		IF fbFindFiles.bEOE AND NOT fbFindFiles.bBusy AND NOT fbFindFiles.bError  THEN
			IF fbFindFiles.nFindFiles <> 0 OR b_datei_vorhanden  THEN
				(*Datei vorhanden -> muss eingelesen werden*)
				fb_state_entry.i16_next_step:=130;
			ELSE
				(*Datei noch nicht vorhanden -> kann nicht eingelesen werden*)
				i32_bestueckhubzaehler_wkz_copy := 0;
				IF b_lesen_komplett THEN
					fb_state_entry.i16_next_step:=150;
				ELSE
					fb_state_entry.i16_next_step := 999;
				END_IF
			END_IF
		(*Datei wurde im Verzeichnis gefunden*)
		ELSIF NOT fbFindFiles.bBusy AND NOT fbFindFiles.bError  THEN
			IF fbFindFiles.nFindFiles <> 0  THEN
				(*Datei vorhanden -> muss eingelesen werden*)
				b_datei_vorhanden := TRUE;
				fb_state_entry.i16_next_step := 110;
			END_IF
		ELSIF fbFindFiles.bError THEN
			nErrId := fbFindFiles.nErrID;
			sm_fehler_lesen_Wartungsprotokoll := TRUE;
			fb_state_entry.i16_next_step:=FEHLER;
		END_IF

(*=======================================================*)
	130:	(* Lesen Werkzeug Wartungsprotokoll *)
		IF fb_state_entry.E THEN
			b_datei_vorhanden := FALSE;
			sPathName := CONCAT(s_wartung_path_wkz,sFileName_wkz);
			sPathName:=CONCAT(sPathName,'.xml');
			fb_xml_srv_read.sSymName := '.gst_datensatz.st_wartungsprotokoll.st_wartung_wkz';
			fb_xml_srv_read.sXPath := '/root/gst_datensatz.st_wartungsprotokoll.st_wartung_wkz';
			fb_xml_srv_read.bExecute:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_xml_srv_read.bBusy THEN
			fb_state_entry.i16_next_step := 140;
		END_IF

		IF fb_state_entry.X THEN
			fb_xml_srv_read.bExecute:= FALSE;
		END_IF

(*=======================================================*)
	140:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(*Lesen erfolgreich*)
		IF NOT fb_xml_srv_read.bError AND NOT fb_xml_srv_read.bBusy AND NOT b_lesen_komplett THEN
			i32_bestueckhubzaehler_wkz_copy := gst_datensatz.st_wartungsprotokoll.st_wartung_wkz.hubzaehler;
			fb_state_entry.i16_next_step := 999;
		ELSIF NOT fb_xml_srv_read.bError AND NOT fb_xml_srv_read.bBusy AND b_lesen_komplett THEN
			i32_bestueckhubzaehler_wkz_copy := gst_datensatz.st_wartungsprotokoll.st_wartung_wkz.hubzaehler;
			fb_state_entry.i16_next_step := 150;
		ELSIF fb_xml_srv_read.bError THEN
			nErrId:=fb_xml_srv_read.nErrId;
			sm_fehler_lesen_Wartungsprotokoll:=TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	150:(*Prüfe, ob Maschinen Datei vorhanden ist*)
		IF fb_state_entry.E THEN
			sPathName := CONCAT(s_wartung_path_md,sFileName_md);
			(*Erste Datei im Verzeichnis kontrollieren*)
			IF fb_state_entry.i16_last_step <> 160 THEN
				fbFindFiles.eCmd := 0;
			(*Dateien im Verzeichnis durchzählen*)
			ELSE
				fbFindFiles.eCmd := 1;
			END_IF
			fbFindFiles.bExecute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbFindFiles.bBusy THEN
			fb_state_entry.i16_next_step:=160;
		END_IF

		IF fb_state_entry.X THEN
			fbFindFiles.bExecute := FALSE;
		END_IF

(*=======================================================*)
	160:(*Prüfe, ob Maschinen Datei vorhanden ist*)
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(*letzte Datei im Verzeichnis erreicht*)
		IF fbFindFiles.bEOE AND NOT fbFindFiles.bBusy AND NOT fbFindFiles.bError  THEN
			IF fbFindFiles.nFindFiles <> 0 OR b_datei_vorhanden  THEN
				(*Datei vorhanden -> muss eingelesen werden*)
				fb_state_entry.i16_next_step:=170;
			ELSE
				(*Datei noch nicht vorhanden -> kann nicht eingelesen werden*)
				fb_state_entry.i16_next_step:=999;
			END_IF
		(*Datei wurde im Verzeichnis gefunden*)
		ELSIF NOT fbFindFiles.bBusy AND NOT fbFindFiles.bError  THEN
			IF fbFindFiles.nFindFiles <> 0  THEN
				(*Datei vorhanden -> muss eingelesen werden*)
				b_datei_vorhanden := TRUE;
				fb_state_entry.i16_next_step := 150;
			END_IF
		ELSIF fbFindFiles.bError THEN
			nErrId := fbFindFiles.nErrID;
			sm_fehler_lesen_wartungsprotokoll := TRUE;
			fb_state_entry.i16_next_step:=FEHLER;
		END_IF

		IF fb_state_entry.X THEN
			b_lesen_komplett := FALSE;
		END_IF

(*=======================================================*)
	170:	(* Lesen Maschinen Wartungsprotokoll *)
		IF fb_state_entry.E THEN
			b_datei_vorhanden := FALSE;
			sPathName := CONCAT(s_wartung_path_md,sFileName_md);
			fb_xml_srv_read.sSymName := '.gst_datensatz.st_wartungsprotokoll.st_wartung_md';
			fb_xml_srv_read.sXPath := '/root/gst_datensatz.st_wartungsprotokoll.st_wartung_md';
			fb_xml_srv_read.bExecute:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_xml_srv_read.bBusy THEN
			fb_state_entry.i16_next_step := 180;
		END_IF

		IF fb_state_entry.X THEN
			fb_xml_srv_read.bExecute:= FALSE;
		END_IF

(*=======================================================*)
	180:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(*Lesen erfolgreich*)
		IF NOT fb_xml_srv_read.bError AND NOT fb_xml_srv_read.bBusy THEN
			fb_state_entry.i16_next_step := 999;
		ELSIF fb_xml_srv_read.bError THEN
			nErrId:=fb_xml_srv_read.nErrId;
			sm_fehler_lesen_Wartungsprotokoll:=TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	200:(*Schreibe Werkzeug Wartungsdatei*)
		IF fb_state_entry.E THEN
			sPathName := CONCAT(s_wartung_path_wkz,sFileName_wkz);
			sPathName:=CONCAT(sPathName,'.xml');
			fb_xml_srv_write.sSymName := '.gst_datensatz.st_wartungsprotokoll.st_wartung_wkz';
			fb_xml_srv_write.sXPath := '/root/gst_datensatz.st_wartungsprotokoll.st_wartung_wkz';
			fb_xml_srv_write.bExecute:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_xml_srv_write.bBusy THEN
			fb_state_entry.i16_next_step := 210;
		END_IF

		IF fb_state_entry.X THEN
			fb_xml_srv_write.bExecute:= FALSE;
		END_IF

(*=======================================================*)
	210:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_xml_srv_write.bError AND NOT fb_xml_srv_write.bBusy THEN
			st_wartungsprotokoll_wkz_copy.st_wartung_wkz:= gst_datensatz.st_wartungsprotokoll.st_wartung_wkz ;
			fb_state_entry.i16_next_step := 999;
		END_IF


		IF fb_xml_srv_write.bError  THEN
			nErrId:=fb_xml_srv_write.nErrId;
			sm_fehler_schreiben_Wartungsprotokoll:=TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF


(*===================Schrittkette====================================*)
	250:(*Schreibe Maschinen Wartungsdatei*)
		IF fb_state_entry.E THEN
			sPathName := CONCAT(s_wartung_path_md,sFileName_md);
			fb_xml_srv_write.sSymName := '.gst_datensatz.st_wartungsprotokoll.st_wartung_md';
			fb_xml_srv_write.sXPath := '/root/gst_datensatz.st_wartungsprotokoll.st_wartung_md';
			fb_xml_srv_write.bExecute:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_xml_srv_write.bBusy THEN
			fb_state_entry.i16_next_step := 260;
		END_IF

		IF fb_state_entry.X THEN
			fb_xml_srv_write.bExecute:= FALSE;
		END_IF

(*=======================================================*)
	260:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_xml_srv_write.bError AND NOT fb_xml_srv_write.bBusy THEN
			st_wartungsprotokoll_md_copy.st_wartung_md:= gst_datensatz.st_wartungsprotokoll.st_wartung_md ;
			fb_state_entry.i16_next_step := 999;
		END_IF

		IF fb_xml_srv_write.bError  THEN
			nErrId:=fb_xml_srv_write.nErrId;
			sm_fehler_schreiben_Wartungsprotokoll:=TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	300:(*Speichern der Wartungsdateien auf den Server*)
		IF 	fb_state_entry.E THEN
			fb_nt_start_process.START:=TRUE;
		END_IF

		IF fb_nt_start_process.BUSY THEN
			fb_state_entry.i16_next_step := 310;
			fb_nt_start_process.START:=FALSE;
		END_IF

(*=======================================================*)
	310:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_nt_start_process.ERR AND NOT fb_nt_start_process.BUSY THEN
			fb_state_entry.i16_next_step := 999;
		END_IF

		IF fb_nt_start_process.ERR THEN
			nErrId:=fb_nt_start_process.ERRID;
			sm_fehler_speichern_Wartungsprotokoll;
			fb_state_entry.i16_next_step:=FEHLER;
		END_IF

(*=======================================================*)
	400:(*Prüfe, ob Werkzeug Datei vorhanden ist*)
		IF fb_state_entry.E THEN
			sPathName := CONCAT(s_wartung_path_wkz,sFileName_wkz);
			sPathName:=CONCAT(sPathName,'_RESET');
			sPathName:=CONCAT(sPathName,'.xml');
			(*Erste Datei im Verzeichnis kontrollieren*)
			IF fb_state_entry.i16_last_step <> 410 THEN
				fbFindFiles.eCmd := 0;
			(*Dateien im Verzeichnis durchzählen*)
			ELSE
				fbFindFiles.eCmd := 1;
			END_IF
			fbFindFiles.bExecute := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fbFindFiles.bBusy THEN
			fb_state_entry.i16_next_step:=410;
		END_IF

		IF fb_state_entry.X THEN
			fbFindFiles.bExecute := FALSE;
		END_IF

(*=======================================================*)
	410:(*Prüfe, ob Werkzeug Datei vorhanden ist*)
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(*letzte Datei im Verzeichnis erreicht*)
		IF fbFindFiles.bEOE AND NOT fbFindFiles.bBusy AND NOT fbFindFiles.bError  THEN
			IF fbFindFiles.nFindFiles <> 0 OR b_datei_vorhanden  THEN
				(*Datei vorhanden -> darf nicht neu geschrieben werden*)
				fb_state_entry.i16_next_step:=999;
			ELSE
				(*Datei noch nicht vorhanden -> muss erstellt werden*)
				fb_state_entry.i16_next_step := 420;
			END_IF
		(*Datei wurde im Verzeichnis gefunden*)
		ELSIF NOT fbFindFiles.bBusy AND NOT fbFindFiles.bError  THEN
			IF fbFindFiles.nFindFiles <> 0  THEN
				(*Datei vorhanden -> muss eingelesen werden*)
				b_datei_vorhanden := TRUE;
				fb_state_entry.i16_next_step := 400;
			END_IF
		ELSIF fbFindFiles.bError THEN
			nErrId := fbFindFiles.nErrID;
			sm_fehler_lesen_Wartungsprotokoll := TRUE;
			fb_state_entry.i16_next_step:=FEHLER;
		END_IF

(*=======================================================*)
	420:(*Schreibe Werkzeug Reset Wartungsdatei*)
		IF fb_state_entry.E THEN
			sPathName := CONCAT(s_wartung_path_wkz,sFileName_wkz);
			sPathName:=CONCAT(sPathName,'_RESET');
			sPathName:=CONCAT(sPathName,'.xml');
			fb_xml_srv_write.sSymName := '.gst_datensatz.st_wartungsprotokoll.st_wartung_wkz';
			fb_xml_srv_write.sXPath := '/root/gst_datensatz.st_wartungsprotokoll.st_wartung_wkz';
			fb_xml_srv_write.bExecute:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_xml_srv_write.bBusy THEN
			fb_state_entry.i16_next_step := 430;
		END_IF

		IF fb_state_entry.X THEN
			fb_xml_srv_write.bExecute:= FALSE;
		END_IF

(*=======================================================*)
	430:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT fb_xml_srv_write.bError AND NOT fb_xml_srv_write.bBusy THEN
			i32_bestueckhubzaehler_md_copy:=gst_datensatz.st_md.i32_bestueckhubzaehler;
			s_aktuelles_wkz_copy:=gst_datensatz.st_md.s_aktuelles_wkz;
			gst_datensatz.st_wartungsprotokoll.st_wartung_wkz.hubzaehler := 0;
			i32_bestueckhubzaehler_wkz_copy := 0;
			fb_state_entry.i16_next_step := 999;
		END_IF

		IF fb_xml_srv_write.bError  THEN
			nErrId:=fb_xml_srv_write.nErrId;
			sm_fehler_schreiben_Wartungsprotokoll:=TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF


(*=======================================================*)
	999:	(* Ende - Befehl wurde korrekt abgearbeitet *)
		IF fb_state_entry.E THEN
			b_datei_vorhanden := FALSE;
			st_ctrl_out.b_busy := FALSE;
			st_ctrl_out.b_fertig := TRUE;
			i16_auftrag := KEIN_WARTUNG_AUFTRAG;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER: (* Fehler *)
		IF fb_state_entry.E THEN
			i16_auftrag := KEIN_WARTUNG_AUFTRAG;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_busy := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(i16_pos:= 2 );

(* ======================================Subkomponenten======================================== *)

IF st_config.b_config_fertig THEN
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_schreiben_Wartungsprotokoll;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_fehler_lesen_Wartungsprotokoll;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_fehler_speichern_Wartungsprotokoll;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;

	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] :=FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM
ACTION	auto_speichern_laden:
(*========================================================================================*)
(*ohne Timer wurde nicht immer gespeichert*)
fb_ton_end(
	IN:=  i16_auftrag = KEIN_WARTUNG_AUFTRAG,
	PT:= t#100ms,
	Q=> ,
	ET=> );


(*Werkzeug Daten speichern*)
IF	fb_ton_end.Q AND gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET AND
	(MEMCMP(ADR(st_wartungsprotokoll_wkz_copy.st_wartung_wkz), ADR(gst_datensatz.st_wartungsprotokoll.st_wartung_wkz), SIZEOF(st_wartungsprotokoll_wkz_copy.st_wartung_wkz)) <> 0 ) THEN
	i16_auftrag:=SCHREIBE_WARTUNGSPROTOKOLL_WKZ;
END_IF


(*Maschinen Daten speichern*)
IF	fb_ton_end.Q AND gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET AND
	(MEMCMP(ADR(st_wartungsprotokoll_md_copy.st_wartung_md), ADR(gst_datensatz.st_wartungsprotokoll.st_wartung_md), SIZEOF(st_wartungsprotokoll_md_copy.st_wartung_md)) <> 0 ) THEN
	i16_auftrag:=SCHREIBE_WARTUNGSPROTOKOLL_MD;
END_IF

(*Button in der Oberfläche für das Reseten nach der Wartung*)
IF fb_ton_end.Q AND gi16_maschinenstatusinfo <> STATUS_MASCHINE_ARBEITET AND fb_r_trig_reset_wkz.Q THEN
	i16_auftrag:=SCHREIBE_WARTUNGSPROTOKOLL_WKZ_RESET;
END_IF



END_ACTION

ACTION	fb_Aufrufe:

fb_xml_srv_read(
	sNetId:= ,
	ePath:= PATH_GENERIC,
	nMode:= XMLSRV_SKIPMISSING,
	sFilePath:=sPathName,
	bExecute:= ,
	tTimeout:= t#20s,
	bBusy=> ,
	bError=> ,
	nErrId=> );


fb_xml_srv_write(
	sNetId:= '',
	ePath:= PATH_GENERIC,
	nMode:= XMLSRV_ADDMISSING,
	sFilePath:=sPathName,
	bExecute:= ,
	tTimeout:= t#10s,
	bBusy=> ,
	bError=> ,
	nErrId=> );


fbFindFiles(
	bExecute	:= ,
	sNetId		:= '',
	sPathName	:= sPathName,
	pFindList		:= ADR(file),
	cbFindList	:= SIZEOF(file),
	tTimeout	:= t#1s );


fb_nt_start_process(
	NETID:= '',
	PATHSTR:= 'C:\Windows\System32\wscript.exe',
	DIRNAME:=s_tools_path,
	COMNDLINE:=CONCAT(visu.s_akt_sprache,'_Wartung_nach_server.vbs'),	 	(*CONCAT(visu.s_akt_sprache,'_Wartung_nach_server.vbs'),		'de_Wartung_nach_server.vbs', 	*)
	START:= ,
	TMOUT:= DEFAULT_ADS_TIMEOUT,
	BUSY=> ,
	ERR=> ,
	ERRID=> nErrId);



FB_GetHostName(
	sNetID:= '127.0.0.1.1.1',
	bExecute:= , 
	tTimeout:= , 
	bBusy=> ,
	bError=> ,
	nErrID=> , 
	sHostName=> );

END_ACTION

ACTION	FileName_erstellen:

(*Name für Werkzeug Datei*)
sFileName_wkz:='';
sFileName_wkz:=CONCAT(sFileName_wkz,gst_datensatz.st_md.s_aktuelles_wkz);
sFileName_wkz:=CONCAT(sFileName_wkz,s_Trennstelle);
sFileName_wkz:=CONCAT(sFileName_wkz,FB_GetHostName.sHostName);
sFileName_wkz:=CONCAT(sFileName_wkz,s_Trennstelle);
sFileName_wkz:=CONCAT(sFileName_wkz,gstr_datum);

(*Name für Maschinen Datei*)
sFileName_md:='';
sFileName_md:=CONCAT(sFileName_md,FB_GetHostName.sHostName);
sFileName_md:=CONCAT(sFileName_md,'.xml');


END_ACTION

ACTION	Zaehler:

IF fb_state_entry.i16_step = BEREIT THEN
	(*Übergabe der aktuellen Betriebsstunden der Zelle in die Wartungsstruktur*)
	gst_datensatz.st_wartungsprotokoll.st_wartung_md.betriebsstunden := gst_datensatz.st_md.i32_betriebssekundenzaehler/ 3600;

	(*Übergabe des aktuellen Hubzählers der Zelle in die Wartungsstruktur*)
	gst_datensatz.st_wartungsprotokoll.st_wartung_md.hubzaehler := gst_datensatz.st_md.i32_bestueckhubzaehler;

	(*Übergabe der aktuell produzierten Stecker der Zelle in die Wartungsstruktur*)
	gst_datensatz.st_wartungsprotokoll.st_wartung_md.produzierte_stecker := gst_datensatz.st_md.produzierte_Stecker;

	(*Übergabe des aktuellen Hubzählers des benutzten Werkzeugs an die Wartungsstruktur*)
	gst_datensatz.st_wartungsprotokoll.st_wartung_wkz.hubzaehler := i32_bestueckhubzaehler_wkz_copy + (gst_datensatz.st_md.i32_bestueckhubzaehler-i32_bestueckhubzaehler_md_copy);
END_IF
END_ACTION







(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Werkzeug' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_WkzAbsicherung
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu								: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz							: TON;
	fb_ton_uez							: TON;
	fb_ton_quitt							: TON;
	fb_state_entry							: ST_StateEntry;
	b_signalmerker_bestueckschieber_on		: BOOL := FALSE;
	b_signalmerker_bestueckschieber_off		: BOOL := FALSE;
	fb_r_trig_signal_bestueckschieber		: R_TRIG;
	fb_f_trig_signal_bestueckschieber		: F_TRIG;
	fb_r_trig_nocke_uw_bestueckschieber	: R_TRIG;
	fb_f_trig_nocke_uw_bestueckschieber	: F_TRIG;

	(* Eingänge *)
	(* BSV 1720 6-fach *)
	e_wkz_sicherung_niederhalter_li			AT %I* : BOOL;
	e_wkz_sicherung_faenger_li			AT %I* : BOOL;
	e_wkz_sicherung_abfallpodest_li		AT %I* : BOOL;
	e_wkz_sicherung_niederhalter_re		AT %I* : BOOL;
	e_wkz_sicherung_faenger_re			AT %I* : BOOL;
	e_wkz_sicherung_abfallpodest_re		AT %I* : BOOL;
	(* Erkennung/Kodierung für alte WKZ z.B. 1708alt *)
	e_kodierung_alt_wkz					AT %I* : BOOL;
	(* BSH 1700 *)
	e_wkz_sicherung_faenger				AT %I* : BOOL;
	e_bestueckschieber_ueberwachung		AT %I* : BOOL;

	(* Meldungen *)
	(* BSV 1720 6-fach *)
	sm_wkz_sicherung_niederhalter_li		: BOOL := FALSE;
	sm_wkz_sicherung_faenger_li			: BOOL := FALSE;
	sm_wkz_sicherung_abfallpodest_li		: BOOL := FALSE;
	sm_wkz_sicherung_niederhalter_re		: BOOL := FALSE;
	sm_wkz_sicherung_faenger_re			: BOOL := FALSE;
	sm_wkz_sicherung_abfallpodest_re		: BOOL := FALSE;
	(* BSH 1700 *)
	sm_wkz_sicherung_faenger				: BOOL := FALSE;
	sm_bestueckschieber_ueberwachung	: BOOL := FALSE;
	UW_Bestueckschieber_on: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Flanken *)

fb_f_trig_nocke_uw_bestueckschieber(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_UW_BESTUECKSCHIEBER_ON], Q=> );
fb_r_trig_nocke_uw_bestueckschieber(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_UW_BESTUECKSCHIEBER_ON], Q=> );
fb_r_trig_signal_bestueckschieber(CLK:= e_bestueckschieber_ueberwachung, Q=> );
fb_f_trig_signal_bestueckschieber(CLK:= e_bestueckschieber_ueberwachung, Q=> );

UW_Bestueckschieber_on:=nockenschaltwerk_bestueckachse.fb.arr_spur[SP_UW_BESTUECKSCHIEBER_ON]; 	(*für Trace*)
(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_quitt.IN	 := FALSE;
			b_signalmerker_bestueckschieber_on := FALSE;
			b_signalmerker_bestueckschieber_off := FALSE;
			sm_wkz_sicherung_niederhalter_li := FALSE;
			sm_wkz_sicherung_faenger_li := FALSE;
			sm_wkz_sicherung_abfallpodest_li := FALSE;
			sm_wkz_sicherung_niederhalter_re := FALSE;
			sm_wkz_sicherung_faenger_re := FALSE;
			sm_wkz_sicherung_abfallpodest_re := FALSE;
			sm_wkz_sicherung_faenger := FALSE;
			sm_bestueckschieber_ueberwachung := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_einzelfertigung := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700:
				IF NOT gst_datensatz.st_md.b_wt_transport_simulation THEN
					IF NOT e_wkz_sicherung_faenger THEN
						sm_wkz_sicherung_faenger := TRUE;
						fb_state_entry.i16_next_step := FEHLER;
					END_IF

					IF ST_Virtuelle_Masterachse.fb_state_entry.i16_step >= BEREIT THEN
						IF gst_datensatz.st_bestueckprogramm.i16_b[ST_Virtuelle_Masterachse.i16_bestueckposzaehler] <> 0 THEN	(* Bei Umfahrung = 0 bewegt sich der Bestückschieber nicht *)
							(* Nocken werden in virtueller Bestückachse nach ein paar Hüben ausgeschaltet *)
							IF	(nockenschaltwerk_bestueckachse.fb.arr_spur[SP_UW_BESTUECKSCHIEBER_ON] AND  NOT e_bestueckschieber_ueberwachung) OR
								(nockenschaltwerk_bestueckachse.fb.arr_spur[SP_UW_BESTUECKSCHIEBER_OFF] AND e_bestueckschieber_ueberwachung)
								THEN
									sm_bestueckschieber_ueberwachung := TRUE;
									fb_state_entry.i16_next_step := FEHLER;
							END_IF
						END_IF
					END_IF


					(* Option: Flankenauswertung der GLS am Bestückschieber *)
(*					IF	nockenschaltwerk_bestueckachse.fb.arr_spur[SP_UW_BESTUECKSCHIEBER_ON] THEN
						IF 	fb_r_trig_signal_bestueckschieber.Q THEN
							b_signalmerker_bestueckschieber_on := TRUE;
						END_IF
						IF	 fb_f_trig_signal_bestueckschieber.Q THEN
							b_signalmerker_bestueckschieber_off := TRUE;
						END_IF
					END_IF

					(* Option: Beide setzen wenn Nocke abgeschaltet ist *)
					IF	NOT gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_UW_BESTUECKSCHIEBER_OFF].b_camvalid THEN
						b_signalmerker_bestueckschieber_on := TRUE;
						b_signalmerker_bestueckschieber_off := TRUE;
					END_IF

					IF 	fb_f_trig_nocke_uw_bestueckschieber.Q THEN

						IF 	b_signalmerker_bestueckschieber_off  AND
							b_signalmerker_bestueckschieber_on THEN
							b_signalmerker_bestueckschieber_on := FALSE;
							b_signalmerker_bestueckschieber_off := FALSE;
						ELSE
							sm_bestueckschieber_ueberwachung := TRUE;
							fb_state_entry.i16_next_step := FEHLER;
						END_IF
					END_IF
*)
				END_IF

			BESTUECKZELLE_1720:
				IF NOT gst_datensatz.st_md.b_wt_transport_simulation THEN
					IF e_kodierung_alt_wkz THEN
						(* BSV 1720 2-fach *)
						IF NOT  e_wkz_sicherung_faenger_li THEN
							sm_wkz_sicherung_faenger_li := TRUE;
							fb_state_entry.i16_next_step := FEHLER;
						END_IF
						IF NOT  e_wkz_sicherung_faenger_re THEN
							sm_wkz_sicherung_faenger_re := TRUE;
							fb_state_entry.i16_next_step := FEHLER;
						END_IF
					ELSE
						(* BSV 1720 6-fach *)
						IF	NOT ST_TippTasten.b_einfaedeln_aktiv THEN
							IF e_wkz_sicherung_niederhalter_li AND nockenschaltwerk_bestueckachse.fb.arr_spur[SP_UW_WKZ_NIEDERHALTER_LI] THEN
								sm_wkz_sicherung_niederhalter_li := TRUE;
								fb_state_entry.i16_next_step := 200;
							END_IF
							IF e_wkz_sicherung_niederhalter_re AND nockenschaltwerk_bestueckachse.fb.arr_spur[SP_UW_WKZ_NIEDERHALTER_RE] THEN
								sm_wkz_sicherung_niederhalter_re := TRUE;
								fb_state_entry.i16_next_step := 200;
							END_IF
						END_IF
						IF NOT  e_wkz_sicherung_faenger_li THEN
							sm_wkz_sicherung_faenger_li := TRUE;
							fb_state_entry.i16_next_step := FEHLER;
						END_IF
						IF NOT  e_wkz_sicherung_faenger_re THEN
							sm_wkz_sicherung_faenger_re := TRUE;
							fb_state_entry.i16_next_step := FEHLER;
						END_IF
						IF NOT e_wkz_sicherung_abfallpodest_li THEN
							sm_wkz_sicherung_abfallpodest_li := TRUE;
							fb_state_entry.i16_next_step := 200;
						END_IF
						IF NOT e_wkz_sicherung_abfallpodest_re THEN
							sm_wkz_sicherung_abfallpodest_re := TRUE;
							fb_state_entry.i16_next_step := 200;
						END_IF
					END_IF
				END_IF

			RASTERFOLIE:
				;
		END_CASE

(*=======================================================*)
	200:	(* Nur aktiv bei 1720 und WKZ-Absicherung 6-fach. Verzweigen nach Fehler erst, wenn OT erreicht wird - leichtere Fehlerbehebung. *)

		IF NOT gst_datensatz.st_md.b_wt_transport_simulation THEN
			(* BSV 1720 6-fach *)
			IF e_wkz_sicherung_niederhalter_li AND nockenschaltwerk_bestueckachse.fb.arr_spur[SP_UW_WKZ_NIEDERHALTER_LI] THEN
				sm_wkz_sicherung_niederhalter_li := TRUE;
			END_IF
			IF NOT  e_wkz_sicherung_faenger_li THEN
				sm_wkz_sicherung_faenger_li := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
			IF NOT e_wkz_sicherung_abfallpodest_li THEN
				sm_wkz_sicherung_abfallpodest_li := TRUE;
			END_IF
			IF e_wkz_sicherung_niederhalter_re AND nockenschaltwerk_bestueckachse.fb.arr_spur[SP_UW_WKZ_NIEDERHALTER_RE] THEN
				sm_wkz_sicherung_niederhalter_re := TRUE;
			END_IF
			IF NOT  e_wkz_sicherung_faenger_re THEN
				sm_wkz_sicherung_faenger_re := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
			IF NOT e_wkz_sicherung_abfallpodest_re THEN
				sm_wkz_sicherung_abfallpodest_re := TRUE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF nockenschaltwerk_bestueckachse.fb.arr_spur[SP_OT]  THEN
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_wkz_sicherung_faenger;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_bestueckschieber_ueberwachung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_wkz_sicherung_niederhalter_li;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := sm_wkz_sicherung_faenger_li;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := sm_wkz_sicherung_abfallpodest_li;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := sm_wkz_sicherung_niederhalter_re;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := sm_wkz_sicherung_faenger_re;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := sm_wkz_sicherung_abfallpodest_re;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/WT Transport' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Hublift_links
VAR_INPUT
	st_config							: struct_config;
	st_ctrl_in							: struct_ctrl_in;
	e_station_nachher_in_erlaubnis		: BOOL := FALSE;
	e_station_nachher_in_angekommen	: BOOL := FALSE;
END_VAR
VAR_IN_OUT
	st_visu							: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out						: struct_ctrl_out;
	a_station_nachher_out_anforderung	: BOOL := FALSE;
	a_station_nachher_out_abgegeben	: BOOL := FALSE;
END_VAR
VAR
	fb_ton_wz						: TON;
	fb_ton_uez						: TON;
	tb_ton_wt_anwesend				: TON;
	fb_ton_quitt						: TON;
	fb_r_trig_start						: R_TRIG;
	fb_state_entry						: ST_StateEntry;
	sm_kein_wt_anwesend				: BOOL := FALSE;
	sm_keine_busverbindung			: BOOL := FALSE;
	sm_schiebetuere_nicht_geschlossen	: BOOL := FALSE;

	e_sensor_wt_anwesend			AT %I* : BOOL;
	e_sensor_wt_von_fb_eingezogen	AT %I* : BOOL;
	e_wc_state						AT%I*: BOOL;	(* 0=Data valid, 1=Data invalid *)

	e_schiebetuere_geschlossen			AT %I* : BOOL;
	a_lampe_erlaubnis_schiebetuere_oeffnen		AT %Q* : BOOL;	(* Wenn Lampe TRUE dann darf der Bediener die Schiebetüre öffnen *)
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
tb_ton_wt_anwesend(IN:=e_sensor_wt_anwesend , PT:= t#500ms, Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_start(CLK:=ST_Euchner_Handbedienpult.b_Taste_Power , Q=>);

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF

	(* Allgemeine Fehler *)
	IF 	st_config.b_station_aktiv AND NOT st_config.b_station_in_simulation AND
		(zyl_hublift_links_lift.st_ctrl.out.b_fehler OR
		zyl_hublift_links_wt_einzug.st_ctrl.out.b_fehler OR
		zyl_hublift_links_wt_klinke.st_ctrl.out.b_fehler OR
		zyl_hublift_links_stopper.st_ctrl.out.b_fehler OR
		zyl_hublift_links_eingriffschutz.st_ctrl.out.b_fehler) THEN
			fb_state_entry.i16_next_step := FEHLER;

	(* Zylinder im Handbetrieb *)
	ELSIF gi16_betriebsart = HAND AND st_config.b_station_aktiv AND NOT st_config.b_station_in_simulation AND
		((st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_hublift_links_lift.fb.st_config.i16_identnummer) OR
		(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_hublift_links_wt_einzug.fb.st_config.i16_identnummer) OR
		(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_hublift_links_wt_klinke.fb.st_config.i16_identnummer) OR
		(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_hublift_links_stopper.fb.st_config.i16_identnummer)  OR
		(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_hublift_links_eingriffschutz.fb.st_config.i16_identnummer) ) THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_quitt.IN := FALSE;
			sm_kein_wt_anwesend	:= FALSE;
			sm_keine_busverbindung := FALSE;
			sm_schiebetuere_nicht_geschlossen := FALSE;
			a_station_nachher_out_anforderung := FALSE;
			a_station_nachher_out_abgegeben := FALSE;
			a_lampe_erlaubnis_schiebetuere_oeffnen := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_hublift_links_lift.st_ctrl.in.b_einfahren := FALSE;
			zyl_hublift_links_lift.st_ctrl.in.b_ausfahren := FALSE;
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_einfahren := FALSE;
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_ausfahren := FALSE;
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_einfahren := FALSE;
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_ausfahren := FALSE;
			zyl_hublift_links_stopper.st_ctrl.in.b_einfahren := FALSE;
			zyl_hublift_links_stopper.st_ctrl.in.b_ausfahren := FALSE;
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_einfahren := FALSE;
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_ausfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_hublift_links_lift.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_stopper.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_quittieren := FALSE;

			IF st_config.b_station_aktiv AND NOT st_config.b_station_in_simulation AND gst_datensatz.st_md.b_wt_transport_aktiv THEN
				fb_state_entry.i16_next_step := 15;
			ELSE
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	15: (* Prüfe, ob Busverbindung vorhanden ist *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wc_state THEN
			sm_keine_busverbindung := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSE
			fb_state_entry.i16_next_step := 18;
		END_IF

(*=======================================================*)
	18: (* Prüfe, ob Eingriffschutz geschlossen ist *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT e_schiebetuere_geschlossen THEN
			sm_schiebetuere_nicht_geschlossen := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSE
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: (* Initialisierung: Stopper ausfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_stopper.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_stopper.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_links_stopper.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30: (* Initialisierung: Abfrage auf WT *)
		IF tb_ton_wt_anwesend.Q THEN
		(* WT anwesend *)
			IF zyl_hublift_links_lift.fb.e_sensor1_eingefahren THEN
			(* Hublift unten *)
				fb_state_entry.i16_next_step := 120;
			ELSE
			(* Hublift oben *)
				fb_state_entry.i16_next_step := 155;
			END_IF
		ELSE
		(* Kein WT vorhanden oder vielleicht steht einer am Stopper *)
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40: (* Initialisierung: Klinke einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_wt_klinke.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_einfahren := FALSE;
			IF zyl_hublift_links_lift.fb.e_sensor1_eingefahren THEN
			(* Hublift unten *)
				fb_state_entry.i16_next_step := 70;
			ELSE
			(* Hublift oben *)
				fb_state_entry.i16_next_step := 50;
			END_IF
		END_IF

(*=======================================================*)
	50: (* Initialisierung: WT-Einzug einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_wt_einzug.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60: (* Initialisierung: Lift einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_lift.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_lift.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_links_lift.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 70;
		END_IF

(*=======================================================*)
	70: (* WT-Einzug ausfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_wt_einzug.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 80;
		END_IF

(*=======================================================*)
	80: (* Initialisierung: Stopper einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_stopper.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_stopper.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_links_stopper.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 90;
		END_IF

(*=======================================================*)
	90: (* Eingriffschutz ausfahren*)
		IF fb_state_entry.E THEN
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_eingriffschutz.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_config.b_station_aktiv AND NOT st_config.b_station_in_simulation AND gst_datensatz.st_md.b_wt_transport_aktiv THEN
			(* Hublift und WT Transport aktiv *)
			fb_state_entry.i16_next_step := 110;
		ELSIF NOT st_config.b_station_aktiv AND st_config.b_station_in_simulation AND gst_datensatz.st_md.b_wt_transport_aktiv THEN
			(* Simulation des Hubliftes *)
			fb_state_entry.i16_next_step := 160;
		ELSE
			;(* Hublift und WT Transport NICHT aktiv *)
		END_IF

(*=======================================================*)
	110:	(* Warte bis der WT angekommen ist *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF tb_ton_wt_anwesend.Q THEN
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120: (* Klinke ausfahren -> WT einhaken*)
		IF fb_state_entry.E THEN
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_wt_klinke.st_ctrl.out.b_ausgefahren AND
			e_sensor_wt_anwesend THEN
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 130;
		END_IF

(*=======================================================*)
	130: (* WT-Einzug einfahren und Stopper bei Signal ausfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	e_sensor_wt_von_fb_eingezogen OR
			zyl_hublift_links_wt_einzug.st_ctrl.out.b_eingefahren THEN
				zyl_hublift_links_stopper.st_ctrl.in.b_ausfahren := TRUE;
				fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	140: (* WT-Einzug ist eingefahren und Stopper ist ausgefahren *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_hublift_links_stopper.st_ctrl.out.b_ausgefahren AND
			zyl_hublift_links_wt_einzug.st_ctrl.out.b_eingefahren AND
			e_sensor_wt_anwesend THEN
				zyl_hublift_links_stopper.st_ctrl.in.b_ausfahren := FALSE;
				zyl_hublift_links_wt_einzug.st_ctrl.in.b_einfahren := FALSE;
				fb_state_entry.i16_next_step := 150;
		END_IF

(*=======================================================*)
	150: (* WT mit Lift anheben *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_lift.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_lift.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_links_lift.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 155;
		END_IF

(*=======================================================*)
	155: (* Warte auf Simulation oder Taste_Power *)
		IF fb_state_entry.E THEN
			a_lampe_erlaubnis_schiebetuere_oeffnen := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_config.b_station_in_simulation OR
			(fb_r_trig_start.Q AND e_schiebetuere_geschlossen) THEN
			fb_state_entry.i16_next_step := 160;
		END_IF

		IF fb_state_entry.X THEN
			a_lampe_erlaubnis_schiebetuere_oeffnen := FALSE;
		END_IF

(*=======================================================*)
	160: (* Warte auf Folgestation *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			a_station_nachher_out_anforderung := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  e_station_nachher_in_erlaubnis AND NOT fb_state_entry.E THEN
			a_station_nachher_out_anforderung := FALSE;
			IF st_config.b_station_in_simulation THEN
				fb_state_entry.i16_next_step := 180;
			ELSE
				IF e_sensor_wt_anwesend THEN
					fb_state_entry.i16_next_step := 165;
				ELSE
					fb_state_entry.i16_next_step := 190;
				END_IF
			END_IF
		END_IF

(*=======================================================*)
	165: (* Eingriffschutz einfahren*)
		IF fb_state_entry.E THEN
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_eingriffschutz.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 170;
		END_IF

(*=======================================================*)
	170: (* WT-Einzug ausfahren und Klinke einfahren und WT aushaken *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_ausfahren := TRUE;
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_einfahren := TRUE;
			st_ctrl_out.b_kontroller_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_hublift_links_wt_einzug.st_ctrl.out.b_ausgefahren AND
			zyl_hublift_links_wt_klinke.st_ctrl.out.b_eingefahren
			THEN
				st_ctrl_out.b_kontroller_start := FALSE;
				zyl_hublift_links_wt_einzug.st_ctrl.in.b_ausfahren := FALSE;
				zyl_hublift_links_wt_klinke.st_ctrl.in.b_einfahren := FALSE;
				fb_state_entry.i16_next_step := 180;
		END_IF

(*=======================================================*)
	180:	(* Warte bis WT angekommen ist *)
		IF fb_state_entry.E THEN
			a_station_nachher_out_abgegeben := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_station_nachher_in_angekommen THEN
			a_station_nachher_out_abgegeben := FALSE;
			IF st_config.b_station_in_simulation THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSE
				fb_state_entry.i16_next_step := 185;
			END_IF
		END_IF

(*=======================================================*)
	185: (* Eingriffschutz ausfahren*)
		IF fb_state_entry.E THEN
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_eingriffschutz.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 190;
		END_IF

(*=======================================================*)
	190: (* Klinke einfahren*)
		IF fb_state_entry.E THEN
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_wt_klinke.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 200;
		END_IF

(*=======================================================*)
	200: (* WT-Einzug einfahren  *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_wt_einzug.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210: (*  Lift einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_lift.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_lift.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_links_lift.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 220;
		END_IF

(*=======================================================*)
	220: (* WT-Einzug ausfahren  *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_wt_einzug.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 230;
		END_IF

(*=======================================================*)
	230: (* Stopper einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_links_stopper.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_links_stopper.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_links_stopper.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			a_station_nachher_out_anforderung := FALSE;
			a_station_nachher_out_abgegeben := FALSE;
			zyl_hublift_links_lift.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_stopper.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_hublift_links_lift.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_links_stopper.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			zyl_hublift_links_lift.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_stopper.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_hublift_links_lift.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_links_wt_einzug.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_links_wt_klinke.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_links_stopper.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_links_eingriffschutz.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_kein_wt_anwesend;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_keine_busverbindung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_schiebetuere_nicht_geschlossen;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/WT Transport' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Hublift_rechts
VAR_INPUT
	st_config							: struct_config;
	st_ctrl_in							: struct_ctrl_in;
	e_station_vorher_in_anforderung		: BOOL := FALSE;
	e_station_vorher_in_abgegeben		: BOOL := FALSE;
END_VAR
VAR_IN_OUT
	st_visu							: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out						: struct_ctrl_out;
	a_station_vorher_out_erlaubnis		: BOOL := FALSE;
	a_station_vorher_out_angekommen	: BOOL := FALSE;
END_VAR
VAR
	fb_ton_wz						: TON;
	fb_ton_uez						: TON;
	fb_ton_quitt						: TON;
	fb_ton_wt_anwesend			: TON;
	fb_state_entry					: ST_StateEntry;
	sm_kein_wt_anwesend			: BOOL := FALSE;
	sm_kein_wt_eingeklinkt			: BOOL := FALSE;
	sm_keine_busverbindung		: BOOL := FALSE;

	e_sensor_wt_anwesend			AT %I* : BOOL;
	e_wc_state						AT%I*: BOOL;	(* 0=Data valid, 1=Data invalid *)
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_wt_anwesend(IN:= e_sensor_wt_anwesend, PT:= t#200ms, Q=> , ET=> );

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF

	(* Allgemeine Fehler *)
	IF 	st_config.b_station_aktiv AND NOT st_config.b_station_in_simulation AND
		(zyl_hublift_rechts_lift.st_ctrl.out.b_fehler OR
		zyl_hublift_rechts_wt_einzug.st_ctrl.out.b_fehler OR
		zyl_hublift_rechts_wt_klinke.st_ctrl.out.b_fehler)
		THEN
			fb_state_entry.i16_next_step := FEHLER;

	(* Zylinder im Handbetrieb *)
	ELSIF gi16_betriebsart = HAND AND st_config.b_station_aktiv AND NOT st_config.b_station_in_simulation AND
		((st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_hublift_rechts_lift.fb.st_config.i16_identnummer) OR
		(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_hublift_rechts_wt_einzug.fb.st_config.i16_identnummer) OR
		(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_hublift_rechts_wt_klinke.fb.st_config.i16_identnummer))
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_quitt.IN := FALSE;
			sm_kein_wt_anwesend	:= FALSE;
			sm_kein_wt_eingeklinkt := FALSE;
			sm_keine_busverbindung := FALSE;
			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			zyl_hublift_rechts_lift.st_ctrl.in.b_einfahren := FALSE;
			zyl_hublift_rechts_lift.st_ctrl.in.b_ausfahren := FALSE;
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_einfahren := FALSE;
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_ausfahren := FALSE;
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_einfahren := FALSE;
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_ausfahren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_quittieren := FALSE;
			IF	 st_config.b_station_aktiv AND NOT st_config.b_station_in_simulation AND
				(gst_datensatz.st_md.b_wt_transport_aktiv OR gst_datensatz.st_md.b_wt_transport_simulation) THEN
					fb_state_entry.i16_next_step := 15;
			ELSE
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	15: (* Prüfe, ob Busverbindung vorhanden ist *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_hublift_rechts_lift.fb.e_sensor1_ausgefahren OR
			zyl_hublift_rechts_lift.fb.e_sensor1_eingefahren OR
			zyl_hublift_rechts_wt_einzug.fb.e_sensor1_ausgefahren OR
			zyl_hublift_rechts_wt_einzug.fb.e_sensor1_eingefahren OR
			zyl_hublift_rechts_wt_klinke.fb.e_sensor1_ausgefahren OR
			zyl_hublift_rechts_wt_klinke.fb.e_sensor1_eingefahren THEN
				fb_state_entry.i16_next_step := 20;
		ELSE
				sm_keine_busverbindung := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
		END_IF


		(* Bei der nächsten TSM Änderung bitte aktivieren
		IF e_wc_state THEN
			sm_keine_busverbindung := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSE
			fb_state_entry.i16_next_step := 20;
		END_IF*)

(*=======================================================*)
	20: (* Initialisierung: Prüfe WT in Lift *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wt_anwesend.Q  THEN
			(* WT ist angekommen *)
			fb_state_entry.i16_next_step := 50;
		ELSE
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30: (* Initialisierung: Klinke einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_klinke.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 35;
		END_IF

(*=======================================================*)
	35: (* Initialisierung: WT-Einzug einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_einzug.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40: (* Initialisierung: Lift Hoch *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_lift.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 45;
		END_IF

(*=======================================================*)
	45: (* Initialisierung: WT-Einzug ausfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_einzug.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	50: (* Initialisierung: Klinke ausfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_klinke.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 55;
		END_IF

(*=======================================================*)
	55: (* Initialisierung: WT-Einzug einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_einzug.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60: (* Initialisierung: Lift einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_lift.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 65;
		END_IF

(*=======================================================*)
	65: (* Initialisierung: WT-Einzug ausfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_einzug.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 70;
		END_IF

(*=======================================================*)
	70: (* Initialisierung: Klinke einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_klinke.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 75;
		END_IF

(*=======================================================*)
	75: (* Initialisierung: Warte WT vom Förderband eingezogen *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT :=t#300ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 80;
		END_IF

(*=======================================================*)
	80: (* Initialisierung: WT-Einzug einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_einzug.st_ctrl.out.b_eingefahren THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 85;
		END_IF

(*=======================================================*)
	85: (* Initialisierung: Lift Hoch *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_lift.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 90;
		END_IF

(*=======================================================*)
	90: (* Initialisierung: WT-Einzug ausfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_einzug.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_ausfahren := FALSE;
			a_station_vorher_out_angekommen := TRUE;	(* benötigtes Signal, damit es an der Vorgängerzelle in "ST_WT_Transport_Abgabe" weiter gehen kann *)
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:	(* Warte auf Anforderung von vorheriger Station zum aufnehmen des WT *)
		IF fb_state_entry.E THEN
			a_station_vorher_out_erlaubnis := FALSE;
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	(st_config.b_station_aktiv OR st_config.b_station_in_simulation) AND
			(gst_datensatz.st_md.b_wt_transport_aktiv OR gst_datensatz.st_md.b_wt_transport_simulation)
			THEN
				(* Hublift und WT Transport aktiv - die Simulation spielt im weiteren Verlauf keine Rolle mehr *)
				IF e_station_vorher_in_anforderung THEN
					a_station_vorher_out_angekommen := FALSE;
					a_station_vorher_out_erlaubnis := TRUE;
					fb_state_entry.i16_next_step := 120;
				END_IF
		ELSE
			;(* Hublift und WT Transport NICHT aktiv *)
		END_IF

(*=======================================================*)
	110: (* Warte bis WT abgegeben wurde*)
		IF fb_state_entry.E THEN
			a_station_vorher_out_erlaubnis := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_station_vorher_in_abgegeben AND NOT fb_state_entry.E THEN
			a_station_vorher_out_erlaubnis := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120:	(* Abfrage, ob der WT auch eingehakt wurde *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#2s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wt_anwesend.Q  THEN
			(* WT ist angekommen *)
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 130;
		END_IF

		(* Pfad für nicht angekommen oder Simulation *)
		IF fb_ton_wz.Q THEN
			a_station_vorher_out_angekommen := TRUE;
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	130: (* Klinke ausfahren -> WT einhaken*)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_klinke.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	140: (* WT-Einzug einfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_wt_einzug.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_einfahren := FALSE;
			IF e_sensor_wt_anwesend THEN
				a_station_vorher_out_erlaubnis := FALSE;
				a_station_vorher_out_angekommen := TRUE;
				fb_state_entry.i16_next_step := 150;
			ELSE
				sm_kein_wt_eingeklinkt := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	150: (* WT mit Lift absenken *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_lift.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160: (* WT-Einzug ausfahren und Klinke einfahren und WT aushaken*)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_ausfahren := TRUE;
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_hublift_rechts_wt_einzug.st_ctrl.out.b_ausgefahren AND
			zyl_hublift_rechts_wt_klinke.st_ctrl.out.b_eingefahren AND
			gb_ba_auto_kontroller
			THEN
				zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_ausfahren := FALSE;
				zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_einfahren := FALSE;
				fb_state_entry.i16_next_step := 170;
		END_IF

(*=======================================================*)
	170:	(* WT wird von FB reingezogen *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT e_sensor_wt_anwesend THEN;
			fb_ton_wz.PT := t#500ms;
			fb_ton_wz.IN := TRUE;
			IF fb_ton_wz.Q THEN
				fb_ton_wz.IN := FALSE;
				fb_state_entry.i16_next_step := 180;
			END_IF
		END_IF

(*=======================================================*)
	180: (* Lift ausfahren *)
		IF fb_state_entry.E THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_hublift_rechts_lift.st_ctrl.out.b_ausgefahren THEN
			zyl_hublift_rechts_lift.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := TRUE;
			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;
			zyl_hublift_rechts_lift.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_hublift_rechts_lift.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			zyl_hublift_rechts_lift.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_quittieren := FALSE;
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_hublift_rechts_lift.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_rechts_wt_einzug.st_ctrl.in.b_quittieren := TRUE;
			zyl_hublift_rechts_wt_klinke.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE


fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_kein_wt_anwesend;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_kein_wt_eingeklinkt;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_keine_busverbindung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/WT Transport' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_WT_Transport_Abgabe
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;
	e_station_nachher_in_erlaubnis			: BOOL := FALSE;
	e_station_nachher_in_angekommen		: BOOL := FALSE;
END_VAR
VAR_IN_OUT
	st_visu								: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
	a_station_nachher_out_anforderung		: BOOL := FALSE;
	a_station_nachher_out_abgegeben		: BOOL := FALSE;
END_VAR
VAR
	fb_ton_uez							: TON;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_wt_auf_abgabepos				: TON;
	fb_tof_wt_auf_abgabepos				: TOF;
	fb_WT_WechselZeit					: ST_Taktzeit;
	t_traegerwechselzeit					: TIME := t#0ms;
	t_traegerwechselzeit_help				: TIME := t#0ms;
	fb_f_trig_abgabepos					: F_TRIG;
	fb_r_trig_start							: R_TRIG;
	fb_r_trig_pm_time						: R_TRIG;
	fb_state_entry							: ST_StateEntry;
	i16_state_msg						: INT;
	sm_wt_hat_abgabepos_nicht_verlassen	: BOOL := FALSE;
	sm_wt_hat_abgabepos_ueberfahren		: BOOL := FALSE;
	bm_setze_anforderung					: BOOL := FALSE;
	bm_abfrage_wt_an_stopper				: BOOL := FALSE;
	pm_traegerwechselzeit					: BOOL := FALSE;
	e_wt_auf_abgabepos					AT %I* : BOOL;
	e_wt_abgabepos_verlassen			AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_WT_WechselZeit(b_start:= , t_zeit=> );

fb_ton_wt_auf_abgabepos(IN:= e_wt_auf_abgabepos, PT:= t#500ms, Q=> , ET=> );
fb_tof_wt_auf_abgabepos(IN:=e_wt_auf_abgabepos , PT:= t#200ms, Q=> , ET=> );

(* Flanken *)
fb_f_trig_abgabepos(CLK:= e_wt_auf_abgabepos, Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );


(*Meldung für Trägerwechselzeit zu groß nur ausgeben, wenn Hublift nicht aktiv ist*)
IF NOT gst_Datensatz.st_md.b_hublift_rechts_aktiv THEN
	fb_r_trig_pm_time(CLK:= pm_traegerwechselzeit, Q=> );
END_IF

IF fb_r_trig_pm_time.Q  THEN
	t_traegerwechselzeit_help := t_traegerwechselzeit;
	i16_state_msg := 1;
END_IF

(*Produktionsmeldung für Übergabe zu lange*)
CASE i16_state_msg OF
	1: (*Warten bis keine ander Produktions Meldung ansteht *)
		IF	TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			i16_state_msg := 2;
		END_IF

	2:  (*Produktions Meldung*)
		Visu.MeldungProduktion.Color_R := 255;
		Visu.MeldungProduktion.Color_G := 255;
		Visu.MeldungProduktion.Color_B := 0;
		IF visu.s_akt_sprache = 'de' THEN
			Visu.MeldungProduktion.Name:=CONCAT('WT Wechsel in die nächste Zelle hat zu lange gedautert.',TIME_TO_STRING(t_traegerwechselzeit_help));
		ELSIF visu.s_akt_sprache = 'en' THEN
			Visu.MeldungProduktion.Name:=CONCAT('carrier exchange into station exceeded time limit.',TIME_TO_STRING(t_traegerwechselzeit_help));
		ELSIF visu.s_akt_sprache = 'cz' THEN
			Visu.MeldungProduktion.Name:=CONCAT('Prejezd paletky do dalsi cely trval prilis dlouho.',TIME_TO_STRING(t_traegerwechselzeit_help));
		END_IF
		Visu.MeldungProduktion.ShowMessage := TRUE;
		Visu.MeldungProduktion.Button1.sichtbar:=TRUE;	(*OK*)
		Visu.MeldungProduktion.Button1.Text:='Ok';
		i16_state_msg := 3;

	3:  (*Warte auf OK*)
		IF Visu.MeldungProduktion.Button1.tasten THEN
			i16_state_msg:=0;
		END_IF
END_CASE

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF

	(* Allgemeine Fehler *)
	IF zyl_wt_stopper_auslauf.st_ctrl.out.b_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;

	(* Zylinder im Handbetrieb *)
	ELSIF gi16_betriebsart = HAND AND
		(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_wt_stopper_auslauf.fb.st_config.i16_identnummer )
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF


(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_stopper_auslauf.st_ctrl.in.b_einfahren := FALSE;
			zyl_wt_stopper_auslauf.st_ctrl.in.b_ausfahren := FALSE;
			sm_wt_hat_abgabepos_nicht_verlassen := FALSE;
			sm_wt_hat_abgabepos_ueberfahren := FALSE;
			bm_setze_anforderung := FALSE;
			bm_abfrage_wt_an_stopper := FALSE;
			a_station_nachher_out_anforderung := FALSE;
			a_station_nachher_out_abgegeben := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_wt_stopper_auslauf.st_ctrl.in.b_quittieren := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: (* Initialisierung: Auslaufstopper ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_auslauf.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_auslauf.st_ctrl.out.b_ausgefahren THEN
			zyl_wt_stopper_auslauf.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:	(* Warte auf Startfreigabe von Kontroller *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
		END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_config.b_station_aktiv OR st_config.b_station_in_simulation THEN
			(* WT Transport aktiv oder in Simulation *)
			IF st_ctrl_in.b_start THEN
				fb_state_entry.i16_next_step := 110;
			END_IF
		ELSE
			(* WT Transport nicht aktiv und nicht in Simulation -> tue nichts  *)
 			;
		END_IF

(*=======================================================*)
	110: (* Statische WT-Abfrage auf Abgabeposition *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_kontroller_start := TRUE;
			bm_abfrage_wt_an_stopper := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wt_auf_abgabepos THEN
			st_ctrl_out.b_kontroller_start := FALSE;
			bm_abfrage_wt_an_stopper := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120:  (* Setze Anforderung an folgende Station *)
		IF fb_state_entry.E THEN
			a_station_nachher_out_anforderung := TRUE;
			bm_setze_anforderung := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_station_nachher_in_erlaubnis  AND NOT fb_state_entry.E THEN
			bm_setze_anforderung := FALSE;
			fb_state_entry.i16_next_step := 130;
		ELSIF e_wt_abgabepos_verlassen THEN
			(* Abgabeposition wurde unerlaubterweise überfahren *)
			sm_wt_hat_abgabepos_ueberfahren := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	130: (* WT-Stopper einfahren *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_kontroller_start := TRUE;
			zyl_wt_stopper_auslauf.st_ctrl.in.b_einfahren := TRUE;
			fb_WT_WechselZeit(b_start:=TRUE , t_zeit=> );
			pm_traegerwechselzeit := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_auslauf.st_ctrl.out.b_eingefahren OR e_wt_abgabepos_verlassen (* wegen möglichen Problemen beim schnellen Förderband*)THEN
			zyl_wt_stopper_auslauf.st_ctrl.in.b_einfahren := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	140: (* Warte bis WT an "verlassen" Sensor *)
		IF fb_state_entry.E THEN
			fb_ton_uez.PT := t#300ms;
 			fb_ton_uez.IN := TRUE;
			st_ctrl_out.b_kontroller_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_Hublift_rechts.st_config.b_station_aktiv THEN
			st_ctrl_out.b_kontroller_start := TRUE;
			IF	 e_wt_abgabepos_verlassen THEN
				(* Bei Hublift kann der WT den Sensor nicht erreichen, deshalb gleich Meldung an nachfolgende Station *)
 				fb_ton_uez.IN := FALSE;
				fb_state_entry.i16_next_step := 150;
			ELSIF fb_ton_uez.Q THEN
				sm_wt_hat_abgabepos_nicht_verlassen := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		ELSE
			st_ctrl_out.b_kontroller_start := FALSE;
			IF e_wt_abgabepos_verlassen THEN
	 			fb_ton_uez.IN := FALSE;
				a_station_nachher_out_abgegeben := TRUE;
				fb_state_entry.i16_next_step := 150;
			ELSIF fb_ton_uez.Q THEN
				sm_wt_hat_abgabepos_nicht_verlassen := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	150: (* Auslaufstopper ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_auslauf.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_auslauf.st_ctrl.out.b_ausgefahren THEN
			zyl_wt_stopper_auslauf.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160: (* Warte bis die folgende Station "angekommen" meldet *)
		IF fb_state_entry.E THEN
			a_station_nachher_out_abgegeben := FALSE;
			st_ctrl_out.b_kontroller_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_station_nachher_in_angekommen THEN
			fb_WT_WechselZeit(b_start:=FALSE , t_zeit=>t_traegerwechselzeit );
			a_station_nachher_out_anforderung := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			pm_traegerwechselzeit := t_traegerwechselzeit > gst_datensatz.st_md.t_max_traegerwechselzeit AND gst_datensatz.st_md.t_max_traegerwechselzeit <> INT_TO_TIME(0);
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_wt_stopper_auslauf.st_ctrl.in.b_quittieren := FALSE;
			a_station_nachher_out_anforderung := FALSE;
			a_station_nachher_out_abgegeben := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_wt_stopper_auslauf.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_stopper_auslauf.st_ctrl.in.b_quittieren := FALSE;
			a_station_nachher_out_anforderung := FALSE;
			a_station_nachher_out_abgegeben := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_wt_stopper_auslauf.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_wt_hat_abgabepos_nicht_verlassen;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_wt_hat_abgabepos_ueberfahren;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_setze_anforderung;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := bm_abfrage_wt_an_stopper;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/WT Transport' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)

PROGRAM ST_WT_Transport_Kontroller
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu								: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
END_VAR
VAR
	fb_ton_uez							: TON;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_stausensor						: TON;
	fb_ton_wz_nachlauf_fb_oben			: TON;
	fb_ton_wz_nachlauf_fb_unten			: TON;
	fb_ton_wz_foerderband_stauzeit			: TON;
	fb_ton_ueberstrom_foerderbaender		: TON;
	fb_r_trig_beladen_start_fb				: R_TRIG;
	fb_r_trig_beladen_1700_start_fb			: R_TRIG;
	fb_r_trig_beladen_wartepos_1700_start_fb	: R_TRIG;
	fb_r_trig_abgabe_start_fb				: R_TRIG;
	fb_r_trig_wartepos_start_fb				: R_TRIG;
	fb_r_trig_start_foerderband				: R_TRIG;
	fb_r_trig_eigenstart_foerderband			: R_TRIG;
	fb_r_trig_hublift						: R_TRIG;
	fb_state_entry							: ST_StateEntry;
	t_foerderband_nachlaufzeit				: TIME := t#10m;
	t_foerderband_stauzeit					: TIME := t#1s;
	b_eigenstart_foerderband				: BOOL := FALSE;
	b_ibn_rundlauf_tipptaste				: BOOL := FALSE;	(* Merker für endlos Lauf und keinen WT-Transport - wird nur im PLC händisch gesetzt *)
	i									: DINT := 0;

	sm_stau_auf_ruecktransport				: BOOL := FALSE;
	sm_ueberstrom_foerderbaender			: BOOL := FALSE;

	bm_einzelfertigung_nach_bandwechsel	: BOOL := FALSE;
	e_stausensor_wt_ruecktransport			AT %I* : BOOL;
	a_foerderband_wt_transport				AT %Q* : BOOL;
	a_foerderband_wt_ruecktransport		AT %Q* : BOOL;
	e_ueberstrom_foerderbaender			AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#150ms, Q=> , ET=> );



(*Trigger*)
CASE gst_datensatz.st_md.i16_typ_zelle OF
	KEINE_ZELLE:
		;

	BESTUECKZELLE_1700, RASTERFOLIE:
		IF NOT gst_datensatz.st_md.b_anwahl_transport_achse THEN
			fb_r_trig_beladen_start_fb(CLK:= wt_transport_beladen.st_ctrl.out.b_kontroller_start, Q=> );
			fb_ton_wz_foerderband_stauzeit(IN:=  ST_WT_Transport_Beladen.e_wt_auf_beladepos AND ST_WT_Transport_Abgabe.e_wt_auf_abgabepos, PT:= t_foerderband_stauzeit, Q=> , ET=> );
		ELSE
			fb_r_trig_beladen_1700_start_fb(CLK:= wt_transport_beladen_achse_1700.st_ctrl.out.b_kontroller_start, Q=> );
			fb_r_trig_beladen_wartepos_1700_start_fb(CLK:= wt_transport_warteposition_1700.st_ctrl.out.b_kontroller_start, Q=> );
			fb_ton_wz_foerderband_stauzeit(IN:= ST_WT_Transport_Warteposition_1700.e_wt_auf_wartepos_1700 AND ST_WT_Transport_Abgabe.e_wt_auf_abgabepos, PT:= t_foerderband_stauzeit, Q=> , ET=> );
		END_IF

	BESTUECKZELLE_1720:
		fb_r_trig_beladen_start_fb(CLK:= wt_transport_beladen_1720.st_ctrl.out.b_kontroller_start, Q=> );
		fb_r_trig_wartepos_start_fb(CLK:= wt_transport_warteposition_1720.st_ctrl.out.b_kontroller_start, Q=> );
		fb_ton_wz_foerderband_stauzeit(IN:=  ST_WT_Transport_Beladen_1720.e_wt_auf_beladepos AND ST_WT_Transport_Abgabe.e_wt_auf_abgabepos AND ST_WT_Transport_Warteposition_1720.e_wt_auf_wartepos , PT:= t_foerderband_stauzeit, Q=> , ET=> );
END_CASE

fb_r_trig_abgabe_start_fb(CLK:= wt_transport_abgabe.st_ctrl.out.b_kontroller_start, Q=> );
fb_r_trig_start_foerderband(CLK:= st_visu.b_start_foerderband, Q=> );
fb_r_trig_eigenstart_foerderband(CLK:= b_eigenstart_foerderband, Q=> );
fb_r_trig_hublift(CLK:= hublift_links.st_ctrl.out.b_kontroller_start, Q=> );
fb_ton_ueberstrom_foerderbaender(IN:=NOT e_ueberstrom_foerderbaender  , PT:= t#200ms, Q=> , ET=> );

(* =====Ansteuerung Förderbänder===== *)
fb_ton_stausensor(IN:= e_stausensor_wt_ruecktransport AND
					NOT st_visu.b_start_foerderband AND
					NOT fb_r_trig_beladen_start_fb.Q AND
					NOT fb_r_trig_wartepos_start_fb.Q AND
					NOT fb_r_trig_beladen_1700_start_fb.Q AND
					NOT fb_r_trig_beladen_wartepos_1700_start_fb.Q

					, PT:= t#5s, Q=> , ET=> );

fb_ton_wz_nachlauf_fb_oben(IN:= , PT:= t_foerderband_nachlaufzeit, Q=> , ET=> );
fb_ton_wz_nachlauf_fb_unten(IN:= , PT:= t_foerderband_nachlaufzeit, Q=> , ET=> );

(* ===Zeit nachtriggern=== *)
(* Förderband oben *)
IF 	fb_r_trig_beladen_start_fb.Q OR
	fb_r_trig_abgabe_start_fb.Q OR
	fb_r_trig_wartepos_start_fb.Q OR
	 fb_r_trig_beladen_1700_start_fb.Q OR
	fb_r_trig_beladen_wartepos_1700_start_fb.Q OR
	fb_r_trig_hublift.Q
	THEN
		fb_ton_wz_nachlauf_fb_oben(IN:= FALSE, PT:= t_foerderband_nachlaufzeit, Q=> , ET=> );
END_IF
(* Förderband unten *)
IF 	fb_r_trig_beladen_start_fb.Q OR
	fb_r_trig_abgabe_start_fb.Q OR
	fb_r_trig_wartepos_start_fb.Q OR
	 fb_r_trig_beladen_1700_start_fb.Q OR
	fb_r_trig_beladen_wartepos_1700_start_fb.Q OR
	fb_r_trig_start_foerderband.Q
	THEN
		fb_ton_wz_nachlauf_fb_unten(IN:= FALSE, PT:= t_foerderband_nachlaufzeit, Q=> , ET=> );
END_IF

(* ===Ansteuerung=== *)
(* Förderband oben *)
IF 	ST_Safetyprogramm.se_steuerung_ein AND ST_Safetyprogramm.se_ba_mit_bedingungen AND
	(st_config.b_station_aktiv  OR st_config.b_station_in_simulation)
	THEN
		IF 	fb_r_trig_beladen_start_fb.Q OR
			fb_r_trig_abgabe_start_fb.Q OR
			fb_r_trig_wartepos_start_fb.Q OR
			fb_r_trig_eigenstart_foerderband.Q OR
			 fb_r_trig_beladen_1700_start_fb.Q OR
			fb_r_trig_beladen_wartepos_1700_start_fb.Q OR
			fb_r_trig_hublift.Q
			 THEN
				a_foerderband_wt_transport := TRUE;
				fb_ton_wz_nachlauf_fb_oben(IN:= TRUE, PT:= t_foerderband_nachlaufzeit, Q=> , ET=> );
				fb_ton_wz_foerderband_stauzeit(IN:= FALSE, PT:= t_foerderband_nachlaufzeit, Q=> , ET=> );
		ELSE
			IF fb_ton_wz_nachlauf_fb_oben.Q OR fb_ton_wz_foerderband_stauzeit.Q THEN
				a_foerderband_wt_transport := FALSE;
				fb_ton_wz_nachlauf_fb_oben(IN:= FALSE, PT:= t_foerderband_nachlaufzeit, Q=> , ET=> );
			END_IF
		END_IF
ELSE
	fb_ton_wz_nachlauf_fb_unten.IN := FALSE;
	a_foerderband_wt_transport := FALSE;
END_IF

(* Förderband unten *)
(* Funktionsweise:
Bei Anforderung von vorheriger Station an das Fb oben wird ebenso das Fb unten gestartet. Somit setzt sich die Kette wieder Bewegung. 
Mit Handstart kann die Anlage in Richtung BEHR-Zelle entleert werden, ohne dass neue WTs oben kommen. *)
IF 	ST_Safetyprogramm.se_steuerung_ein AND ST_Safetyprogramm.se_ba_mit_bedingungen AND
	(st_config.b_station_aktiv  OR st_config.b_station_in_simulation)
	THEN
		IF 	fb_r_trig_beladen_start_fb.Q OR
			fb_r_trig_abgabe_start_fb.Q OR
			fb_r_trig_wartepos_start_fb.Q OR
			fb_r_trig_start_foerderband.Q OR
			fb_r_trig_beladen_1700_start_fb.Q OR
			fb_r_trig_beladen_wartepos_1700_start_fb.Q OR
			fb_r_trig_eigenstart_foerderband.Q
			THEN
				a_foerderband_wt_ruecktransport := TRUE;
				fb_ton_wz_nachlauf_fb_unten(IN:= TRUE, PT:= t_foerderband_nachlaufzeit, Q=> , ET=> );
		ELSE
			IF fb_ton_wz_nachlauf_fb_unten.Q OR fb_ton_stausensor.Q THEN
				a_foerderband_wt_ruecktransport := FALSE;
				fb_ton_wz_nachlauf_fb_unten(IN:= FALSE, PT:= t_foerderband_nachlaufzeit, Q=> , ET=> );
			END_IF
		END_IF
ELSE
	fb_ton_wz_nachlauf_fb_unten.IN := FALSE;
	a_foerderband_wt_ruecktransport := FALSE;
END_IF


(* =================================Toplevel=================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF

	(* Allgemeine Fehler *)
	IF	wt_transport_beladen.st_ctrl.out.b_fehler OR
		wt_transport_beladen_achse_1700.st_ctrl.out.b_fehler OR
		wt_transport_beladen_1720.st_ctrl.out.b_fehler
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ==================================Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			sm_stau_auf_ruecktransport := FALSE;
			sm_ueberstrom_foerderbaender := FALSE;
			bm_einzelfertigung_nach_bandwechsel := FALSE;

			wt_transport_beladen.st_ctrl.in.b_init := FALSE;
			wt_transport_abgabe.st_ctrl.in.b_init := FALSE;
			wt_transport_warteposition_1700.st_ctrl.in.b_init := FALSE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_init := FALSE;
			wt_transport_warteposition_1720.st_ctrl.in.b_init := FALSE;
			wt_transport_beladen_1720.st_ctrl.in.b_init := FALSE;
			wt_transport_beladen.st_ctrl.in.b_start := FALSE;
			wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
			wt_transport_warteposition_1700.st_ctrl.in.b_start := FALSE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_start := FALSE;
			wt_transport_warteposition_1720.st_ctrl.in.b_start := FALSE;
			wt_transport_beladen_1720.st_ctrl.in.b_start := FALSE;

			gb_nach_bawe_einzelfertigung := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			EtherCatDiag[1].st_ctrl_in.b_quitt := TRUE;
			EtherCatDiag[2].st_ctrl_in.b_quitt := TRUE;
			EtherCatDiag[3].st_ctrl_in.b_quitt := TRUE;
			EtherCatDiag[4].st_ctrl_in.b_quitt := TRUE;
			wt_transport_beladen.st_ctrl.in.b_quitt := FALSE;
			wt_transport_abgabe.st_ctrl.in.b_quitt := FALSE;
			wt_transport_warteposition_1700.st_ctrl.in.b_quitt := FALSE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_quitt := FALSE;
			wt_transport_warteposition_1720.st_ctrl.in.b_quitt := FALSE;
			wt_transport_beladen_1720.st_ctrl.in.b_quitt := FALSE;
			fb_ton_ueberstrom_foerderbaender.IN := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: (* Initialisierung Subkomponenten *)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700, RASTERFOLIE:
				IF fb_state_entry.E THEN
					IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
						wt_transport_beladen_achse_1700.st_ctrl.in.b_init := TRUE;
						wt_transport_warteposition_1700.st_ctrl.in.b_init := TRUE;
					ELSE
						wt_transport_beladen.st_ctrl.in.b_init := TRUE;
					END_IF
					wt_transport_abgabe.st_ctrl.in.b_init := TRUE;
				END_IF

				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
					IF 	wt_transport_beladen_achse_1700.st_ctrl.out.b_bereit AND
						wt_transport_warteposition_1700.st_ctrl.out.b_bereit AND
						wt_transport_abgabe.st_ctrl.out.b_bereit THEN
						wt_transport_beladen_achse_1700.st_ctrl.in.b_init := FALSE;
						wt_transport_warteposition_1700.st_ctrl.in.b_init := FALSE;
						wt_transport_abgabe.st_ctrl.in.b_init := FALSE;
						fb_state_entry.i16_next_step := BEREIT;
					END_IF
				ELSE
					IF 	wt_transport_beladen.st_ctrl.out.b_bereit AND
						wt_transport_abgabe.st_ctrl.out.b_bereit THEN
						wt_transport_beladen.st_ctrl.in.b_init := FALSE;
						wt_transport_abgabe.st_ctrl.in.b_init := FALSE;
						fb_state_entry.i16_next_step := BEREIT;
					END_IF
				END_IF


			BESTUECKZELLE_1720:
				IF fb_state_entry.E THEN
					wt_transport_warteposition_1720.st_ctrl.in.b_init := TRUE;
					wt_transport_beladen_1720.st_ctrl.in.b_init := TRUE;
					wt_transport_abgabe.st_ctrl.in.b_init := TRUE;
				END_IF
		
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF	wt_transport_warteposition_1720.st_ctrl.out.b_bereit AND
					wt_transport_beladen_1720.st_ctrl.out.b_bereit AND
					wt_transport_abgabe.st_ctrl.out.b_bereit
					THEN
						wt_transport_warteposition_1720.st_ctrl.in.b_init := FALSE;
						wt_transport_beladen_1720.st_ctrl.in.b_init := FALSE;
						wt_transport_abgabe.st_ctrl.in.b_init := FALSE;
						b_eigenstart_foerderband := TRUE;
						fb_state_entry.i16_next_step := BEREIT;
				END_IF
		END_CASE

		IF fb_state_entry.X THEN
			EtherCatDiag[1].st_ctrl_in.b_quitt := FALSE;
			EtherCatDiag[2].st_ctrl_in.b_quitt := FALSE;
			EtherCatDiag[3].st_ctrl_in.b_quitt := FALSE;
			EtherCatDiag[4].st_ctrl_in.b_quitt := FALSE;
		END_IF

(*=======================================================*)
	BEREIT:	(* WT-Stationen sind bereit für Annahme oder Abgabe *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
			b_eigenstart_foerderband := FALSE;
			bm_einzelfertigung_nach_bandwechsel := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;
			RASTERFOLIE:
				IF st_config.b_station_aktiv  OR st_config.b_station_in_simulation THEN
					(* WT-Transport aktiv oder in Simulation *)
					(* Warte auf Start *)
					IF ST_TippTasten.r_trig_tippen.Q THEN
						st_ctrl_out.b_fertig := FALSE;
						wt_transport_beladen.st_ctrl.in.b_start := TRUE;
						wt_transport_abgabe.st_ctrl.in.b_start := TRUE;
						fb_state_entry.i16_next_step := 110;
					END_IF
				ELSE
					(* WT-Transport nicht aktiv  *)
					wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
					(* Warte auf Start *)
					IF ST_TippTasten.r_trig_tippen.Q OR b_ibn_rundlauf_tipptaste THEN
						st_ctrl_out.b_fertig := FALSE;
						fb_state_entry.i16_next_step := 200;
					END_IF
				END_IF

			BESTUECKZELLE_1700:
				(* WT-Transport aktiv oder in Simulation *)
				IF st_config.b_station_aktiv  OR st_config.b_station_in_simulation THEN
					(* Warte auf Start von Visu bzw. Handbedienpult wenn kein Bandwechsel war *)
					IF ST_TippTasten.r_trig_tippen.Q THEN
						st_ctrl_out.b_fertig := FALSE;
						IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
							wt_transport_beladen_achse_1700.st_ctrl.in.b_start := TRUE;
							wt_transport_warteposition_1700.st_ctrl.in.b_start := TRUE;
						ELSE
							wt_transport_beladen.st_ctrl.in.b_start := TRUE;
						END_IF
						wt_transport_abgabe.st_ctrl.in.b_start := TRUE;
						fb_state_entry.i16_next_step := 110;
					END_IF

				(* WT-Transport nicht aktiv  *)
				ELSE
					wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
					(* Warte auf Start von Visu oder Handbedienpult *)
					IF ST_TippTasten.r_trig_tippen.Q OR b_ibn_rundlauf_tipptaste THEN
						st_ctrl_out.b_fertig := FALSE;
						bm_einzelfertigung_nach_bandwechsel := FALSE;
						fb_state_entry.i16_next_step := 200;
					END_IF
				END_IF

			BESTUECKZELLE_1720:
				IF st_config.b_station_aktiv  OR st_config.b_station_in_simulation THEN
					(* WT-Transport aktiv oder in Simulation *)
					(* Warte auf Start von Visu oder Handbedienpult *)
					IF ST_TippTasten.r_trig_tippen.Q THEN
						st_ctrl_out.b_fertig := FALSE;
						wt_transport_abgabe.st_ctrl.in.b_start := TRUE;
						wt_transport_warteposition_1720.st_ctrl.in.b_start := TRUE;
						wt_transport_beladen_1720.st_ctrl.in.b_start := TRUE;
						fb_state_entry.i16_next_step := 110;
					END_IF
				ELSE
					(* WT-Transport nicht aktiv  *)
					wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
					wt_transport_warteposition_1720.st_ctrl.in.b_start := FALSE;
					(* Warte auf Start von Visu oder Handbedienpult *)
					IF ST_TippTasten.r_trig_tippen.Q OR b_ibn_rundlauf_tipptaste THEN
						st_ctrl_out.b_fertig := FALSE;
						fb_state_entry.i16_next_step := 200;
					END_IF
				END_IF

		END_CASE

(*=======================================================*)
	105: (* Wenn der Bediener nach einem Bandwechsel die niO Taste auf der Visu drückt, wird der WT als schlecht beschrieben *)
		IF fb_state_entry.E THEN
			(* WT  mit "nio" beschreiben *)
			ST_Markiere_WT_NIO();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
				wt_transport_beladen_achse_1700.st_ctrl.in.b_start := TRUE;
				wt_transport_warteposition_1700.st_ctrl.in.b_start := TRUE;
			ELSE
				wt_transport_beladen.st_ctrl.in.b_start := TRUE;
			END_IF
			wt_transport_abgabe.st_ctrl.in.b_start := TRUE;
			fb_state_entry.i16_next_step := 107;
		END_IF

(*=======================================================*)
	107: (* Anlage wird wieder in Einzelfertigung geschickt *)
		IF fb_state_entry.E THEN
			IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
				wt_transport_beladen_achse_1700.st_ctrl.in.b_start := FALSE;
				wt_transport_warteposition_1700.st_ctrl.in.b_start := FALSE;
			ELSE
				wt_transport_beladen.st_ctrl.in.b_start := FALSE;
			END_IF
			wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 120;

(*=======================================================*)
	110:	(* Produktion: Anlage läuft im Verbund *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700:
				IF 	visu.b_einzelfertigung OR visu_hinten.out.b_einzelfertigung OR gb_nach_bawe_einzelfertigung OR bandspruehoeler.st_ctrl.out.b_einzelfertigung THEN
					IF gb_nach_bawe_einzelfertigung THEN
						bm_einzelfertigung_nach_bandwechsel := TRUE;
					END_IF
					IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
						wt_transport_beladen_achse_1700.st_ctrl.in.b_start := FALSE;
						wt_transport_warteposition_1700.st_ctrl.in.b_start := FALSE;
					ELSE
						wt_transport_beladen.st_ctrl.in.b_start := FALSE;
					END_IF
					wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
					gb_nach_bawe_einzelfertigung := FALSE;
					fb_state_entry.i16_next_step := 120;
				ELSIF 	hublift_links.st_ctrl.out.b_fehler OR
						hublift_rechts.st_ctrl.out.b_fehler OR
						(wt_transport_beladen.st_ctrl.out.b_fehler AND NOT gst_datensatz.st_md.b_anwahl_transport_achse) OR
						(wt_transport_beladen_achse_1700.st_ctrl.out.b_fehler AND gst_datensatz.st_md.b_anwahl_transport_achse) OR
						wt_transport_warteposition_1700.st_ctrl.out.b_fehler OR
						wt_transport_abgabe.st_ctrl.out.b_fehler OR
						EtherCatDiag[1].st_ctrl_out.b_fehler OR
						EtherCatDiag[2].st_ctrl_out.b_fehler OR
						EtherCatDiag[3].st_ctrl_out.b_fehler OR
						EtherCatDiag[4].st_ctrl_out.b_fehler OR
						fb_ton_ueberstrom_foerderbaender.Q THEN
						IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
							wt_transport_beladen_achse_1700.st_ctrl.in.b_start := FALSE;
							wt_transport_warteposition_1700.st_ctrl.in.b_start := FALSE;
						ELSE
							wt_transport_beladen.st_ctrl.in.b_start := FALSE;
						END_IF
						wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
						gb_nach_bawe_einzelfertigung := FALSE;
						fb_state_entry.i16_next_step := 130;
				END_IF

			BESTUECKZELLE_1720:
				IF visu.b_einzelfertigung OR visu_hinten.out.b_einzelfertigung OR gb_nach_bawe_einzelfertigung OR ST_WkzAbsicherung.st_ctrl_out.b_einzelfertigung OR bandspruehoeler.st_ctrl.out.b_einzelfertigung  THEN
					wt_transport_warteposition_1720.st_ctrl.in.b_start := FALSE;
					wt_transport_beladen_1720.st_ctrl.in.b_start := FALSE;
					wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
					gb_nach_bawe_einzelfertigung := FALSE;
					fb_state_entry.i16_next_step := 120;
				ELSIF 	hublift_links.st_ctrl.out.b_fehler OR
						hublift_rechts.st_ctrl.out.b_fehler OR
						wt_transport_warteposition_1720.st_ctrl.out.b_fehler OR
						EtherCatDiag[1].st_ctrl_out.b_fehler OR
						EtherCatDiag[2].st_ctrl_out.b_fehler OR
						EtherCatDiag[3].st_ctrl_out.b_fehler OR
						EtherCatDiag[4].st_ctrl_out.b_fehler OR
						fb_ton_ueberstrom_foerderbaender.Q THEN
						wt_transport_warteposition_1720.st_ctrl.in.b_start := FALSE;
						wt_transport_beladen_1720.st_ctrl.in.b_start := FALSE;
						wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
						gb_nach_bawe_einzelfertigung := FALSE;
						fb_state_entry.i16_next_step := 130;
				END_IF

			RASTERFOLIE:
				IF visu.b_einzelfertigung OR visu_hinten.out.b_einzelfertigung THEN
					wt_transport_beladen.st_ctrl.in.b_start := FALSE;
					wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
					fb_state_entry.i16_next_step := 120;
				ELSIF 	hublift_links.st_ctrl.out.b_fehler OR
						hublift_rechts.st_ctrl.out.b_fehler OR
						wt_transport_abgabe.st_ctrl.out.b_fehler OR
						EtherCatDiag[1].st_ctrl_out.b_fehler OR
						EtherCatDiag[2].st_ctrl_out.b_fehler OR
						EtherCatDiag[3].st_ctrl_out.b_fehler OR
						EtherCatDiag[4].st_ctrl_out.b_fehler OR
						fb_ton_ueberstrom_foerderbaender.Q THEN
						wt_transport_beladen.st_ctrl.in.b_start := FALSE;
						wt_transport_abgabe.st_ctrl.in.b_start := FALSE;
						fb_state_entry.i16_next_step := 130;
				END_IF
		END_CASE

(*=======================================================*)
	120:	(* Produktion beenden, wenn WT fertig bestückt *)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700, RASTERFOLIE:
			(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
					IF wt_transport_beladen_achse_1700.st_ctrl.out.b_fertig THEN
						fb_state_entry.i16_next_step := BEREIT;
					END_IF
				ELSE
					IF wt_transport_beladen.st_ctrl.out.b_fertig THEN
						fb_state_entry.i16_next_step := BEREIT;
					END_IF
				END_IF

			BESTUECKZELLE_1720:
			(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF wt_transport_beladen_1720.st_ctrl.out.b_fertig THEN
					fb_state_entry.i16_next_step := BEREIT;
				END_IF
		END_CASE

(*=======================================================*)
	130:	(* Produktion beenden, wenn WT fertig bestückt, dann FEHLER*)
		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700, RASTERFOLIE:
			IF 	fb_ton_ueberstrom_foerderbaender.Q THEN
				sm_ueberstrom_foerderbaender := TRUE;
			END_IF
			(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
					IF 	wt_transport_beladen_achse_1700.st_ctrl.out.b_fertig OR
						wt_transport_beladen_achse_1700.st_ctrl.out.b_fehler THEN
						fb_state_entry.i16_next_step := FEHLER;
					END_IF
				ELSE
					IF 	wt_transport_beladen.st_ctrl.out.b_fertig OR
						wt_transport_beladen.st_ctrl.out.b_fehler THEN
						fb_state_entry.i16_next_step := FEHLER;
					END_IF
				END_IF

			BESTUECKZELLE_1720:
			IF 	fb_ton_ueberstrom_foerderbaender.Q THEN
				sm_ueberstrom_foerderbaender := TRUE;
			END_IF
			(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF wt_transport_beladen_1720.st_ctrl.out.b_fertig THEN
					fb_state_entry.i16_next_step := FEHLER;
				END_IF
		END_CASE

		IF fb_state_entry.E THEN
			fb_ton_ueberstrom_foerderbaender.IN := FALSE;
		END_IF
(*=======================================================*)
	200: (*Warten bis keine ander Produktions Meldung ansteht *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			fb_state_entry.i16_next_step := 201;
		END_IF

(*=======================================================*)
	201:  (*Produktions Meldung*)
		Visu.MeldungProduktion.Color_R := 255;
		Visu.MeldungProduktion.Color_G := 0;
		Visu.MeldungProduktion.Color_B := 0;
		IF visu.s_akt_sprache = 'de' THEN
			Visu.MeldungProduktion.Name:='WT Transport nicht aktiviert. Weiter mit OK';
		ELSIF visu.s_akt_sprache = 'en' THEN
			Visu.MeldungProduktion.Name:='carrier transport deactivated. Confirm with OK';
		ELSIF visu.s_akt_sprache = 'cz' THEN
			Visu.MeldungProduktion.Name:='Transport WT deaktivovan. Potvrdte pres OK';
		END_IF
		Visu.MeldungProduktion.ShowMessage := TRUE;
		Visu.MeldungProduktion.Button1.sichtbar:=TRUE;	(*OK*)
		Visu.MeldungProduktion.Button1.Text:='Ok';
		Visu.MeldungProduktion.Button2.sichtbar:=TRUE;	(*Abbrechen*)
		Visu.MeldungProduktion.Button2.Text:='Abbrechen';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		fb_state_entry.i16_next_step := 202;

(*=======================================================*)
	202:  (*Warte auf OK*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF Visu.MeldungProduktion.Button1.tasten THEN
			IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
				wt_transport_beladen_achse_1700.st_ctrl.in.b_start := TRUE;
			ELSE
				wt_transport_beladen.st_ctrl.in.b_start := TRUE;
			END_IF
			wt_transport_beladen_1720.st_ctrl.in.b_start := TRUE;
			fb_state_entry.i16_next_step:=210;
		ELSIF Visu.MeldungProduktion.Button2.tasten THEN
			fb_state_entry.i16_next_step:=100;
		END_IF

(*=======================================================*)
	210:	(* Produktion: Anlage läuft im Singelbetrieb *)

		CASE gst_datensatz.st_md.i16_typ_zelle OF
			KEINE_ZELLE:
				;

			BESTUECKZELLE_1700, RASTERFOLIE:
			(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF gst_datensatz.st_md.b_anwahl_transport_achse THEN
					IF wt_transport_beladen_achse_1700.st_ctrl.out.b_fertig THEN
						wt_transport_beladen_achse_1700.st_ctrl.in.b_start := FALSE;
						fb_state_entry.i16_next_step := BEREIT;
					END_IF
				ELSE
					IF wt_transport_beladen.st_ctrl.out.b_fertig THEN
						wt_transport_beladen.st_ctrl.in.b_start := FALSE;
						fb_state_entry.i16_next_step := BEREIT;
					END_IF
				END_IF

			BESTUECKZELLE_1720:
			(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF wt_transport_beladen_1720.st_ctrl.out.b_fertig THEN
					wt_transport_beladen_1720.st_ctrl.in.b_start := FALSE;
					fb_state_entry.i16_next_step := BEREIT;
				END_IF
		END_CASE

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			a_foerderband_wt_transport := FALSE;
			wt_transport_beladen.st_ctrl.in.b_stop := TRUE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_stop  := TRUE;
			wt_transport_warteposition_1700.st_ctrl.in.b_stop  := TRUE;
			wt_transport_abgabe.st_ctrl.in.b_stop := TRUE;
			wt_transport_warteposition_1720.st_ctrl.in.b_stop := TRUE;
			wt_transport_beladen_1720.st_ctrl.in.b_stop := TRUE;
			wt_transport_beladen.st_ctrl.in.b_quitt := FALSE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_quitt  := FALSE;
			wt_transport_warteposition_1700.st_ctrl.in.b_quitt  := FALSE;
			wt_transport_abgabe.st_ctrl.in.b_quitt := FALSE;
			wt_transport_warteposition_1720.st_ctrl.in.b_quitt := FALSE;
			wt_transport_beladen_1720.st_ctrl.in.b_quitt := FALSE;

			EtherCatDiag[1].st_ctrl_in.b_quitt := FALSE;
			EtherCatDiag[2].st_ctrl_in.b_quitt := FALSE;
			EtherCatDiag[3].st_ctrl_in.b_quitt := FALSE;
			EtherCatDiag[4].st_ctrl_in.b_quitt := FALSE;

			fb_ton_ueberstrom_foerderbaender.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			wt_transport_beladen.st_ctrl.in.b_quitt := TRUE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_quitt  := TRUE;
			wt_transport_warteposition_1700.st_ctrl.in.b_quitt  := TRUE;
			wt_transport_abgabe.st_ctrl.in.b_quitt := TRUE;
			wt_transport_warteposition_1720.st_ctrl.in.b_quitt := TRUE;
			wt_transport_beladen_1720.st_ctrl.in.b_quitt := TRUE;
			wt_transport_beladen.st_ctrl.in.b_stop := FALSE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_stop  := FALSE;
			wt_transport_warteposition_1700.st_ctrl.in.b_stop  := FALSE;
			wt_transport_abgabe.st_ctrl.in.b_stop := FALSE;
			wt_transport_warteposition_1720.st_ctrl.in.b_stop := FALSE;
			wt_transport_beladen_1720.st_ctrl.in.b_stop := FALSE;

			EtherCatDiag[1].st_ctrl_in.b_quitt := TRUE;
			EtherCatDiag[2].st_ctrl_in.b_quitt := TRUE;
			EtherCatDiag[3].st_ctrl_in.b_quitt := TRUE;
			EtherCatDiag[4].st_ctrl_in.b_quitt := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			a_foerderband_wt_transport := FALSE;
			wt_transport_beladen.st_ctrl.in.b_stop := TRUE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_stop  := TRUE;
			wt_transport_warteposition_1700.st_ctrl.in.b_stop  := TRUE;
			wt_transport_abgabe.st_ctrl.in.b_stop := TRUE;
			wt_transport_warteposition_1720.st_ctrl.in.b_stop := TRUE;
			wt_transport_beladen_1720.st_ctrl.in.b_stop := TRUE;
			wt_transport_beladen.st_ctrl.in.b_quitt := FALSE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_quitt  := FALSE;
			wt_transport_warteposition_1700.st_ctrl.in.b_quitt  := FALSE;
			wt_transport_abgabe.st_ctrl.in.b_quitt := FALSE;
			wt_transport_warteposition_1720.st_ctrl.in.b_quitt := FALSE;
			wt_transport_beladen_1720.st_ctrl.in.b_quitt := FALSE;

			EtherCatDiag[1].st_ctrl_in.b_quitt := FALSE;
			EtherCatDiag[2].st_ctrl_in.b_quitt := FALSE;
			EtherCatDiag[3].st_ctrl_in.b_quitt := FALSE;
			EtherCatDiag[4].st_ctrl_in.b_quitt := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			wt_transport_beladen.st_ctrl.in.b_stop := FALSE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_stop  := FALSE;
			wt_transport_warteposition_1700.st_ctrl.in.b_stop  := FALSE;
			wt_transport_abgabe.st_ctrl.in.b_stop := FALSE;
			wt_transport_warteposition_1720.st_ctrl.in.b_stop := FALSE;
			wt_transport_beladen_1720.st_ctrl.in.b_stop := FALSE;
			wt_transport_beladen.st_ctrl.in.b_quitt := TRUE;
			wt_transport_beladen_achse_1700.st_ctrl.in.b_quitt  := TRUE;
			wt_transport_warteposition_1700.st_ctrl.in.b_quitt  := TRUE;
			wt_transport_abgabe.st_ctrl.in.b_quitt := TRUE;
			wt_transport_warteposition_1720.st_ctrl.in.b_quitt := TRUE;
			wt_transport_beladen_1720.st_ctrl.in.b_quitt := TRUE;

			EtherCatDiag[1].st_ctrl_in.b_quitt := TRUE;
			EtherCatDiag[2].st_ctrl_in.b_quitt := TRUE;
			EtherCatDiag[3].st_ctrl_in.b_quitt := TRUE;
			EtherCatDiag[4].st_ctrl_in.b_quitt := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_stau_auf_ruecktransport;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] :=FALSE ;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_ueberstrom_foerderbaender;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_einzelfertigung_nach_bandwechsel;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/XML Server' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_2OrdnerMitDateiErstellen
VAR_INPUT
	bExecute					: BOOL;
	bQuit						: BOOL;
	s_path						: STRING;
	s_dateiname					: STRING;
	s_datei_erweiterung			: STRING;
	s_x_path_name				: STRING;
	s_symname					: STRING;
END_VAR
VAR_IN_OUT
END_VAR
VAR_OUTPUT
	bBusy						: BOOL;
	bError						: BOOL;
	nErrId						: UDINT;

END_VAR
VAR
	fb_enum_find_file_list			: FB_EnumFindFileList;
	fb_enum_find_file_entry			: FB_EnumFindFileEntry;
	fb_create_directory			: FB_CreateDir;	(* mit diesem FB kan nur eine Ordnerverzeichnissstruktur angelegt werden, jedoch keine Dateien erzeugt werden *)
	fb_file_open					: FB_FileOpen;	(* Eine vorhandene Datei öffnen oder eine Neue erzeugen *)
	fb_file_close					: FB_FileClose;
	fb_file_write					: FB_FileWrite;
	h_filehandle					: UINT := 0;(* file handle of the file *)
	arr_file_list					: ARRAY[0..63] OF ST_FindFileEntry;
	fb_ton_quitt					: TON;
	fb_r_trig_execute				: R_TRIG;
	fb_state_entry					: ST_StateEntry;
	temp_string					: STRING[255];
	i16_file_entry_zaehler			: INT := 0;
	i16_file_nr					: INT := 0;
	i							: INT := 0;
	b_pfad_vorhanden			: BOOL;
	b_datei_vorhanden			: BOOL;
	arr_rootpath					: ARRAY[0..2] OF STRING;
END_VAR
(* @END_DECLARATION := '0' *)
fb_r_trig_execute(CLK:= bExecute, Q=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:(* INIT *)
		bBusy := FALSE;
		bError := FALSE;
		nErrId := 0;
		fb_create_directory.bExecute := FALSE;
		fb_enum_find_file_list.bExecute := FALSE;
		fb_enum_find_file_entry.bExecute := FALSE;
		fb_file_open.bExecute := FALSE;
		fb_file_close.bExecute := FALSE;
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte auf Execute-Befehl *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
		END_IF

		IF fb_r_trig_execute.Q THEN
			bBusy := TRUE;
			b_pfad_vorhanden := FALSE;
			b_datei_vorhanden := FALSE;
			arr_rootpath[0] := MID(s_path, 1,3);
			arr_rootpath[1] := MID(s_path, 4,3);
			arr_rootpath[2] := MID(s_path, 10,3);
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Prüfe, ob gewünschter Pfad auf dem Maschinen-PC vorhanden ist *)
		IF fb_state_entry.E THEN
			fb_enum_find_file_list.sPathName := s_path;
			fb_enum_find_file_list.eCmd := eEnumCmd_First;
			fb_enum_find_file_list.bExecute := TRUE;
		END_IF

		IF fb_enum_find_file_list.bBusy THEN
			fb_enum_find_file_list.bExecute := FALSE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Auswerten des Ordner-Suchergebnis *)
		IF NOT fb_enum_find_file_list.bBusy THEN
			fb_enum_find_file_list.bExecute := FALSE;
		 	IF fb_enum_find_file_list.bError OR fb_enum_find_file_list.bEOE THEN
				 IF fb_enum_find_file_list.nFindFiles=0 THEN
					b_pfad_vorhanden := FALSE;
					fb_state_entry.i16_next_step := 40;	(* Pfad nicht vorhanden -> wird angelegt *)
				ELSE
					b_pfad_vorhanden := TRUE;
					fb_state_entry.i16_next_step := 60;	(* O.K. Pfad vorhanden -> Datei prüfen *)
				END_IF
			END_IF
		END_IF

(*=======================================================*)
	40:	(* Erstellen des ersten Ordnerverzeichnisses auf dem Laufwerk des Maschinen-PCs *)
		IF fb_state_entry.E THEN
			fb_create_directory.sPathName := s_path;
			fb_create_directory.bExecute := TRUE;
		END_IF

		IF fb_create_directory.bBusy THEN
			fb_create_directory.bExecute := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:	(* Ordner wurde erstellt *)
		IF NOT fb_create_directory.bBusy  THEN
			IF NOT fb_create_directory.bError THEN
				fb_state_entry.i16_next_step := 60;	(* Ordnerverzeichnis wurde erfolgreich erstellt -> eine neue Datei anlegen oder eine Vorhandene öffnen *)
			ELSE
				fb_state_entry.i16_next_step := 1000;	(* Fehler *)
			END_IF
		END_IF

(*=======================================================*)
	60:	(* Prüfe, ob die gewünschte Datei in diesem Ordnerverzeichnis vorhanden ist *)
		IF fb_state_entry.E THEN
			temp_string := '';
			temp_string := CONCAT(temp_string, s_path);
			temp_string := CONCAT(temp_string, '\');
			temp_string := CONCAT(temp_string, s_dateiname);
			temp_string := CONCAT(temp_string, s_datei_erweiterung);
			fb_enum_find_file_entry.sPathName := temp_string;
			fb_enum_find_file_entry.eCmd := eEnumCmd_First;
			fb_enum_find_file_entry.bExecute := TRUE;
		END_IF

		IF fb_enum_find_file_entry.bBusy THEN
			fb_enum_find_file_entry.bExecute := FALSE;
			fb_state_entry.i16_next_step := 70;
		END_IF

(*=======================================================*)
	70:	(* Auswerten des Datei-Suchergebnis *)
		IF NOT fb_enum_find_file_entry.bBusy THEN
			fb_enum_find_file_entry.bExecute := FALSE;
		 	IF NOT fb_enum_find_file_entry.bError THEN
				IF fb_enum_find_file_entry.bEOE THEN
					IF fb_enum_find_file_entry.stFindFile.sFileName = CONCAT(s_dateiname, s_datei_erweiterung) THEN
					(* Datei bereits vorhanden *)
						b_datei_vorhanden := TRUE;
						fb_state_entry.i16_next_step := 0;
					ELSE
					(* Ende der Fileliste wurde erreicht und die gesuchte Datei ist  nicht vorhanden -> muss später angelegt werden *)
						b_datei_vorhanden := FALSE;
						fb_state_entry.i16_next_step := 100;
					END_IF
				ELSE
				(* Dateisuche im FB mit Abort korrekt beenden *)
					IF fb_enum_find_file_entry.stFindFile.sFileName = CONCAT(s_dateiname, s_datei_erweiterung) THEN
					(* Die gesuchte Datei wurde in der Fileliste gefunden *)
						b_datei_vorhanden := TRUE;
						fb_state_entry.i16_next_step := 80;
					ELSE
					(* Datei ist  nicht vorhanden -> muss später angelegt werden *)
						b_datei_vorhanden := FALSE;
						fb_state_entry.i16_next_step := 80;
					END_IF
				END_IF
			ELSE
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	80:	(* Dateisuchen wird beendet *)
		IF fb_state_entry.E THEN
			fb_enum_find_file_entry.eCmd := eEnumCmd_Abort;
			fb_enum_find_file_entry.bExecute := TRUE;
		END_IF

		IF fb_enum_find_file_entry.bBusy THEN
			fb_enum_find_file_entry.bExecute := FALSE;
			fb_state_entry.i16_next_step := 90;
		END_IF

(*=======================================================*)
	90:	(* Filehandle wieder frei *)
		IF NOT fb_enum_find_file_entry.bBusy THEN
			fb_enum_find_file_entry.bExecute := FALSE;
		 	IF NOT fb_enum_find_file_entry.bError AND fb_enum_find_file_entry.bEOE THEN
				fb_state_entry.i16_next_step := 100;
			ELSE
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	100:	(* Abfrage auf Datei anlegen *)
		IF fb_state_entry.E THEN
			IF NOT b_datei_vorhanden THEN
				fb_state_entry.i16_next_step := 110;
			ELSE
				fb_state_entry.i16_next_step := 0;	(* Fertig *)
			END_IF
		END_IF

(*=======================================================*)
	110:	(* Erzeugen einer neuen Datei *)
		IF fb_state_entry.E THEN
			temp_string := '';
			temp_string := CONCAT(temp_string, s_path);
			temp_string := CONCAT(temp_string, '\');
			temp_string := CONCAT(temp_string, s_dateiname);
			temp_string := CONCAT(temp_string, s_datei_erweiterung);
			fb_file_open.sPathName := temp_string;
			fb_file_open.nMode := FOPEN_MODEWRITE OR FOPEN_MODEBINARY;
			fb_file_open.bExecute := TRUE;
		END_IF

		IF fb_file_open.bBusy THEN
			fb_file_open.bExecute := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120:	(* Warte bis Datei geöffnet wurde *)
		IF NOT fb_file_open.bBusy  THEN
			IF NOT fb_file_open.bError THEN
				h_filehandle := fb_file_open.hFile;
				fb_state_entry.i16_next_step := 130;
			ELSE	(* Fehler *)
				nErrId := fb_file_open.nErrId;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	130:	(* Schreibe die Dateistruktur im XML-Format: z.B.*)
		(*
		<Maschine1700_Datensicherung>
		<gst_datensatz>
		</gst_datensatz>
		</Maschine1700_Datensicherung>
		*)
		IF fb_state_entry.E THEN
			temp_string := '';
			temp_string := CONCAT(temp_string, '<');
			temp_string := CONCAT(temp_string, s_x_path_name);
			temp_string := CONCAT(temp_string, '>');
			temp_string := CONCAT(temp_string, '$r$n');

			(* Die Variable "s_xml_variablenname" wird hier schon mit angelegt, *)
			(* damit später beim "WECHSELN>" daraus gelesen werden kann, obwohl noch nichts drin steht *)
			temp_string := CONCAT(temp_string, '<');
			temp_string := CONCAT(temp_string, s_symname);
			temp_string := CONCAT(temp_string, '>');
			temp_string := CONCAT(temp_string, '$r$n');
			temp_string := CONCAT(temp_string, '<');
			temp_string := CONCAT(temp_string, '/');
			temp_string := CONCAT(temp_string, s_symname);
			temp_string := CONCAT(temp_string, '>');
			temp_string := CONCAT(temp_string, '$r$n');

			temp_string := CONCAT(temp_string, '<');
			temp_string := CONCAT(temp_string, '/');
			temp_string := CONCAT(temp_string, s_x_path_name);
			temp_string := CONCAT(temp_string, '>');
			fb_file_write.hFile := h_filehandle;
 			fb_file_write.bExecute := TRUE;
		END_IF

		IF fb_file_write.bBusy THEN
			fb_file_write.bExecute := FALSE;
			fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	140:	(* Warte bis Datei geschrieben wurde *)
		IF NOT fb_file_write.bBusy  THEN
			IF NOT fb_file_write.bError THEN
				fb_state_entry.i16_next_step := 150;
			ELSE	(* Fehler *)
				nErrId := fb_file_write.nErrId;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	150:	(* Schliesse Datei wieder, damit ein erneuter Zugriff möglich ist *)
		IF fb_state_entry.E THEN
			fb_file_close.hFile := h_filehandle;
			fb_file_close.bExecute := TRUE;
		END_IF

		IF fb_file_close.bBusy THEN
			fb_file_close.bExecute := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160:	(* Warte bis geschlossen *)
		IF NOT fb_file_close.bBusy  THEN
			IF NOT fb_file_close.bError THEN
				h_filehandle := 0;
				fb_state_entry.i16_next_step :=0;
			ELSE	(* Fehler *)
				nErrId := fb_file_close.nErrId;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
			bError := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bQuit AND NOT fb_state_entry.E THEN
			bError := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

fb_enum_find_file_list(
	sNetId:= '',
	sPathName:= ,
	eCmd:= ,
	pFindList:= ADR(arr_file_list),
	cbFindList:= SIZEOF(arr_file_list),
	bExecute:= ,
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> ,
	bError=> ,
	nErrID=> , 
	bEOE=> ,
	nFindFiles=> );

fb_enum_find_file_entry(
	sNetId:= '',
	sPathName:= , 
	eCmd:= , 
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> ,
	nErrID=> , 
	bEOE=> , 
	stFindFile=> );

fb_create_directory(
	sNetId:= '',
	sPathName:= ,
	ePath:= PATH_GENERIC,
	bExecute:= ,
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> ,
	nErrId=> );

fb_file_open(
	sNetId:= '',
	sPathName:= , 
	nMode:= ,
	ePath:= PATH_GENERIC,
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> , 
	nErrId=> , 
	hFile=> );

fb_file_close(
	sNetId:= '',
	hFile:= , 
	bExecute:= , 
	tTimeout:= t#10s,
	bBusy=> ,
	bError=> ,
	nErrId=> );

fb_file_write(
	sNetId:= '',
	hFile:= , 
	pWriteBuff:= ADR(temp_string),
	cbWriteLen:= LEN(temp_string),
	bExecute:= , 
	tTimeout:= t#10s,
	bBusy=> ,
	bError=> , 
	nErrId=> , 
	cbWrite=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/XML Server' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_Datei_erstellen
VAR_INPUT
	bExecute					: BOOL;
	bQuit						: BOOL;
	s_path						: STRING;
	s_dateiname					: STRING;
	s_datei_erweiterung			: STRING;
	s_x_path_name				: STRING;
	s_symname					: STRING;
END_VAR
VAR_IN_OUT
END_VAR
VAR_OUTPUT
	bBusy						: BOOL;
	bError						: BOOL;
	nErrId						: UDINT;
END_VAR
VAR
	fb_enum_find_file_list			: FB_EnumFindFileList;
	fb_enum_find_file_entry			: FB_EnumFindFileEntry;
	fb_create_directory			: FB_CreateDir;	(* mit diesem FB kan nur eine Ordnerverzeichnissstruktur angelegt werden, jedoch keine Dateien erzeugt werden *)
	fb_file_open					: FB_FileOpen;	(* Eine vorhandene Datei öffnen oder eine Neue erzeugen *)
	fb_file_close					: FB_FileClose;
	fb_file_write					: FB_FileWrite;
	h_filehandle					: UINT := 0;(* file handle of the file *)
	arr_file_list					: ARRAY[0..63] OF ST_FindFileEntry;
	fb_ton_quitt					: TON;
	fb_r_trig_execute				: R_TRIG;
	fb_state_entry					: ST_StateEntry;
	temp_string					: STRING[255];
	i16_file_entry_zaehler			: INT := 0;
	i16_file_nr					: INT := 0;
	i							: INT := 0;
	b_pfad_vorhanden			: BOOL;
	b_datei_vorhanden			: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
fb_r_trig_execute(CLK:= bExecute, Q=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:(* INIT *)
		bBusy := FALSE;
		bError := FALSE;
		nErrId := 0;
		fb_create_directory.bExecute := FALSE;
		fb_enum_find_file_list.bExecute := FALSE;
		fb_enum_find_file_entry.bExecute := FALSE;
		fb_file_open.bExecute := FALSE;
		fb_file_close.bExecute := FALSE;
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte auf Execute-Befehl *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
		END_IF

		IF fb_r_trig_execute.Q THEN
			bBusy := TRUE;
			b_pfad_vorhanden := FALSE;
			b_datei_vorhanden := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Prüfe, ob gewünschter Pfad auf dem Maschinen-PC vorhanden ist *)
		IF fb_state_entry.E THEN
			fb_enum_find_file_list.sPathName := s_path;
			fb_enum_find_file_list.eCmd := eEnumCmd_First;
			fb_enum_find_file_list.bExecute := TRUE;
		END_IF

		IF fb_enum_find_file_list.bBusy THEN
			fb_enum_find_file_list.bExecute := FALSE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Auswerten des Ordner-Suchergebnis *)
		IF NOT fb_enum_find_file_list.bBusy THEN
			fb_enum_find_file_list.bExecute := FALSE;
		 	IF fb_enum_find_file_list.bError OR fb_enum_find_file_list.bEOE THEN
				 IF fb_enum_find_file_list.nFindFiles=0 THEN
					b_pfad_vorhanden := FALSE;
					fb_state_entry.i16_next_step := 40;	(* Pfad nicht vorhanden -> wird angelegt *)
				ELSE
					b_pfad_vorhanden := TRUE;
					fb_state_entry.i16_next_step := 60;	(* O.K. Pfad vorhanden -> Datei prüfen *)
				END_IF
			END_IF
		END_IF

(*=======================================================*)
	40:	(* Erstellen eines Ordnerverzeichnisses auf dem Laufwerk des Maschinen-PCs *)
		IF fb_state_entry.E THEN
			fb_create_directory.sPathName := s_path;
			fb_create_directory.bExecute := TRUE;
		END_IF

		IF fb_create_directory.bBusy THEN
			fb_create_directory.bExecute := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:	(* Ordner wurde erstellt *)
		IF NOT fb_create_directory.bBusy  THEN
			IF NOT fb_create_directory.bError THEN
				fb_state_entry.i16_next_step := 60;	(* Ordnerverzeichnis wurde erfolgreich erstellt -> eine neue Datei anlegen oder eine Vorhandene öffnen *)
			ELSE
				fb_state_entry.i16_next_step := 1000;	(* Fehler *)
			END_IF
		END_IF

(*=======================================================*)
	60:	(* Prüfe, ob die gewünschte Datei in diesem Ordnerverzeichnis vorhanden ist *)
		IF fb_state_entry.E THEN
			temp_string := '';
			temp_string := CONCAT(temp_string, s_path);
			temp_string := CONCAT(temp_string, '\');
			temp_string := CONCAT(temp_string, s_dateiname);
			temp_string := CONCAT(temp_string, s_datei_erweiterung);
			fb_enum_find_file_entry.sPathName := temp_string;
			fb_enum_find_file_entry.eCmd := eEnumCmd_First;
			fb_enum_find_file_entry.bExecute := TRUE;
		END_IF

		IF fb_enum_find_file_entry.bBusy THEN
			fb_enum_find_file_entry.bExecute := FALSE;
			fb_state_entry.i16_next_step := 70;
		END_IF

(*=======================================================*)
	70:	(* Auswerten des Datei-Suchergebnis *)
		IF NOT fb_enum_find_file_entry.bBusy THEN
			fb_enum_find_file_entry.bExecute := FALSE;
		 	IF NOT fb_enum_find_file_entry.bError THEN
				IF fb_enum_find_file_entry.bEOE THEN
					IF fb_enum_find_file_entry.stFindFile.sFileName = CONCAT(s_dateiname, s_datei_erweiterung) THEN
					(* Datei bereits vorhanden *)
						b_datei_vorhanden := TRUE;
						fb_state_entry.i16_next_step := 0;
					ELSE
					(* Ende der Fileliste wurde erreicht und die gesuchte Datei ist  nicht vorhanden -> muss später angelegt werden *)
						b_datei_vorhanden := FALSE;
						fb_state_entry.i16_next_step := 100;
					END_IF
				ELSE
				(* Dateisuche im FB mit Abort korrekt beenden *)
					IF fb_enum_find_file_entry.stFindFile.sFileName = CONCAT(s_dateiname, s_datei_erweiterung) THEN
					(* Die gesuchte Datei wurde in der Fileliste gefunden *)
						b_datei_vorhanden := TRUE;
						fb_state_entry.i16_next_step := 80;
					ELSE
					(* Datei ist  nicht vorhanden -> muss später angelegt werden *)
						b_datei_vorhanden := FALSE;
						fb_state_entry.i16_next_step := 80;
					END_IF
				END_IF
			ELSE
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	80:	(* Dateisuchen wird beendet *)
		IF fb_state_entry.E THEN
			fb_enum_find_file_entry.eCmd := eEnumCmd_Abort;
			fb_enum_find_file_entry.bExecute := TRUE;
		END_IF

		IF fb_enum_find_file_entry.bBusy THEN
			fb_enum_find_file_entry.bExecute := FALSE;
			fb_state_entry.i16_next_step := 90;
		END_IF

(*=======================================================*)
	90:	(* Filehandle wieder frei *)
		IF NOT fb_enum_find_file_entry.bBusy THEN
			fb_enum_find_file_entry.bExecute := FALSE;
		 	IF NOT fb_enum_find_file_entry.bError AND fb_enum_find_file_entry.bEOE THEN
				fb_state_entry.i16_next_step := 100;
			ELSE
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	100:	(* Abfrage auf Datei anlegen *)
		IF fb_state_entry.E THEN
			IF NOT b_datei_vorhanden THEN
				fb_state_entry.i16_next_step := 110;
			ELSE
				fb_state_entry.i16_next_step := 0;	(* Fertig *)
			END_IF
		END_IF

(*=======================================================*)
	110:	(* Erzeugen einer neuen Datei *)
		IF fb_state_entry.E THEN
			temp_string := '';
			temp_string := CONCAT(temp_string, s_path);
			temp_string := CONCAT(temp_string, '\');
			temp_string := CONCAT(temp_string, s_dateiname);
			temp_string := CONCAT(temp_string, s_datei_erweiterung);
			fb_file_open.sPathName := temp_string;
			fb_file_open.nMode := FOPEN_MODEWRITE OR FOPEN_MODEBINARY;
			fb_file_open.bExecute := TRUE;
		END_IF

		IF fb_file_open.bBusy THEN
			fb_file_open.bExecute := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120:	(* Warte bis Datei geöffnet wurde *)
		IF NOT fb_file_open.bBusy  THEN
			IF NOT fb_file_open.bError THEN
				h_filehandle := fb_file_open.hFile;
				fb_state_entry.i16_next_step := 130;
			ELSE	(* Fehler *)
				nErrId := fb_file_open.nErrId;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	130:	(* Schreibe die Dateistruktur im XML-Format: z.B.*)
		(*
		<Maschine1700_Datensicherung>
		<gst_datensatz>
		</gst_datensatz>
		</Maschine1700_Datensicherung>
		*)
		IF fb_state_entry.E THEN
			temp_string := '';
			temp_string := CONCAT(temp_string, '<');
			temp_string := CONCAT(temp_string, s_x_path_name);
			temp_string := CONCAT(temp_string, '>');
			temp_string := CONCAT(temp_string, '$r$n');

			(* Die Variable "s_xml_variablenname" wird hier schon mit angelegt, *)
			(* damit später beim "WECHSELN>" daraus gelesen werden kann, obwohl noch nichts drin steht *)
			temp_string := CONCAT(temp_string, '<');
			temp_string := CONCAT(temp_string, s_symname);
			temp_string := CONCAT(temp_string, '>');
			temp_string := CONCAT(temp_string, '$r$n');
			temp_string := CONCAT(temp_string, '<');
			temp_string := CONCAT(temp_string, '/');
			temp_string := CONCAT(temp_string, s_symname);
			temp_string := CONCAT(temp_string, '>');
			temp_string := CONCAT(temp_string, '$r$n');

			temp_string := CONCAT(temp_string, '<');
			temp_string := CONCAT(temp_string, '/');
			temp_string := CONCAT(temp_string, s_x_path_name);
			temp_string := CONCAT(temp_string, '>');
			fb_file_write.hFile := h_filehandle;
 			fb_file_write.bExecute := TRUE;
		END_IF

		IF fb_file_write.bBusy THEN
			fb_file_write.bExecute := FALSE;
			fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	140:	(* Warte bis Datei geschrieben wurde *)
		IF NOT fb_file_write.bBusy  THEN
			IF NOT fb_file_write.bError THEN
				fb_state_entry.i16_next_step := 150;
			ELSE	(* Fehler *)
				nErrId := fb_file_write.nErrId;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	150:	(* Schliesse Datei wieder, damit ein erneuter Zugriff möglich ist *)
		IF fb_state_entry.E THEN
			fb_file_close.hFile := h_filehandle;
			fb_file_close.bExecute := TRUE;
		END_IF

		IF fb_file_close.bBusy THEN
			fb_file_close.bExecute := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160:	(* Warte bis geschlossen *)
		IF NOT fb_file_close.bBusy  THEN
			IF NOT fb_file_close.bError THEN
				h_filehandle := 0;
				fb_state_entry.i16_next_step :=0;
			ELSE	(* Fehler *)
				nErrId := fb_file_close.nErrId;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
			bError := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bQuit AND NOT fb_state_entry.E THEN
			bError := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

fb_enum_find_file_list(
	sNetId:= '',
	sPathName:= ,
	eCmd:= ,
	pFindList:= ADR(arr_file_list),
	cbFindList:= SIZEOF(arr_file_list),
	bExecute:= ,
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> ,
	bError=> ,
	nErrID=> , 
	bEOE=> ,
	nFindFiles=> );

fb_enum_find_file_entry(
	sNetId:= '',
	sPathName:= , 
	eCmd:= , 
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> ,
	nErrID=> , 
	bEOE=> , 
	stFindFile=> );

fb_create_directory(
	sNetId:= '',
	sPathName:= ,
	ePath:= PATH_GENERIC,
	bExecute:= ,
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> ,
	nErrId=> );

fb_file_open(
	sNetId:= '',
	sPathName:= , 
	nMode:= ,
	ePath:= PATH_GENERIC,
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> , 
	nErrId=> , 
	hFile=> );

fb_file_close(
	sNetId:= '',
	hFile:= , 
	bExecute:= , 
	tTimeout:= t#10s,
	bBusy=> ,
	bError=> ,
	nErrId=> );

fb_file_write(
	sNetId:= '',
	hFile:= , 
	pWriteBuff:= ADR(temp_string),
	cbWriteLen:= LEN(temp_string),
	bExecute:= , 
	tTimeout:= t#10s,
	bBusy=> ,
	bError=> , 
	nErrId=> , 
	cbWrite=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/XML Server' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_XMLFileCopy
VAR_INPUT
	srcNetId				: T_AmsNetId;	(* TwinCAT network address of the source file *)
	destNetId			: T_AmsNetId;	(* TwinCAT network address of the destination file *)
	bExecute			: BOOL;
	bQuit				: BOOL;
	s_name_quelldatei	: STRING;
	s_name_zieldatei		: STRING;
END_VAR
VAR_OUTPUT
	bBusy				: BOOL;
	bError				: BOOL;
	nErrId				: UDINT;
END_VAR
VAR
	fb_file_open			: FB_FileOpen;
	fb_file_close			: FB_FileClose;
	fb_file_read			: FB_FileRead;
	fb_file_write			: FB_FileWrite;

	h_quell_filehandle		: UINT := 0;(* file handle of the source file *)
	h_ziel_filehandle		: UINT := 0;(* file handle of the destination file *)

	fb_state_entry			: ST_StateEntry;
	fb_r_trig_execute		: R_TRIG;
	fb_ton_quitt			: TON;
	p_read_write_buffer	: ARRAY[1..100000] OF BYTE;
	cb_write_length		: UDINT :=0;
	cb_read_length		: UDINT :=0;
END_VAR
(* @END_DECLARATION := '0' *)
fb_r_trig_execute(CLK:= bExecute, Q=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	0:(* INIT *)
		bBusy := FALSE;
		bError := FALSE;
		nErrId := 0;
		fb_file_open.bExecute := FALSE;
		fb_file_close.bExecute := FALSE;
		fb_file_read.bExecute := FALSE;
		fb_file_write.bExecute := FALSE;
		h_quell_filehandle := 0;
		h_ziel_filehandle := 0;
		cb_write_length :=0;
		cb_read_length :=0;
		fb_state_entry.i16_next_step := 10;

(*=======================================================*)
	10:	(* Warte auf Execute-Befehl *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
		END_IF

		IF fb_r_trig_execute.Q THEN
			bBusy := TRUE;
			fb_state_entry.i16_next_step := 100;
		END_IF

(*=======================================================*)
	100:	(* Öffne Quelldatei *)
		IF fb_state_entry.E THEN
			fb_file_open.nMode := FOPEN_MODEREAD OR FOPEN_MODEBINARY;
			fb_file_open.sPathName := s_name_quelldatei;
			fb_file_open.bExecute := TRUE;
		END_IF

		IF fb_file_open.bBusy THEN
			fb_file_open.bExecute := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110:	(* Warte bis Quelle geöffnet *)
		IF NOT fb_file_open.bBusy  THEN
			IF NOT fb_file_open.bError THEN
				h_quell_filehandle := fb_file_open.hFile;
				fb_state_entry.i16_next_step := 120;
			ELSE	(* Fehler *)
				nErrId := fb_file_open.nErrId;
				fb_state_entry.i16_next_step := 300;
			END_IF
		END_IF

(*=======================================================*)
	120:	(* Öffne Zieldatei *)
		IF fb_state_entry.E THEN
			fb_file_open.nMode := FOPEN_MODEWRITE OR FOPEN_MODEBINARY;
			fb_file_open.sPathName := s_name_zieldatei;
			fb_file_open.bExecute := TRUE;
		END_IF

		IF fb_file_open.bBusy THEN
			fb_file_open.bExecute := FALSE;
			fb_state_entry.i16_next_step := 130;
		END_IF

(*=======================================================*)
	130:	(* Warte bis Ziel geöffnet *)
		IF NOT fb_file_open.bBusy  THEN
			IF NOT fb_file_open.bError THEN
				h_ziel_filehandle := fb_file_open.hFile;
				fb_state_entry.i16_next_step := 150;
			ELSE	(* Fehler *)
				nErrId := fb_file_open.nErrId;
				fb_state_entry.i16_next_step := 300;
			END_IF
		END_IF

(*=======================================================*)
	150:	(* Lese Daten von der Quelldatei *)
		IF fb_state_entry.E THEN
			fb_file_read.hFile := h_quell_filehandle;
			fb_file_read.bExecute := TRUE;
		END_IF

		IF fb_file_read.bBusy THEN
			fb_file_read.bExecute := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160:	(* Warte bis gelesen *)
		IF NOT fb_file_read.bBusy  THEN
			IF NOT fb_file_read.bError THEN
				cb_read_length := fb_file_read.cbRead;
				fb_state_entry.i16_next_step := 170;
			ELSE	(* Fehler *)
				nErrId := fb_file_read.nErrId;
				fb_state_entry.i16_next_step := 300;
			END_IF
		END_IF

(*=======================================================*)
	170:	(* Schreibe Daten in die Zieldatei *)
		IF fb_state_entry.E THEN
			fb_file_write.hFile := h_ziel_filehandle;
			cb_write_length := cb_read_length;
			fb_file_write.bExecute := TRUE;
		END_IF

		IF fb_file_write.bBusy THEN
			fb_file_write.bExecute := FALSE;
			fb_state_entry.i16_next_step := 180;
		END_IF

(*=======================================================*)
	180:	(* Warte bis geschrieben *)
		IF NOT fb_file_write.bBusy  THEN
			IF NOT fb_file_write.bError THEN
				IF fb_file_read.bEOF THEN (* Prüfe, ob das EOF-Flag gesetzt ist *)
					fb_state_entry.i16_next_step := 200; (* Quell- und Zieldatei schliessen *)
				ELSE
					fb_state_entry.i16_next_step := 150; (* Weitere Daten lesen *)
				END_IF
			ELSE	(* Fehler *)
				nErrId := fb_file_write.nErrId;
				fb_state_entry.i16_next_step := 300;
			END_IF
		END_IF

(*=======================================================*)
	200:	(* Schliessen der Zieldatei *)
		IF fb_state_entry.E THEN
			fb_file_close.hFile := h_ziel_filehandle;
			fb_file_close.bExecute := TRUE;
		END_IF

		IF fb_file_close.bBusy THEN
			fb_file_close.bExecute := FALSE;
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* Warte bis Ziel geschlossen *)
		IF NOT fb_file_close.bBusy  THEN
			IF NOT fb_file_close.bError THEN
				h_ziel_filehandle := 0;
				fb_state_entry.i16_next_step := 220;
			ELSE	(* Fehler *)
				nErrId := fb_file_close.nErrId;
				fb_state_entry.i16_next_step := 300;
			END_IF
		END_IF

(*=======================================================*)
	220:	(* Schliessen der Quelldatei *)
		IF fb_state_entry.E THEN
			fb_file_close.hFile := h_quell_filehandle;
			fb_file_close.bExecute := TRUE;
		END_IF

		IF fb_file_close.bBusy THEN
			fb_file_close.bExecute := FALSE;
			fb_state_entry.i16_next_step := 230;
		END_IF

(*=======================================================*)
	230:	(* Warte bis Quelle geschlossen *)
		IF NOT fb_file_close.bBusy  THEN
			IF NOT fb_file_close.bError THEN
				h_quell_filehandle := 0;
				fb_state_entry.i16_next_step := 10;
			ELSE	(* Fehler *)
				nErrId := fb_file_close.nErrId;
				fb_state_entry.i16_next_step := 300;
			END_IF
		END_IF

(*=======================================================*)
	300:	(* Bei Fehler müssen Quell- und Zieldatei auf jeden Fall geschlossen werden *)
		(* Beide Dateien korrekt geschlossen -> Fehler auswerten *)
		IF ( h_ziel_filehandle = 0 AND h_quell_filehandle = 0 ) THEN
			fb_state_entry.i16_next_step := 1000;
		(* Beide Dateien sind noch offen und müsse zuerst geschlossen werden -> schliesse zuerst die Quelle*)
		ELSIF (h_quell_filehandle <> 0 AND h_ziel_filehandle <> 0 ) THEN
			fb_file_close.hFile := h_quell_filehandle;
			fb_state_entry.i16_next_step := 310;
		(* Quelle offen und Ziel geschlossen -> Quelle schliessen *)
		ELSIF (h_quell_filehandle <> 0 AND h_ziel_filehandle = 0 ) THEN
			fb_file_close.hFile := h_quell_filehandle;
			fb_state_entry.i16_next_step := 310; (* Schliesse Quelldatei *)
		(* Ziel offen und Quelle geschlossen -> Ziel schliessen *)
		ELSIF (h_quell_filehandle = 0 AND h_ziel_filehandle <> 0) THEN
			fb_file_close.hFile := h_ziel_filehandle;
			fb_state_entry.i16_next_step := 310; (* Schliesse Zielldatei *)
			bBusy := FALSE;
		END_IF

(*=======================================================*)
	310:	(* Schliessen der Datei *)
		IF fb_state_entry.E THEN
			fb_file_close.bExecute := TRUE;
		END_IF

		IF fb_file_close.bBusy THEN
			fb_file_close.bExecute := FALSE;
			fb_state_entry.i16_next_step := 320;
		END_IF

(*=======================================================*)
	320:	(* Warte bis geschlossen *)
		IF NOT fb_file_close.bBusy  THEN
			IF NOT fb_file_close.bError THEN
				IF fb_file_close.hFile = h_quell_filehandle THEN
					h_quell_filehandle := 0;
				ELSIF fb_file_close.hFile = h_ziel_filehandle THEN
					h_ziel_filehandle := 0;
				END_IF
				fb_state_entry.i16_next_step := 300;
			ELSE	(* Fehler *)
				nErrId := fb_file_close.nErrId;
				fb_state_entry.i16_next_step := 1000;
			END_IF
		END_IF

(*=======================================================*)
	1000: (* Fehler *)
		IF fb_state_entry.E THEN
			bBusy := FALSE;
			bError := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bQuit AND NOT fb_state_entry.E THEN
			bError := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := 0;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

fb_file_close(
	sNetId:= '',
	hFile:= , 
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> ,
	bError=> , 
	nErrId=> );

fb_file_open(
	sNetId:= '',
	sPathName:= ,
	nMode:= 	,
	ePath:= PATH_GENERIC,
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> ,
	bError=> , 
	nErrId=> ,
	hFile=> );

fb_file_read(
	sNetId:= ,
	hFile:= , 
	pReadBuff:= ADR(p_read_write_buffer),
	cbReadLen:= SIZEOF(p_read_write_buffer),
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> ,
	nErrId=> ,
	cbRead=> , 
	bEOF=> );

fb_file_write(
	sNetId:= ,
	hFile:= ,
	pWriteBuff:= ADR(p_read_write_buffer),
	cbWriteLen:= cb_write_length,
	bExecute:= , 
	tTimeout:= DEFAULT_ADS_TIMEOUT,
	bBusy=> , 
	bError=> , 
	nErrId=> , 
	cbWrite=> );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Zylinder
VAR
	b_first_cycle 			: BOOL := TRUE;
END_VAR
(* @END_DECLARATION := '0' *)
IF ST_BBGen.b_lesen_komplett THEN

	ST_Datainit_Zylinder();

	(* Zylinderaufrufe *)
	zyl_wt_zentrierer_tisch.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_wt_zentrierer_tisch.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_wt_zentrierer_tisch.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	zyl_wt_stopper_tisch.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_wt_stopper_tisch.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_wt_stopper_tisch.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	zyl_wt_stopper_auslauf.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_wt_stopper_auslauf.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_wt_stopper_auslauf.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	zyl_hublift_rechts_lift.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_hublift_rechts_lift.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_hublift_rechts_lift.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	zyl_hublift_rechts_wt_einzug.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_hublift_rechts_wt_einzug.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_hublift_rechts_wt_einzug.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	zyl_hublift_rechts_wt_klinke.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_hublift_rechts_wt_klinke.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_hublift_rechts_wt_klinke.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	zyl_hublift_links_lift.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_hublift_links_lift.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_hublift_links_lift.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	zyl_hublift_links_wt_einzug.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_hublift_links_wt_einzug.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_hublift_links_wt_einzug.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	zyl_hublift_links_wt_klinke.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_hublift_links_wt_klinke.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_hublift_links_wt_klinke.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	zyl_hublift_links_stopper.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_hublift_links_stopper.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_hublift_links_stopper.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	zyl_hublift_links_eingriffschutz.fb(
		st_config:= ,
		bw_nocken_zylinder_einfahren:= ,
		bw_nocken_zylinder_ausfahren:= ,
		uw_nocken_zylinder_einfahren:= ,
		uw_nocken_zylinder_ausfahren:= ,
		b_direkttaste_ausfahren:= ,
		b_direkttaste_mittefahren:= ,
		b_direkttaste_einfahren	:= ,
		e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
		i16_betriebsart:= gi16_betriebsart,
		b_no_gesteuert_im_norm_betrieb:= ,
		st_ctrl_in:= zyl_hublift_links_eingriffschutz.st_ctrl.in,
		b_masterachse_hand_dialog_aktiv:= ,
		st_visu:= visu.st_zyl,
		st_ctrl_out=> zyl_hublift_links_eingriffschutz.st_ctrl.out,
		a_ventil_einfahren=> ,
		a_ventil_ausfahren=> );
	
	CASE gst_datensatz.st_md.i16_typ_zelle OF
		KEINE_ZELLE:
			;
	
		BESTUECKZELLE_1700:
			zyl_bawe_faenger_li.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_bawe_faenger_li.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_bawe_faenger_li.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_bawe_faenger_li.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_bawe_faenger_re.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_bawe_faenger_re.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_bawe_faenger_re.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_bawe_faenger_re.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_bawe_halter_li.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_bawe_halter_li.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_bawe_halter_li.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_bawe_halter_li.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_bawe_halter_re.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_bawe_halter_re.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_bawe_halter_re.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_bawe_halter_re.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_bawe_querschub.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_bawe_querschub.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_bawe_querschub.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_bawe_querschub.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_bawe_vorschub.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_bawe_vorschub.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_bawe_vorschub.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_bawe_vorschub.st_ctrl.out,
				a_ventil_einfahren=> a_zyl_vorschub_einfahren,
				a_ventil_ausfahren=> a_zyl_vorschub_ausfahren);
			
			zyl_haspel_li_heben.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_li_heben.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_li_heben.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_haspel_li_abspulen.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_li_abspulen.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_li_abspulen.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_li_sperren.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_li_sperren.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_li_sperren.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_re_heben.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_re_heben.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_re_heben.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_re_abspulen.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_re_abspulen.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_re_abspulen.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_re_sperren.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_re_sperren.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_re_sperren.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_verschieben.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_verschieben.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_verschieben.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );

			zyl_bandeinzuege_verschieben.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_bandeinzuege_verschieben.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_bandeinzuege_verschieben.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	

		(*	zyl_Indexier_Bestueckpos.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;*)
			zyl_Indexier_Bestueckpos.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_Indexier_Bestueckpos.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_Indexier_Bestueckpos.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
		(*	zyl_Indexier_Einlauf.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;*)
			zyl_Indexier_Einlauf.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_Indexier_Einlauf.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_Indexier_Einlauf.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );

		BESTUECKZELLE_1720:
			zyl_wt_stopper_einlauf.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_wt_stopper_einlauf.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_wt_stopper_einlauf.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_haspel_li_heben.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_li_heben.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_li_heben.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_li_abspulen.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_li_abspulen.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_li_abspulen.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_li_sperren.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_li_sperren.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_li_sperren.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_re_heben.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_re_heben.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_re_heben.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_re_abspulen.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_re_abspulen.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_re_abspulen.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_re_sperren.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_re_sperren.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_re_sperren.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_bawe_halter_li.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_bawe_halter_li.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_bawe_halter_li.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_bawe_halter_li.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_bawe_halter_re.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_bawe_halter_re.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_bawe_halter_re.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_bawe_halter_re.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
		RASTERFOLIE:
			zyl_haspel_li_heben.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_li_heben.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_li_heben.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_li_abspulen.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_li_abspulen.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_li_abspulen.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_haspel_li_sperren.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_li_sperren.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_li_sperren.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_re_heben.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_re_heben.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_re_heben.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_re_abspulen.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_re_abspulen.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_re_abspulen.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_re_sperren.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_re_sperren.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_re_sperren.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
			
			zyl_haspel_verschieben.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_haspel_verschieben.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_haspel_verschieben.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );

			zyl_bandeinzuege_verschieben.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_bandeinzuege_verschieben.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_bandeinzuege_verschieben.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_rafo_faenger.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_rafo_faenger.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_rafo_faenger.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_rafo_faenger.st_ctrl.out,
				a_ventil_einfahren=> a_zyl_faenger_einfahren,
				a_ventil_ausfahren=> );
	
			zyl_rafo_klemmen.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_rafo_klemmen.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_rafo_klemmen.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_rafo_klemmen.st_ctrl.out,
				a_ventil_einfahren=> a_zyl_klemmen_einfahren,
				a_ventil_ausfahren=> );
	
			zyl_rafo_vorschub.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_rafo_vorschub.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_rafo_vorschub.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_rafo_vorschub.st_ctrl.out,
				a_ventil_einfahren=> a_zyl_vorschub_einfahren,
				a_ventil_ausfahren=> a_zyl_vorschub_ausfahren);
	
			zyl_rafo_kamm.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_rafo_kamm.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_rafo_kamm.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_rafo_kamm.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	
			zyl_rafo_vorzentrierer.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
			zyl_rafo_vorzentrierer.fb(
				st_config:= ,
				bw_nocken_zylinder_einfahren:= ,
				bw_nocken_zylinder_ausfahren:= ,
				uw_nocken_zylinder_einfahren:= ,
				uw_nocken_zylinder_ausfahren:= ,
				b_direkttaste_ausfahren:= ,
				b_direkttaste_mittefahren:= ,
				b_direkttaste_einfahren	:= ,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				i16_betriebsart:= gi16_betriebsart,
				b_no_gesteuert_im_norm_betrieb:= ,
				st_ctrl_in:= zyl_rafo_vorzentrierer.st_ctrl.in,
				b_masterachse_hand_dialog_aktiv:= ,
				st_visu:= visu.st_zyl,
				st_ctrl_out=> zyl_rafo_vorzentrierer.st_ctrl.out,
				a_ventil_einfahren=> ,
				a_ventil_ausfahren=> );
	END_CASE
END_IF

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Zylinder_Fast
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(* Zylinderaufrufe *)
CASE gst_datensatz.st_md.i16_typ_zelle OF
	KEINE_ZELLE:
		;

	BESTUECKZELLE_1700:
		ST_Datainit_Fast_Zylinder();

		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			KEIN_EINZUG:
				;

			STANDARD_2FACH_V2:
				;

				BANDWECHSLER_V2:
				zyl_bandfaenger.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
				zyl_bandfaenger.fb(
					st_config:= ,
					e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
					i16_betriebsart:= gi16_betriebsart,
					b_no_gesteuert_im_norm_betrieb:= ,
					b_direkttaste_ausfahren:= ,
					b_direkttaste_mittefahren:= ,
					b_direkttaste_einfahren	:= ,
					st_ctrl_in:= zyl_bandfaenger.st_ctrl.in,
					b_masterachse_hand_dialog_aktiv:= ST_Bestueckachse.b_hand_dialog_aktiv,
					st_visu:= visu.st_zyl,
					bw_nocken_zylinder_einfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDFAENGER_BAWEV2_EINFAHREN],
					bw_nocken_zylinder_ausfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDFAENGER_BAWEV2_AUSFAHREN],
					uw_nocken_zylinder_einfahren := ,
					uw_nocken_zylinder_ausfahren := ,
					st_ctrl_out=> zyl_bandfaenger.st_ctrl.out,
					a_ventil_einfahren=> a_zyl_faenger_einfahren,
					a_ventil_ausfahren=> );
		
				zyl_bandklemmen.fb.st_config.b_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;
				zyl_bandklemmen.fb(
					st_config:= ,
					e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
					i16_betriebsart:= gi16_betriebsart,
					b_no_gesteuert_im_norm_betrieb:= ,
					b_direkttaste_ausfahren:= ,
					b_direkttaste_mittefahren:= ,
					b_direkttaste_einfahren	:= ,
					st_ctrl_in:= zyl_bandklemmen.st_ctrl.in,
					b_masterachse_hand_dialog_aktiv:= ST_Bestueckachse.b_hand_dialog_aktiv,
					st_visu:= visu.st_zyl,
					bw_nocken_zylinder_einfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDKLEMMEN_BAWEV2_EINFAHREN],
					bw_nocken_zylinder_ausfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN],
					uw_nocken_zylinder_einfahren :=  ,
					uw_nocken_zylinder_ausfahren :=  ,
					st_ctrl_out=> zyl_bandklemmen.st_ctrl.out,
					a_ventil_einfahren=> a_zyl_klemmen_einfahren,
					a_ventil_ausfahren=> );

				IF NOT gst_datensatz.st_md.b_auswahlSpruehoeler THEN
					zyl_oelen_oben.fb(
						st_config:= ,
						e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
						i16_betriebsart:= gi16_betriebsart,
						b_no_gesteuert_im_norm_betrieb:= ,
						b_direkttaste_ausfahren:= ,
						b_direkttaste_mittefahren:= ,
						b_direkttaste_einfahren	:= ,
						st_ctrl_in:=zyl_oelen_oben.st_ctrl.in ,
						b_masterachse_hand_dialog_aktiv:=ST_Bestueckachse.b_hand_dialog_aktiv,
						st_visu:= visu.st_zyl,
						bw_nocken_zylinder_einfahren := (*ST_BandoelerZylinder.b_zyl_oben = FALSE OR*) nockenschaltwerk_bestueckachse.fb.arr_spur[56],
						bw_nocken_zylinder_ausfahren := (*ST_BandoelerZylinder.b_zyl_oben = TRUE AND*)  nockenschaltwerk_bestueckachse.fb.arr_spur[57],
						uw_nocken_zylinder_einfahren := zyl_oelen_oben.fb.e_sensor1_eingefahren AND  nockenschaltwerk_bestueckachse.fb.arr_spur[58],
						uw_nocken_zylinder_ausfahren := zyl_oelen_oben.fb.e_sensor1_ausgefahren AND  nockenschaltwerk_bestueckachse.fb.arr_spur[59],
						st_ctrl_out=> zyl_oelen_oben.st_ctrl.out,
						a_ventil_einfahren=> ,
						a_ventil_ausfahren=> );
	
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[56].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[57].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[58].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[59].b_camvalid := TRUE;
	
					zyl_oelen_unten.fb(
						st_config:= ,
						e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
						i16_betriebsart:= gi16_betriebsart,
						b_no_gesteuert_im_norm_betrieb:= ,
						b_direkttaste_ausfahren:= ,
						b_direkttaste_mittefahren:= ,
						b_direkttaste_einfahren	:= ,
						st_ctrl_in:=zyl_oelen_unten.st_ctrl.in ,
						b_masterachse_hand_dialog_aktiv:=ST_Bestueckachse.b_hand_dialog_aktiv,
						st_visu:= visu.st_zyl,
						bw_nocken_zylinder_einfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[60],
						bw_nocken_zylinder_ausfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[61],
						uw_nocken_zylinder_einfahren := zyl_oelen_unten.fb.e_sensor1_eingefahren AND nockenschaltwerk_bestueckachse.fb.arr_spur[62],
						uw_nocken_zylinder_ausfahren := zyl_oelen_unten.fb.e_sensor1_ausgefahren AND  nockenschaltwerk_bestueckachse.fb.arr_spur[63],
						st_ctrl_out=>zyl_oelen_unten.st_ctrl.out ,
						a_ventil_einfahren=> ,
						a_ventil_ausfahren=> );
	
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[60].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[61].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[62].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[63].b_camvalid := TRUE;
				END_IF

			SERVO:
				;
		END_CASE

	BESTUECKZELLE_1720:
		ST_Datainit_Fast_Zylinder();

		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			KEIN_EINZUG:
				;
		
			STANDARD_2FACH_V2:
				zyl_bandfaenger_li.fb(
					st_config:= ,
					e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
					i16_betriebsart:= gi16_betriebsart,
					b_no_gesteuert_im_norm_betrieb:= ,
					b_direkttaste_ausfahren:= ,
					b_direkttaste_mittefahren:= ,
					b_direkttaste_einfahren	:= ,
					st_ctrl_in:= zyl_bandfaenger_li.st_ctrl.in,
					b_masterachse_hand_dialog_aktiv:= ST_Bestueckachse.b_hand_dialog_aktiv,
					st_visu:= visu.st_zyl,
					bw_nocken_zylinder_einfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDFAENGER_LI_BAEZV2_EINFAHREN],
					bw_nocken_zylinder_ausfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDFAENGER_LI_BAEZV2_AUSFAHREN],
					uw_nocken_zylinder_einfahren := ,
					uw_nocken_zylinder_ausfahren := ,
					st_ctrl_out=> zyl_bandfaenger_li.st_ctrl.out,
					a_ventil_einfahren=> ,
					a_ventil_ausfahren=> );
				
				zyl_bandfaenger_re.fb(
					st_config:= ,
					e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
					i16_betriebsart:= gi16_betriebsart,
					b_no_gesteuert_im_norm_betrieb:= ,
					b_direkttaste_ausfahren:= ,
					b_direkttaste_mittefahren:= ,
					b_direkttaste_einfahren	:= ,
					st_ctrl_in:= zyl_bandfaenger_re.st_ctrl.in,
					b_masterachse_hand_dialog_aktiv:= ST_Bestueckachse.b_hand_dialog_aktiv,
					st_visu:= visu.st_zyl,
					bw_nocken_zylinder_einfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDFAENGER_RE_BAEZV2_EINFAHREN],
					bw_nocken_zylinder_ausfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDFAENGER_RE_BAEZV2_AUSFAHREN],
					uw_nocken_zylinder_einfahren := ,
					uw_nocken_zylinder_ausfahren := ,
					st_ctrl_out=> zyl_bandfaenger_re.st_ctrl.out,
					a_ventil_einfahren=> ,
					a_ventil_ausfahren=> );
		
				zyl_bandklemmen_li.fb(
					st_config:= ,
					e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
					i16_betriebsart:= gi16_betriebsart,
					b_no_gesteuert_im_norm_betrieb:= ,
					b_direkttaste_ausfahren:= ,
					b_direkttaste_mittefahren:= ,
					b_direkttaste_einfahren	:= ,
					st_ctrl_in:= zyl_bandklemmen_li.st_ctrl.in,
					b_masterachse_hand_dialog_aktiv:= ST_Bestueckachse.b_hand_dialog_aktiv,
					st_visu:= visu.st_zyl,
					bw_nocken_zylinder_einfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDKLEMMEN_LI_BAEZV2_EINFAHREN],
					bw_nocken_zylinder_ausfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDKLEMMEN_LI_BAEZV2_AUSFAHREN],
					uw_nocken_zylinder_einfahren := ,
					uw_nocken_zylinder_ausfahren := ,
					st_ctrl_out=> zyl_bandklemmen_li.st_ctrl.out,
					a_ventil_einfahren=> ,
					a_ventil_ausfahren=> );
				
				zyl_bandklemmen_re.fb(
					st_config:= ,
					e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
					i16_betriebsart:= gi16_betriebsart,
					b_no_gesteuert_im_norm_betrieb:= ,
					b_direkttaste_ausfahren:= ,
					b_direkttaste_mittefahren:= ,
					b_direkttaste_einfahren	:= ,
					st_ctrl_in:= zyl_bandklemmen_re.st_ctrl.in,
					b_masterachse_hand_dialog_aktiv:= ST_Bestueckachse.b_hand_dialog_aktiv,
					st_visu:= visu.st_zyl,
					bw_nocken_zylinder_einfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDKLEMMEN_RE_BAEZV2_EINFAHREN],
					bw_nocken_zylinder_ausfahren := nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BW_BANDKLEMMEN_RE_BAEZV2_AUSFAHREN],
					uw_nocken_zylinder_einfahren := ,
					uw_nocken_zylinder_ausfahren := ,
					st_ctrl_out=> zyl_bandklemmen_re.st_ctrl.out,
					a_ventil_einfahren=> ,
					a_ventil_ausfahren=> );

			BANDWECHSLER_V2:
				;

			SERVO:
				;
		END_CASE;

	RASTERFOLIE:
		;
END_CASE
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/MAINs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MAIN_BBGen
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(* BBGen in einem extra Task um lange Berechnungen zu ermöglichen ohne dass die Verbindung zum Prozessabbild abbricht *)
(* Fehlermeldung sonst: Watchdog des asynchronen Mapping 5 zwischen Prozeßabbild 2 und 6 hat zugeschlagen, da Prozeßabbild 2 keine neuen Daten lieferte
 * Die Safty schaltet sonst alles ab *)


ST_BBGen(
	st_config:= bbgen.st_config,
	st_visu:= visu.st_xml_server,
	st_ctrl_in:= bbgen.st_ctrl.in,
	st_ctrl_out=> bbgen.st_ctrl.out,
	i16_auftrag:= gi16_bbgen_auftrag);


(*Maschinendaten müssen bereits ausgelesen sein.*)
IF gst_datensatz.st_md.i16_typ_zelle <> KEINE_ZELLE THEN
	ST_Wartung(
		st_config:= wartung.st_config,
		st_ctrl_in:= wartung.st_ctrl.in,
		st_ctrl_out=> wartung.st_ctrl.out,
		i16_auftrag:= gi16_wartung_auftrag);
END_IF








END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/MAINs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MAIN_FAST
VAR
END_VAR
(* @END_DECLARATION := '0' *)
CASE gst_datensatz.st_md.i16_typ_zelle OF
	KEINE_ZELLE:
		ST_Safetyprogramm(
			st_config:= safety.st_config,
			st_ctrl_in:= safety.st_ctrl.in,
			st_visu:= safety.st_visu,
			st_ctrl_out=> safety.st_ctrl.out);

		ST_Betriebsfreigaben(
			st_config:= betriebsfreigaben.st_config,
			st_ctrl_in:= betriebsfreigaben.st_ctrl.in,
			b_lampe_stoerung:= ,
			b_lampe_produktion:= ,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			st_ctrl_out=> betriebsfreigaben.st_ctrl.out);

		nockenschaltwerk_bestueckachse.fb(
			r_achsposition:= virtuelle_master_achse.NcToPlc.ModuloActPos,
			r_achsgeschwindigkeit:= virtuelle_master_achse.NcToPlc.ActVelo * 60 / 360,
			i16_verfahrrichtung_achse_extern:=  ,
			b_verfahrrichtungsauswertung_extern:= FALSE,
			i16_art_der_achse:= RUND,
			st_config:= nockenschaltwerk_bestueckachse.st_config,
			arr_nocken:= gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken,
			st_visu:= visu);

	BESTUECKZELLE_1700:
		ST_Safetyprogramm(
			st_config:= safety.st_config,
			st_ctrl_in:= safety.st_ctrl.in,
			st_visu:= safety.st_visu,
			st_ctrl_out=> safety.st_ctrl.out);

		ST_Betriebsfreigaben(
			st_config:= betriebsfreigaben.st_config,
			st_ctrl_in:= betriebsfreigaben.st_ctrl.in,
			b_lampe_stoerung:= ,
			b_lampe_produktion:= ,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			st_ctrl_out=> betriebsfreigaben.st_ctrl.out);

		nockenschaltwerk_bestueckachse.fb(
			r_achsposition:= virtuelle_master_achse.NcToPlc.ModuloActPos,
			r_achsgeschwindigkeit:= virtuelle_master_achse.NcToPlc.ActVelo * 60 / 360,
			i16_verfahrrichtung_achse_extern:=  ,
			b_verfahrrichtungsauswertung_extern:= FALSE,
			i16_art_der_achse:= RUND,
			st_config:= nockenschaltwerk_bestueckachse.st_config,
			arr_nocken:= gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken,
			st_visu:= visu);

		ST_Virtuelle_Masterachse(
			st_config_achse:= axis_virt_master.st_config,
			e_ls_bandende_re := ST_Bandwechsel_Kontroller.e_ls_bandende_re,
			e_ls_bandende_li	:= ST_Bandwechsel_Kontroller.e_ls_bandende_li,
			st_ctrl_in:= axis_virt_master.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			st_visu:= axis_virt_master.st_visu,
			st_visu_virtuell:= axis_virt_master.st_visu,
			st_ctrl_out=> axis_virt_master.st_ctrl.out,
			b_materialmangel=> ST_LampeMaterialMangel.b_materialmangel[2],
			b_materialmangel2=> ST_LampeMaterialMangel.b_materialmangel[6]);

		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			KEIN_EINZUG:
				;
			STANDARD_2FACH_V2:
				;
			BANDWECHSLER_V2:
				;
			SERVO:
				ST_Servobandeinzug(
					st_config_achse:= axis_bandeinzug_achse.st_config,
					st_ctrl_in:= axis_bandeinzug_achse.st_ctrl.in,
					e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
					e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
					e_tuere_vorne_offen:= ST_Safetyprogramm.se_tuere_vorne_offen,
					e_tuere_hinten_offen:= ST_Safetyprogramm.se_tuere_hinten_offen,
					st_visu:= axis_bandeinzug_achse.st_visu,
					st_ctrl_out=> axis_bandeinzug_achse.st_ctrl.out);
		END_CASE

		ST_WkzAbsicherung(
			st_config:= wkz_absicherung.st_config,
			st_ctrl_in:= wkz_absicherung.st_ctrl.in,
			st_visu:= wkz_absicherung.st_visu,
			st_ctrl_out=> wkz_absicherung.st_ctrl.out);

		ST_Einpress_Kontroller(
			st_config:= einpresskraft_kontroller.st_config,
			st_ctrl_in:= einpresskraft_kontroller.st_ctrl.in,
			lr_achsposition:= bestueckachse.NcToPlc.ModuloActPos,
			st_visu:= einpresskraft_kontroller.st_visu,
			st_einpressen:= gst_datensatz.st_band.st_einpressen,
			st_ctrl_out=> einpresskraft_kontroller.st_ctrl.out);


		ST_Bandeinzug_Kontroller_1700(
			st_config:= bandeinzug_kontroller.st_config,
			st_ctrl_in:= bandeinzug_kontroller.st_ctrl.in,
			st_visu:= bandeinzug_kontroller.st_visu,
			st_ctrl_out=> bandeinzug_kontroller.st_ctrl.out);

		ST_Zylinder_Fast();

	BESTUECKZELLE_1720:
		ST_Safetyprogramm(
			st_config:= safety.st_config,
			st_ctrl_in:= safety.st_ctrl.in,
			st_visu:= safety.st_visu,
			st_ctrl_out=> safety.st_ctrl.out);

		ST_Betriebsfreigaben(
			st_config:= betriebsfreigaben.st_config,
			st_ctrl_in:= betriebsfreigaben.st_ctrl.in,
			b_lampe_stoerung:= ,
			b_lampe_produktion:= ,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			st_ctrl_out=> betriebsfreigaben.st_ctrl.out);
		
		nockenschaltwerk_bestueckachse.fb(
			r_achsposition:= virtuelle_master_achse.NcToPlc.ModuloActPos,
			r_achsgeschwindigkeit:= virtuelle_master_achse.NcToPlc.ActVelo * 60 / 360,
			i16_verfahrrichtung_achse_extern:=  ,
			b_verfahrrichtungsauswertung_extern:= FALSE,
			i16_art_der_achse:= RUND,
			st_config:= nockenschaltwerk_bestueckachse.st_config,
			arr_nocken:= gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken,
			st_visu:= visu);

		ST_Virtuelle_Masterachse(
			st_config_achse:= axis_virt_master.st_config,
			e_ls_bandende_re := ST_Bandeinzug_Kontroller_1720.e_ls_bandende_re,
			e_ls_bandende_li	:= ST_Bandeinzug_Kontroller_1720.e_ls_bandende_li,
			st_ctrl_in:= axis_virt_master.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			st_visu:= axis_virt_master.st_visu,
			st_visu_virtuell:= axis_virt_master.st_visu,
			st_ctrl_out=> axis_virt_master.st_ctrl.out,
			b_materialmangel=> ST_LampeMaterialMangel.b_materialmangel[2],
			b_materialmangel2=> ST_LampeMaterialMangel.b_materialmangel[6]);

		ST_WkzAbsicherung(
			st_config:= wkz_absicherung.st_config,
			st_ctrl_in:= wkz_absicherung.st_ctrl.in,
			st_visu:= wkz_absicherung.st_visu,
			st_ctrl_out=> wkz_absicherung.st_ctrl.out);

		ST_Bandeinzug_Kontroller_1720(
			st_config:= bandeinzug_kontroller.st_config,
			st_ctrl_in:= bandeinzug_kontroller.st_ctrl.in,
			st_visu:= bandeinzug_kontroller.st_visu,
			st_ctrl_out=> bandeinzug_kontroller.st_ctrl.out);

		ST_Zylinder_Fast();

	RASTERFOLIE:
		ST_Safetyprogramm(
			st_config:= safety.st_config,
			st_ctrl_in:= safety.st_ctrl.in,
			st_visu:= safety.st_visu,
			st_ctrl_out=> safety.st_ctrl.out);
	
		ST_Betriebsfreigaben(
			st_config:= betriebsfreigaben.st_config,
			st_ctrl_in:= betriebsfreigaben.st_ctrl.in,
			b_lampe_stoerung:= ,
			b_lampe_produktion:= ,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			st_ctrl_out=> betriebsfreigaben.st_ctrl.out);
		
		nockenschaltwerk_bestueckachse.fb(
			r_achsposition:= virtuelle_master_achse.NcToPlc.ModuloActPos,
			r_achsgeschwindigkeit:= virtuelle_master_achse.NcToPlc.ActVelo * 60 / 360,
			i16_verfahrrichtung_achse_extern:=  ,
			b_verfahrrichtungsauswertung_extern:= FALSE,
			i16_art_der_achse:= RUND,
			st_config:= nockenschaltwerk_bestueckachse.st_config,
			arr_nocken:= gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken,
			st_visu:= visu);

		ST_Virtuelle_Masterachse(
			st_config_achse:= axis_virt_master.st_config,
			e_ls_bandende_re := ST_Bandwechsel_Kontroller.e_ls_bandende_re,
			e_ls_bandende_li	:= ST_Bandwechsel_Kontroller.e_ls_bandende_li,
			st_ctrl_in:= axis_virt_master.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			st_visu:= axis_virt_master.st_visu,
			st_visu_virtuell:= axis_virt_master.st_visu,
			st_ctrl_out=> axis_virt_master.st_ctrl.out,
			b_materialmangel=> ST_LampeMaterialMangel.b_materialmangel[2],
			b_materialmangel2=> ST_LampeMaterialMangel.b_materialmangel[6]);
END_CASE
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/MAINs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MAIN_STANDARD
VAR
END_VAR
(* @END_DECLARATION := '0' *)
CASE gst_datensatz.st_md.i16_typ_zelle OF
	KEINE_ZELLE:
		;
	BESTUECKZELLE_1700:
		IF visu.s_akt_sprache <> 'en' THEN
			ST_AutoCheckIn( i_IntervalDay:=7 );
		END_IF
		ST_SaveAndLoad();
		ST_Datainit_Stationen();
		ST_Datainit_Achsen();

		ST_EthercatDiag();

		(* Grundmaschine *)
		EtherCatDiag[1]( );
		EtherCatDiag[1].st_config.b_station_aktiv := TRUE;

		(* Hublift links *)
		EtherCatDiag[2]( );
		EtherCatDiag[2].st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_links_aktiv;

		(* Hublift rechts *)
		EtherCatDiag[3]( );
		EtherCatDiag[3].st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_rechts_aktiv;

		(* Bandeinzug *)
		(* Bandeinzug nicht aufrufen, weil in allen TSM der Mulitpol A170 für die Rasterfolie drin ist und dieser
		in keinem normalen Bandeinzug
		Bei normalem Bandeinzug kommt immer Fehler Busverbindung *)
		(*EtherCatDiag[4]( );
		EtherCatDiag[4].st_config.b_station_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;*)

		ST_UPS(st_config:= UPS.st_config,
			st_ctrl_in:= UPS.st_ctrl.in,
			b_Ups := TRUE,
			st_ctrl_out=> UPS.st_ctrl.out);

		ST_RoutingBackpanel(
			st_config:= routing_backpanel.st_config,
			st_ctrl_in:= routing_backpanel.st_ctrl.in,
			st_ctrl_out=> routing_backpanel.st_ctrl.out);

		ST_MotionFunctionPoints(
			st_ctrl_in:= edit_mfps.st_ctrl.in,
			st_ctrl_out=> edit_mfps.st_ctrl.out);

		ST_Schreibe_Persistente_Daten(
			bExecute:= ,
			bQuit:= ,
			t_schreibintervall:= t#60s,
			b_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			bBusy=> ,
			bError=> ,
			nErrId=> );

		ST_System_DateAndTime();

		betriebsstundenzaehler.fb(
			b_eingekuppelt:= (ST_Z_Achse.fb_state_entry.i16_step > BEREIT AND ST_Z_Achse.fb_state_entry.i16_step < HALT) AND (gi16_betriebsart = AUTO),
			b_reset:= ,
			i32_betriebssekundenzaehler_in:= gst_datensatz.st_md.i32_betriebssekundenzaehler,
			i32_betriebssekundenzaehler=> gst_datensatz.st_md.i32_betriebssekundenzaehler);

		ST_Tuerverriegelung(
			e_quittiertaste:= ST_Safetyprogramm.se_quittiertaste);

		ST_LampeMaterialMangel(b_materialmangel:=  );

		ST_Zylinder();

		ST_start_OSK(bExecute:= ST_Safetyprogramm.se_quittiertaste);

		ST_Euchner_Handbedienpult();

		ST_TippTasten(
			i16_akt_stufe:= ,
			b_initialisierungsphase:= ,
			b_einfaedeln_aktiv:= ,
			st_visu:= visu,
			st_visu_hinten:= visu_hinten);

		ST_Betriebsarten(st_config:= betriebsarten.st_config);

		(* Übernahme der Daten aus der Datenbank: Beladen und Abgabe greifen dann auf diese Konfiguration zu *)
		wt_transport_kontroller.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
		wt_transport_kontroller.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;

		ST_WT_Transport_Kontroller(
			st_config:= wt_transport_kontroller.st_config,
			st_ctrl_in:= wt_transport_kontroller.st_ctrl.in,
			st_visu:= visu,
			st_ctrl_out=> wt_transport_kontroller.st_ctrl.out);

		(* Aktivierung durch den Kontroller *)
		wt_transport_abgabe.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
		wt_transport_abgabe.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;

		ST_WT_Transport_Abgabe(
			st_config:= wt_transport_abgabe.st_config,
			st_ctrl_in:= wt_transport_abgabe.st_ctrl.in,
			e_station_nachher_in_erlaubnis:= ,
			e_station_nachher_in_angekommen:= ,
			st_visu:= wt_transport_abgabe.st_visu,
			st_ctrl_out=> wt_transport_abgabe.st_ctrl.out,
			a_station_nachher_out_anforderung=> a_smema_station_nachher_out_anforderung,
			a_station_nachher_out_abgegeben=> a_smema_station_nachher_out_abgegeben);

		hublift_rechts.st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_rechts_aktiv;
		hublift_rechts.st_config.b_station_in_simulation := gst_datensatz.st_md.b_hublift_rechts_simulation;

		ST_Hublift_rechts(
			st_config:= hublift_rechts.st_config,
			st_ctrl_in:= hublift_rechts.st_ctrl.in,
			e_station_vorher_in_anforderung	:= ,
			e_station_vorher_in_abgegeben:= ,
			st_visu:= hublift_rechts.st_visu,
			st_ctrl_out=> hublift_rechts.st_ctrl.out,
			a_station_vorher_out_erlaubnis=> ,
			a_station_vorher_out_angekommen=> );
		IF hublift_rechts.st_config.b_station_aktiv OR hublift_rechts.st_config.b_station_in_simulation THEN
			ST_Hublift_rechts.e_station_vorher_in_abgegeben := ST_WT_Transport_Abgabe.a_station_nachher_out_abgegeben;
			ST_Hublift_rechts.e_station_vorher_in_anforderung := ST_WT_Transport_Abgabe.a_station_nachher_out_anforderung;
			ST_WT_Transport_Abgabe.e_station_nachher_in_angekommen := ST_Hublift_rechts.a_station_vorher_out_angekommen;
			ST_WT_Transport_Abgabe.e_station_nachher_in_erlaubnis := ST_Hublift_rechts.a_station_vorher_out_erlaubnis;
		ELSE
			ST_WT_Transport_Abgabe.e_station_nachher_in_angekommen := e_smema_station_nachher_in_angekommen;
			ST_WT_Transport_Abgabe.e_station_nachher_in_erlaubnis := e_smema_station_nachher_in_erlaubnis;
		END_IF

		balluff_tag_reader.fb(
			st_config:= balluff_tag_reader.fb.st_config,
			i16_addresse:= ,
			i16_anzahl_byte:= ,
			s_schreib_daten:= ,
			st_ctrl_in:= balluff_tag_reader.st_ctrl.in,
			s_lese_daten=> ,
			st_ctrl_out=> balluff_tag_reader.st_ctrl.out);

		barcode.fb(
			st_config:= barcode.fb.st_config,
			st_barcode_daten := gst_barcode_daten,
			b_steuerung_ein := ST_Safetyprogramm.se_steuerung_ein,
			b_bandende_links := ST_Bandwechsel_Kontroller.e_ls_bandende_li ,
			b_bandende_rechts := ST_Bandwechsel_Kontroller.e_ls_bandende_re,
			b_bandende_1720 := ST_Bandeinzug_Kontroller_1720.e_ls_bandende_li,
			b_band_nicht_gescannt=> ST_LampeMaterialMangel.b_materialmangel[5]);

		visu_hinten.in.bandfreigabe[0] := gst_barcode_daten.b_band_rechts_ok;
		visu_hinten.in.bandfreigabe[1] := gst_barcode_daten.b_band_links_ok;
		visu_hinten.in.band_ID[0] := gst_barcode_daten.b_band_ID_rechts_ok;
		visu_hinten.in.band_ID[1] := gst_barcode_daten.b_band_ID_links_ok;

		ST_VisuRouter();

		ST_Message_Produktion();

		ST_Bestueckachse(
			st_config_achse:= axis_bestueckachse.st_config,
			st_ctrl_in:= axis_bestueckachse.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			e_tuere_vorne_offen:= ST_Safetyprogramm.se_tuere_vorne_offen,
			e_tuere_hinten_offen:= ST_Safetyprogramm.se_tuere_hinten_offen,
			st_visu:= axis_bestueckachse.st_visu,
			st_ctrl_out=> axis_bestueckachse.st_ctrl.out);

		ST_Z_Achse(
			st_config_achse:= axis_z_achse.st_config,
			st_ctrl_in:= axis_z_achse.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			e_tuere_vorne_offen:= ST_Safetyprogramm.se_tuere_vorne_offen,
			e_tuere_hinten_offen:= ST_Safetyprogramm.se_tuere_hinten_offen,
			st_visu:= axis_z_achse.st_visu,
			st_ctrl_out=> axis_z_achse.st_ctrl.out,
			t_Z_Achse_ausfahren=>visu.ST_Service.t_Z_Achse_ausfahren,
			t_Bestueckung=>visu.ST_Service.t_Bestueckung,
			t_Z_Achse_einfahren=>visu.ST_Service.t_Z_Achse_einfahren);

		ST_TouchProbe();

		ST_Y_Achse(
			st_config_achse:= axis_y_achse.st_config,
			st_ctrl_in:= axis_y_achse.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			e_tuere_vorne_offen:= ST_Safetyprogramm.se_tuere_vorne_offen,
			e_tuere_hinten_offen:= ST_Safetyprogramm.se_tuere_hinten_offen,
			e_not_steu_tuer_schutz_ok:= ,
			st_visu:= axis_y_achse.st_visu,
			st_ctrl_out=> axis_y_achse.st_ctrl.out);


		ST_Gesamthubzaehler();

		IF gst_Datensatz.st_md.b_anwahl_transport_achse THEN

			ST_WT_Transport_Achse(
				st_config_achse:= axis_transport_wt_achse.st_config,
				st_ctrl_in:= axis_transport_wt_achse.st_ctrl.in,
				e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
				e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
				e_tuere_vorne_offen:= ST_Safetyprogramm.se_tuere_vorne_offen,
				e_tuere_hinten_offen:= ST_Safetyprogramm.se_tuere_hinten_offen,
				st_visu:= axis_transport_wt_achse.st_visu,
				st_ctrl_out=> axis_transport_wt_achse.st_ctrl.out);

			wt_transport_warteposition_1700.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
			wt_transport_warteposition_1700.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;

			ST_WT_Transport_Warteposition_1700(
				st_config:= wt_transport_warteposition_1700.st_config,
				st_ctrl_in:= wt_transport_warteposition_1700.st_ctrl.in,
				e_station_vorher_in_anforderung	:= ,
				e_station_vorher_in_abgegeben:= ,
				st_visu:= wt_transport_warteposition_1700.st_visu,
				st_ctrl_out=> wt_transport_warteposition_1700.st_ctrl.out,
				a_station_vorher_out_erlaubnis=> a_smema_station_vorher_out_erlaubnis,
				a_station_vorher_out_angekommen=> a_smema_station_vorher_out_angekommen);
	
			wt_transport_beladen_achse_1700.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
			wt_transport_beladen_achse_1700.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;
	
			ST_WT_Transport_Beladen_Achse_1700(
				st_config:= wt_transport_beladen_achse_1700.st_config,
				st_ctrl_in:= wt_transport_beladen_achse_1700.st_ctrl.in,
				e_wt_im_aktionsfeld := balluff_tag_reader.fb.e_tag_im_aktionsfeld,
				st_visu:= wt_transport_beladen_achse_1700.st_visu,
				st_ctrl_out=> wt_transport_beladen_achse_1700.st_ctrl.out,
				t_WT_WechselZeit=>visu.ST_Service.t_WT_wechsel,
				t_traegerwechselzeit=>visu.ST_Service.t_traegerwechselzeit,
				t_Zentrierer_ausfahren=>visu.ST_Service.t_Zentrierer_ausfahren,
				t_Zentrierer_einfahren=>visu.ST_Service.t_Zentrierer_einfahren,
				t_komplett_zyklus=>visu.ST_Service.t_komplett_zyklus,);

		ELSE
			(* Aktivierung durch den Kontroller *)
			wt_transport_beladen.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
			wt_transport_beladen.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;
	
			ST_WT_Transport_Beladen(
				st_config:= wt_transport_beladen.st_config,
				st_ctrl_in:= wt_transport_beladen.st_ctrl.in,
				e_station_vorher_in_anforderung	:= ,
				e_station_vorher_in_abgegeben:= ,
				st_visu:= wt_transport_beladen.st_visu,
				st_ctrl_out=> wt_transport_beladen.st_ctrl.out,
				a_station_vorher_out_erlaubnis=> a_smema_station_vorher_out_erlaubnis,
				a_station_vorher_out_angekommen=> a_smema_station_vorher_out_angekommen,
				t_WT_WechselZeit=>visu.ST_Service.t_WT_wechsel,
				t_traegerwechselzeit=>visu.ST_Service.t_traegerwechselzeit,
				t_Zentrierer_ausfahren=>visu.ST_Service.t_Zentrierer_ausfahren,
				t_Zentrierer_einfahren=>visu.ST_Service.t_Zentrierer_einfahren,
				t_komplett_zyklus=>visu.ST_Service.t_komplett_zyklus,);
		END_IF

		hublift_links.st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_links_aktiv;
		hublift_links.st_config.b_station_in_simulation := gst_datensatz.st_md.b_hublift_links_simulation;

		ST_Hublift_links(
			st_config:= hublift_links.st_config,
			st_ctrl_in:= hublift_links.st_ctrl.in,
			e_station_nachher_in_erlaubnis:= ,
			e_station_nachher_in_angekommen:= ,
			st_visu:= hublift_links.st_visu,
			st_ctrl_out=> hublift_links.st_ctrl.out,
			a_station_nachher_out_anforderung=> ,
			a_station_nachher_out_abgegeben=> );
		IF hublift_links.st_config.b_station_aktiv OR hublift_links.st_config.b_station_in_simulation THEN
			IF gst_Datensatz.st_md.b_anwahl_transport_achse THEN
				ST_WT_Transport_Warteposition_1700.e_station_vorher_in_abgegeben := ST_Hublift_links.a_station_nachher_out_abgegeben;
				ST_WT_Transport_Warteposition_1700.e_station_vorher_in_anforderung := ST_Hublift_links.a_station_nachher_out_anforderung;
				ST_Hublift_links.e_station_nachher_in_angekommen := ST_WT_Transport_Warteposition_1700.a_station_vorher_out_angekommen;
				ST_Hublift_links.e_station_nachher_in_erlaubnis := ST_WT_Transport_Warteposition_1700.a_station_vorher_out_erlaubnis;
			ELSE
				ST_WT_Transport_Beladen.e_station_vorher_in_abgegeben := ST_Hublift_links.a_station_nachher_out_abgegeben;
				ST_WT_Transport_Beladen.e_station_vorher_in_anforderung := ST_Hublift_links.a_station_nachher_out_anforderung;
				ST_Hublift_links.e_station_nachher_in_angekommen := ST_WT_Transport_Beladen.a_station_vorher_out_angekommen;
				ST_Hublift_links.e_station_nachher_in_erlaubnis := ST_WT_Transport_Beladen.a_station_vorher_out_erlaubnis;
			END_IF
		ELSE
			IF gst_Datensatz.st_md.b_anwahl_transport_achse THEN
				ST_WT_Transport_Warteposition_1700.e_station_vorher_in_abgegeben := e_smema_station_vorher_in_abgegeben;
				ST_WT_Transport_Warteposition_1700.e_station_vorher_in_anforderung := e_smema_station_vorher_in_anforderung;
			ELSE
				ST_WT_Transport_Beladen.e_station_vorher_in_abgegeben := e_smema_station_vorher_in_abgegeben;
				ST_WT_Transport_Beladen.e_station_vorher_in_anforderung := e_smema_station_vorher_in_anforderung;
			END_IF
		END_IF

		ST_Stoerungen_Quitt_1700(
			st_config:= stoerungen_quittieren.st_config,
			st_ctrl_in:= stoerungen_quittieren.st_ctrl.in,
			st_visu:= visu,
			st_visu_hinten:= visu_hinten,
			st_ctrl_out=> stoerungen_quittieren.st_ctrl.out,
			b_lampe_stoerung=> ST_Betriebsfreigaben.b_lampe_stoerung,
			b_lampe_produktion=> ST_Betriebsfreigaben.b_lampe_produktion);

		ST_Bandwechsel_Kontroller(
			st_config:= bandwechsel_kontroller.st_config,
			st_ctrl_in:= bandwechsel_kontroller.st_ctrl.in,
			st_visu:= visu,
			b_materialmangel=> ST_LampeMaterialMangel.b_materialmangel[3],
			st_ctrl_out=> bandwechsel_kontroller.st_ctrl.out);

		ST_Haspel_Kontroller_2H(
			t_abschaltzeit_motor:= haspel_kontroller.t_abschaltzeit_motor,
			b_drehrichtung_antrieb_links := gst_datensatz.st_wkz.b_laufrichtung_haspel_links,
			st_config:= haspel_kontroller.st_config,
			e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			st_ctrl_in:= haspel_kontroller.st_ctrl.in,
			haspel1_ctrl_in:= haspel_li.st_ctrl.out,
			haspel2_ctrl_in:= haspel_re.st_ctrl.out,
			st_visu:= haspel_kontroller.st_visu,
			st_ctrl_out=> haspel_kontroller.st_ctrl.out,
			haspel1_ctrl_out=> haspel_li.st_ctrl.in,
			haspel2_ctrl_out=> haspel_re.st_ctrl.in,
			b_materialmangel_bandende=> ST_LampeMaterialMangel.b_materialmangel[0]);

		Haspel_Li.fb(
			t_wartezeit_bandende:= t#5s,
			b_bandende_Bandeinzug := ST_Bandwechsel_Kontroller.e_ls_bandende_li ,
			b_band_ok := gst_barcode_daten.b_band_links_ok AND gst_barcode_daten.b_band_ID_links_ok,
			st_config:= Haspel_Li.fb.st_config,
			st_ctrl_in:= Haspel_Li.st_ctrl.in,
			st_visu := Haspel_Li.st_visu,
			st_zyl_heben:= zyl_haspel_li_heben,
			st_zyl_abspulen:= zyl_haspel_li_abspulen,
			st_zyl_sperren:= zyl_haspel_li_sperren,
			st_ctrl_out=> Haspel_Li.st_ctrl.out);

		Haspel_Re.fb(
			t_wartezeit_bandende:= t#5s,
			b_bandende_Bandeinzug := ST_Bandwechsel_Kontroller.e_ls_bandende_re ,
			b_band_ok := gst_barcode_daten.b_band_rechts_ok AND gst_barcode_daten.b_band_ID_rechts_ok ,
			st_config:= Haspel_Re.fb.st_config,
			st_ctrl_in:= Haspel_Re.st_ctrl.in,
			st_visu := Haspel_Re.st_visu,
			st_zyl_heben:= zyl_haspel_re_heben,
			st_zyl_abspulen:= zyl_haspel_re_abspulen,
			st_zyl_sperren:= zyl_haspel_re_sperren,
			st_ctrl_out=> Haspel_Re.st_ctrl.out);

		IF gst_datensatz.st_md.b_auswahlSpruehoeler THEN
			ST_Menzel_Spruehoeler(
				st_config:= bandspruehoeler.st_config,
				st_ctrl_in:= bandspruehoeler.st_ctrl.in,
				lr_achse_position:= bestueckachse.NcToPlc.ModuloActPos,
				e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
				e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
				st_ctrl_out =>bandspruehoeler.st_ctrl.out,
				b_oelmangel=> ST_LampeMaterialMangel.b_materialmangel[1]);
		ELSE
			ST_BandoelerZylinder(
					st_config:= bandspruehoeler.st_config,
					st_ctrl_in:= bandspruehoeler.st_ctrl.in,
					lr_achse_position:= bestueckachse.NcToPlc.ModuloActPos,
					e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
					e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
					st_ctrl_out =>bandspruehoeler.st_ctrl.out,
					b_oelmangel=> ST_LampeMaterialMangel.b_materialmangel[1]);
		END_IF

		ST_Lesen_Schreiben_Tag(
			st_config:= Lesen_Schreiben_Tag.st_config,
			st_ctrl_in:= Lesen_Schreiben_Tag.st_ctrl.in,
			st_ctrl_out=> Lesen_Schreiben_Tag.st_ctrl.out);

		ST_Anwahl_Bandeinzug();
		ST_Scope();

	BESTUECKZELLE_1720:
		ST_AutoCheckIn( i_IntervalDay:=7 );
		ST_SaveAndLoad();
		ST_Datainit_Stationen();
		ST_Datainit_Achsen();

		ST_EthercatDiag();

		(* Grundmaschine *)
		EtherCatDiag[1]( );
		EtherCatDiag[1].st_config.b_station_aktiv := TRUE;

		(* Hublift links *)
		EtherCatDiag[2]( );
		EtherCatDiag[2].st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_links_aktiv;

		(* Hublift rechts *)
		EtherCatDiag[3]( );
		EtherCatDiag[3].st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_rechts_aktiv;

		(* Bandeinzug *)
		EtherCatDiag[4]( );
		EtherCatDiag[4].st_config.b_station_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;

		ST_UPS(st_config:= UPS.st_config,
			st_ctrl_in:= UPS.st_ctrl.in,
			b_Ups := TRUE,
			st_ctrl_out=> UPS.st_ctrl.out);

		ST_RoutingBackpanel(
			st_config:= routing_backpanel.st_config,
			st_ctrl_in:= routing_backpanel.st_ctrl.in,
			st_ctrl_out=> routing_backpanel.st_ctrl.out);

		ST_MotionFunctionPoints(
			st_ctrl_in:= edit_mfps.st_ctrl.in,
			st_ctrl_out=> edit_mfps.st_ctrl.out);

		ST_Schreibe_Persistente_Daten(
			bExecute:= ,
			bQuit:= ,
			t_schreibintervall:= t#60s,
			b_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			bBusy=> ,
			bError=> ,
			nErrId=> );

		ST_System_DateAndTime();

		betriebsstundenzaehler.fb(
			b_eingekuppelt:= (ST_Z_Achse.fb_state_entry.i16_step > BEREIT AND ST_Z_Achse.fb_state_entry.i16_step < HALT) AND (gi16_betriebsart = AUTO),
			b_reset:= ,
			i32_betriebssekundenzaehler_in:= gst_datensatz.st_md.i32_betriebssekundenzaehler,
			i32_betriebssekundenzaehler=> gst_datensatz.st_md.i32_betriebssekundenzaehler);

		ST_Tuerverriegelung(
			e_quittiertaste:= ST_Safetyprogramm.se_quittiertaste);

		ST_LampeMaterialMangel(b_materialmangel:=  );

		ST_Zylinder();

		ST_start_OSK(bExecute:= ST_Safetyprogramm.se_quittiertaste);

		ST_Euchner_Handbedienpult();

		ST_TippTasten(
			i16_akt_stufe:= ,
			b_initialisierungsphase:= ,
			b_einfaedeln_aktiv:= ,
			st_visu:= visu,
			st_visu_hinten:= visu_hinten);

		ST_Betriebsarten(st_config:= betriebsarten.st_config);

		(* Übernahme der Daten aus der Datenbank: Beladen und Abgabe greifen dann auf diese Konfiguration zu *)
		wt_transport_kontroller.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
		wt_transport_kontroller.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;

		ST_WT_Transport_Kontroller(
			st_config:= wt_transport_kontroller.st_config,
			st_ctrl_in:= wt_transport_kontroller.st_ctrl.in,
			st_visu:= visu,
			st_ctrl_out=> wt_transport_kontroller.st_ctrl.out);

		(* Aktivierung durch den Kontroller *)
		wt_transport_abgabe.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
		wt_transport_abgabe.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;

		ST_WT_Transport_Abgabe(
			st_config:= wt_transport_abgabe.st_config,
			st_ctrl_in:= wt_transport_abgabe.st_ctrl.in,
			e_station_nachher_in_erlaubnis:= ,
			e_station_nachher_in_angekommen:= ,
			st_visu:= wt_transport_abgabe.st_visu,
			st_ctrl_out=> wt_transport_abgabe.st_ctrl.out,
			a_station_nachher_out_anforderung=> a_smema_station_nachher_out_anforderung,
			a_station_nachher_out_abgegeben=> a_smema_station_nachher_out_abgegeben);

		hublift_rechts.st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_rechts_aktiv;
		hublift_rechts.st_config.b_station_in_simulation := gst_datensatz.st_md.b_hublift_rechts_simulation;

		ST_Hublift_rechts(
			st_config:= hublift_rechts.st_config,
			st_ctrl_in:= hublift_rechts.st_ctrl.in,
			e_station_vorher_in_anforderung	:= ,
			e_station_vorher_in_abgegeben:= ,
			st_visu:= hublift_rechts.st_visu,
			st_ctrl_out=> hublift_rechts.st_ctrl.out,
			a_station_vorher_out_erlaubnis=> ,
			a_station_vorher_out_angekommen=> );
		IF hublift_rechts.st_config.b_station_aktiv OR hublift_rechts.st_config.b_station_in_simulation THEN
			ST_Hublift_rechts.e_station_vorher_in_abgegeben := ST_WT_Transport_Abgabe.a_station_nachher_out_abgegeben;
			ST_Hublift_rechts.e_station_vorher_in_anforderung := ST_WT_Transport_Abgabe.a_station_nachher_out_anforderung;
			ST_WT_Transport_Abgabe.e_station_nachher_in_angekommen := ST_Hublift_rechts.a_station_vorher_out_angekommen;
			ST_WT_Transport_Abgabe.e_station_nachher_in_erlaubnis := ST_Hublift_rechts.a_station_vorher_out_erlaubnis;
		ELSE
			ST_WT_Transport_Abgabe.e_station_nachher_in_angekommen := e_smema_station_nachher_in_angekommen;
			ST_WT_Transport_Abgabe.e_station_nachher_in_erlaubnis := e_smema_station_nachher_in_erlaubnis;
		END_IF

		balluff_tag_reader.fb(
			st_config:= balluff_tag_reader.fb.st_config,
			i16_addresse:= ,
			i16_anzahl_byte:= ,
			s_schreib_daten:= ,
			st_ctrl_in:= balluff_tag_reader.st_ctrl.in,
			s_lese_daten=> ,
			st_ctrl_out=> balluff_tag_reader.st_ctrl.out);

		barcode.fb(
			st_config:= barcode.fb.st_config,
			st_barcode_daten := gst_barcode_daten,
			b_steuerung_ein := ST_Safetyprogramm.se_steuerung_ein,
			b_bandende_links := ST_Bandeinzug_Kontroller_1720.e_ls_bandende_li ,
			b_bandende_rechts := ST_Bandeinzug_Kontroller_1720.e_ls_bandende_re,
			b_bandende_1720 := ST_Bandeinzug_Kontroller_1720.e_ls_bandende_li OR ST_Bandeinzug_Kontroller_1720.e_ls_bandende_re,
			b_band_nicht_gescannt=> ST_LampeMaterialMangel.b_materialmangel[5]);

		visu_hinten.in.bandfreigabe[0] := gst_barcode_daten.b_band_rechts_ok;
		visu_hinten.in.bandfreigabe[1] := gst_barcode_daten.b_band_links_ok;
		visu_hinten.in.band_ID[0] := gst_barcode_daten.b_band_ID_rechts_ok;
		visu_hinten.in.band_ID[1] := gst_barcode_daten.b_band_ID_links_ok;

		ST_VisuRouter();

		ST_Message_Produktion();

		ST_Bestueckachse(
			st_config_achse:= axis_bestueckachse.st_config,
			st_ctrl_in:= axis_bestueckachse.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			e_tuere_vorne_offen:= ST_Safetyprogramm.se_tuere_vorne_offen,
			e_tuere_hinten_offen:= ST_Safetyprogramm.se_tuere_hinten_offen,
			st_visu:= axis_bestueckachse.st_visu,
			st_ctrl_out=> axis_bestueckachse.st_ctrl.out);

		ST_Z_Achse(
			st_config_achse:= axis_z_achse.st_config,
			st_ctrl_in:= axis_z_achse.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			e_tuere_vorne_offen:= ST_Safetyprogramm.se_tuere_vorne_offen,
			e_tuere_hinten_offen:= ST_Safetyprogramm.se_tuere_hinten_offen,
			st_visu:= axis_z_achse.st_visu,
			st_ctrl_out=> axis_z_achse.st_ctrl.out,
			t_Z_Achse_ausfahren=>visu.ST_Service.t_Z_Achse_ausfahren,
			t_Bestueckung=>visu.ST_Service.t_Bestueckung,
			t_Z_Achse_einfahren=>visu.ST_Service.t_Z_Achse_einfahren);

		ST_TouchProbe();

		ST_Gesamthubzaehler();

		(* Aktivierung durch den Kontroller *)
		wt_transport_warteposition_1720.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
		wt_transport_warteposition_1720.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;

		ST_WT_Transport_Warteposition_1720(
			st_config:= wt_transport_warteposition_1720.st_config,
			st_ctrl_in:= wt_transport_warteposition_1720.st_ctrl.in,
			e_station_vorher_in_anforderung	:= ,
			e_station_vorher_in_abgegeben:= ,
			st_visu:= wt_transport_warteposition_1720.st_visu,
			st_ctrl_out=> wt_transport_warteposition_1720.st_ctrl.out,
			a_station_vorher_out_erlaubnis=> a_smema_station_vorher_out_erlaubnis,
			a_station_vorher_out_angekommen=> a_smema_station_vorher_out_angekommen);

		(* Aktivierung durch den Kontroller *)
		wt_transport_beladen_1720.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
		wt_transport_beladen_1720.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;

		ST_WT_Transport_Beladen_1720(
			st_config:= wt_transport_beladen_1720.st_config,
			st_ctrl_in:= wt_transport_beladen_1720.st_ctrl.in,
			st_visu:= wt_transport_beladen_1720.st_visu,
			st_ctrl_out=> wt_transport_beladen_1720.st_ctrl.out,
			t_WT_WechselZeit=>visu.ST_Service.t_WT_wechsel,
			t_traegerwechselzeit=>visu.ST_Service.t_traegerwechselzeit,
			t_Zentrierer_ausfahren=>visu.ST_Service.t_Zentrierer_ausfahren,
			t_Zentrierer_einfahren=>visu.ST_Service.t_Zentrierer_einfahren,
			t_komplett_zyklus=>visu.ST_Service.t_komplett_zyklus,);

		hublift_links.st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_links_aktiv;
		hublift_links.st_config.b_station_in_simulation := gst_datensatz.st_md.b_hublift_links_simulation;

		ST_Hublift_links(
			st_config:= hublift_links.st_config,
			st_ctrl_in:= hublift_links.st_ctrl.in,
			e_station_nachher_in_erlaubnis:= ,
			e_station_nachher_in_angekommen:= ,
			st_visu:= hublift_links.st_visu,
			st_ctrl_out=> hublift_links.st_ctrl.out,
			a_station_nachher_out_anforderung=> ,
			a_station_nachher_out_abgegeben=> );
		IF hublift_links.st_config.b_station_aktiv OR hublift_links.st_config.b_station_in_simulation THEN
			ST_Hublift_links.e_station_nachher_in_angekommen := ST_WT_Transport_Warteposition_1720.a_station_vorher_out_angekommen;
			ST_Hublift_links.e_station_nachher_in_erlaubnis := ST_WT_Transport_Warteposition_1720.a_station_vorher_out_erlaubnis;
			ST_WT_Transport_Warteposition_1720.e_station_vorher_in_abgegeben := ST_Hublift_links.a_station_nachher_out_abgegeben;
			ST_WT_Transport_Warteposition_1720.e_station_vorher_in_anforderung := ST_Hublift_links.a_station_nachher_out_anforderung;
		ELSE
			ST_WT_Transport_Warteposition_1720.e_station_vorher_in_abgegeben := e_smema_station_vorher_in_abgegeben;
			ST_WT_Transport_Warteposition_1720.e_station_vorher_in_anforderung := e_smema_station_vorher_in_anforderung;
		END_IF

		ST_Stoerungen_Quitt_1720(
			st_config:= stoerungen_quittieren.st_config,
			st_ctrl_in:= stoerungen_quittieren.st_ctrl.in,
			st_visu:= visu,
			st_visu_hinten:= visu_hinten,
			st_ctrl_out=> stoerungen_quittieren.st_ctrl.out,
			b_lampe_stoerung=> ST_Betriebsfreigaben.b_lampe_stoerung,
			b_lampe_produktion=> ST_Betriebsfreigaben.b_lampe_produktion);

		ST_Haspel_Kontroller_2H(
			t_abschaltzeit_motor:= haspel_kontroller.t_abschaltzeit_motor,
			b_drehrichtung_antrieb_links := gst_datensatz.st_wkz.b_laufrichtung_haspel_links,
			st_config:= haspel_kontroller.st_config,
			e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			st_ctrl_in:= haspel_kontroller.st_ctrl.in,
			haspel1_ctrl_in:= haspel_li.st_ctrl.out,
			haspel2_ctrl_in:= haspel_re.st_ctrl.out,
			st_visu:= haspel_kontroller.st_visu,
			st_ctrl_out=> haspel_kontroller.st_ctrl.out,
			haspel1_ctrl_out=> haspel_li.st_ctrl.in,
			haspel2_ctrl_out=> haspel_re.st_ctrl.in,
			b_materialmangel_bandende=> ST_LampeMaterialMangel.b_materialmangel[0]);

		Haspel_Li.fb(
			t_wartezeit_bandende:= t#5s,
			b_bandende_Bandeinzug := ST_Bandwechsel_Kontroller.e_ls_bandende_li ,
			st_config:= Haspel_Li.fb.st_config,
			st_ctrl_in:= Haspel_Li.st_ctrl.in,
			st_visu := Haspel_Li.st_visu,
			st_zyl_heben:= zyl_haspel_li_heben,
			st_zyl_abspulen:= zyl_haspel_li_abspulen,
			st_zyl_sperren:= zyl_haspel_li_sperren,
			st_ctrl_out=> Haspel_Li.st_ctrl.out);

		Haspel_Re.fb(
			t_wartezeit_bandende:= t#5s,
			b_bandende_Bandeinzug := ST_Bandwechsel_Kontroller.e_ls_bandende_re ,
			st_config:= Haspel_Re.fb.st_config,
			st_ctrl_in:= Haspel_Re.st_ctrl.in,
			st_visu := Haspel_Re.st_visu,
			st_zyl_heben:= zyl_haspel_re_heben,
			st_zyl_abspulen:= zyl_haspel_re_abspulen,
			st_zyl_sperren:= zyl_haspel_re_sperren,
			st_ctrl_out=> Haspel_Re.st_ctrl.out);

		ST_Menzel_Spruehoeler(
			st_config:= bandspruehoeler.st_config,
			st_ctrl_in:= bandspruehoeler.st_ctrl.in,
			lr_achse_position:= bestueckachse.NcToPlc.ModuloActPos,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
			st_ctrl_out =>bandspruehoeler.st_ctrl.out,
			b_oelmangel=> ST_LampeMaterialMangel.b_materialmangel[1]);

		ST_AbfallBlasluft(
			b_wkz_blasluft_aktiv:= gst_datensatz.st_wkz.b_wkz_blasluft_aktiv);

		ST_Lesen_Schreiben_Tag(
			st_config:= Lesen_Schreiben_Tag.st_config,
			st_ctrl_in:= Lesen_Schreiben_Tag.st_ctrl.in,
			st_ctrl_out=> Lesen_Schreiben_Tag.st_ctrl.out);

		ST_Anwahl_Bandeinzug();
		ST_Scope();

	RASTERFOLIE:
		ST_AutoCheckIn( i_IntervalDay:=7 );
		ST_SaveAndLoad();
		ST_Datainit_Stationen();
		ST_Datainit_Achsen();

		ST_EthercatDiag();

		(* Grundmaschine *)
		EtherCatDiag[1]( );
		EtherCatDiag[1].st_config.b_station_aktiv := TRUE;

		(* Hublift links *)
		EtherCatDiag[2]( );
		EtherCatDiag[2].st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_links_aktiv;

		(* Hublift rechts *)
		EtherCatDiag[3]( );
		EtherCatDiag[3].st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_rechts_aktiv;

		(* Bandeinzug *)
		EtherCatDiag[4]( );
		EtherCatDiag[4].st_config.b_station_aktiv := NOT gst_datensatz.st_md.b_wt_transport_simulation;

		ST_UPS(st_config:= UPS.st_config,
			st_ctrl_in:= UPS.st_ctrl.in,
			b_Ups := TRUE,
			st_ctrl_out=> UPS.st_ctrl.out);

		ST_RoutingBackpanel(
			st_config:= routing_backpanel.st_config,
			st_ctrl_in:= routing_backpanel.st_ctrl.in,
			st_ctrl_out=> routing_backpanel.st_ctrl.out);


		ST_MotionFunctionPoints(
			st_ctrl_in:= edit_mfps.st_ctrl.in,
			st_ctrl_out=> edit_mfps.st_ctrl.out);

		ST_Schreibe_Persistente_Daten(
			bExecute:= ,
			bQuit:= ,
			t_schreibintervall:= t#60s,
			b_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			bBusy=> ,
			bError=> ,
			nErrId=> );

		ST_System_DateAndTime();

		betriebsstundenzaehler.fb(
			b_eingekuppelt:= (ST_Z_Achse.fb_state_entry.i16_step > BEREIT AND ST_Z_Achse.fb_state_entry.i16_step < HALT) AND (gi16_betriebsart = AUTO),
			b_reset:= ,
			i32_betriebssekundenzaehler_in:= gst_datensatz.st_md.i32_betriebssekundenzaehler,
			i32_betriebssekundenzaehler=> gst_datensatz.st_md.i32_betriebssekundenzaehler);

		ST_Tuerverriegelung(
			e_quittiertaste:= ST_Safetyprogramm.se_quittiertaste);

		ST_LampeMaterialMangel(b_materialmangel:=  );

		ST_Zylinder();

		ST_start_OSK(bExecute:= ST_Safetyprogramm.se_quittiertaste);

		ST_Euchner_Handbedienpult();

		ST_TippTasten(
			i16_akt_stufe:= ,
			b_initialisierungsphase:= ,
			b_einfaedeln_aktiv:= ,
			st_visu:= visu,
			st_visu_hinten:= visu_hinten);

		ST_Betriebsarten(st_config:= betriebsarten.st_config);

		(* Übernahme der Daten aus der Datenbank: Beladen und Abgabe greifen dann auf diese Konfiguration zu *)
		wt_transport_kontroller.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
		wt_transport_kontroller.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;

		ST_WT_Transport_Kontroller(
			st_config:= wt_transport_kontroller.st_config,
			st_ctrl_in:= wt_transport_kontroller.st_ctrl.in,
			st_visu:= visu,
			st_ctrl_out=> wt_transport_kontroller.st_ctrl.out);

		(* Aktivierung durch den Kontroller *)
		wt_transport_abgabe.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
		wt_transport_abgabe.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;

		ST_WT_Transport_Abgabe(
			st_config:= wt_transport_abgabe.st_config,
			st_ctrl_in:= wt_transport_abgabe.st_ctrl.in,
			e_station_nachher_in_erlaubnis:= ,
			e_station_nachher_in_angekommen:= ,
			st_visu:= wt_transport_abgabe.st_visu,
			st_ctrl_out=> wt_transport_abgabe.st_ctrl.out,
			a_station_nachher_out_anforderung=> a_smema_station_nachher_out_anforderung,
			a_station_nachher_out_abgegeben=> a_smema_station_nachher_out_abgegeben);

		hublift_rechts.st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_rechts_aktiv;
		hublift_rechts.st_config.b_station_in_simulation := gst_datensatz.st_md.b_hublift_rechts_simulation;

		ST_Hublift_rechts(
			st_config:= hublift_rechts.st_config,
			st_ctrl_in:= hublift_rechts.st_ctrl.in,
			e_station_vorher_in_anforderung	:= ,
			e_station_vorher_in_abgegeben:= ,
			st_visu:= hublift_rechts.st_visu,
			st_ctrl_out=> hublift_rechts.st_ctrl.out,
			a_station_vorher_out_erlaubnis=> ,
			a_station_vorher_out_angekommen=> );
		IF hublift_rechts.st_config.b_station_aktiv OR hublift_rechts.st_config.b_station_in_simulation THEN
			ST_Hublift_rechts.e_station_vorher_in_abgegeben := ST_WT_Transport_Abgabe.a_station_nachher_out_abgegeben;
			ST_Hublift_rechts.e_station_vorher_in_anforderung := ST_WT_Transport_Abgabe.a_station_nachher_out_anforderung;
			ST_WT_Transport_Abgabe.e_station_nachher_in_angekommen := ST_Hublift_rechts.a_station_vorher_out_angekommen;
			ST_WT_Transport_Abgabe.e_station_nachher_in_erlaubnis := ST_Hublift_rechts.a_station_vorher_out_erlaubnis;
		ELSE
			ST_WT_Transport_Abgabe.e_station_nachher_in_angekommen := e_smema_station_nachher_in_angekommen;
			ST_WT_Transport_Abgabe.e_station_nachher_in_erlaubnis := e_smema_station_nachher_in_erlaubnis;
		END_IF

		balluff_tag_reader.fb(
			st_config:= balluff_tag_reader.fb.st_config,
			i16_addresse:= ,
			i16_anzahl_byte:= ,
			s_schreib_daten:= ,
			st_ctrl_in:= balluff_tag_reader.st_ctrl.in,
			s_lese_daten=> ,
			st_ctrl_out=> balluff_tag_reader.st_ctrl.out);

		barcode.fb(
			st_config:= barcode.fb.st_config,
			st_barcode_daten := gst_barcode_daten,
			b_steuerung_ein := ST_Safetyprogramm.se_steuerung_ein,
			b_bandende_links := ST_Bandwechsel_Kontroller.e_ls_bandende_li ,
			b_bandende_rechts := ST_Bandwechsel_Kontroller.e_ls_bandende_re,
			b_bandende_1720 := ST_Bandeinzug_Kontroller_1720.e_ls_bandende_li,
			b_band_nicht_gescannt=> ST_LampeMaterialMangel.b_materialmangel[5]);

		visu_hinten.in.bandfreigabe[0] := gst_barcode_daten.b_band_rechts_ok;
		visu_hinten.in.bandfreigabe[1] := gst_barcode_daten.b_band_links_ok;
		visu_hinten.in.band_ID[0] := gst_barcode_daten.b_band_ID_rechts_ok;
		visu_hinten.in.band_ID[1] := gst_barcode_daten.b_band_ID_links_ok;

		ST_VisuRouter();

		ST_Message_Produktion();

 		ST_Rafl_Stoerungen_Quitt(
			st_config:= stoerungen_quittieren.st_config,
			st_ctrl_in:= stoerungen_quittieren.st_ctrl.in,
			st_visu:= visu,
			st_visu_hinten:= visu_hinten,
			st_ctrl_out=> stoerungen_quittieren.st_ctrl.out,
			b_lampe_stoerung=> ST_Betriebsfreigaben.b_lampe_stoerung,
			b_lampe_produktion=> ST_Betriebsfreigaben.b_lampe_produktion);

		ST_Rasterfolienmontage(
			st_config:= rasterfolienmontage.st_config,
			st_ctrl_in:= rasterfolienmontage.st_ctrl.in,
			st_visu:= rasterfolienmontage.st_visu,
			st_ctrl_out=> rasterfolienmontage.st_ctrl.out);

		ST_Rasterfolieneinzug(
			st_config:= rasterfolieneinzug.st_config,
			st_ctrl_in:= rasterfolieneinzug.st_ctrl.in,
			st_visu:= rasterfolieneinzug.st_visu,
			st_ctrl_out=> rasterfolieneinzug.st_ctrl.out);

		ST_Bestueckachse(
			st_config_achse:= axis_bestueckachse.st_config,
			st_ctrl_in:= axis_bestueckachse.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			e_tuere_vorne_offen:= ST_Safetyprogramm.se_tuere_vorne_offen,
			e_tuere_hinten_offen:= ST_Safetyprogramm.se_tuere_hinten_offen,
			st_visu:= axis_bestueckachse.st_visu,
			st_ctrl_out=> axis_bestueckachse.st_ctrl.out);

		ST_Z_Achse(
			st_config_achse:= axis_z_achse.st_config,
			st_ctrl_in:= axis_z_achse.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			e_tuere_vorne_offen:= ST_Safetyprogramm.se_tuere_vorne_offen,
			e_tuere_hinten_offen:= ST_Safetyprogramm.se_tuere_hinten_offen,
			st_visu:= axis_z_achse.st_visu,
			st_ctrl_out=> axis_z_achse.st_ctrl.out,
			t_Z_Achse_ausfahren=>visu.ST_Service.t_Z_Achse_ausfahren,
			t_Bestueckung=>visu.ST_Service.t_Bestueckung,
			t_Z_Achse_einfahren=>visu.ST_Service.t_Z_Achse_einfahren);

		ST_Y_Achse(
			st_config_achse:= axis_y_achse.st_config,
			st_ctrl_in:= axis_y_achse.st_ctrl.in,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			e_ba_mit_bedingungen:= ST_Safetyprogramm.se_ba_mit_bedingungen,
			e_tuere_vorne_offen:= ST_Safetyprogramm.se_tuere_vorne_offen,
			e_tuere_hinten_offen:= ST_Safetyprogramm.se_tuere_hinten_offen,
			e_not_steu_tuer_schutz_ok:= ,
			st_visu:= axis_y_achse.st_visu,
			st_ctrl_out=> axis_y_achse.st_ctrl.out);

		ST_Gesamthubzaehler();

		(* Aktivierung durch den Kontroller *)
		wt_transport_beladen.st_config.b_station_aktiv := gst_datensatz.st_md.b_wt_transport_aktiv;
		wt_transport_beladen.st_config.b_station_in_simulation := gst_datensatz.st_md.b_wt_transport_simulation;

		ST_WT_Transport_Beladen(
			st_config:= wt_transport_beladen.st_config,
			st_ctrl_in:= wt_transport_beladen.st_ctrl.in,
			e_station_vorher_in_anforderung	:= ,
			e_station_vorher_in_abgegeben:= ,
			st_visu:= wt_transport_beladen.st_visu,
			st_ctrl_out=> wt_transport_beladen.st_ctrl.out,
			a_station_vorher_out_erlaubnis=> a_smema_station_vorher_out_erlaubnis,
			a_station_vorher_out_angekommen=> a_smema_station_vorher_out_angekommen,
			t_WT_WechselZeit=>visu.ST_Service.t_WT_wechsel,
			t_traegerwechselzeit=>visu.ST_Service.t_traegerwechselzeit,
			t_Zentrierer_ausfahren=>visu.ST_Service.t_Zentrierer_ausfahren,
			t_Zentrierer_einfahren=>visu.ST_Service.t_Zentrierer_einfahren,
			t_komplett_zyklus=>visu.ST_Service.t_komplett_zyklus,);

		hublift_links.st_config.b_station_aktiv := gst_datensatz.st_md.b_hublift_links_aktiv;
		hublift_links.st_config.b_station_in_simulation := gst_datensatz.st_md.b_hublift_links_simulation;

		ST_Hublift_links(
			st_config:= hublift_links.st_config,
			st_ctrl_in:= hublift_links.st_ctrl.in,
			e_station_nachher_in_erlaubnis:= ,
			e_station_nachher_in_angekommen:= ,
			st_visu:= hublift_links.st_visu,
			st_ctrl_out=> hublift_links.st_ctrl.out,
			a_station_nachher_out_anforderung=> ,
			a_station_nachher_out_abgegeben=> );
		IF hublift_links.st_config.b_station_aktiv OR hublift_links.st_config.b_station_in_simulation THEN
			ST_Hublift_links.e_station_nachher_in_angekommen := ST_WT_Transport_Beladen.a_station_vorher_out_angekommen;
			ST_Hublift_links.e_station_nachher_in_erlaubnis := ST_WT_Transport_Beladen.a_station_vorher_out_erlaubnis;
			ST_WT_Transport_Beladen.e_station_vorher_in_abgegeben := ST_Hublift_links.a_station_nachher_out_abgegeben;
			ST_WT_Transport_Beladen.e_station_vorher_in_anforderung := ST_Hublift_links.a_station_nachher_out_anforderung;
		ELSE
			ST_WT_Transport_Beladen.e_station_vorher_in_abgegeben := e_smema_station_vorher_in_abgegeben;
			ST_WT_Transport_Beladen.e_station_vorher_in_anforderung := e_smema_station_vorher_in_anforderung;
		END_IF

		ST_Lesen_Schreiben_Tag(
			st_config:= Lesen_Schreiben_Tag.st_config,
			st_ctrl_in:= Lesen_Schreiben_Tag.st_ctrl.in,
			st_ctrl_out=> Lesen_Schreiben_Tag.st_ctrl.out);

		ST_Anwahl_Bandeinzug();
		ST_Scope();

		ST_TouchProbe();

		ST_Haspel_Kontroller_2H(
			t_abschaltzeit_motor:= haspel_kontroller.t_abschaltzeit_motor,
			b_drehrichtung_antrieb_links := gst_datensatz.st_wkz.b_laufrichtung_haspel_links,
			st_config:= haspel_kontroller.st_config,
			e_druckwaechter:= ST_Betriebsfreigaben.e_druckwaechter,
			e_steuerung_ein:= ST_Safetyprogramm.se_steuerung_ein,
			st_ctrl_in:= haspel_kontroller.st_ctrl.in,
			haspel1_ctrl_in:= haspel_li.st_ctrl.out,
			haspel2_ctrl_in:= haspel_re.st_ctrl.out,
			st_visu:= haspel_kontroller.st_visu,
			st_ctrl_out=> haspel_kontroller.st_ctrl.out,
			haspel1_ctrl_out=> haspel_li.st_ctrl.in,
			haspel2_ctrl_out=> haspel_re.st_ctrl.in,
			b_materialmangel_bandende=> ST_LampeMaterialMangel.b_materialmangel[0]);

		Haspel_Li.fb(
			t_wartezeit_bandende:= t#5s,
			b_bandende_Bandeinzug := ST_Bandwechsel_Kontroller.e_ls_bandende_li ,
			b_band_ok := gst_barcode_daten.b_band_links_ok AND gst_barcode_daten.b_band_ID_links_ok,
			st_config:= Haspel_Li.fb.st_config,
			st_ctrl_in:= Haspel_Li.st_ctrl.in,
			st_visu := Haspel_Li.st_visu,
			st_zyl_heben:= zyl_haspel_li_heben,
			st_zyl_abspulen:= zyl_haspel_li_abspulen,
			st_zyl_sperren:= zyl_haspel_li_sperren,
			st_ctrl_out=> Haspel_Li.st_ctrl.out);

		Haspel_Re.fb(
			t_wartezeit_bandende:= t#5s,
			b_bandende_Bandeinzug := ST_Bandwechsel_Kontroller.e_ls_bandende_re ,
			b_band_ok := gst_barcode_daten.b_band_rechts_ok AND gst_barcode_daten.b_band_ID_rechts_ok ,
			st_config:= Haspel_Re.fb.st_config,
			st_ctrl_in:= Haspel_Re.st_ctrl.in,
			st_visu := Haspel_Re.st_visu,
			st_zyl_heben:= zyl_haspel_re_heben,
			st_zyl_abspulen:= zyl_haspel_re_abspulen,
			st_zyl_sperren:= zyl_haspel_re_sperren,
			st_ctrl_out=> Haspel_Re.st_ctrl.out);

END_CASE

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Band' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Bandeinzug_Kontroller_1700
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu						: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz					: TON;
	fb_ton_uez					: TON;
	fb_ton_quitt					: TON;
	fb_state_entry					: ST_StateEntry;
	b_einzug_stop				: BOOL := FALSE;

	fb_r_trig_vorschubkontrolle		: R_TRIG;
	fb_f_trig_vorschubkontrolle		: F_TRIG;
	fb_r_trig_nocke_einzug			: R_TRIG;
	fb_f_trig_nocke_einzug			: F_TRIG;
	b_hm_pos_flanke_vorschub	: BOOL := FALSE;
	b_hm_neg_flanke_vorschub	: BOOL := FALSE;
	sm_fehler_bandvorschub		: BOOL := FALSE;
	sm_keine_busverbindung	: BOOL := FALSE;

	e_wc_state					AT %I* : BOOL;	(* 0=Data valid, 1=Data invalid *)
	e_gls_bandvorschubkontrolle	AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Flanken *)
fb_f_trig_vorschubkontrolle(CLK:= e_gls_bandvorschubkontrolle, Q=> );
fb_r_trig_vorschubkontrolle(CLK:= e_gls_bandvorschubkontrolle, Q=> );
fb_f_trig_nocke_einzug(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_PNEUMATIKBANDEINZUG_GLS], Q=> );
fb_r_trig_nocke_einzug(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_PNEUMATIKBANDEINZUG_GLS], Q=> );

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
	(* Allgemeine Fehler *)
	IF	NOT gst_datensatz.st_md.b_wt_transport_simulation AND
		(zyl_bandfaenger.st_ctrl.out.b_fehler OR
		zyl_bandklemmen.st_ctrl.out.b_fehler)
		 THEN
			fb_state_entry.i16_next_step := FEHLER;

	(* Zylinder im Handbetrieb *)
	ELSIF	 gi16_betriebsart = HAND AND (
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bandfaenger.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bandklemmen.fb.st_config.i16_identnummer) )
			THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			zyl_bandfaenger.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bandfaenger.st_ctrl.in.b_einfahren := FALSE;
			 zyl_bandklemmen.st_ctrl.in.b_ausfahren := FALSE;
			 zyl_bandklemmen.st_ctrl.in.b_einfahren := FALSE;
			sm_fehler_bandvorschub := FALSE;
			sm_keine_busverbindung := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_bandfaenger.st_ctrl.in.b_quittieren := FALSE;
			 zyl_bandklemmen.st_ctrl.in.b_quittieren := FALSE;
			IF gst_datensatz.st_md.b_wt_transport_simulation THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSE
				(*fb_state_entry.i16_next_step := 20; Bei nächster TSM-Änderung bitte aktivieren*)
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	20: (* Prüfe, ob Busverbindung vorhanden ist *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wc_state THEN	(* Prüfe Busverbindung ( 0=Data valid, 1=Data invalid )*)
			sm_keine_busverbindung := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSE
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			BANDWECHSLER_V2:
				(* Versuchsablauf zum mehrfach Biegen eines Bandes *)
				(* Die Anzahl der Werkzeughübe zum Biegen wird durch das Bestückprogramm bestimmt *)
				IF b_einzug_stop AND nockenschaltwerk_bestueckachse.fb.arr_spur[SP_OT] THEN
					fb_state_entry.i16_next_step := 500;
				ELSE
					fb_state_entry.i16_next_step := 200;
				END_IF
			SERVO:
				;
		END_CASE;

(*===========================Bandvorschub mit GLS-Kontrolle============================*)
	200:	(* Warte auf Vorschubnocke  und Freigabe von der Bestückachse *)
		(* Die Freigabe erfolgt nur im normalen Produktionsablauf; nicht bei Bandwechsel, Einfädeln, ... da hier keine Überwachung erfolgen soll. *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_nocke_einzug.Q AND gi16_betriebsart <> HAND AND st_ctrl_in.b_freigabe THEN
			b_hm_pos_flanke_vorschub := FALSE;
			b_hm_neg_flanke_vorschub := FALSE;
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* Band wird vorgeschoben *)
		(* Vorschubkontrolle durch positive Flanke *)
		IF fb_r_trig_vorschubkontrolle.Q THEN
			b_hm_pos_flanke_vorschub := TRUE;
		END_IF
		(* Vorschubkontrolle durch negative Flanke *)
		IF fb_f_trig_vorschubkontrolle.Q THEN
			b_hm_neg_flanke_vorschub := TRUE;
		END_IF

		(* bei abgeschalteten Nocken *)
		IF	NOT gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_PNEUMATIKBANDEINZUG_GLS].b_camvalid THEN
			b_hm_neg_flanke_vorschub := TRUE;
			b_hm_pos_flanke_vorschub := TRUE;
		END_IF
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_f_trig_nocke_einzug.Q THEN
			IF b_hm_pos_flanke_vorschub AND b_hm_neg_flanke_vorschub THEN
				fb_state_entry.i16_next_step := 200;
			ELSE
				sm_fehler_bandvorschub := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		ELSIF gi16_betriebsart = HAND OR NOT st_ctrl_in.b_freigabe THEN
			fb_state_entry.i16_next_step := 200;
		END_IF

(*=======================================================*)
	500:	(* Nocken deaktivieren und Bandfänger deaktivieren/einfahren sowie Bandklemmen ausfahren*)
		IF fb_state_entry.E THEN
			CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

				BANDWECHSLER_V2:
					(* Bandwechsler V2 ohne Sensoren und anderen Zylindern *)
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_EINFAHREN].b_camvalid := FALSE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_AUSFAHREN].b_camvalid := FALSE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_EINFAHREN].b_camvalid := FALSE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN].b_camvalid := FALSE;
				SERVO:
					;
			END_CASE;

			zyl_bandfaenger.fb.b_no_gesteuert_im_norm_betrieb := TRUE;
			zyl_bandklemmen.fb.b_no_gesteuert_im_norm_betrieb := TRUE;
			(* Zylinder einfahren *)
			zyl_bandfaenger.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandklemmen.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bandfaenger.st_ctrl.out.b_eingefahren AND zyl_bandklemmen.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bandfaenger.st_ctrl.in.b_einfahren := FALSE;
			zyl_bandklemmen.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 510;
		END_IF

(*=======================================================*)
	510:
		IF fb_state_entry.E THEN
			;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT b_einzug_stop THEN
			(* Bandwechsler V1 *)
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_EINFAHREN].b_camvalid := TRUE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_AUSFAHREN].b_camvalid := TRUE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_EINFAHREN].b_camvalid := TRUE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDFAENGER_AUSFAHREN].b_camvalid := TRUE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_EINFAHREN].b_camvalid := TRUE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_AUSFAHREN].b_camvalid := TRUE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_EINFAHREN].b_camvalid := TRUE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_UW_BANDKLEMMEN_AUSFAHREN].b_camvalid := TRUE;
			(* Bandwechsler V2 ohne Sensoren und anderen Zylindern *)
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_EINFAHREN].b_camvalid := TRUE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_AUSFAHREN].b_camvalid := TRUE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_EINFAHREN].b_camvalid := TRUE;
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN].b_camvalid := TRUE;

			zyl_bandfaenger.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
			zyl_bandklemmen.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_bandfaenger.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandklemmen.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_bandfaenger.st_ctrl.in.b_quittieren := TRUE;
			zyl_bandklemmen.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			zyl_bandfaenger.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandklemmen.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_bandfaenger.st_ctrl.in.b_quittieren := TRUE;
			zyl_bandklemmen.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_bandvorschub;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;(* belegt  durch Bandeinzugskontroller 1720 *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;(* belegt  durch Bandeinzugskontroller 1720 *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_keine_busverbindung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Band' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Bandwechsel_Kontroller
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu						: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
	b_materialmangel				: BOOL;
	b_materialmangel_links				: BOOL;
	b_materialmangel_rechts				: BOOL;
END_VAR
VAR
	fb_ton_wz					: TON;
	fb_ton_uez					: TON;
	fb_ton_quitt					: TON;
	fb_tof_bandende_li			: TOF;
	fb_tof_bandende_re			: TOF;
	fb_ton_bandende_li			: TON;
	fb_ton_bandende_re			: TON;
	fb_r_trig_start					: R_TRIG;
	fb_r_trig_auto_Bandwechsel_aus: R_TRIG;
	fb_state_entry					: ST_StateEntry;
	b_ibn_start					: BOOL := FALSE;
	fb_r_trig_ibn_start				: R_TRIG;
	fb_ton_ibn_start				: TON;
	i16_vorgabe_einfaedeln		: INT := 0;
	i16_akt_einfaedeln			: INT := 0;
	i16_vorgabe_ausfaedeln		: INT := 0;
	i16_akt_ausfaedeln			: INT := 0;
	i							: INT := 0;
	b_ausgefaedelt				: BOOL;
	b_spulenwechsel				: BOOL;

	sm_halter_nicht_oben			: BOOL:= FALSE;
	sm_bandwechsel_ohne_ende	: BOOL:= FALSE;
	sm_kein_band_anderer_einzug	: BOOL:= FALSE;
	sm_kein_band_in_akt_einzug	: BOOL:= FALSE;
	bm_bandwechselvorgang		: BOOL := FALSE;
	bm_bandwechsel_manuell		: BOOL := FALSE;

	e_ls_bandende_li				AT %I* : BOOL;
	e_ls_bandende_re			AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

fb_ton_bandende_li(IN:= e_ls_bandende_li, PT:= t#1000ms, Q=> , ET=> );
fb_ton_bandende_re(IN:= e_ls_bandende_re, PT:= t#1000ms, Q=> , ET=> );
fb_tof_bandende_li(IN:= fb_ton_bandende_li.Q, PT:= t#1100ms, Q=> , ET=> );
fb_tof_bandende_re(IN:= fb_ton_bandende_re.Q, PT:= t#1100ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );

(* Inbetriebnahme *)
fb_r_trig_ibn_start (CLK:= b_ibn_start , Q=> );
fb_ton_ibn_start (IN:= , PT:= t#1s, Q=> , ET=> );

IF fb_r_trig_ibn_start .Q THEN
	fb_ton_ibn_start .IN := TRUE;
ELSE
	IF fb_ton_ibn_start .Q THEN
		b_ibn_start  := FALSE;
	 	fb_ton_ibn_start .IN := FALSE;
	END_IF
END_IF

(* auto Bandwechsel aus *)
fb_r_trig_auto_Bandwechsel_aus(CLK:=visu_hinten.out.auto_Bandwechsel_aus, Q=>);

IF	fb_r_trig_auto_Bandwechsel_aus.Q THEN
	gst_datensatz.st_md.b_auto_Bandwechsel:=NOT gst_datensatz.st_md.b_auto_Bandwechsel;
END_IF
visu_hinten.in.Lampe_auto_Bandwechsel:=gst_datensatz.st_md.b_auto_Bandwechsel;


(* Hier nur Abschaltungen welche zum Bandwechsel Stop führen müssen *)
IF	axis_bestueckachse.st_ctrl.out.b_fehler OR
	axis_z_achse.st_ctrl.out.b_fehler OR
	axis_y_achse.st_ctrl.out.b_fehler OR
	bandspruehoeler.st_ctrl.out.b_fehler OR
	bandeinzug_kontroller.st_ctrl.out.b_fehler OR
	bandwechsel_kontroller.st_ctrl.out.b_fehler OR
	wkz_absicherung.st_ctrl.out.b_fehler OR
	wt_transport_kontroller.st_ctrl.out.b_fehler OR
	hublift_links.st_ctrl.out.b_fehler OR
	hublift_rechts.st_ctrl.out.b_fehler OR
	balluff_tag_reader.st_ctrl.out.b_fehler OR
	haspel_kontroller.st_ctrl.out.b_fehler OR
	bbgen.st_ctrl.out.b_fehler OR
	einpresskraft_kontroller.st_ctrl.out.b_fehler OR
	edit_mfps.st_ctrl.out.b_fehler OR
	Lesen_Schreiben_Tag.st_ctrl.out.b_fehler OR
	Service.st_ctrl.out.b_fehler OR
	gi16_betriebsart = HAND
	THEN
		visu_hinten.in.b_bandwechsel_aktiv := FALSE;
		visu_hinten.in.current_visu_folie := 'BA_1700_BAND_EINFAEDELN';
END_IF

(* Toplevel *)
IF fb_state_entry.i16_step < FEHLER THEN
	IF st_ctrl_in.b_stop THEN
		fb_state_entry.i16_next_step := STOP;
	END_IF
	(* Allgemeine Fehler *)
	IF	NOT gst_datensatz.st_md.b_wt_transport_simulation AND
		(zyl_bawe_vorschub.st_ctrl.out.b_fehler OR
		zyl_bawe_querschub.st_ctrl.out.b_fehler OR
		zyl_bawe_faenger_li.st_ctrl.out.b_fehler OR
		zyl_bawe_faenger_re.st_ctrl.out.b_fehler OR
		zyl_bawe_halter_li.st_ctrl.out.b_fehler OR
		zyl_bawe_halter_re.st_ctrl.out.b_fehler OR
		zyl_haspel_verschieben.st_ctrl.out.b_fehler OR
		zyl_bandeinzuege_verschieben.st_ctrl.out.b_fehler)
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	(* Zylinder im Handbetrieb *)
	ELSIF gi16_betriebsart = HAND AND (
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bawe_vorschub.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bawe_querschub.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bawe_faenger_li.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bawe_faenger_re.fb.st_config.i16_identnummer ) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bawe_halter_li.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bawe_halter_re.fb.st_config.i16_identnummer)OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_haspel_verschieben.fb.st_config.i16_identnummer)OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bandeinzuege_verschieben.fb.st_config.i16_identnummer))
			THEN
				fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* Bandwechsel wird durch eine gelbe Dauerleuchte angezeigt *)
b_materialmangel := b_materialmangel_links OR b_materialmangel_rechts;

IF	b_ausgefaedelt THEN
	IF 	b_materialmangel_links AND
		NOT fb_tof_bandende_li.Q THEN
		b_materialmangel_links := FALSE;
		b_ausgefaedelt:=FALSE;
	END_IF
	IF 	b_materialmangel_rechts AND
		NOT fb_tof_bandende_re.Q   THEN
		b_materialmangel_rechts := FALSE;
		b_ausgefaedelt:=FALSE;
	END_IF
ELSE
	IF	gi16_maschinenstatusinfo = STATUS_MASCHINE_ARBEITET THEN
		IF 	NOT fb_tof_bandende_li.Q  AND zyl_bawe_querschub.fb.e_sensor1_eingefahren THEN
			b_materialmangel_links := TRUE;
		END_IF
		IF	NOT fb_tof_bandende_re.Q  AND zyl_bawe_querschub.fb.e_sensor1_ausgefahren THEN
			b_materialmangel_rechts := TRUE;
		END_IF
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN	:= FALSE;
			fb_ton_quitt.IN := FALSE;
			sm_halter_nicht_oben := FALSE;
			sm_bandwechsel_ohne_ende := FALSE;
			sm_kein_band_anderer_einzug := FALSE;
			sm_kein_band_in_akt_einzug := FALSE;
			bm_bandwechselvorgang := FALSE;
			bm_bandwechsel_manuell := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_fertig_2 := FALSE;
			i16_vorgabe_ausfaedeln := 5;
			zyl_bawe_vorschub.st_ctrl.in.b_einfahren := FALSE;
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bawe_querschub.st_ctrl.in.b_einfahren := FALSE;
			zyl_bawe_querschub.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := FALSE;
			zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := FALSE;
			zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bawe_halter_li.st_ctrl.in.b_einfahren := FALSE;
			zyl_bawe_halter_li.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bawe_halter_re.st_ctrl.in.b_einfahren := FALSE;
			zyl_bawe_halter_re.st_ctrl.in.b_ausfahren := FALSE;
			zyl_haspel_verschieben.st_ctrl.in.b_einfahren := FALSE;
			zyl_haspel_verschieben.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_einfahren := FALSE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_ausfahren := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_startpos := FALSE;
			visu_hinten.in.b_bandwechsel_aktiv := FALSE;
			b_materialmangel_links := FALSE;
			b_materialmangel_rechts := FALSE;
			b_ausgefaedelt:=FALSE;
			b_spulenwechsel:=FALSE;

			IF gst_datensatz.st_wkz.i16_typ_bandeinzug = SERVO THEN
				i16_vorgabe_einfaedeln :=2;
			ELSE
				i16_vorgabe_einfaedeln := gst_datensatz.st_wkz.i16_vorgabe_einfaedeln;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_bawe_vorschub.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_querschub.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_faenger_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_faenger_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_haspel_verschieben.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_quittieren := FALSE;

			IF NOT gst_datensatz.st_md.b_wt_transport_simulation THEN
				fb_state_entry.i16_next_step := 20;
			ELSE
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	20:	(* Abfrage Stellung Bandwechselquerschub  *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_querschub.fb.e_sensor1_eingefahren THEN
			fb_state_entry.i16_next_step := 30;
		ELSIF zyl_bawe_querschub.fb.e_sensor1_ausgefahren THEN
			fb_state_entry.i16_next_step := 60;
		ELSE
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Bandwechselquerschub einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_querschub.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_querschub.st_ctrl.out.b_eingefahren THEN
			zyl_bawe_querschub.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:	(* Haspeln rechts: Haspel verschieben einfahren und Bandabzug ausfahren *)
		IF fb_state_entry.E THEN
			zyl_haspel_verschieben.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_ausfahren := TRUE;
		END_IF
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  	zyl_haspel_verschieben.st_ctrl.out.b_eingefahren AND
 			zyl_bandeinzuege_verschieben.st_ctrl.out.b_ausgefahren
			THEN
				zyl_haspel_verschieben.st_ctrl.in.b_einfahren := FALSE;
				zyl_bandeinzuege_verschieben.st_ctrl.in.b_ausfahren := FALSE;
				fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:	(* Halter rechts ausfahren und Band heben, Halter links einfahren  *)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_re.st_ctrl.in.b_ausfahren := TRUE;
			zyl_bawe_halter_li.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_halter_re.st_ctrl.out.b_ausgefahren AND
			zyl_bawe_halter_li.st_ctrl.out.b_eingefahren
			THEN
				zyl_bawe_halter_re.st_ctrl.in.b_ausfahren := FALSE;
				zyl_bawe_halter_li.st_ctrl.in.b_einfahren := FALSE;
				fb_state_entry.i16_next_step := 90;
		END_IF

(*=======================================================*)
	60:	(* Bandwechselquerschub ausfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_querschub.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_querschub.st_ctrl.out.b_ausgefahren THEN
			zyl_bawe_querschub.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 70;
		END_IF

(*=======================================================*)
	70:	(* Haspeln links: Haspel verschieben ausfahren und Bandabzug einfahren *)
		IF fb_state_entry.E THEN
			zyl_haspel_verschieben.st_ctrl.in.b_ausfahren := TRUE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_einfahren := TRUE;
		END_IF
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  	zyl_haspel_verschieben.st_ctrl.out.b_ausgefahren AND
 			zyl_bandeinzuege_verschieben.st_ctrl.out.b_eingefahren
			THEN
				zyl_haspel_verschieben.st_ctrl.in.b_ausfahren := FALSE;
				zyl_bandeinzuege_verschieben.st_ctrl.in.b_einfahren := FALSE;
				fb_state_entry.i16_next_step := 80;
		END_IF

(*=======================================================*)
	80:	(* Halter links ausfahren und Band heben, Halter rechts einfahren  *)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_li.st_ctrl.in.b_ausfahren := TRUE;
			zyl_bawe_halter_re.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_halter_li.st_ctrl.out.b_ausgefahren AND
			zyl_bawe_halter_re.st_ctrl.out.b_eingefahren
			THEN
				zyl_bawe_halter_li.st_ctrl.in.b_ausfahren := FALSE;
				zyl_bawe_halter_re.st_ctrl.in.b_einfahren := FALSE;
				fb_state_entry.i16_next_step := 90;
		END_IF

(*=======================================================*)
	90:	(* Fänger links und rechts einfahren, damit Vorschub nach vorne fahren kann *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := TRUE;
			zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_faenger_li.st_ctrl.out.b_eingefahren AND
			zyl_bawe_faenger_re.st_ctrl.out.b_eingefahren
			THEN
				zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := FALSE;
				zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := FALSE;
				fb_state_entry.i16_next_step := 95;
		END_IF

(*=======================================================*)
	95:	(* Vorschub ausfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_ausgefahren THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			i16_akt_einfaedeln := 0;
			i16_akt_ausfaedeln := 0;
			bm_bandwechselvorgang := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Warte darauf, das ein Band leer wird und Starte Teil 1 zum Bandausfädeln *)
		(* Freigaben bei installietem Barcodereader wieder rein *)
		IF fb_r_trig_start.Q OR fb_r_trig_ibn_start.Q THEN
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_fertig_2 := FALSE;
			(* Nach dem Bandwechsel soll die Maschine in Einzelfertigung gehen*)
			IF NOT fb_tof_bandende_li.Q  AND zyl_bawe_querschub.fb.e_sensor1_eingefahren (*AND gst_barcode_persistent.b_band_rechts_ok*) THEN
				bm_bandwechselvorgang := TRUE;
				(* Nach dem Bandwechsel geht die Maschine in Abhängigkeit der Bedienereinstellung auf der Visu in Einzelfertigung *)
				fb_state_entry.i16_next_step := 200;
			ELSIF NOT fb_tof_bandende_re.Q  AND zyl_bawe_querschub.fb.e_sensor1_ausgefahren (* AND gst_barcode_persistent.b_band_links_ok*) THEN
				bm_bandwechselvorgang := TRUE;
				(* Nach dem Bandwechsel geht die Maschine in Abhängigkeit der Bedienereinstellung auf der Visu in Einzelfertigung *)
				fb_state_entry.i16_next_step := 500;
			ELSE
				sm_bandwechsel_ohne_ende := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF


(*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*)
(*========================Bandeinzug links ist leer===============================*)
	200:	(* Fänger links ausfahren zum Band halten, Fänger rechts einfahren zur Bandfreigabe im rechten Einzug - Halter gegensinnig *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := TRUE;
			zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := TRUE;
			zyl_bawe_halter_li.st_ctrl.in.b_einfahren := TRUE;
			zyl_bawe_halter_re.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_faenger_li.st_ctrl.out.b_ausgefahren AND
			zyl_bawe_faenger_re.st_ctrl.out.b_eingefahren AND
			zyl_bawe_halter_li.st_ctrl.out.b_eingefahren AND
			zyl_bawe_halter_re.st_ctrl.out.b_ausgefahren AND
			gb_ba_auto_kontroller
			THEN
				zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := FALSE;
				zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := FALSE;
				zyl_bawe_halter_li.st_ctrl.in.b_einfahren := FALSE;
				zyl_bawe_halter_re.st_ctrl.in.b_ausfahren := FALSE;
				fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* Band-Zylinder einfahren bzw. Servobandeinzug lösen *)
		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

			BANDWECHSLER_V2:
				IF fb_state_entry.E THEN
					(* Zylinder einfahren *)
					zyl_bandfaenger.st_ctrl.in.b_einfahren := TRUE;
					zyl_bandklemmen.st_ctrl.in.b_einfahren := TRUE;
				END_IF
					(* Bandwechsler V2 ohne Sensoren und anderen Zylindern *)
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_EINFAHREN].b_camvalid := FALSE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_AUSFAHREN].b_camvalid := FALSE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_EINFAHREN].b_camvalid := FALSE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN].b_camvalid := FALSE;
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF 	zyl_bandfaenger.st_ctrl.out.b_eingefahren AND
					zyl_bandklemmen.st_ctrl.out.b_eingefahren AND
					gb_ba_auto_kontroller
					THEN
						zyl_bandfaenger.st_ctrl.in.b_einfahren := FALSE;
						zyl_bandklemmen.st_ctrl.in.b_einfahren := FALSE;
						fb_state_entry.i16_next_step := 220;
				END_IF

			SERVO:
				zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := TRUE;
				zyl_bawe_halter_li.st_ctrl.in.b_einfahren := TRUE;
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF 	zyl_bawe_faenger_li.st_ctrl.out.b_eingefahren AND
					zyl_bawe_halter_li.st_ctrl.out.b_eingefahren AND
					gb_ba_auto_kontroller
					THEN
						zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := FALSE;
						zyl_bawe_halter_li.st_ctrl.in.b_einfahren := FALSE;
						fb_state_entry.i16_next_step := 216;
				END_IF
		END_CASE;

(*=======================================================*)
	216:	(* Servobandeinzug rückwärts fahren, damit die Ausschiebezylinder das Band sicher erwischen *)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_ausfaedeln_servo := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_ausgefaedelt_servo AND NOT fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_ausfaedeln_servo := FALSE;
			fb_state_entry.i16_next_step := 217;(*Neu*)
		END_IF

(*=======================================================*)
	217:	(* Fänger ins Band fahren, damit die Bremse gelöst werden kann *)
		IF fb_state_entry.E THEN
				zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_faenger_li.st_ctrl.out.b_ausgefahren AND
			gb_ba_auto_kontroller
			THEN
				zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := FALSE;
				fb_state_entry.i16_next_step := 218;
		END_IF

(*=======================================================*)
	218:	(* Bremse an Servobandeinzug lösen, damit Band heraus gezogen werden kann. Die Bestückachse hat die Slavekopplung bereits gelöst. *)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_bremse_auf := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_bremse_geoeffnet AND NOT fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_bremse_auf := FALSE;
			fb_state_entry.i16_next_step := 220;
		END_IF

(*=======================================================*)
	220:	(* Vorschub einfahren und Band aus WKZ rausziehen *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_einfahren := TRUE;
			i16_akt_ausfaedeln := i16_akt_ausfaedeln + 1;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_vorschub.st_ctrl.in.b_einfahren := FALSE;
			IF i16_akt_ausfaedeln <= i16_vorgabe_ausfaedeln THEN
				fb_state_entry.i16_next_step := 230;
			ELSE
				fb_state_entry.i16_next_step := 280;
			END_IF
		END_IF

(*=======================================================*)
	230:	(* Bandwechselhalter links ausfahren um Band nachfassen zu können *)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_li.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_halter_li.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_halter_li.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 240;
		END_IF

(*=======================================================*)
	240:	(* Bandwechselfänger links einfahren*)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_li.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 250;
		END_IF

(*=======================================================*)
	250:	(* Vorschub ausfahren und Band nachfassen *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 260;
		END_IF

(*=======================================================*)
	260:	(* Bandwechselfänger links ausfahren zum Band halten *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_li.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 270;
		END_IF

(*=======================================================*)
	270:	(* Bandwechselhalter links einfahren und Band freigeben*)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_li.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_halter_li.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_halter_li.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 220;
		END_IF

(*=======================================================*)
	280:	(* Fänger links einfahren zum Ausfädeln *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_li.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 290;
		END_IF

(*=======================================================*)
	290:	(* Band ist herausgezogen - prüfe Einstellung bzw. Bandanwesenheit im rechten Einzug *)
		b_ausgefaedelt:=b_materialmangel;
			(* Band vorhanden -> Beginn automatischer Bandwechsel *)
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_tof_bandende_re.Q AND gst_datensatz.st_md.b_auto_Bandwechsel THEN
			b_spulenwechsel := TRUE;
			fb_state_entry.i16_next_step := 300;
		ELSE
			(* Bandherausziehen ist fertig *)
			fb_state_entry.i16_next_step := 295;
		END_IF

(*=======================================================*)
	291:	(* Bediener muss am Backpanel auswählen ob Bandwechsel oder Trennstelle *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF visu_hinten.out.b_Bandwechsel THEN
			(* Band vorhanden -> Beginn automatischer Bandwechsel *)
			visu_hinten.in.b_bandwechsel_aktiv := FALSE;
			visu_hinten.in.current_visu_folie := 'BESTUECKZELLE_1700';
			fb_state_entry.i16_next_step := 300;
		ELSIF visu_hinten.out.b_Trennstelle THEN
			visu_hinten.in.b_bandwechsel_aktiv := FALSE;
			CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

				 BANDWECHSLER_V2:
					visu_hinten.in.current_visu_folie := 'BA_1700_BAND_EINFAEDELN';

				SERVO:
					visu_hinten.in.current_visu_folie := 'BA1700_SERVO_BAND_EINFAEDELN';
			END_CASE
			fb_state_entry.i16_next_step := 295;
		END_IF

(*=======================================================*)
	295:	(* Vorschub ausfahren und fertig -> Band wird jetzt im gleichen Einzug manuell eingelegt mit Einfädelprozedur in der Bestückachse *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			st_ctrl_out.b_fertig_2 := TRUE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	300:	(* Fänger rechts ausfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_faenger_re.st_ctrl.out.b_ausgefahren AND
			gb_ba_auto_kontroller
			THEN
				zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := FALSE;
				fb_state_entry.i16_next_step := 310;
		END_IF

(*=======================================================*)
	310:	(* Halter rechts einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_re.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_halter_re.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_halter_re.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 315;
		END_IF

(*=======================================================*)
	315:	(* Spulenbremse rechts oben? *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_haspel_re_abspulen.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			fb_state_entry.i16_next_step := 320;
		END_IF

(*=======================================================*)
	320:	(* Querschub ausfahren -> nach links und Haspeln nach links: Haspel verschieben ausfahren und Bandabzug einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_querschub.st_ctrl.in.b_ausfahren := TRUE;
			zyl_haspel_verschieben.st_ctrl.in.b_ausfahren := TRUE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_querschub.st_ctrl.out.b_ausgefahren AND
			zyl_haspel_verschieben.st_ctrl.out.b_ausgefahren AND
			zyl_bandeinzuege_verschieben.st_ctrl.out.b_eingefahren AND
			gb_ba_auto_kontroller
			THEN
				zyl_bawe_querschub.st_ctrl.in.b_ausfahren := FALSE;
				zyl_haspel_verschieben.st_ctrl.in.b_ausfahren := FALSE;
				zyl_bandeinzuege_verschieben.st_ctrl.in.b_einfahren := FALSE;
				CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

					BANDWECHSLER_V2:
						fb_state_entry.i16_next_step := 330;

					SERVO:
						fb_state_entry.i16_next_step := 325;
				END_CASE
		END_IF

		IF fb_state_entry.X THEN
			b_spulenwechsel := FALSE;
		END_IF

(*=======================================================*)
	325:	(* Igelrad auf Position *)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_startpos := TRUE;
			fb_ton_wz.PT := t#100ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_servo_auf_einfaedelpos
		AND gb_ba_auto_kontroller AND fb_ton_wz.Q THEN
			axis_bandeinzug_achse.st_ctrl.in.b_startpos := FALSE;
			fb_state_entry.i16_next_step := 330;
		END_IF

		IF fb_state_entry.X THEN
			fb_ton_wz.IN := FALSE;
		END_IF

(*=======================================================*)
	330:	(* Vorschub ausfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := TRUE;
			i16_akt_einfaedeln := i16_akt_einfaedeln + 1;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			IF i16_akt_einfaedeln < i16_vorgabe_einfaedeln THEN
				fb_state_entry.i16_next_step := 340;
			ELSE
				fb_state_entry.i16_next_step := 390;		 (*mit Wartezeit alt 400*)
			END_IF
		END_IF

(*=======================================================*)
	340:	(* Halter rechts ausfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_re.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_halter_re.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_halter_re.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 350;
		END_IF

(*=======================================================*)
	350:	(* Fänger rechts einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_re.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 360;
		END_IF

(*=======================================================*)
	360:	(* Vorschub einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_vorschub.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 370;
		END_IF

(*=======================================================*)
	370:	(* Fänger rechts ausfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_re.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 380;
		END_IF

(*=======================================================*)
	380:	(* Halter rechts einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_re.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_halter_re.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_halter_re.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 330;
		END_IF

(*=======================================================*)
	390:	(* Wartezeit damit der Fänger vom WZ trifft*)
		IF	 fb_state_entry.E THEN
			fb_ton_wz.IN:=FALSE;
		END_IF
		fb_ton_wz(IN:=TRUE,PT:=t#1000ms);
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	fb_ton_wz.Q THEN
			fb_ton_wz.IN:=FALSE;
			fb_state_entry.i16_next_step := 400;
		END_IF

(*=======================================================*)
	400:	(* Nocken für Zylinder am Bandeinzug einschalten und somit Bandfänger ausfahren bzw. Bremse an Servobandeinzug wieder fest machen. *)

		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

			BANDWECHSLER_V2:

				IF fb_state_entry.E THEN
					(* Bandwechsler V2 ohne Sensoren und anderen Zylindern *)
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_EINFAHREN].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_AUSFAHREN].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_EINFAHREN].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN].b_camvalid := TRUE;

					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_PNEUMATIKBANDEINZUG_GLS].b_camvalid := TRUE;

					zyl_bandfaenger.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
					zyl_bandklemmen.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
					fb_ton_wz.PT := t#500ms;
					fb_ton_wz.IN := TRUE;
				END_IF

				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF fb_ton_wz.Q THEN
					fb_ton_wz.IN := FALSE;
					fb_state_entry.i16_next_step := 410;
				END_IF

			SERVO:
				IF fb_state_entry.E THEN
					axis_bandeinzug_achse.st_ctrl.in.b_bremse_auf := TRUE;	(* Bremse auf zum Position übernehmen *)
				END_IF

				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF axis_bandeinzug_achse.st_ctrl.out.b_bremse_geoeffnet THEN
					axis_bandeinzug_achse.st_ctrl.in.b_bremse_auf := FALSE;
					fb_state_entry.i16_next_step := 410;
				END_IF
		END_CASE;

(*=======================================================*)
	410:	(* Fänger rechts einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_re.st_ctrl.out.b_eingefahren
		AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := FALSE;
			(* Bandwechsel ist fertig *)
			st_ctrl_out.b_fertig := TRUE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF


(*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*)
(*========================Bandeinzug rechts ist leer===============================*)
	500:	(* Fänger links ausfahren zum Band halten, Fänger rechts einfahren zur Bandfreigabe im rechten Einzug - Halter gegensinnig *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := TRUE;
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := TRUE;
			zyl_bawe_halter_re.st_ctrl.in.b_einfahren := TRUE;
			zyl_bawe_halter_li.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_faenger_re.st_ctrl.out.b_ausgefahren AND
			zyl_bawe_faenger_li.st_ctrl.out.b_eingefahren AND
			zyl_bawe_halter_re.st_ctrl.out.b_eingefahren AND
			zyl_bawe_halter_li.st_ctrl.out.b_ausgefahren AND
			gb_ba_auto_kontroller
			THEN
				zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := FALSE;
				zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := FALSE;
				zyl_bawe_halter_re.st_ctrl.in.b_einfahren := FALSE;
				zyl_bawe_halter_li.st_ctrl.in.b_ausfahren := FALSE;
				fb_state_entry.i16_next_step := 510;
		END_IF

(*=======================================================*)
	510:	(* Band-Zylinder einfahren bzw. Servobandeinzug lösen *)
		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			BANDWECHSLER_V2:
				IF fb_state_entry.E THEN
					(* Zylinder einfahren *)
					zyl_bandfaenger.st_ctrl.in.b_einfahren := TRUE;
					zyl_bandklemmen.st_ctrl.in.b_einfahren := TRUE;
				END_IF

				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF 	zyl_bandfaenger.st_ctrl.out.b_eingefahren AND
					zyl_bandklemmen.st_ctrl.out.b_eingefahren AND
					gb_ba_auto_kontroller
					THEN
						zyl_bandfaenger.st_ctrl.in.b_einfahren := FALSE;
						zyl_bandklemmen.st_ctrl.in.b_einfahren := FALSE;
						fb_state_entry.i16_next_step := 520;
				END_IF

			SERVO:
				zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := TRUE;
				zyl_bawe_halter_re.st_ctrl.in.b_einfahren := TRUE;
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF 	zyl_bawe_faenger_re.st_ctrl.out.b_eingefahren AND
					zyl_bawe_halter_re.st_ctrl.out.b_eingefahren AND
					gb_ba_auto_kontroller
					THEN
						zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := FALSE;
						zyl_bawe_halter_re.st_ctrl.in.b_einfahren := FALSE;
						fb_state_entry.i16_next_step := 516;
				END_IF
		END_CASE;

(*=======================================================*)
	516:	(* Servobandeinzug rückwärts fahren, damit die Ausschiebezylinder das Band sicher erwischen *)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_ausfaedeln_servo := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_ausgefaedelt_servo AND NOT fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_ausfaedeln_servo := FALSE;
			fb_state_entry.i16_next_step := 517;(*Neu*)
		END_IF

(*=======================================================*)
	517:	(* Fänger ins Band fahren, damit die Bremse gelöst werden kann *)
		IF fb_state_entry.E THEN
				zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_faenger_re.st_ctrl.out.b_ausgefahren AND
			gb_ba_auto_kontroller
			THEN
				zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := FALSE;
				fb_state_entry.i16_next_step := 518;
		END_IF

(*=======================================================*)
	518:	(* Bremse an Servobandeinzug lösen, damit Band heraus gezogen werden kann. Die Bestückachse hat die Slavekopplung bereits gelöst. *)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_bremse_auf := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_bremse_geoeffnet AND NOT fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_bremse_auf := FALSE;
			fb_state_entry.i16_next_step := 520;
		END_IF

(*=======================================================*)
	520:	(* Vorschub einfahren und Band aus WKZ rausziehen *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_einfahren := TRUE;
			i16_akt_ausfaedeln := i16_akt_ausfaedeln + 1;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_vorschub.st_ctrl.in.b_einfahren := FALSE;
			IF i16_akt_ausfaedeln <= i16_vorgabe_ausfaedeln THEN
				fb_state_entry.i16_next_step := 530;
			ELSE
				fb_state_entry.i16_next_step := 580;
			END_IF
		END_IF

(*=======================================================*)
	530:	(* Bandwechselhalter rechts ausfahren um Band nachfassen zu können *)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_re.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_halter_re.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_halter_re.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 540;
		END_IF

(*=======================================================*)
	540:	(* Bandwechselfänger rechts einfahren*)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_re.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 550;
		END_IF

(*=======================================================*)
	550:	(* Vorschub ausfahren und Band nachfassen *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 560;
		END_IF

(*=======================================================*)
	560:	(* Bandwechselfänger rechts ausfahren zum Band halten *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_re.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 570;
		END_IF

(*=======================================================*)
	570:	(* Bandwechselhalter rechts einfahren und Band freigeben*)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_re.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_halter_re.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_halter_re.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 520;
		END_IF

(*=======================================================*)
	580:	(* Fänger rechts einfahren zum Ausfädeln *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_faenger_re.st_ctrl.out.b_eingefahren AND
			gb_ba_auto_kontroller
			THEN
				zyl_bawe_faenger_re.st_ctrl.in.b_einfahren := FALSE;
				fb_state_entry.i16_next_step := 590;
		END_IF

(*=======================================================*)
	590:	(* Band ist herausgezogen  - prüfe Einstellung bzw. Bandanwesenheit im linken Einzug *)
		b_ausgefaedelt:=b_materialmangel;
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_tof_bandende_li.Q  AND gst_datensatz.st_md.b_auto_Bandwechsel THEN
			b_spulenwechsel := TRUE;
			fb_state_entry.i16_next_step := 600;
		ELSE
			(* Bandherausziehen ist fertig *)
			fb_state_entry.i16_next_step := 595;
		END_IF

(*=======================================================*)
	591:	(* Bediener muss am Backpanel auswählen ob Bandwechsel oder Trennstelle *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF visu_hinten.out.b_Bandwechsel THEN
			(* Band vorhanden -> Beginn automatischer Bandwechsel *)
			visu_hinten.in.b_bandwechsel_aktiv := FALSE;
			visu_hinten.in.current_visu_folie := 'BESTUECKZELLE_1700';
			fb_state_entry.i16_next_step := 600;
		ELSIF visu_hinten.out.b_Trennstelle THEN
			visu_hinten.in.b_bandwechsel_aktiv := FALSE;
			CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

				BANDWECHSLER_V2:
					visu_hinten.in.current_visu_folie := 'BA_1700_BAND_EINFAEDELN';

				SERVO:
					visu_hinten.in.current_visu_folie := 'BA1700_SERVO_BAND_EINFAEDELN';
			END_CASE
			fb_state_entry.i16_next_step := 595;
		END_IF


(*=======================================================*)
	595:	(* Vorschub ausfahren und fertig -> Band wird jetzt im gleichen Einzug manuell eingelegt mit Einfädelprozedur in der Bestückachse *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			st_ctrl_out.b_fertig_2 := TRUE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	600:	(* Fänger links ausfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_faenger_li.st_ctrl.out.b_ausgefahren AND
			gb_ba_auto_kontroller
			THEN
				zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := FALSE;
				fb_state_entry.i16_next_step := 610;
		END_IF

(*=======================================================*)
	610:	(* Halter links einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_li.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_halter_li.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_halter_li.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 615;
		END_IF

(*=======================================================*)
	615:	(* Spulenbremse links oben? *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_haspel_li_abspulen.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			fb_state_entry.i16_next_step := 620;
		END_IF

(*=======================================================*)
	620:	(* Querschub einfahren -> nach rechts und Haspeln nach rechts: Haspel verschieben einfahren und Bandabzug ausfahren*)
		IF fb_state_entry.E THEN
			zyl_bawe_querschub.st_ctrl.in.b_einfahren := TRUE;
			zyl_haspel_verschieben.st_ctrl.in.b_einfahren := TRUE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_bawe_querschub.st_ctrl.out.b_eingefahren AND
			zyl_haspel_verschieben.st_ctrl.out.b_eingefahren AND
			zyl_bandeinzuege_verschieben.st_ctrl.out.b_ausgefahren AND
			gb_ba_auto_kontroller
			THEN
				zyl_bawe_querschub.st_ctrl.in.b_einfahren := FALSE;
				zyl_haspel_verschieben.st_ctrl.in.b_einfahren := FALSE;
				zyl_bandeinzuege_verschieben.st_ctrl.in.b_ausfahren := FALSE;
				CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

					BANDWECHSLER_V2:
						fb_state_entry.i16_next_step := 630;

					SERVO:
						fb_state_entry.i16_next_step := 625;
				END_CASE
		END_IF

		IF fb_state_entry.X THEN
			b_spulenwechsel := FALSE;
		END_IF

(*=======================================================*)
	625:	(* Igelrad auf Position *)
		IF fb_state_entry.E THEN
			axis_bandeinzug_achse.st_ctrl.in.b_startpos := TRUE;
			fb_ton_wz.PT := t#100ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bandeinzug_achse.st_ctrl.out.b_servo_auf_einfaedelpos
			AND gb_ba_auto_kontroller AND fb_ton_wz.Q THEN
			axis_bandeinzug_achse.st_ctrl.in.b_startpos := FALSE;
			fb_state_entry.i16_next_step := 630;
		END_IF

		IF fb_state_entry.X THEN
			fb_ton_wz.IN := FALSE;
		END_IF

(*=======================================================*)
	630:	(* Vorschub ausfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := TRUE;
			i16_akt_einfaedeln := i16_akt_einfaedeln + 1;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			IF i16_akt_einfaedeln < i16_vorgabe_einfaedeln THEN
				fb_state_entry.i16_next_step := 640;
			ELSE
				fb_state_entry.i16_next_step := 690; (*mit Wartezeit alt auf 700*)
			END_IF
		END_IF

(*=======================================================*)
	640:	(* Halter links ausfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_li.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_halter_li.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_halter_li.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 650;
		END_IF

(*=======================================================*)
	650:	(* Fänger links einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_li.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 660;
		END_IF

(*=======================================================*)
	660:	(* Vorschub einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_vorschub.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_vorschub.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_vorschub.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 670;
		END_IF

(*=======================================================*)
	670:	(* Fänger links ausfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_li.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 680;
		END_IF

(*=======================================================*)
	680:	(* Halter links einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_halter_li.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_halter_li.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_bawe_halter_li.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 630;
		END_IF
(*=======================================================*)
	690:	(* Wartezeit damit der Fänger vom WZ trifft*)
		IF	 fb_state_entry.E THEN
			fb_ton_wz.IN:=FALSE;
		END_IF
		fb_ton_wz(IN:=TRUE,PT:=t#1000ms);
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	fb_ton_wz.Q THEN
			fb_ton_wz.IN:=FALSE;
			fb_state_entry.i16_next_step := 700;
		END_IF

(*=======================================================*)
	700:	(* Nocken für Zylinder am Bandeinzug einschalten und somit Bandfänger ausfahren bzw. Bremse an Servobandeinzug wieder fest machen. *)
		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

			BANDWECHSLER_V2:

				IF fb_state_entry.E THEN
					(* Bandwechsler V2 ohne Sensoren und anderen Zylindern *)
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_EINFAHREN].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDFAENGER_BAWEV2_AUSFAHREN].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_EINFAHREN].b_camvalid := TRUE;
					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN].b_camvalid := TRUE;

					gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_PNEUMATIKBANDEINZUG_GLS].b_camvalid := TRUE;

					zyl_bandfaenger.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
					zyl_bandklemmen.fb.b_no_gesteuert_im_norm_betrieb := FALSE;
					fb_ton_wz.PT := t#500ms;
					fb_ton_wz.IN := TRUE;
				END_IF
		
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF fb_ton_wz.Q THEN
					fb_ton_wz.IN := FALSE;
					fb_state_entry.i16_next_step := 710;
				END_IF

			SERVO:
				IF fb_state_entry.E THEN
					axis_bandeinzug_achse.st_ctrl.in.b_bremse_auf := TRUE;	(* Bremse auf zum Position übernehmen *)
				END_IF

				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF axis_bandeinzug_achse.st_ctrl.out.b_bremse_geoeffnet THEN
					axis_bandeinzug_achse.st_ctrl.in.b_bremse_auf := FALSE;
					fb_state_entry.i16_next_step := 710;
				END_IF
		END_CASE;

(*=======================================================*)
	710:	(* Fänger links einfahren *)
		IF fb_state_entry.E THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_bawe_faenger_li.st_ctrl.out.b_eingefahren
		AND gb_ba_auto_kontroller THEN
			zyl_bawe_faenger_li.st_ctrl.in.b_einfahren := FALSE;
			(* Bandwechsel ist fertig *)
			st_ctrl_out.b_fertig := TRUE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_bawe_vorschub.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_querschub.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_faenger_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_faenger_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_haspel_verschieben.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			zyl_bawe_vorschub.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_querschub.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_faenger_li.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_faenger_re.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_halter_li.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_halter_re.st_ctrl.in.b_quittieren := TRUE;
			zyl_haspel_verschieben.st_ctrl.in.b_quittieren := TRUE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			zyl_bawe_vorschub.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_querschub.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_faenger_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_faenger_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_haspel_verschieben.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_bawe_vorschub.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_querschub.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_faenger_li.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_faenger_re.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_halter_li.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_halter_re.st_ctrl.in.b_quittieren := TRUE;
			zyl_haspel_verschieben.st_ctrl.in.b_quittieren := TRUE;
			zyl_bandeinzuege_verschieben.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_halter_nicht_oben;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_bandwechsel_ohne_ende;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_kein_band_anderer_einzug;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_kein_band_in_akt_einzug;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_bandwechselvorgang;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := bm_bandwechsel_manuell;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Einpresskraftueberwachung' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Einpress_Kontroller
VAR_INPUT
	st_config									: struct_config;
	st_ctrl_in									: struct_ctrl_in;
	lr_achsposition							: LREAL;
END_VAR
VAR_IN_OUT
	st_visu									: struct_visu;
	st_einpressen							: struct_einpresskraftueberwachung;
END_VAR
VAR_OUTPUT
	st_ctrl_out								: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz								: TON;
	fb_ton_uez								: TON;
	fb_ton_quitt								: TON;
	fb_r_trig_start								: R_TRIG;
	fb_f_trig_bestueckposzaehler				: F_TRIG;
	fb_state_entry								: ST_StateEntry;
	lr_kraft_n									: LREAL := 0.0;
	i16_pin_nr								: INT := 0;
	i16_pin_nr_alt								: INT := 0;
	i16_kraftfaktor								: INT := 0;
	sm_fehler_einpressmodus					: BOOL := FALSE;
	sm_aktkraft_groesser_maxkraft_einpressen	: BOOL := FALSE;
	sm_aktkraft_groesserr_mittelkraft_einpressen	: BOOL := FALSE;
	sm_fehler_analogwert_kraftmessdose		: BOOL := FALSE;
	sm_max_mb_ueberschritten					: BOOL := FALSE;
	sm_max_einstell_mb_ueberschritten			: BOOL := FALSE;

	a_start_messung							AT %Q* : BOOL := FALSE;
	a_messbereich_1_oder_2					AT %Q* : BOOL := FALSE;	(* MB1 = low, MB2 = high *)

	st_ausgabe								: struct_einpressausgabe;
	lr_vergleich_kraft_einpressen				: LREAL;
	lr_arr_aktuelle_kraft						: ARRAY[0..9] OF LREAL;
	lr_max_kraft_im_arr						: LREAL;
	lr_mittel_kraft_im_arr						: LREAL;
	lr_aktuelle_kraft_pin						: LREAL;
	lr_akutelle_kraft_messbereich			: LREAL;
	i										: INT;
	b_ueberwachung_gueltig					: BOOL;
END_VAR
VAR CONSTANT
	i_KRAFTFAKTOR_MB1		: INT := 200;	(* Der Kraftfaktor richtet sich nach der Messbereichskalibrierung in der Zusatzsoftware (ICAM) für den Ladungsverstärker *)
	i_KRAFTFAKTOR_MB2		: INT := 2000;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );

fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );
fb_f_trig_bestueckposzaehler(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BESTUECKSCHIEBERHUB ], Q=> );

(* Analogwert Kraftmessdose *)
kraftmessdose.fb(
	t_verzoegerung:= t#500ms,
	st_config:= kraftmessdose.fb.st_config);

(* Berechnung der aktuellen Kraft in Newton aus dem Analogwert in  Volt. *)
(* Die Normierung der Analogspannung als Kraft erfolgt mit dem Kalibrierschein der Kraftmessdose und der Software "ICAM5073" *)
(* Eingestellter Messbereich1: 0 - 200N, Messbereich2: 0 - 2000N *)
IF a_messbereich_1_oder_2 THEN
	i16_kraftfaktor := i_KRAFTFAKTOR_MB2;
ELSE
	i16_kraftfaktor := i_KRAFTFAKTOR_MB1;
END_IF

(* Behandlung Ausnahmefall Division durch 0  *)
IF kraftmessdose.fb.i16_anzeigewert_max <> 0 THEN
	lr_kraft_n := i16_kraftfaktor * kraftmessdose.fb.st_sensor.e_i16_value / kraftmessdose.fb.i16_anzeigewert_max;
END_IF

(* ===============Toplevel================ *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF

	(* Fehlersignal der Kraftmessdose *)
	IF st_config.b_station_aktiv THEN
		IF kraftmessdose.fb.b_error THEN
			sm_fehler_analogwert_kraftmessdose := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
		IF 	(NOT a_messbereich_1_oder_2 AND lr_kraft_n > i_KRAFTFAKTOR_MB1) OR
			(a_messbereich_1_oder_2 AND lr_kraft_n > i_KRAFTFAKTOR_MB2) OR
			(gst_datensatz.st_band.st_einpressen.st_einstellungen.lr_maxkraft_einpressen > i_KRAFTFAKTOR_MB2)
			THEN
				sm_max_mb_ueberschritten := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
		END_IF
		IF gst_datensatz.st_band.st_einpressen.st_einstellungen.lr_maxkraft_einpressen > i_KRAFTFAKTOR_MB2 THEN
			sm_max_einstell_mb_ueberschritten := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			a_messbereich_1_oder_2 := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			a_start_messung := FALSE;
			b_ueberwachung_gueltig := FALSE;
			i16_pin_nr := 0;
			sm_fehler_einpressmodus := FALSE;
			sm_aktkraft_groesser_maxkraft_einpressen := FALSE;
			sm_aktkraft_groesserr_mittelkraft_einpressen := FALSE;
			sm_fehler_analogwert_kraftmessdose := FALSE;
			sm_max_mb_ueberschritten := FALSE;
			sm_max_einstell_mb_ueberschritten := FALSE;
			(*Löschen der gesammelten Kräfte der letzten zehn Hübe*)
			FOR i := 0 TO 9 DO
				lr_arr_aktuelle_kraft[i] := 0;
			END_FOR

		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
			i16_pin_nr := 0;
			i16_pin_nr_alt := 0;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_start THEN
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110:	(* Kraftmessung starten *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig := FALSE;
			a_start_messung := TRUE;
			st_ausgabe.st_ergebnisse.lr_maxkraft_einpressen := 0;
			st_ausgabe.st_ergebnisse.lr_maxkraft_einpres_proHub:=0;
			st_ausgabe.st_ergebnisse.lr_ueberlaufkraft := 0;
			lr_aktuelle_kraft_pin := 0;
			lr_akutelle_kraft_messbereich := 0;
		END_IF

		(* Hochzählen mit der Anzahl der bestückten Pins *)
		IF fb_f_trig_bestueckposzaehler.Q THEN
			i16_pin_nr := i16_pin_nr +1;
		END_IF

		(*aktuell höchste Kraft wird sich gemerkt*)
		IF  lr_kraft_n > lr_aktuelle_kraft_pin THEN
			lr_aktuelle_kraft_pin := lr_kraft_n;
			lr_akutelle_kraft_messbereich := lr_kraft_n;
		END_IF

		(*Bei jedem neuen Pin wird die höchste gemessene Kraft in ein Array geschrieben und die älteste von den letzten 10
		wird gelöscht*)
		IF i16_pin_nr_alt <> i16_pin_nr AND ST_Virtuelle_Masterachse.i16_bestueckachse_cam_table_id = 5 THEN
			FOR i:=9 TO 1 BY -1 DO
				lr_arr_aktuelle_kraft[i]:=lr_arr_aktuelle_kraft[i-1];
			END_FOR
			lr_arr_aktuelle_kraft[0] := lr_aktuelle_kraft_pin;
			lr_aktuelle_kraft_pin := 0;
			i16_pin_nr_alt := i16_pin_nr;
		END_IF

		(*Überprüfung, ob das Array komplett mit Werten befüllt ist*)
		FOR i := 0 TO 9 DO
			IF lr_arr_aktuelle_kraft[i] = 0 THEN
				b_ueberwachung_gueltig := FALSE;
				EXIT;
			ELSE
				b_ueberwachung_gueltig := TRUE;
			END_IF
		END_FOR

		(*Auswahl Auswertemodus*)
		CASE st_einpressen.st_einstellungen.enu_modus OF

			KEIN_MODUS:	(* Kraftübwerachung ausgeschalten *)
					;
			F_MAXWERT:	(* Einpressen mit Überwachung auf den Maximalwert *)

				IF b_ueberwachung_gueltig THEN
					lr_max_kraft_im_arr := 0;
					(*Maximalkraft im Array wird gesucht*)
					FOR i := 0 TO 9 DO
						IF  lr_arr_aktuelle_kraft[i] > lr_max_kraft_im_arr THEN
							lr_max_kraft_im_arr := lr_arr_aktuelle_kraft[i];
						END_IF
					END_FOR

					(* nur bei voller Drehzahl und normalen Bestückbild mit ermittelter Kraft prüfen*)
					IF ST_TippTasten.i16_akt_stufe = 9 AND (FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'ruef') = 0		(*es wird nur auf ruef abgefragt, weil das P groß oder klein sein kann*)
						 AND FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'erth') = 0) THEN
						lr_vergleich_kraft_einpressen:=lr_max_kraft_im_arr;
					ELSE
						lr_vergleich_kraft_einpressen:=800;
					END_IF

					(* Fehlerfall: Ermittelte Maximalkraft überschritten nur im Automatik Betrieb *)
					IF  gi16_betriebsart = AUTO AND lr_kraft_n > lr_vergleich_kraft_einpressen + st_einpressen.st_einstellungen.lr_delta_kraft THEN
						st_einpressen.st_einstellungen.lr_maxkraft_einpressen := lr_kraft_n;
						st_ausgabe.st_ergebnisse.lr_maxkraft_einpressen:=lr_kraft_n;
						sm_aktkraft_groesser_maxkraft_einpressen := TRUE;
						fb_state_entry.i16_next_step := FEHLER;
					END_IF
				END_IF


			F_MITTELWERT:	(* Einpressen mit Überwachung auf den Mittelwert *)

				IF b_ueberwachung_gueltig THEN
					(*Kraft im Array wird aufaddiert*)
					FOR i := 0 TO 9 DO
						lr_mittel_kraft_im_arr := lr_mittel_kraft_im_arr + lr_arr_aktuelle_kraft[i];
					END_FOR
					(*Mittelwert der Kräfte im Array wird gebildet*)
					lr_mittel_kraft_im_arr := lr_mittel_kraft_im_arr / 10;

					(* nur bei voller Drehzahl und normalen Bestückbild mit ermittelter Kraft prüfen*)
					IF ST_TippTasten.i16_akt_stufe = 9 AND (FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'ruef') = 0			(*es wird nur auf ruef abgefragt, weil das P groß oder klein sein kann*)
						AND FIND(gst_datensatz.st_md.s_aktuelle_artikelnummer,'erth') = 0) THEN
						lr_vergleich_kraft_einpressen:=lr_mittel_kraft_im_arr;
					ELSE
						lr_vergleich_kraft_einpressen:=800;
					END_IF

					(* Fehlerfall: Ermittelte Maximalkraft überschritten nur im Automatik Betrieb *)
					IF  gi16_betriebsart = AUTO AND lr_kraft_n > lr_vergleich_kraft_einpressen + st_einpressen.st_einstellungen.lr_delta_kraft THEN
						sm_aktkraft_groesserr_mittelkraft_einpressen := TRUE;
						st_einpressen.st_einstellungen.lr_maxkraft_einpressen := lr_kraft_n;
						st_ausgabe.st_ergebnisse.lr_maxkraft_einpressen:=lr_kraft_n;
						fb_state_entry.i16_next_step := FEHLER;
					END_IF
				END_IF
		END_CASE

		(* Manuelle Messbereichsumschaltung anhand des Einstellwertes für Maximalkraft beim Einpressen. *)
		IF gst_datensatz.st_band.st_einpressen.st_einstellungen.lr_maxkraft_einpressen > (i_KRAFTFAKTOR_MB1 * 0.75) THEN
			a_messbereich_1_oder_2 := TRUE;
		ELSE
			(* Automatische Messbereichsumschaltung, wenn die maximale Einpresskraft 75% des Messbereichsendwertes überschreitet. *)
			IF lr_akutelle_kraft_messbereich > (i_KRAFTFAKTOR_MB1 * 0.75) THEN
				a_messbereich_1_oder_2 := TRUE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT st_ctrl_in.b_start THEN
			(* Messbereichsanpassung nur, wenn die Krafteinstellung für maximale Einpresskraft es erlaubt. *)
			IF gst_datensatz.st_band.st_einpressen.st_einstellungen.lr_maxkraft_einpressen < (i_KRAFTFAKTOR_MB1 * 0.75) THEN
				(* Automatische Messbereichsumschaltung, wenn die maximale Einpresskraft 50% des Messbereichsendwertes unterschreitet. *)
				IF lr_akutelle_kraft_messbereich < (i_KRAFTFAKTOR_MB1 * 0.5) THEN
					a_messbereich_1_oder_2 := FALSE;
				END_IF
			END_IF
			a_start_messung := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(* Aufzeichnen der Überlaufkraft nach einem Einpressfehler *)
		IF  lr_kraft_n > st_ausgabe.st_ergebnisse.lr_ueberlaufkraft THEN
			st_ausgabe.st_ergebnisse.lr_ueberlaufkraft := lr_kraft_n;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_einpressmodus;
garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_aktkraft_groesser_maxkraft_einpressen;
garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_aktkraft_groesserr_mittelkraft_einpressen;
garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_fehler_analogwert_kraftmessdose;
garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_max_mb_ueberschritten;
garr_stoermeldungen[st_config.i16_meld_startindex + 5] := sm_max_einstell_mb_ueberschritten;
garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;

garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Einpresskraftueberwachung' *)
(* @OBJECTFLAGS := '8, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Einpress_Kontroller_alt
VAR_INPUT
	st_config									: struct_config;
	st_ctrl_in									: struct_ctrl_in;
	lr_achsposition							: LREAL;
END_VAR
VAR_IN_OUT
	st_visu									: struct_visu;
	st_einpressen							: struct_einpresskraftueberwachung;
END_VAR
VAR_OUTPUT
	st_ctrl_out								: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz								: TON;
	fb_ton_uez								: TON;
	fb_ton_quitt								: TON;
	fb_r_trig_start								: R_TRIG;
	fb_state_entry								: ST_StateEntry;
	lr_kraft_n									: LREAL := 0.0;
	lr_weg_grad								: LREAL := 0.0;
	i16_pin_nr								: INT := 0;
	i16_kraftfaktor								: INT := 0;
	ui_akt_pos_bestueckachse					: UINT := 0;
	i16_ku_nr								: INT := 0;
	i16_mp_nr								: INT := 0;
	b_kraft_weg_in_mp_ok						: BOOL := FALSE;
	sm_fehler_einpressmodus					: BOOL := FALSE;
	sm_aktkraft_groesser_maxkraft_aufnahme	: BOOL := FALSE;
	sm_aktkraft_groesser_maxkraft_einpressen	: BOOL := FALSE;
	sm_aktkraft_kleiner_minkraft_einpressen		: BOOL := FALSE;
	sm_kraft_weg_ausserhalb_huellkurve		: BOOL := FALSE;
	sm_fehler_analogwert_kraftmessdose		: BOOL := FALSE;
	sm_max_mb_ueberschritten					: BOOL := FALSE;
	sm_max_einstell_mb_ueberschritten			: BOOL := FALSE;

	a_start_messung							AT %Q* : BOOL := FALSE;
	a_messbereich_1_oder_2					AT %Q* : BOOL := FALSE;	(* MB1 = low, MB2 = high *)

	st_ausgabe								: struct_einpressausgabe;
	i16_merker								: INT := 0;
	lr_help_maxkraft_einpressen				:LREAL;
END_VAR
VAR CONSTANT
	i_KRAFTFAKTOR_MB1		: INT := 200;	(* Der Kraftfaktor richtet sich nach der Messbereichskalibrierung in der Zusatzsoftware (ICAM) für den Ladungsverstärker *)
	i_KRAFTFAKTOR_MB2		: INT := 2000;
	i_MAX_MESSPUNKTE			: INT := 360;
	i_MAX_KURVEN				: INT := 99;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );

fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );

(* Analogwert Kraftmessdose *)
kraftmessdose.fb(
	t_verzoegerung:= t#500ms,
	st_config:= kraftmessdose.fb.st_config);

(* Berechnung der aktuellen Kraft in Newton aus dem Analogwert in  Volt. *)
(* Die Normierung der Analogspannung als Kraft erfolgt mit dem Kalibrierschein der Kraftmessdose und der Software "ICAM5073" *)
(* Eingestellter Messbereich1: 0 - 200N, Messbereich2: 0 - 2000N *)
IF a_messbereich_1_oder_2 THEN
	i16_kraftfaktor := i_KRAFTFAKTOR_MB2;
ELSE
	i16_kraftfaktor := i_KRAFTFAKTOR_MB1;
END_IF

(* nur bei voller Drehzahl mit eingestellter Kraft prüfen*)
IF	ST_TippTasten.i16_akt_stufe = 9 THEN
	lr_help_maxkraft_einpressen:=st_einpressen.st_einstellungen.lr_maxkraft_einpressen;
ELSE
	lr_help_maxkraft_einpressen:=800;
END_IF

(* Behandlung Ausnahmefall Division durch 0  *)
IF kraftmessdose.fb.i16_anzeigewert_max <> 0 THEN
	lr_kraft_n := i16_kraftfaktor * kraftmessdose.fb.st_sensor.e_i16_value / kraftmessdose.fb.i16_anzeigewert_max;
END_IF

lr_weg_grad := lr_achsposition;
ui_akt_pos_bestueckachse := LREAL_TO_UINT(lr_achsposition);

(* ===============Toplevel================ *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF

	(* Fehlersignal der Kraftmessdose *)
	IF st_config.b_station_aktiv THEN
		IF kraftmessdose.fb.b_error THEN
			sm_fehler_analogwert_kraftmessdose := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
		IF 	(NOT a_messbereich_1_oder_2 AND lr_kraft_n > i_KRAFTFAKTOR_MB1) OR
			(a_messbereich_1_oder_2 AND lr_kraft_n > i_KRAFTFAKTOR_MB2) OR
			(gst_datensatz.st_band.st_einpressen.st_einstellungen.lr_maxkraft_einpressen > i_KRAFTFAKTOR_MB2)
			THEN
				sm_max_mb_ueberschritten := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
		END_IF
		IF gst_datensatz.st_band.st_einpressen.st_einstellungen.lr_maxkraft_einpressen > i_KRAFTFAKTOR_MB2 THEN
			sm_max_einstell_mb_ueberschritten := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			a_messbereich_1_oder_2 := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			a_start_messung := FALSE;
			i16_pin_nr := 0;
			sm_fehler_einpressmodus := FALSE;
			sm_aktkraft_groesser_maxkraft_aufnahme := FALSE;
			sm_aktkraft_groesser_maxkraft_einpressen := FALSE;
			sm_aktkraft_kleiner_minkraft_einpressen := FALSE;
			sm_kraft_weg_ausserhalb_huellkurve := FALSE;
			sm_fehler_analogwert_kraftmessdose := FALSE;
			sm_max_mb_ueberschritten := FALSE;
			sm_max_einstell_mb_ueberschritten := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
			i16_pin_nr := 0;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_start THEN
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110:	(* Kraftmessung starten *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fertig := FALSE;
			a_start_messung := TRUE;
			st_ausgabe.st_ergebnisse.lr_maxkraft_einpressen := 0;
			st_ausgabe.st_ergebnisse.lr_maxkraft_einpres_proHub:=0;
			st_ausgabe.st_ergebnisse.lr_ueberlaufkraft := 0;

			(* Löschen der Kraftwerte in den beiden IST-Einpresskurven *)
			FOR i16_ku_nr := 0  TO i_MAX_KURVEN BY 1DO
				FOR i16_mp_nr := 0  TO i_MAX_MESSPUNKTE BY 1DO
					st_ausgabe.st_kurve[i16_ku_nr].arr_kraft_ist[i16_mp_nr] := 0;
					st_ausgabe.st_kurve[i16_ku_nr].arr_weg_ist[i16_mp_nr] := 0;
				END_FOR
			END_FOR

			(* Löschen der Kraftwerte in allen Stützkurven*)
			IF st_einpressen.st_einstellungen.enu_modus = STUETZKURVE THEN
				FOR i16_ku_nr := 0  TO i_MAX_KURVEN BY 1DO
					FOR i16_mp_nr := 0  TO i_MAX_MESSPUNKTE BY 1DO
						st_ausgabe.st_kurve[i16_ku_nr].arr_kraft_stuetz[i16_mp_nr] := 0;
						st_ausgabe.st_kurve[i16_ku_nr].arr_weg_stuetz[i16_mp_nr] := 0;
					END_FOR
				END_FOR
			END_IF
		END_IF

		(* Hochzählen mit der Anzahl der bestückten Pins *)
		i16_pin_nr := ST_Virtuelle_Masterachse.i16_bestueckposzaehler;
		(* Abfrage Array-Grösse auf Überlauf *)
		IF i16_pin_nr > i_MAX_KURVEN THEN
			i16_pin_nr := 0;
		END_IF

		(* Die Messpunkte werden gradgenau aufgenommen und entsprechen deshalb den Winkelgraden der Bestückachse *)
		i16_mp_nr := ui_akt_pos_bestueckachse;

		CASE st_einpressen.st_einstellungen.enu_modus OF
			KEIN_MODUS:	(* Fehler Auswahl Einpressmodus *)
				sm_fehler_einpressmodus := TRUE;
				fb_state_entry.i16_next_step := FEHLER;

			FMAX:	(* Einpressen mit Überwachung auf Maximalkraft und Sicherheitsabfrage der Minimalkraft*)
				(*st_einpressen.st_einstellungen.lr_minkraft_einpressen := 12.0;*)
				IF  lr_kraft_n > st_ausgabe.st_ergebnisse.lr_maxkraft_einpressen THEN
					st_ausgabe.st_ergebnisse.lr_maxkraft_einpressen := lr_kraft_n;
				END_IF
				(* Fehlerfall: Voreingestellte Maximalkraft überschritten nur im Automatik Betrieb *)
				IF  gi16_betriebsart = AUTO AND lr_kraft_n > lr_help_maxkraft_einpressen THEN		(*st_einpressen.st_einstellungen.lr_maxkraft_einpressen*)
					sm_aktkraft_groesser_maxkraft_einpressen := TRUE;
					fb_state_entry.i16_next_step := FEHLER;
				END_IF

				(* Fehlerfall: Voreingestellte Minimalkraft unterschritten *)
				IF	lr_weg_grad =0 THEN
					st_ausgabe.st_ergebnisse.lr_maxkraft_einpres_proHub:=0;
				END_IF
				IF  lr_kraft_n > st_ausgabe.st_ergebnisse.lr_maxkraft_einpres_proHub THEN
					st_ausgabe.st_ergebnisse.lr_maxkraft_einpres_proHub:=lr_kraft_n;
				END_IF

				IF	gi16_betriebsart = AUTO AND
					st_einpressen.st_einstellungen.lr_minkraft_einpressen > 0 AND
					nockenschaltwerk_bestueckachse.fb.arr_spur[SP_BESTUECKSCHIEBERHUB ] AND
					st_ausgabe.st_ergebnisse.lr_maxkraft_einpres_proHub < st_einpressen.st_einstellungen.lr_minkraft_einpressen	THEN
					i16_merker:=i16_merker+1;
					(*	sm_aktkraft_kleiner_minkraft_einpressen := TRUE;
						fb_state_entry.i16_next_step := FEHLER;*)
				END_IF

				(* Aufzeichnen der Überlaufkraft nach einem Einpressfehler *)
				IF  lr_kraft_n > st_ausgabe.st_ergebnisse.lr_ueberlaufkraft THEN
					st_ausgabe.st_ergebnisse.lr_ueberlaufkraft := lr_kraft_n;
				END_IF

			FMIN_FMAX:	(* Einpressen mit Überwachung von Minimal- und Maximalkraft. Der Weg spielt hier keine Rolle! *)
				(* Aktuelle Kraft gradgenau einlesen *)
				IF st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] = 0 THEN
					(* Einmalig den aktuellen Kraftwert eintragen, wenn Messpunkt im Array noch leer ist *)
					st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] := lr_kraft_n;
				END_IF

				(* Aufnehmen der maximal aufgetretenen Kraft *)
				IF st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] > st_ausgabe.st_ergebnisse.lr_maxkraft_einpressen THEN
					st_ausgabe.st_ergebnisse.lr_maxkraft_einpressen := st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr];
				END_IF

				(* Fehlerfall: Überwachen der Maximalkraft beim Aufnahmehub *)
				IF 	nockenschaltwerk_bestueckachse.fb.arr_spur[SP_AUFNAHMEHUB ] AND
					st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] > 0
					THEN
						IF st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] > st_einpressen.st_einstellungen.lr_maxkraft_aufnahme THEN
							st_einpressen.st_einstellungen.lr_maxkraft_aufnahme := st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr];
							sm_aktkraft_groesser_maxkraft_aufnahme := TRUE;
							fb_state_entry.i16_next_step := FEHLER;
						END_IF
				END_IF

				(* Fehlerfall: Überwachen der Maximalkraft beim Auftreffen des Pins auf den Isolierkörper *)
				IF 	nockenschaltwerk_bestueckachse.fb.arr_spur[SP_EINPRESSHUB ] AND
					st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] > 0
					THEN
						IF st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] > st_einpressen.st_einstellungen.lr_maxkraft_einpressen THEN
							st_einpressen.st_einstellungen.lr_maxkraft_einpressen := st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr];
							sm_aktkraft_groesser_maxkraft_einpressen := TRUE;
							fb_state_entry.i16_next_step := FEHLER;
						END_IF
				END_IF

				(* Fehlerfall: Überwachen der Minimalkraft beim Einpresshub *)
				IF 	nockenschaltwerk_bestueckachse.fb.arr_spur[SP_MIN_KRAFT_EINPRESSEN ] AND
					st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] > 0
					THEN
						IF st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] < st_einpressen.st_einstellungen.lr_minkraft_einpressen THEN
							st_einpressen.st_einstellungen.lr_minkraft_einpressen := st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr];
							sm_aktkraft_kleiner_minkraft_einpressen := TRUE;
							fb_state_entry.i16_next_step := FEHLER;
						END_IF
				END_IF

			HUELLKURVE:	(* Einpressen mit Hüllkurve um Stützkurve*)
				(* Aktuelle Kraft in die Ist-Kurve einlesen *)
				IF st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] = 0 THEN
					(* Einmalig den aktuellen Kraftwert eintragen, wenn Messpunkt im Array noch leer ist *)
					st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] := lr_kraft_n;
				END_IF
				(* Aktuellen Weg in die Ist-Kurve einlesen, wobei in diesem Fall das Arrayelement dem aktuellen Winkel entspricht. *)
				IF st_ausgabe.st_kurve[i16_pin_nr].arr_weg_ist[i16_mp_nr] = 0 THEN
					(* Einmalig den aktuellen Wegwert eintragen, wenn Messpunkt im Array noch leer ist *)
					st_ausgabe.st_kurve[i16_pin_nr].arr_weg_ist[i16_mp_nr] := lr_weg_grad;
				END_IF

				(* Toleranzabfrage und Fehlerauswertung *)
				IF st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] > 0 AND st_ausgabe.st_kurve[i16_pin_nr].arr_weg_ist[i16_mp_nr] > 0 THEN
					b_kraft_weg_in_mp_ok := FALSE;
					(* Werte sind gültig -> Abfrage , ob Kraft und Weg im Toleranzrechteck liegen. *)
					FOR i16_mp_nr := 0  TO i_MAX_MESSPUNKTE BY 1DO
						IF	st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] >= (st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] - st_einpressen.st_einstellungen.lr_delta_kraft) AND
							st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] <= (st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_ist[i16_mp_nr] + st_einpressen.st_einstellungen.lr_delta_kraft) AND
							st_ausgabe.st_kurve[i16_pin_nr].arr_weg_ist[i16_mp_nr] >= (st_ausgabe.st_kurve[i16_pin_nr].arr_weg_ist[i16_mp_nr] - st_einpressen.st_einstellungen.lr_delta_weg) AND
							st_ausgabe.st_kurve[i16_pin_nr].arr_weg_ist[i16_mp_nr] <= (st_ausgabe.st_kurve[i16_pin_nr].arr_weg_ist[i16_mp_nr] + st_einpressen.st_einstellungen.lr_delta_weg)
							THEN
								b_kraft_weg_in_mp_ok := TRUE;
								EXIT;
						ELSE
							b_kraft_weg_in_mp_ok := FALSE;
						END_IF
					END_FOR

					(* Fehlerfall: Aktueller Messpunkt liegt mit seiner Kraft oder seinem Weg nicht im Toleranzrechteck *)
					IF NOT b_kraft_weg_in_mp_ok THEN
						sm_kraft_weg_ausserhalb_huellkurve := TRUE;
						fb_state_entry.i16_next_step := FEHLER;
					END_IF
				END_IF

			STUETZKURVE:	(* Einlernen der Stützkurve *)
				(* Aktuelle Kraft in die Stuetzkurve einlesen *)
				IF st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_stuetz[i16_mp_nr] = 0 THEN
					(* Einmalig den aktuellen Kraftwert eintragen, wenn Messpunkt im Array noch leer ist *)
					st_ausgabe.st_kurve[i16_pin_nr].arr_kraft_stuetz[i16_mp_nr] := lr_kraft_n;
				END_IF
				(* Aktuellen Weg in die Stuetzkurve einlesen, wobei in diesem Fall das Arrayelement dem aktuellen Winkel entspricht. *)
				IF st_ausgabe.st_kurve[i16_pin_nr].arr_weg_stuetz[i16_mp_nr] = 0 THEN
					(* Einmalig den aktuellen Wegwert eintragen, wenn Messpunkt im Array noch leer ist *)
					st_ausgabe.st_kurve[i16_pin_nr].arr_weg_stuetz[i16_mp_nr] := lr_weg_grad;
				END_IF
		END_CASE

		(* Manuelle Messbereichsumschaltung anhand des Einstellwertes für Maximalkraft beim Einpressen. *)
		IF gst_datensatz.st_band.st_einpressen.st_einstellungen.lr_maxkraft_einpressen > (i_KRAFTFAKTOR_MB1 * 0.75) THEN
			a_messbereich_1_oder_2 := TRUE;
		ELSE
			(* Automatische Messbereichsumschaltung, wenn die maximale Einpresskraft 75% des Messbereichsendwertes überschreitet. *)
			IF st_ausgabe.st_ergebnisse.lr_maxkraft_einpressen > (i_KRAFTFAKTOR_MB1 * 0.75) THEN
				a_messbereich_1_oder_2 := TRUE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT st_ctrl_in.b_start THEN
			(* Messbereichsanpassung nur, wenn die Krafteinstellung für maximale Einpresskraft es erlaubt. *)
			IF gst_datensatz.st_band.st_einpressen.st_einstellungen.lr_maxkraft_einpressen < (i_KRAFTFAKTOR_MB1 * 0.75) THEN
				(* Automatische Messbereichsumschaltung, wenn die maximale Einpresskraft 50% des Messbereichsendwertes unterschreitet. *)
				IF st_ausgabe.st_ergebnisse.lr_maxkraft_einpressen < (i_KRAFTFAKTOR_MB1 * 0.5) THEN
					a_messbereich_1_oder_2 := FALSE;
				END_IF
			END_IF
			a_start_messung := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
		END_IF

		(* Aufzeichnen der Überlaufkraft nach einem Einpressfehler *)
		IF  lr_kraft_n > st_ausgabe.st_ergebnisse.lr_ueberlaufkraft THEN
			st_ausgabe.st_ergebnisse.lr_ueberlaufkraft := lr_kraft_n;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> ,
	i16_step=> ,
	i16_last_step=> );

(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_einpressmodus;
garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_aktkraft_groesser_maxkraft_aufnahme;
garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_aktkraft_groesser_maxkraft_einpressen;
garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_aktkraft_kleiner_minkraft_einpressen;
garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_kraft_weg_ausserhalb_huellkurve;
garr_stoermeldungen[st_config.i16_meld_startindex + 5] := sm_fehler_analogwert_kraftmessdose;
garr_stoermeldungen[st_config.i16_meld_startindex + 6] := sm_max_mb_ueberschritten;
garr_stoermeldungen[st_config.i16_meld_startindex + 7] := sm_max_einstell_mb_ueberschritten;
garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;

garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/WT Transport' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_WT_Transport_Beladen
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;
	e_station_vorher_in_anforderung			: BOOL := FALSE;
	e_station_vorher_in_abgegeben			: BOOL := FALSE;
END_VAR
VAR_IN_OUT
	st_visu								: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
	a_station_vorher_out_erlaubnis			: BOOL := FALSE;
	a_station_vorher_out_angekommen		: BOOL := FALSE;
	t_WT_WechselZeit					: TIME := t#0ms;
	t_traegerwechselzeit					: TIME := t#0ms;
	t_Zentrierer_ausfahren					: TIME := t#0ms;
	t_Zentrierer_einfahren					: TIME := t#0ms;
	t_komplett_zyklus						: TIME := t#0ms;
END_VAR
VAR
	fb_ton_uez							: TON;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_wt_auf_beladepos				: TON;
	fb_tof_wt_auf_beladepos				: TOF;
	fb_r_trig_start							: R_TRIG;
	fb_r_trig_beladepos					: R_TRIG;
	fb_r_trig_beladepos_verlassen			: R_TRIG;
	fb_r_trig_pm_time						: R_TRIG;
	fb_state_entry							: ST_StateEntry;
	sm_wt_hat_beladepos_nicht_verlassen	: BOOL := FALSE;
	sm_tagnummer_ungueltig				: BOOL := FALSE;
	sm_wt_hat_kein_tag					: BOOL := FALSE;
	sm_tagreader_nicht_fertig				: BOOL := FALSE;
	sm_wt_zu_frueh_in_zelle				: BOOL := FALSE;
	sm_keine_bandfreigabe				: BOOL := FALSE;
	bm_abfrage_wt_auf_beladepos			: BOOL := FALSE;
	bm_warte_anforderung					: BOOL := FALSE;
	bm_warte_auf_wt_an_stopper			: BOOL := FALSE;
	bMerkerSchrittketteKommtVonInit		: BOOL := FALSE;
	fb_ton_abfrage_wt_auf_beladepos		: TON;
	fb_ton_warte_anforderung				: TON;
	fb_ton_warte_auf_wt_an_stopper			: TON;
	fb_WT_WechselZeit					: ST_Taktzeit;
	fb_Tisch_WechselZeit					: ST_Taktzeit;
	fb_Zentrierer_ausfahren				: ST_Taktzeit;
	fb_Zentrierer_einfahren					: ST_Taktzeit;
	t_bestueckzeit						: TIME := t#0ms;
	i									: INT := 0;

	sm_sensorfehler_beladepos			: BOOL := FALSE;

	(* zum Testen der Achsen nach Tausch, Bestückbild "Becherspucken", WKZ ausgebaut, Vorschubkontrolle abeschaltet,
	Bit muss von Programmierer geforct werden, zum Beenden Schlüsselschalter auf HAND und Zelle neu starten *)
	b_Dauertest_Achsen					: BOOL := FALSE;

	e_wt_auf_beladepos					AT %I* : BOOL;
	e_wt_im_aktionsfeld					AT %I* : BOOL;
	e_wt_beladepos_verlassen				AT %I* : BOOL;
	e_wt_auf_pufferstrecke					AT %I* : BOOL;
	e_wt_faellt_in_achse_ueberw			AT %I* : BOOL;

	zeit_wt_kompletter_zyklus				: DINT := 0;

	i16_state_msg						: INT;
	pm_traegerwechselzeit					: BOOL := FALSE;
	t_tischwechselzeit					: TIME := t#0ms;
	t_tischwechselzeit_help				: TIME := t#0ms;

END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

fb_ton_wt_auf_beladepos(IN:= e_wt_auf_beladepos, PT:= t#100ms, Q=> , ET=> );
fb_tof_wt_auf_beladepos(IN:= e_wt_auf_beladepos, PT:= t#100ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_beladepos(CLK:= e_wt_auf_beladepos, Q=> );
fb_r_trig_beladepos_verlassen(CLK:= e_wt_beladepos_verlassen, Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );

(*Trägerwechselzeiten*)
fb_WT_WechselZeit(b_start:= , t_zeit=> );
fb_Zentrierer_ausfahren(b_start:= , t_zeit=> );
fb_Zentrierer_einfahren(b_start:= , t_zeit=> );
fb_Tisch_WechselZeit(b_start:= , t_zeit=> );


(*Meldung für Trägerwechselzeit zu groß*)
fb_r_trig_pm_time(CLK:= pm_traegerwechselzeit, Q=> );

IF fb_r_trig_pm_time.Q  THEN
	t_tischwechselzeit_help := t_tischwechselzeit;
	i16_state_msg := 1;
END_IF

(*Produktionsmeldung für Übergabe zu lange*)
CASE i16_state_msg OF
	1: (*Warten bis keine ander Produktions Meldung ansteht *)
		IF	TestAndSet(ST_Message_Produktion.LockFlag) THEN
			ST_Message_Produktion.ClearMessageLines();
			i16_state_msg := 2;
		END_IF

	2:  (*Produktions Meldung*)
		Visu.MeldungProduktion.Color_R := 255;
		Visu.MeldungProduktion.Color_G := 255;
		Visu.MeldungProduktion.Color_B := 0;
		IF visu.s_akt_sprache = 'de' THEN
			Visu.MeldungProduktion.Name:=CONCAT('WT zu langsam vom Tisch gefahren.',TIME_TO_STRING(t_tischwechselzeit_help));
		ELSIF visu.s_akt_sprache = 'en' THEN
			Visu.MeldungProduktion.Name:=CONCAT('carrier exceeded time to leave stiching table.',TIME_TO_STRING(t_tischwechselzeit_help));
		ELSIF visu.s_akt_sprache = 'cz' THEN
			Visu.MeldungProduktion.Name:=CONCAT('Prekroceni casu vyjezdu paletky z osazovani.',TIME_TO_STRING(t_tischwechselzeit_help));
		END_IF
		Visu.MeldungProduktion.ShowMessage := TRUE;
		Visu.MeldungProduktion.Button1.sichtbar:=TRUE;	(*OK*)
		Visu.MeldungProduktion.Button1.Text:='Ok';
		i16_state_msg := 3;

	3:  (*Warte auf OK*)
		IF Visu.MeldungProduktion.Button1.tasten THEN
			i16_state_msg:=0;
		END_IF
END_CASE

(* ==================================Toplevel=================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF st_ctrl_in.b_stop THEN
		fb_state_entry.i16_next_step := STOP;

	(* Allgemeine Fehler *)
	ELSIF zyl_wt_zentrierer_tisch.st_ctrl.out.b_fehler OR zyl_wt_stopper_tisch.st_ctrl.out.b_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;

	(* Überwachung ob ein WT zu früh in die Zelle fällt und dadurch die Z-Achse beschädigt *)
	ELSIF e_wt_faellt_in_achse_ueberw AND ST_Z_Achse.fb_state_entry.i16_step >=130 AND
		ST_Z_Achse.fb_state_entry.i16_step < FEHLER THEN
			sm_wt_zu_frueh_in_zelle := TRUE;
			fb_state_entry.i16_next_step := FEHLER;

	(* Zylinder im Handbetrieb *)
	ELSIF gi16_betriebsart = HAND AND
		(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_wt_zentrierer_tisch.fb.st_config.i16_identnummer OR
		st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_wt_stopper_tisch.fb.st_config.i16_identnummer)
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ============================Haupt-Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := FALSE;
			axis_z_achse.st_ctrl.in.b_start := FALSE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := FALSE;
			sm_wt_hat_beladepos_nicht_verlassen := FALSE;
			sm_tagnummer_ungueltig := FALSE;
			sm_wt_hat_kein_tag := FALSE;
			sm_sensorfehler_beladepos := FALSE;
			sm_tagreader_nicht_fertig := FALSE;
			sm_wt_zu_frueh_in_zelle := FALSE;
			sm_keine_bandfreigabe := FALSE;
			bm_abfrage_wt_auf_beladepos := FALSE;
			bm_warte_anforderung := FALSE;
			bm_warte_auf_wt_an_stopper := FALSE;
			balluff_tag_reader.st_ctrl.in.b_start_lesen := FALSE;
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;
			bMerkerSchrittketteKommtVonInit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: (* Initialisierung: Stopper ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_tisch.st_ctrl.out.b_ausgefahren THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := FALSE;
			a_station_vorher_out_angekommen := TRUE;	(* benötigtes Signal, damit es an der Vorgängerzelle in "ST_WT_Transport_Abgabe" weiter gehen kann *)
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:	(* Warte auf Start von Kontroller *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* WT Transport aktiv oder in Simulation *)
		IF st_config.b_station_aktiv OR st_config.b_station_in_simulation THEN

			IF st_ctrl_in.b_start THEN
			(* WT Transport gestartet *)
				st_ctrl_out.b_fertig := FALSE;
				fb_ton_wz.IN := FALSE;
				st_ctrl_out.b_kontroller_start := TRUE;
				(* Abfrage, ob Schrittkette von Init kommt und ob WT auf Beladepos ist *)
				IF bMerkerSchrittketteKommtVonInit AND
					e_wt_auf_beladepos THEN
					fb_state_entry.i16_next_step := 170;	(* WT auslesen und prüfen, ob dieser schon bestückt wurde *)
				ELSE
					fb_state_entry.i16_next_step := 110;
				END_IF
			END_IF

		(* WT-Transport nicht aktiv  *)
		ELSE
			IF fb_r_trig_start.Q THEN
			(* Nur Z-Achse gestartet *)
				st_ctrl_out.b_fertig := FALSE;
				fb_ton_wz.IN := FALSE;
				fb_state_entry.i16_next_step := 500;
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			bMerkerSchrittketteKommtVonInit := FALSE;
		END_IF

(*=======================================================*)
	105: (* Schreibe Daten auf Tag *)
		IF fb_state_entry.E THEN
			(* WT wird auf jeden Fall mit "nio" beschrieben *)
			ST_Markiere_WT_NIO();
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF balluff_tag_reader.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110: (* WT-Abfrage auf Beladeposition *)

		IF NOT e_station_vorher_in_abgegeben THEN
			a_station_vorher_out_angekommen := FALSE;
			bm_abfrage_wt_auf_beladepos := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wt_auf_beladepos THEN
			(* Ein WT ist anwesend zum rausschicken *)
			IF NOT ST_WT_Transport_Abgabe.e_wt_auf_abgabepos THEN
				(* Erst wenn kein Stau vorhanden ist, dann wird der WT weiter gelassen *)
				fb_state_entry.i16_next_step := 120;
			END_IF
		ELSE
			fb_state_entry.i16_next_step := 140;
		END_IF

		IF fb_state_entry.X THEN
			bm_abfrage_wt_auf_beladepos := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
		END_IF

(*=======================================================*)
	120: (* WT-Zentrierer und Stopper einfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := TRUE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := TRUE;
			fb_Zentrierer_einfahren(b_start:= TRUE, t_zeit=> );
			fb_Tisch_WechselZeit(b_start:=TRUE , t_zeit=> );
			pm_traegerwechselzeit := FALSE;
		END_IF

		IF 	zyl_wt_zentrierer_tisch.st_ctrl.out.b_eingefahren THEN
			fb_Zentrierer_einfahren(b_start:= FALSE, t_zeit=>t_Zentrierer_einfahren );
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_tisch.st_ctrl.out.b_eingefahren AND zyl_wt_zentrierer_tisch.st_ctrl.out.b_eingefahren THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 130;
		END_IF

(*=======================================================*)
	130: (* WT fährt von Bestücktisch heraus *)
		IF fb_state_entry.E THEN
			fb_ton_uez.PT := t#5s;
 			fb_ton_uez.IN := TRUE;
			st_ctrl_out.b_kontroller_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_beladepos_verlassen.Q THEN
			fb_ton_uez.IN := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			IF	gst_datensatz.st_md.i16_WdhTouchProbe = 0 THEN
				fb_state_entry.i16_next_step := 144;
			ELSE
				fb_state_entry.i16_next_step := 140;
			END_IF
		ELSIF fb_ton_uez.Q THEN
			sm_wt_hat_beladepos_nicht_verlassen := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	140: (* Starte Touchprobe => kann immer gestartet werden. Wenn kein Taster eingebaut ist, wird gleich wieder fertig gemeldet*)
		IF fb_state_entry.E THEN
			ST_TouchProbe.st_ctrl_in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	ST_TouchProbe.st_ctrl_out.b_busy THEN
			fb_state_entry.i16_next_step := 142;
		END_IF

(*=======================================================*)
	142: (* Warte auf fertig*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	ST_TouchProbe.st_ctrl_out.b_fertig THEN
			fb_state_entry.i16_next_step := 144;
		END_IF

(*=======================================================*)
	144: (* Stopper in Simulation nicht ausfahren  und  WT-Zentrierer einfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := TRUE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_wt_stopper_tisch.st_ctrl.out.b_ausgefahren AND
			zyl_wt_zentrierer_tisch.st_ctrl.out.b_eingefahren
			THEN
				zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := FALSE;
				zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := FALSE;
				fb_Tisch_WechselZeit(b_start:=FALSE , t_zeit=>t_tischwechselzeit );
				pm_traegerwechselzeit := t_tischwechselzeit > gst_datensatz.st_md.t_max_tischwechselzeit AND gst_datensatz.st_md.t_max_tischwechselzeit <> INT_TO_TIME(0);
				fb_state_entry.i16_next_step := 150;
		END_IF

(*=======================================================*)
	150: (* Warte auf Anforderung von vorheriger Station *)
		IF fb_state_entry.E THEN
			bm_warte_anforderung := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_station_vorher_in_anforderung AND NOT e_wt_auf_beladepos THEN
			a_station_vorher_out_angekommen := FALSE;
			a_station_vorher_out_erlaubnis := TRUE;
			st_ctrl_out.b_kontroller_start := TRUE;
			bm_warte_anforderung := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160: (* Warte bis angekommen an Tisch-Stopper *)
		IF fb_state_entry.E THEN
			bm_warte_auf_wt_an_stopper := TRUE;
		END_IF

		IF e_wt_im_aktionsfeld AND NOT fb_ton_wz.Q THEN
			fb_ton_wz.PT := t#3s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*Kontroller neu starten wenn das Förderband zwischenzeitlich abgeschaltet hat*)
		IF 	e_station_vorher_in_abgegeben AND NOT ST_WT_Transport_Kontroller.a_foerderband_wt_transport THEN
			st_ctrl_out.b_kontroller_start := TRUE;
		ELSE
			st_ctrl_out.b_kontroller_start := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Auf das Kommando "e_station_vorher_in_abgegeben" wird nicht gewartet,
		da auch mal ein WT nach einer Störung so aus der vorherigen Station kommen kann. *)
		IF fb_ton_wt_auf_beladepos.Q THEN
			st_ctrl_out.b_kontroller_start := FALSE;
			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := TRUE;
			bm_warte_auf_wt_an_stopper := FALSE;
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 170;
		END_IF

		(*Abfrage auf Sensorfehler des Beladepositionssensors *)
		IF e_wt_im_aktionsfeld AND NOT e_wt_auf_beladepos AND fb_ton_wz.Q THEN
			sm_sensorfehler_beladepos := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	170: (* WT-Zentrierer ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
			fb_Zentrierer_ausfahren(b_start:= TRUE, t_zeit=> );
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_ausgefahren AND
			NOT ST_TippTasten.b_einfaedeln_aktiv AND
			(NOT ST_Virtuelle_Masterachse.b_merker_bandende_links  OR
 			NOT ST_Virtuelle_Masterachse.b_merker_bandende_rechts) THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_Zentrierer_ausfahren(b_start:= FALSE, t_zeit=> t_Zentrierer_ausfahren);
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			IF st_config.b_station_in_simulation THEN
				(* WT-Transport ist in Simulation und deshalb wird der WT ohne zu Bestücken weiter gefahren *)
				fb_state_entry.i16_next_step := BEREIT;
			ELSE
				fb_state_entry.i16_next_step := 190;
			END_IF
		END_IF

(*=======================================================*)
	190: (* WT-Tag mit RFID-Lesegerät abfragen *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#100ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			IF e_wt_im_aktionsfeld THEN
				(* Tag auslesen *)
				fb_state_entry.i16_next_step := 240;
			ELSE
				(* Kein Tag auf WT *)
				sm_wt_hat_kein_tag := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			fb_ton_wz.IN := FALSE;
		END_IF

(*=======================================================*)
	240: (* Starte Z-Achse *)
		IF fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_start := TRUE;
			st_ctrl_out.b_kontroller_start := TRUE;
			(*Zeitmessung Trägerwechsel stoppen und ausgeben*)
			fb_WT_WechselZeit(b_start:=FALSE , t_zeit=>t_WT_WechselZeit );
			(*Zeitmessung Bestückvorgang starten*)
			fb_Zentrierer_ausfahren(b_start:= FALSE, t_zeit=>t_Zentrierer_ausfahren );
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_start := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := TRUE;
			(*Zeitmessung Trägerwechsel starten*)
			fb_WT_WechselZeit(b_start:=TRUE , t_zeit=> );
			(*Zeitmessung zusammenfassen*)
			t_bestueckzeit:=ST_Z_Achse.t_Bestueckung;
			t_traegerwechselzeit:=t_WT_WechselZeit + ST_Z_Achse.t_Z_Achse_einfahren + ST_Z_Achse.t_Z_Achse_ausfahren;
			t_komplett_zyklus:= t_traegerwechselzeit + t_bestueckzeit;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

		IF fb_state_entry.X THEN
			gst_datensatz.st_md.produzierte_Stecker := gst_datensatz.st_md.produzierte_Stecker + 1;
		END_IF

(*=======================================================*)
	500: (* Warte bis angekommen an Stopper *)
		IF fb_state_entry.E THEN
			bm_warte_auf_wt_an_stopper := TRUE;
		END_IF

		IF e_wt_im_aktionsfeld AND NOT fb_ton_wz.Q THEN
			fb_ton_wz.PT := t#3s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wt_auf_beladepos.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 510;
		END_IF

		(*Abfrage auf Sensorfehler des Beladepositionssensors *)
		IF e_wt_im_aktionsfeld AND NOT e_wt_auf_beladepos AND fb_ton_wz.Q THEN
			sm_sensorfehler_beladepos := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	510: (* WT-Zentrierer ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_ausgefahren  THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 520;
		END_IF

(*=======================================================*)
	520:	(* Produktion ohne aktiven WT Transport *)
		IF fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_start := FALSE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := TRUE;
			IF NOT b_Dauertest_Achsen THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSE
				(* zum Testen der Achsen nach Tausch, Bestückbild "Becherspucken", WKZ ausgebaut, Vorschubkontrolle abeschaltet,
				Bit muss von Programmierer geforct werden, zum Beenden Schlüsselschalter auf HAND und Zelle neu starten *)
				fb_state_entry.i16_next_step := 500;	(* Dauertest *)
			END_IF
		END_IF

		IF fb_state_entry.X AND NOT b_Dauertest_Achsen THEN
			gst_datensatz.st_md.produzierte_Stecker := gst_datensatz.st_md.produzierte_Stecker + 1;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := FALSE;

			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;

			st_ctrl_out.b_kontroller_start := FALSE;

			(*ST_Markiere_WT_NIO();*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := TRUE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := FALSE;
			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;
			(*ST_Markiere_WT_NIO();*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := TRUE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

fb_ton_abfrage_wt_auf_beladepos (IN:=bm_abfrage_wt_auf_beladepos,PT:=t#30s);
fb_ton_warte_anforderung (IN:=bm_warte_anforderung,PT:=t#30s);
fb_ton_warte_auf_wt_an_stopper (IN:=bm_warte_auf_wt_an_stopper,PT:=t#30s);

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_wt_hat_beladepos_nicht_verlassen;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_tagnummer_ungueltig;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_wt_hat_kein_tag;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_sensorfehler_beladepos;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := sm_tagreader_nicht_fertig;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := sm_wt_zu_frueh_in_zelle;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := sm_keine_bandfreigabe;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := fb_ton_abfrage_wt_auf_beladepos.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := fb_ton_warte_anforderung.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := fb_ton_warte_auf_wt_an_stopper.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/WT Transport' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_WT_Transport_Beladen_Achse_1700
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;
	e_wt_im_aktionsfeld					: BOOL;
END_VAR
VAR_IN_OUT
	st_visu								: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
	t_WT_WechselZeit					: TIME := t#0ms;
	t_traegerwechselzeit					: TIME := t#0ms;
	t_Zentrierer_ausfahren					: TIME := t#0ms;
	t_Zentrierer_einfahren					: TIME := t#0ms;
	t_komplett_zyklus						: TIME := t#0ms;
END_VAR
VAR
	fb_ton_uez							: TON;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_wt_auf_beladepos				: TON;
	fb_tof_wt_auf_beladepos				: TOF;
	fb_r_trig_start							: R_TRIG;
	fb_r_trig_beladepos					: R_TRIG;
	fb_r_trig_beladepos_verlassen			: R_TRIG;
	fb_state_entry							: ST_StateEntry;
	fb_traegerwechselzeit					: ST_Taktzeit;
	fb_WT_WechselZeit					: ST_Taktzeit;
	fb_Zentrierer_ausfahren				: ST_Taktzeit;
	fb_Zentrierer_einfahren					: ST_Taktzeit;
	t_bestueckzeit						: TIME := t#0ms;
	sm_wt_hat_beladepos_nicht_verlassen	: BOOL := FALSE;
	sm_tagnummer_ungueltig				: BOOL := FALSE;
	sm_wt_hat_kein_tag					: BOOL := FALSE;
	sm_tagreader_nicht_fertig				: BOOL := FALSE;
	sm_keine_bandfreigabe				: BOOL := FALSE;
	sm_sensorfehler_beladepos			: BOOL := FALSE;
	bm_abfrage_wt_auf_beladepos			: BOOL := FALSE;
	bm_abfrage_wt_auf_wartepos			: BOOL := FALSE;
	bm_warte_auf_wt_an_stopper			: BOOL := FALSE;
	bMerkerSchrittketteKommtVonInit		: BOOL := FALSE;
	fb_ton_abfrage_wt_auf_beladepos		: TON;
	fb_ton_warte_auf_wt_an_stopper			: TON;
	i									: INT := 0;

	(* zum Testen der Achsen nach Tausch, Bestückbild "Becherspucken", WKZ ausgebaut, Vorschubkontrolle abeschaltet,
	Bit muss von Programmierer geforct werden, zum Beenden Schlüsselschalter auf HAND und Zelle neu starten *)
	b_Dauertest_Achsen					: BOOL := FALSE;

	e_wt_auf_beladepos					AT %I* : BOOL;
	e_wt_beladepos_verlassen				AT %I* : BOOL;
	e_wt_auf_pufferstrecke					AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

fb_ton_wt_auf_beladepos(IN:= e_wt_im_aktionsfeld, PT:= t#200ms, Q=> , ET=> );
fb_tof_wt_auf_beladepos(IN:= e_wt_im_aktionsfeld, PT:= t#200ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_beladepos(CLK:= e_wt_auf_beladepos, Q=> );
fb_r_trig_beladepos_verlassen(CLK:= e_wt_beladepos_verlassen, Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );

(*Trägerwechselzeiten*)
fb_WT_WechselZeit(b_start:= , t_zeit=> );
fb_Zentrierer_ausfahren(b_start:= , t_zeit=> );
fb_Zentrierer_einfahren(b_start:= , t_zeit=> );

(* ==================================Toplevel=================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* Allgemeine Fehler *)
	IF st_ctrl_in.b_stop THEN
		fb_state_entry.i16_next_step := STOP;
	ELSIF zyl_wt_zentrierer_tisch.st_ctrl.out.b_fehler OR
		zyl_Indexier_Bestueckpos.st_ctrl.out.b_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;
	(* Zylinder im Handbetrieb *)
	ELSIF gi16_betriebsart = HAND AND
		st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_wt_zentrierer_tisch.fb.st_config.i16_identnummer OR
		st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_Indexier_Bestueckpos.fb.st_config.i16_identnummer  THEN
		fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ============================Haupt-Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_luftlos := FALSE;
			axis_transport_wt_achse.st_ctrl.in.b_start := FALSE;
			axis_z_achse.st_ctrl.in.b_start := FALSE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := FALSE;
			sm_wt_hat_beladepos_nicht_verlassen := FALSE;
			sm_tagnummer_ungueltig := FALSE;
			sm_wt_hat_kein_tag := FALSE;
			sm_tagreader_nicht_fertig := FALSE;
			sm_keine_bandfreigabe := FALSE;
			bm_abfrage_wt_auf_beladepos := FALSE;
			bm_warte_auf_wt_an_stopper := FALSE;
			balluff_tag_reader.st_ctrl.in.b_start_lesen := FALSE;
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_ausfahren := FALSE;
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_einfahren := FALSE;
			bMerkerSchrittketteKommtVonInit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_quittieren := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: fb_state_entry.s_debugtext := 'Initialisierung: Stopper an Bestücktisch ausfahren und Zentrierer einfahren';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wt_im_aktionsfeld THEN
			fb_state_entry.i16_next_step := 25;
		ELSE
			fb_state_entry.i16_next_step := 22;
		END_IF

(*=======================================================*)
	22: fb_state_entry.s_debugtext := 'Initialisierung: Stopper an Bestücktisch ausfahren und Zentrierer einfahren';

		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  zyl_wt_zentrierer_tisch.st_ctrl.out.b_eingefahren THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	25: fb_state_entry.s_debugtext := 'Initialisierung: Stopper an Bestücktisch ausfahren und Zentrierer einfahren';

		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  zyl_wt_zentrierer_tisch.st_ctrl.out.b_ausgefahren THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30: fb_state_entry.s_debugtext := 'Indexierzylinder wieder einfahren';

		IF fb_state_entry.E THEN
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_ausfahren:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_Indexier_Bestueckpos.st_ctrl.out.b_ausgefahren THEN
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_ausfahren:= FALSE;
			fb_state_entry.i16_next_step := 35;
		END_IF

(*=======================================================*)
	35: fb_state_entry.s_debugtext := 'warten auf Achse bereit';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_bereit AND
			NOT axis_transport_wt_achse.st_ctrl.in.b_start THEN
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40: fb_state_entry.s_debugtext := 'Fahre Achse wieder zurück';

		IF fb_state_entry.E THEN
			ST_WT_Transport_Achse.lr_Achspos_in:=gst_datensatz.st_md.st_md_transport_wt_achse.lr_startposition;
			ST_WT_Transport_Achse.lr_Velo_in:= gst_datensatz.st_md.r_geschwindigkeit_achse_transport;
			ST_WT_Transport_Achse.enu_cmd_in:=MOVE_ABSOLUTE;
			axis_transport_wt_achse.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  axis_transport_wt_achse.st_ctrl.out.b_busy THEN
			axis_transport_wt_achse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50: fb_state_entry.s_debugtext := 'warten auf Achse hinten fertig';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_fertig  THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:	fb_state_entry.s_debugtext := 'Warte auf Start von Kontroller';

		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_config.b_station_aktiv OR st_config.b_station_in_simulation THEN

		(* WT Transport aktiv oder in Simulation *)
			IF 	st_ctrl_in.b_start  AND
				((NOT ST_Virtuelle_Masterachse.b_merker_bandende_links  AND
 				NOT ST_Virtuelle_Masterachse.b_merker_bandende_rechts) OR
				gst_datensatz.st_md.b_auto_Bandwechsel) THEN
			(* WT Transport gestartet *)
				st_ctrl_out.b_fertig := FALSE;
				fb_ton_wz.IN := FALSE;
				st_ctrl_out.b_kontroller_start := TRUE;
				(* Abfrage, ob Schrittkette von Init kommt und ob WT auf Beladepos ist *)
				IF bMerkerSchrittketteKommtVonInit AND
					e_wt_auf_beladepos THEN
					fb_state_entry.i16_next_step := 150;	(* WT auslesen und prüfen, ob dieser schon bestückt wurde *)
				ELSE
					fb_state_entry.i16_next_step := 110;
				END_IF
			END_IF

		(* WT-Transport nicht aktiv  *)
		ELSE
			IF fb_r_trig_start.Q THEN
				(* Nur Z-Achse gestartet *)
				st_ctrl_out.b_fertig := FALSE;
				fb_ton_wz.IN := FALSE;
				fb_state_entry.i16_next_step := 500;
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			bMerkerSchrittketteKommtVonInit := FALSE;
		END_IF

(*=======================================================*)
	110: fb_state_entry.s_debugtext := 'WT-Abfrage auf Beladeposition';

		IF fb_state_entry.E THEN
			bm_abfrage_wt_auf_beladepos := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wt_im_aktionsfeld THEN
			(* Ein WT ist anwesend zum rausschicken *)
			IF NOT ST_WT_Transport_Abgabe.e_wt_auf_abgabepos THEN
				(* Erst wenn kein Stau vorhanden ist, dann wird der WT weiter gelassen *)
				fb_state_entry.i16_next_step := 115;
			END_IF
		ELSE	(* Kein WT da, deshalb einen holen *)
			fb_state_entry.i16_next_step := 130;
		END_IF

		IF fb_state_entry.X THEN
			bm_abfrage_wt_auf_beladepos := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
		END_IF

(*=======================================================*)
	115: fb_state_entry.s_debugtext := 'Indexierzylinder Bestückposition ausfahren (WT festhalten)';

		IF fb_state_entry.E THEN
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_einfahren:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_Indexier_Bestueckpos.st_ctrl.out.b_eingefahren THEN
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_einfahren:= FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120: fb_state_entry.s_debugtext := 'WT-Zentrierer einfahren';

		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := TRUE;
			fb_Zentrierer_einfahren(b_start:= TRUE, t_zeit=> );
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_eingefahren THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := FALSE;
			fb_Zentrierer_einfahren(b_start:= FALSE, t_zeit=>t_Zentrierer_einfahren);
			fb_state_entry.i16_next_step := 130;
		END_IF

(*=======================================================*)
	130: fb_state_entry.s_debugtext := 'WT ist auf Warteposition und mit Indexierzylinder fixiert, wenn 2 Sekunden kein WT aus der vorherigen Zelle kommt wird der WT weitergeschickt';

		IF fb_state_entry.E THEN
			bm_abfrage_wt_auf_wartepos := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_WT_Transport_Warteposition_1700.e_wt_auf_wartepos_1700 AND
			 zyl_Indexier_Einlauf.st_ctrl.out.b_eingefahren AND
			ST_WT_Transport_Warteposition_1700.b_helpStartAchse AND
			zyl_wt_stopper_tisch.st_ctrl.out.b_eingefahren THEN
			fb_state_entry.i16_next_step := 135;
		ELSIF fb_state_entry.fb_ton_Step.ET >= T#2S AND
			 zyl_Indexier_Bestueckpos.st_ctrl.out.b_eingefahren THEN
			fb_state_entry.i16_next_step := 132;
		END_IF

(*=======================================================*)
	132: fb_state_entry.s_debugtext := 'Warten bis kein WT mehr auf der Abgabeposition steht';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT ST_WT_Transport_Abgabe.e_wt_auf_abgabepos THEN
			fb_state_entry.i16_next_step := 135;
		END_IF

(*=======================================================*)
	135: fb_state_entry.s_debugtext := 'warten auf Achse bereit';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_bereit AND
			NOT axis_transport_wt_achse.st_ctrl.out.b_busy  AND
			NOT axis_transport_wt_achse.st_ctrl.in.b_start AND
			((ST_WT_Transport_Warteposition_1700.b_helpStartAchse AND
			ST_WT_Transport_Warteposition_1700.e_wt_auf_wartepos_1700)
			OR
			(zyl_Indexier_Einlauf.st_ctrl.out.b_ausgefahren AND
			NOT ST_WT_Transport_Warteposition_1700.e_wt_auf_wartepos_1700))  THEN
			fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	140: fb_state_entry.s_debugtext := 'Fahre Achse nach vorne -> Bestückposition';

		IF fb_state_entry.E THEN
			ST_WT_Transport_Achse.lr_Achspos_in:=gst_datensatz.st_md.st_md_transport_wt_achse.lr_wt_uebergabepos;
			ST_WT_Transport_Achse.lr_Velo_in:= gst_datensatz.st_md.r_geschwindigkeit_achse_transport;
			ST_WT_Transport_Achse.enu_cmd_in:=MOVE_ABSOLUTE;
			axis_transport_wt_achse.st_ctrl.in.b_start := TRUE;

			st_ctrl_out.b_kontroller_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_busy THEN
			axis_transport_wt_achse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 145;
		END_IF

(*=======================================================*)
	145: fb_state_entry.s_debugtext := 'warten auf Achse vorne fertig';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_fertig THEN
			IF  zyl_Indexier_Einlauf.st_ctrl.out.b_eingefahren THEN
				fb_state_entry.i16_next_step := 147;	(* Neuer WT kommt von Warteposition *)
			ELSE
				fb_state_entry.i16_next_step := 300;	(* Es kommt kein neuer WT *)
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			st_ctrl_out.b_kontroller_start := FALSE;
		END_IF

(*=======================================================*)
	147: fb_state_entry.s_debugtext := 'Prüfe, ob WT auf Beladeposition angekommen ist';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wt_im_aktionsfeld AND
			NOT  ST_WT_Transport_Warteposition_1700.e_wt_auf_wartepos_1700  THEN
			fb_state_entry.i16_next_step := 150;
		ELSE
			sm_wt_hat_beladepos_nicht_verlassen := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	150: (*erst weiter wenn Abgabe funktioniert hat  *)

		IF 	NOT ST_WT_Transport_Abgabe.sm_wt_hat_abgabepos_nicht_verlassen THEN
			fb_state_entry.i16_next_step := 152;
		END_IF

		IF fb_state_entry.fb_ton_Step.ET > t#5s  THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF

(*=======================================================*)
	152: (* WT-Zentrierer ausfahren *)

		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_ausfahren:= TRUE;
			fb_Zentrierer_ausfahren(b_start:= TRUE, t_zeit=> );
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_ausgefahren AND
			NOT ST_TippTasten.b_einfaedeln_aktiv AND
			NOT ST_Virtuelle_Masterachse.b_merker_bandende_links  AND
 			NOT ST_Virtuelle_Masterachse.b_merker_bandende_rechts AND
			zyl_Indexier_Bestueckpos.st_ctrl.out.b_ausgefahren THEN
			fb_Zentrierer_ausfahren(b_start:= FALSE, t_zeit=> t_Zentrierer_ausfahren);
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 155;
		END_IF

(*=======================================================*)
	155: fb_state_entry.s_debugtext := 'WT-Tag mit RFID-Lesegerät abfragen';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_state_entry.fb_ton_Step.ET >= T#100MS THEN
			IF e_wt_im_aktionsfeld THEN
				(* Tag auslesen *)
				fb_state_entry.i16_next_step := 160;
			ELSE
				(* Kein Tag auf WT *)
				sm_wt_hat_kein_tag := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	160: fb_state_entry.s_debugtext := 'Prüfe ob Simulation';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	st_config.b_station_in_simulation AND
			NOT visu.b_inbetriebnahme THEN
			fb_state_entry.i16_next_step := 300;
		ELSE
			fb_state_entry.i16_next_step := 170;
		END_IF

(*=======================================================*)
	170: fb_state_entry.s_debugtext := 'Z-Achse und anschliessend Bestückachse wird gestartet';

		IF fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_start := TRUE;
			(*Zeitmessung Trägerwechsel stoppen und ausgeben*)
			fb_WT_WechselZeit(b_start:=FALSE , t_zeit=>t_WT_WechselZeit );
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_busy THEN
			axis_z_achse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 175;
		END_IF

(*=======================================================*)
	175: (*erst weiter wenn Abgabe funktioniert hat  *)

		IF 	NOT ST_WT_Transport_Abgabe.sm_wt_hat_abgabepos_nicht_verlassen THEN
			fb_state_entry.i16_next_step := 180;
		END_IF

		IF fb_state_entry.fb_ton_Step.ET > t#5s  THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF

(*=======================================================*)
	180: fb_state_entry.s_debugtext := 'Indexierzylinder wieder einfahren (WT freigeben)';

		IF fb_state_entry.E THEN
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_ausfahren:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_Indexier_Bestueckpos.st_ctrl.out.b_ausgefahren AND
			zyl_Indexier_Einlauf.st_ctrl.out.b_ausgefahren THEN
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_ausfahren:= FALSE;
			fb_state_entry.i16_next_step := 190;
		END_IF

(*=======================================================*)
	190: fb_state_entry.s_debugtext := 'warten auf Achse bereit';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_bereit AND
			NOT axis_transport_wt_achse.st_ctrl.out.b_busy  AND
			NOT axis_transport_wt_achse.st_ctrl.in.b_start THEN
			fb_state_entry.i16_next_step := 200;
		END_IF

(*=======================================================*)
	200: fb_state_entry.s_debugtext := 'Fahre Achse wieder zurück';

		IF fb_state_entry.E THEN
			ST_WT_Transport_Achse.lr_Achspos_in:=gst_datensatz.st_md.st_md_transport_wt_achse.lr_startposition;
			ST_WT_Transport_Achse.lr_Velo_in:= gst_datensatz.st_md.r_geschwindigkeit_achse_transport;
			ST_WT_Transport_Achse.enu_cmd_in:=MOVE_ABSOLUTE;
			axis_transport_wt_achse.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_busy  THEN
			axis_transport_wt_achse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210: fb_state_entry.s_debugtext := 'warten auf Achse hinten fertig';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_fertig  THEN
			fb_state_entry.i16_next_step := 220;
		END_IF

(*=======================================================*)
	220: fb_state_entry.s_debugtext := 'Indexierzylinder Bestückposition ausfahren (WT festhalten)';

		IF fb_state_entry.E THEN
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_einfahren:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_Indexier_Bestueckpos.st_ctrl.out.b_eingefahren THEN
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_einfahren:= FALSE;
			fb_state_entry.i16_next_step := 230;
		END_IF

(*=======================================================*)
	230: fb_state_entry.s_debugtext := 'Bestückachse ist fertig';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_fertig THEN
			IF axis_z_achse.st_ctrl.out.b_fertig THEN
				(*Zeitmessung Trägerwechsel starten*)
				fb_WT_WechselZeit(b_start:=TRUE , t_zeit=> );
				(*Zeitmessung zusammenfassen*)
				t_bestueckzeit:=ST_Z_Achse.t_Bestueckung;
				t_traegerwechselzeit:=t_WT_WechselZeit + ST_Z_Achse.t_Z_Achse_einfahren + ST_Z_Achse.t_Z_Achse_ausfahren;
				t_komplett_zyklus:= t_traegerwechselzeit + t_bestueckzeit;

				stueckzahlen.st_ctrl.in.b_gutteil_produziert := TRUE;

				st_ctrl_out.b_kontroller_start := FALSE;
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	300: fb_state_entry.s_debugtext := 'Indexierzylinder wieder einfahren (WT freigeben)';

		IF fb_state_entry.E THEN
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_ausfahren:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_Indexier_Bestueckpos.st_ctrl.out.b_ausgefahren AND
			zyl_Indexier_Einlauf.st_ctrl.out.b_ausgefahren THEN
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_ausfahren:= FALSE;
			fb_state_entry.i16_next_step := 310;
		END_IF

(*=======================================================*)
	310: fb_state_entry.s_debugtext := 'warten auf Achse bereit';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_bereit AND
			NOT axis_transport_wt_achse.st_ctrl.out.b_busy  AND
			NOT axis_transport_wt_achse.st_ctrl.in.b_start THEN
			fb_state_entry.i16_next_step := 320;
		END_IF

(*=======================================================*)
	320: fb_state_entry.s_debugtext := 'Fahre Achse wieder zurück';

		IF fb_state_entry.E THEN
			ST_WT_Transport_Achse.lr_Achspos_in:=gst_datensatz.st_md.st_md_transport_wt_achse.lr_startposition;
			ST_WT_Transport_Achse.lr_Velo_in:= gst_datensatz.st_md.r_geschwindigkeit_achse_transport;
			ST_WT_Transport_Achse.enu_cmd_in:=MOVE_ABSOLUTE;
			axis_transport_wt_achse.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_busy  THEN
			axis_transport_wt_achse.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 330;
		END_IF

(*=======================================================*)
	330: fb_state_entry.s_debugtext := 'warten auf Achse hinten fertig';

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	axis_transport_wt_achse.st_ctrl.out.b_fertig  THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	500: fb_state_entry.s_debugtext := 'Warte bis angekommen an Stopper';
		IF fb_state_entry.E THEN
			bm_warte_auf_wt_an_stopper := TRUE;
		END_IF

		IF e_wt_im_aktionsfeld AND NOT fb_ton_wz.Q THEN
			fb_ton_wz.PT := t#3s;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wt_auf_beladepos.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 510;
		END_IF

		(*Abfrage auf Sensorfehler des Beladepositionssensors *)
		IF NOT e_wt_im_aktionsfeld  AND fb_ton_wz.Q THEN
			sm_sensorfehler_beladepos := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	510: fb_state_entry.s_debugtext := 'WT-Zentrierer ausfahren';

		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_ausgefahren  THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 520;
		END_IF

(*=======================================================*)
	520:	fb_state_entry.s_debugtext := 'Produktion ohne aktiven WT Transport';

		IF fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_start := FALSE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := TRUE;
			IF NOT b_Dauertest_Achsen THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSE
				(* zum Testen der Achsen nach Tausch, Bestückbild "Becherspucken", WKZ ausgebaut, Vorschubkontrolle abeschaltet,
				Bit muss von Programmierer geforct werden, zum Beenden Schlüsselschalter auf HAND und Zelle neu starten *)
				fb_state_entry.i16_next_step := 500;	(* Dauertest *)
			END_IF
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_quittieren := FALSE;
			(*ST_Markiere_WT_NIO();*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := TRUE;
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_quittieren := FALSE;

			(*ST_Markiere_WT_NIO();*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := TRUE;
			zyl_Indexier_Bestueckpos.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

fb_ton_abfrage_wt_auf_beladepos (IN:=bm_abfrage_wt_auf_beladepos,PT:=t#30s);
fb_ton_warte_auf_wt_an_stopper (IN:=bm_warte_auf_wt_an_stopper,PT:=t#30s);

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_wt_hat_beladepos_nicht_verlassen;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_tagnummer_ungueltig;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_wt_hat_kein_tag;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_tagreader_nicht_fertig;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := sm_keine_bandfreigabe;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := fb_ton_abfrage_wt_auf_beladepos.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := fb_ton_warte_auf_wt_an_stopper.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/WT Transport' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_WT_Transport_Warteposition_1700
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;
	e_station_vorher_in_anforderung			: BOOL := FALSE;
	e_station_vorher_in_abgegeben			: BOOL := FALSE;
END_VAR
VAR_IN_OUT
	st_visu								: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
	a_station_vorher_out_erlaubnis			: BOOL := FALSE;
	a_station_vorher_out_angekommen		: BOOL := FALSE;
END_VAR
VAR
	fb_ton_uez							: TON;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_wt_auf_wartepos				: TON;
	fb_tof_wt_auf_wartepos					: TOF;
	fb_r_trig_start							: R_TRIG;
	fb_r_trig_wartepos						: R_TRIG;
	fb_r_trig_wartepos_verlassen			: R_TRIG;
	fb_state_entry							: ST_StateEntry;
	sm_wt_hat_wartepos_nicht_verlassen	: BOOL := FALSE;
	sm_wt_hat_wartepos_ueberfahren		: BOOL := FALSE;
	bm_warte_anforderung					: BOOL := FALSE;
	bm_warte_wt_an_stopper				: BOOL := FALSE;
	bm_warte_beladepos_frei				: BOOL := FALSE;

	b_helpStartAchse						:BOOL;

	e_wt_auf_wartepos_1700					AT %I* : BOOL;
	e_wt_wartepos_verlassen_1700				AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

fb_ton_wt_auf_wartepos(IN:= e_wt_auf_wartepos_1700, PT:= t#200ms, Q=> , ET=> );
fb_tof_wt_auf_wartepos(IN:= e_wt_auf_wartepos_1700, PT:= t#200ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_wartepos(CLK:= e_wt_auf_wartepos_1700, Q=> );
fb_r_trig_wartepos_verlassen(CLK:= e_wt_wartepos_verlassen_1700, Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );

(* ==================================Toplevel=================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* Allgemeine Fehler *)
	IF st_ctrl_in.b_stop THEN
		fb_state_entry.i16_next_step := STOP;
	ELSIF zyl_wt_stopper_tisch.st_ctrl.out.b_fehler OR
		zyl_Indexier_Einlauf.st_ctrl.out.b_fehler  THEN
		fb_state_entry.i16_next_step := FEHLER;
	(* Zylinder im Handbetrieb *)
	ELSIF gi16_betriebsart = HAND AND
		st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_wt_stopper_tisch.fb.st_config.i16_identnummer OR
		st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_Indexier_Einlauf.fb.st_config.i16_identnummer THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ============================Haupt-Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := FALSE;
			zyl_Indexier_Einlauf.st_ctrl.in.b_ausfahren := FALSE;
			zyl_Indexier_Einlauf.st_ctrl.in.b_einfahren := FALSE;
			sm_wt_hat_wartepos_nicht_verlassen := FALSE;
			sm_wt_hat_wartepos_ueberfahren := FALSE;
			bm_warte_anforderung := FALSE;
			bm_warte_wt_an_stopper := FALSE;
			bm_warte_beladepos_frei := FALSE;
			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;
			b_helpStartAchse := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_Indexier_Einlauf.st_ctrl.in.b_quittieren := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: (* Initialisierung: Prüfe ob WT auf Warteposition *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT  e_wt_auf_wartepos_1700 THEN
			fb_state_entry.i16_next_step :=  30;
		ELSE
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	30: (* Indexierzylinder wieder einfahren und Stopper ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := TRUE;
			zyl_Indexier_Einlauf.st_ctrl.in.b_ausfahren:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_Indexier_Einlauf.st_ctrl.out.b_ausgefahren THEN
			zyl_Indexier_Einlauf.st_ctrl.in.b_ausfahren:= FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	40: (*Einlauf Stopper einfahren und WT mit Indexierzylinder fixieren *)

		IF fb_state_entry.E THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := TRUE;
			zyl_Indexier_Einlauf.st_ctrl.in.b_ausfahren:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_wt_stopper_tisch.st_ctrl.out.b_eingefahren AND
			zyl_Indexier_Einlauf.st_ctrl.out.b_ausgefahren AND
			transport_wt_achse.NcToPlc.ActPos <
			gst_datensatz.st_md.st_md_transport_wt_achse.lr_startposition + 0.1 THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := FALSE;
			zyl_Indexier_Einlauf.st_ctrl.in.b_ausfahren:= FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50: (*Einlauf Stopper einfahren und WT mit Indexierzylinder fixieren *)

		IF fb_state_entry.E THEN
			zyl_Indexier_Einlauf.st_ctrl.in.b_einfahren:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_Indexier_Einlauf.st_ctrl.out.b_eingefahren THEN
			zyl_Indexier_Einlauf.st_ctrl.in.b_einfahren:= FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:	(* Warte auf Start von Kontroller *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_config.b_station_aktiv OR st_config.b_station_in_simulation THEN
			(* WT Transport aktiv oder in Simulation *)
			IF st_ctrl_in.b_start THEN
			(* WT Transport gestartet *)
				st_ctrl_out.b_fertig := FALSE;
				fb_state_entry.i16_next_step := 110;
			END_IF
		END_IF

(*=======================================================*)
	110: (* Statische WT-Abfrage auf Warteposition nach der Initialisierung *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_kontroller_start := TRUE;
		END_IF

		IF NOT e_station_vorher_in_abgegeben THEN
			a_station_vorher_out_angekommen := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wt_auf_wartepos_1700 THEN
			st_ctrl_out.b_kontroller_start := FALSE;
			fb_state_entry.i16_next_step := 135;
		ELSE	(* Kein WT da, deshalb einen holen *)
			st_ctrl_out.b_kontroller_start := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120: (* Kein WT da -> warte auf Anforderung von vorheriger Station *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_kontroller_start := TRUE;
			bm_warte_anforderung := TRUE;
		END_IF

		IF NOT e_station_vorher_in_abgegeben THEN
			a_station_vorher_out_angekommen := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_station_vorher_in_anforderung THEN
			a_station_vorher_out_angekommen := FALSE;
			a_station_vorher_out_erlaubnis := TRUE;
			st_ctrl_out.b_kontroller_start := FALSE;
			bm_warte_anforderung := FALSE;
			fb_state_entry.i16_next_step := 130;
		END_IF

(*=======================================================*)
	130: (* Warte bis WT an Stopper angekommen ist *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_kontroller_start := TRUE;
			bm_warte_wt_an_stopper := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_wartepos.Q THEN
			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := TRUE;
			st_ctrl_out.b_kontroller_start := FALSE;
			fb_ton_uez.IN := FALSE;
			bm_warte_wt_an_stopper := FALSE;
			fb_state_entry.i16_next_step := 131;
		END_IF

(*=======================================================*)
	131: (* Warte kurz *)
			IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#300ms;
			fb_ton_wz.IN := TRUE;
 		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 132;
		END_IF

(*=======================================================*)
	132: (*Prüfe ob Achse hinten *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  ST_WT_Transport_Achse.lr_Achspos_in = gst_datensatz.st_md.st_md_transport_wt_achse.lr_startposition AND
			axis_transport_wt_achse.st_ctrl.out.b_fertig AND
			NOT axis_transport_wt_achse.st_ctrl.out.b_busy  AND
			NOT axis_transport_wt_achse.st_ctrl.in.b_start  THEN
			fb_state_entry.i16_next_step := 135;
		END_IF

(*=======================================================*)
	135: (*Indexierzylinder Warteposition ausfahren *)
		IF fb_state_entry.E THEN
			zyl_Indexier_Einlauf.st_ctrl.in.b_einfahren:= TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_Indexier_Einlauf.st_ctrl.out.b_eingefahren THEN
			zyl_Indexier_Einlauf.st_ctrl.in.b_einfahren:= FALSE;
			fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	140: (* WT ist fixiert -> Einlaufstopper einfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_tisch.st_ctrl.out.b_eingefahren THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 145;
		END_IF

(*=======================================================*)
	145: (* Warte kurz *)
			IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#200ms;
			fb_ton_wz.IN := TRUE;
 		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 150;
		END_IF

(*=======================================================*)
	150: (* Hilfsmerker Achse setzen *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		b_helpStartAchse := TRUE;
		fb_state_entry.i16_next_step := 165;

(*=======================================================*)
	165:(*Warten bis Achse ausgefahren ist*)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_WT_Transport_Achse.lr_Achspos_in =gst_datensatz.st_md.st_md_transport_wt_achse.lr_wt_uebergabepos AND
			axis_transport_wt_achse.st_ctrl.out.b_fertig AND
			 zyl_wt_zentrierer_tisch.st_ctrl.out.b_ausgefahren  THEN
			b_helpStartAchse := FALSE;
			fb_state_entry.i16_next_step := 170;
		END_IF

(*=======================================================*)
	170: (* Einlaufstopper ausfahren *)
		IF fb_state_entry.E THEN
			zyl_Indexier_Einlauf.st_ctrl.in.b_ausfahren := TRUE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_Indexier_Einlauf.st_ctrl.out.b_ausgefahren THEN
			zyl_Indexier_Einlauf.st_ctrl.in.b_ausfahren := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_Indexier_Einlauf.st_ctrl.in.b_quittieren := FALSE;

			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := TRUE;
			zyl_Indexier_Einlauf.st_ctrl.in.b_quittieren := TRUE;

			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_Indexier_Einlauf.st_ctrl.in.b_quittieren := FALSE;

			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := TRUE;
			zyl_Indexier_Einlauf.st_ctrl.in.b_quittieren := TRUE;

		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_wt_hat_wartepos_nicht_verlassen;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_wt_hat_wartepos_ueberfahren;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_warte_anforderung;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := bm_warte_wt_an_stopper;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := bm_warte_beladepos_frei;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Stoerungen_Quitt_1700
VAR_INPUT
	st_config					: struct_config;
	st_ctrl_in					: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu					: struct_visu;
	st_visu_hinten				: struct_visu_hinten;
END_VAR
VAR_OUTPUT
	st_ctrl_out				: struct_ctrl_out;
	b_lampe_stoerung		: BOOL;
	b_lampe_produktion		: BOOL;
END_VAR
VAR
	fb_ton_quitt				: TON;
	b_Merker_quitt			: BOOL:=FALSE;
	fb_ton_wz				: TON;
	fb_r_trig_quittieren			: R_TRIG;
	fb_state_entry				: ST_StateEntry;

	fb_blinker				: ST_Blinker;

	bm_Maschine_in_Gst		: BOOL := FALSE;
	bm_Check		: BOOL := FALSE;
	sm_disable_auto_reset	: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_quitt(IN:= , PT:= t#300ms, Q=> , ET=> );
fb_ton_wz(IN:= , PT:= t#3000ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_quittieren(CLK:= (st_visu.b_quittieren OR st_visu_hinten.out.b_quittieren) AND gi16_betriebsart <> HAND, Q=> );

(* Blinker *)
fb_blinker(
	b_start:= TRUE,
	t_taktzeit_on:=t#500ms,
	t_taktzeit_off:=t#500ms,
	b_blinker_out=> );

(* Lampen *)
b_lampe_stoerung := gi16_maschinenstatusinfo = KEIN_STATUS OR gi16_maschinenstatusinfo = STATUS_FEHLER;

b_lampe_produktion := (fb_blinker.b_blinker_out AND
					(gi16_maschinenstatusinfo = STATUS_FEHLER_QUITTIERT OR
					gi16_maschinenstatusinfo = STATUS_BETRIEBSBEREIT)) OR
					gi16_maschinenstatusinfo = STATUS_MASCHINE_ARBEITET;

bm_Check:=(
	CheckBounds_ErrCnt+
	CheckByteZeroDiv_ErrCnt+
	CheckDWordZeroDiv_ErrCnt+
	CheckRealZeroDiv_ErrCnt+
	CheckWordZeroDiv_ErrCnt+
	CheckRangeSigned_ErrCnt+
	CheckRangeUnsigned_ErrCnt) > 0 ;

(* Toplevel *)
(* Hier nur Abschaltungen welche zu sofortigem Stop führen müssen *)
IF fb_state_entry.i16_step < FEHLER AND
	(axis_virt_master.st_ctrl.out.b_fehler OR
	axis_bestueckachse.st_ctrl.out.b_fehler OR
	axis_z_achse.st_ctrl.out.b_fehler OR
	axis_y_achse.st_ctrl.out.b_fehler OR
	ST_TouchProbe.st_ctrl_out.b_fehler OR
	(axis_bandeinzug_achse.st_ctrl.out.b_fehler AND gst_datensatz.st_wkz.i16_typ_bandeinzug = SERVO) OR
	bandspruehoeler.st_ctrl.out.b_fehler OR
	(bandeinzug_kontroller.st_ctrl.out.b_fehler AND gst_datensatz.st_wkz.i16_typ_bandeinzug = BANDWECHSLER_V2) OR
	bandwechsel_kontroller.st_ctrl.out.b_fehler OR
	wkz_absicherung.st_ctrl.out.b_fehler OR
	wt_transport_kontroller.st_ctrl.out.b_fehler OR
	balluff_tag_reader.st_ctrl.out.b_fehler OR
	haspel_kontroller.st_ctrl.out.b_fehler OR
	bbgen.st_ctrl.out.b_fehler OR
	wartung.st_ctrl.out.b_fehler OR
	betriebsfreigaben.st_ctrl.out.b_fehler OR
	einpresskraft_kontroller.st_ctrl.out.b_fehler OR
	safety.st_ctrl.out.b_fehler OR
	edit_mfps.st_ctrl.out.b_fehler OR
	Lesen_Schreiben_Tag.st_ctrl.out.b_fehler OR
	Service.st_ctrl.out.b_fehler OR
	axis_transport_wt_achse.st_ctrl.out.b_fehler)
	THEN
		fb_state_entry.i16_next_step := FEHLER;
END_IF

(* Prüfe ob BA = Hand -> Stoppe Abläufe *)
IF  fb_state_entry.i16_step > INIT  AND fb_state_entry.i16_step < FEHLER  AND gi16_betriebsart = HAND THEN
	fb_state_entry.i16_next_step := FEHLER;
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			gi16_maschinenstatusinfo := STATUS_FEHLER_QUITTIERT;
			fb_ton_quitt.IN := FALSE;
			UPS.st_ctrl.in.b_quitt := FALSE;
			betriebsfreigaben.st_ctrl.in.b_quitt := FALSE;
			bandeinzug_kontroller.st_ctrl.in.b_quitt := FALSE;
			bandwechsel_kontroller.st_ctrl.in.b_quitt := FALSE;
			axis_virt_master.st_ctrl.in.b_quitt := FALSE;
			axis_bestueckachse.st_ctrl.in.b_quitt := FALSE;
			axis_y_achse.st_ctrl.in.b_quitt := FALSE;
			axis_z_achse.st_ctrl.in.b_quitt := FALSE;
			ST_TouchProbe.st_ctrl_in.b_quitt := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_quitt := FALSE;
			bandspruehoeler.st_ctrl.in.b_quitt := FALSE;
			haspel_kontroller.st_ctrl.in.b_quitt := FALSE;
			hublift_links.st_ctrl.in.b_quitt := FALSE;
			hublift_rechts.st_ctrl.in.b_quitt := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_quitt := FALSE;
			wkz_absicherung.st_ctrl.in.b_quitt := FALSE;
			stueckzahlen.st_ctrl.in.b_quitt := FALSE;
			balluff_tag_reader.st_ctrl.in.b_quitt := FALSE;
			bbgen.st_ctrl.in.b_quitt := FALSE;
			wartung.st_ctrl.in.b_quitt := FALSE;
			einpresskraft_kontroller.st_ctrl.in.b_quitt := FALSE;
			safety.st_ctrl.in.b_quitt := FALSE;
			edit_mfps.st_ctrl.in.b_quitt := FALSE;
			routing_backpanel.st_ctrl.in.b_quitt := FALSE;
			routing_nachbarpc.st_ctrl.in.b_quitt := FALSE;
			bm_Maschine_in_Gst := FALSE;
			Lesen_Schreiben_Tag.st_ctrl.in.b_quitt := FALSE;
			Service.st_ctrl.in.b_quitt := FALSE;
			ST_TippTasten.b_initialisierungsphase := TRUE;
			sm_disable_auto_reset := FALSE;
			axis_transport_wt_achse.st_ctrl.in.b_quitt := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF safety.st_ctrl.out.b_bereit THEN
			fb_state_entry.i16_next_step := 11;
		END_IF

(*=======================================================*)
	11:
		IF fb_state_entry.E THEN
			axis_virt_master.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_prebereit  THEN
			axis_virt_master.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 12;
		END_IF

(*=======================================================*)
	12:
		IF fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_prebereit  THEN
			axis_z_achse.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 13;
		END_IF

(*=======================================================*)
	13:
		IF fb_state_entry.E THEN
			axis_y_achse.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_y_achse.st_ctrl.out.b_prebereit  THEN
			axis_y_achse.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 14;
		END_IF

(*=======================================================*)
	14:
		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			BANDWECHSLER_V2:
				fb_state_entry.i16_next_step := 15;
			SERVO:
				IF fb_state_entry.E THEN
					axis_bandeinzug_achse.st_ctrl.in.b_preinit := TRUE;
				END_IF

				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF axis_bandeinzug_achse.st_ctrl.out.b_prebereit  THEN
					axis_bandeinzug_achse.st_ctrl.in.b_preinit := FALSE;
					fb_state_entry.i16_next_step := 15;
				END_IF
		END_CASE

(*=======================================================*)
	15:
		IF fb_state_entry.E THEN
			axis_bestueckachse.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bestueckachse.st_ctrl.out.b_prebereit  THEN
			axis_bestueckachse.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 16;
		END_IF

(*=======================================================*)
	16:
		(*Wenn die Bestückachse nicht in einem bestimmten Bereich steht, dann muss sie von Hand
		    freigefahren werden. Außer es ist die Nocke auf 0,0 gestellt*)
		IF	gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_begin = 0 AND
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_end = 0 THEN
				fb_state_entry.i16_next_step := 17;
		ELSE
			IF gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_begin > gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_end THEN
				IF bestueckachse.NcToPlc.ModuloActPos > gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_begin OR
					bestueckachse.NcToPlc.ModuloActPos < gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_end THEN
					sm_disable_auto_reset := TRUE;
					fb_state_entry.i16_next_step := FEHLER;
				ELSE
					fb_state_entry.i16_next_step := 17;
				END_IF
			ELSE
				IF bestueckachse.NcToPlc.ModuloActPos > gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_begin AND
					bestueckachse.NcToPlc.ModuloActPos < gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_end THEN
					sm_disable_auto_reset := TRUE;
					fb_state_entry.i16_next_step := FEHLER;
				ELSE
					fb_state_entry.i16_next_step := 17;
				END_IF
			END_IF
		END_IF
(*=======================================================*)
	17:
		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	gst_datensatz.st_md.b_anwahl_transport_achse  THEN
			fb_state_entry.i16_next_step := 18;
		ELSE
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	18:
		IF fb_state_entry.E THEN
			axis_transport_wt_achse.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_transport_wt_achse.st_ctrl.out.b_prebereit  THEN
			axis_transport_wt_achse.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:
		IF fb_state_entry.E THEN
			haspel_kontroller.st_ctrl.in.b_init := TRUE;
			bandspruehoeler.st_ctrl.in.b_init := TRUE;
			wkz_absicherung.st_ctrl.in.b_init := TRUE;
			stueckzahlen.st_ctrl.in.b_init := TRUE;
			(*balluff_tag_reader.st_ctrl.in.b_init := TRUE;*)
			einpresskraft_kontroller.st_ctrl.in.b_init := TRUE;
			edit_mfps.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	haspel_kontroller.st_ctrl.out.b_bereit  AND
			bandspruehoeler.st_ctrl.out.b_bereit  AND
			wkz_absicherung.st_ctrl.out.b_bereit AND
			einpresskraft_kontroller.st_ctrl.out.b_bereit AND
			balluff_tag_reader.st_ctrl.out.b_bereit AND
			edit_mfps.st_ctrl.out.b_bereit
			THEN
				haspel_kontroller.st_ctrl.in.b_init := FALSE;
				bandspruehoeler.st_ctrl.in.b_init := FALSE;
				wkz_absicherung.st_ctrl.in.b_init := FALSE;
				stueckzahlen.st_ctrl.in.b_init := FALSE;
				(*balluff_tag_reader.st_ctrl.in.b_init := FALSE;*)
				einpresskraft_kontroller.st_ctrl.in.b_init := FALSE;
				edit_mfps.st_ctrl.in.b_init := FALSE;
				fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:
		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			BANDWECHSLER_V2:
				IF fb_state_entry.E THEN
					bandeinzug_kontroller.st_ctrl.in.b_init := TRUE;
				END_IF
		
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF bandeinzug_kontroller.st_ctrl.out.b_bereit THEN
					bandeinzug_kontroller.st_ctrl.in.b_init := FALSE;
					fb_state_entry.i16_next_step := 40;
				END_IF
			SERVO:
				fb_state_entry.i16_next_step := 40;
		END_CASE

(*=======================================================*)
	40:
		IF fb_state_entry.E THEN
			bandwechsel_kontroller.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bandwechsel_kontroller.st_ctrl.out.b_bereit THEN
			bandwechsel_kontroller.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:
		IF fb_state_entry.E THEN
			axis_bestueckachse.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bestueckachse.st_ctrl.out.b_bereit  THEN
			axis_bestueckachse.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60:
		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF
			BANDWECHSLER_V2:
				IF fb_state_entry.E THEN
					axis_z_achse.st_ctrl.in.b_init := TRUE;
					axis_y_achse.st_ctrl.in.b_init := TRUE;
					axis_transport_wt_achse.st_ctrl.in.b_init := gst_datensatz.st_md.b_anwahl_transport_achse;
				END_IF
		
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF 	axis_z_achse.st_ctrl.out.b_bereit AND
					axis_y_achse.st_ctrl.out.b_bereit AND
					(axis_transport_wt_achse.st_ctrl.out.b_bereit OR NOT gst_datensatz.st_md.b_anwahl_transport_achse)
					THEN
						axis_z_achse.st_ctrl.in.b_init := FALSE;
						axis_y_achse.st_ctrl.in.b_init := FALSE;
						axis_transport_wt_achse.st_ctrl.in.b_init := FALSE;
						fb_state_entry.i16_next_step := 70;
				END_IF
			SERVO:
				IF fb_state_entry.E THEN
					axis_z_achse.st_ctrl.in.b_init := TRUE;
					axis_y_achse.st_ctrl.in.b_init := TRUE;
					axis_bandeinzug_achse.st_ctrl.in.b_init := TRUE;
				END_IF
		
				(*-----------------------Weiterschaltbedingungen----------------------------*)
				IF 	axis_z_achse.st_ctrl.out.b_bereit AND
					axis_y_achse.st_ctrl.out.b_bereit AND
					axis_bandeinzug_achse.st_ctrl.out.b_bereit
					THEN
						axis_z_achse.st_ctrl.in.b_init := FALSE;
						axis_y_achse.st_ctrl.in.b_init := FALSE;
						fb_state_entry.i16_next_step := 70;
				END_IF
		END_CASE

(*=======================================================*)
	70:
		IF fb_state_entry.E THEN
			axis_virt_master.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_bereit  THEN
			axis_virt_master.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 80;
		END_IF

(*=======================================================*)
	80:
		IF fb_state_entry.E THEN
			hublift_links.st_ctrl.in.b_init := TRUE;
			hublift_rechts.st_ctrl.in.b_init := TRUE;
			wt_transport_kontroller.st_ctrl.in.b_init := TRUE;
			ST_TouchProbe.st_ctrl_in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF hublift_links.st_ctrl.out.b_bereit AND hublift_rechts.st_ctrl.out.b_bereit AND wt_transport_kontroller.st_ctrl.out.b_bereit AND
			ST_TouchProbe.st_ctrl_out.b_bereit THEN
			hublift_links.st_ctrl.in.b_init := FALSE;
			hublift_rechts.st_ctrl.in.b_init := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_init := FALSE;
			ST_TouchProbe.st_ctrl_in.b_init := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			ST_TippTasten.b_initialisierungsphase  := FALSE;
			(* Setze Maschinenstatus *)
			bm_Maschine_in_Gst := TRUE;
		END_IF

		(*Beim Einfädeln muss der Status geändert werden, damit nicht
		ständig neue Maschinendaten erzeugt werden*)
		IF ST_TippTasten.b_einfaedeln_aktiv THEN
			gi16_maschinenstatusinfo := STATUS_MASCHINE_ARBEITET;
		ELSE
			gi16_maschinenstatusinfo := STATUS_BETRIEBSBEREIT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT wt_transport_kontroller.st_ctrl.out.b_fertig THEN
			bm_Maschine_in_Gst := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110: (* Produktion *)
		IF fb_state_entry.E THEN
			gi16_maschinenstatusinfo := STATUS_MASCHINE_ARBEITET;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF wt_transport_kontroller.st_ctrl.out.b_fertig THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			gi16_maschinenstatusinfo := STATUS_FEHLER;
			bm_Maschine_in_Gst := FALSE;
			ST_TippTasten.b_initialisierungsphase  := FALSE;
			fb_ton_quitt.IN := FALSE;
			fb_ton_wz.IN:=FALSE;
			s_alte_artikelnummer := '';

			(* Schlecht Stueckzahl erhöhen *)
			IF fb_state_entry.i16_last_step = 110 THEN
				stueckzahlen.st_ctrl.in.b_schlechtteil_produziert := TRUE;
			END_IF

			UPS.st_ctrl.in.b_quitt := FALSE;
			betriebsfreigaben.st_ctrl.in.b_quitt := FALSE;
			bandeinzug_kontroller.st_ctrl.in.b_quitt := FALSE;
			bandwechsel_kontroller.st_ctrl.in.b_quitt := FALSE;
			axis_virt_master.st_ctrl.in.b_quitt := FALSE;
			axis_bestueckachse.st_ctrl.in.b_quitt := FALSE;
			axis_y_achse.st_ctrl.in.b_quitt := FALSE;
			axis_z_achse.st_ctrl.in.b_quitt := FALSE;
			ST_TouchProbe.st_ctrl_in.b_quitt := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_quitt := FALSE;
			bandspruehoeler.st_ctrl.in.b_quitt := FALSE;
			haspel_kontroller.st_ctrl.in.b_quitt := FALSE;
			hublift_links.st_ctrl.in.b_quitt := FALSE;
			hublift_rechts.st_ctrl.in.b_quitt := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_quitt := FALSE;
			wkz_absicherung.st_ctrl.in.b_quitt := FALSE;
			stueckzahlen.st_ctrl.in.b_quitt := FALSE;
			balluff_tag_reader.st_ctrl.in.b_quitt := FALSE;
			bbgen.st_ctrl.in.b_quitt := FALSE;
			wartung.st_ctrl.in.b_quitt := FALSE;
			einpresskraft_kontroller.st_ctrl.in.b_quitt := FALSE;
			safety.st_ctrl.in.b_quitt := FALSE;
			edit_mfps.st_ctrl.in.b_quitt := FALSE;
			routing_backpanel.st_ctrl.in.b_quitt := FALSE;
			routing_nachbarpc.st_ctrl.in.b_quitt := FALSE;
			Lesen_Schreiben_Tag.st_ctrl.in.b_quitt := FALSE;
			Service.st_ctrl.in.b_quitt := FALSE;
			axis_transport_wt_achse.st_ctrl.in.b_quitt := FALSE;

			axis_virt_master.st_ctrl.in.b_preinit := FALSE;
			axis_bestueckachse.st_ctrl.in.b_preinit := FALSE;
			axis_y_achse.st_ctrl.in.b_preinit := FALSE;
			axis_z_achse.st_ctrl.in.b_preinit := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_preinit := FALSE;
			axis_transport_wt_achse.st_ctrl.in.b_preinit := FALSE;

			bandeinzug_kontroller.st_ctrl.in.b_init := FALSE;
			bandwechsel_kontroller.st_ctrl.in.b_init := FALSE;
			axis_virt_master.st_ctrl.in.b_init := FALSE;
			axis_bestueckachse.st_ctrl.in.b_init := FALSE;
			axis_y_achse.st_ctrl.in.b_init := FALSE;
			axis_z_achse.st_ctrl.in.b_init := FALSE;
			ST_TouchProbe.st_ctrl_in.b_init := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_init := FALSE;
			bandspruehoeler.st_ctrl.in.b_init := FALSE;
			haspel_kontroller.st_ctrl.in.b_init := FALSE;
			hublift_links.st_ctrl.in.b_init := FALSE;
			hublift_rechts.st_ctrl.in.b_init := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_init := FALSE;
			wkz_absicherung.st_ctrl.in.b_init := FALSE;
			stueckzahlen.st_ctrl.in.b_init := FALSE;
			(*balluff_tag_reader.st_ctrl.in.b_init := FALSE;*)
			edit_mfps.st_ctrl.in.b_init := FALSE;
			axis_transport_wt_achse.st_ctrl.in.b_init := FALSE;
		END_IF

		(* Fehlerhandling: was soll bei welchem Fehler passieren? *)
		IF 	NOT fb_ton_quitt.IN THEN
			(* Stoppe/Halte Komponenten an *)
			bandeinzug_kontroller.st_ctrl.in.b_stop := TRUE;
			bandwechsel_kontroller.st_ctrl.in.b_stop := TRUE;
			bandspruehoeler.st_ctrl.in.b_stop := TRUE;
			(*haspel_kontroller.st_ctrl.in.b_stop := TRUE;*)
			hublift_links.st_ctrl.in.b_stop := TRUE;
			hublift_rechts.st_ctrl.in.b_stop := TRUE;
			wt_transport_kontroller.st_ctrl.in.b_stop := TRUE;
			stueckzahlen.st_ctrl.in.b_stop := TRUE;
			balluff_tag_reader.st_ctrl.in.b_stop := TRUE;
			edit_mfps.st_ctrl.in.b_stop := TRUE;

			(* Diese Fehler führt zum "Stop" in der Maschine *)
			IF safety.st_ctrl.out.b_fehler THEN
				axis_virt_master.st_ctrl.in.b_stop := TRUE;
				axis_bestueckachse.st_ctrl.in.b_stop := TRUE;
				axis_z_achse.st_ctrl.in.b_stop := TRUE;
				axis_y_achse.st_ctrl.in.b_stop := TRUE;
				axis_bandeinzug_achse.st_ctrl.in.b_stop := TRUE;
				axis_transport_wt_achse.st_ctrl.in.b_stop := TRUE;
				axis_virt_master.st_ctrl.in.b_halt := FALSE;
				axis_bestueckachse.st_ctrl.in.b_halt := FALSE;
				axis_z_achse.st_ctrl.in.b_halt := FALSE;
				axis_y_achse.st_ctrl.in.b_halt := FALSE;
				axis_bandeinzug_achse.st_ctrl.in.b_halt := FALSE;
				axis_transport_wt_achse.st_ctrl.in.b_halt := FALSE;
			ELSE
				axis_virt_master.st_ctrl.in.b_halt := TRUE;
				axis_bestueckachse.st_ctrl.in.b_halt := TRUE;
				axis_z_achse.st_ctrl.in.b_halt := TRUE;
				axis_y_achse.st_ctrl.in.b_halt := TRUE;
				axis_bandeinzug_achse.st_ctrl.in.b_halt := TRUE;
				axis_transport_wt_achse.st_ctrl.in.b_halt := TRUE;
				axis_virt_master.st_ctrl.in.b_stop := FALSE;
				axis_bestueckachse.st_ctrl.in.b_stop := FALSE;
				axis_z_achse.st_ctrl.in.b_stop := FALSE;
				axis_y_achse.st_ctrl.in.b_stop := FALSE;
				axis_bandeinzug_achse.st_ctrl.in.b_stop := FALSE;
				axis_transport_wt_achse.st_ctrl.in.b_stop := FALSE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	fb_r_trig_quittieren.Q THEN
			fb_ton_wz.IN:=TRUE;
			b_Merker_quitt:=TRUE;
		END_IF
		IF 	(b_Merker_quitt AND ST_Betriebsfreigaben.e_druckwaechter) OR
			fb_ton_wz.Q THEN
			fb_ton_wz.IN:=FALSE;
			b_Merker_quitt:=FALSE;
			fb_ton_quitt.IN := TRUE;
			(* QUITT *)
			UPS.st_ctrl.in.b_quitt := TRUE;
			betriebsfreigaben.st_ctrl.in.b_quitt := TRUE;
			bandeinzug_kontroller.st_ctrl.in.b_quitt := TRUE;
			bandwechsel_kontroller.st_ctrl.in.b_quitt := TRUE;
			axis_virt_master.st_ctrl.in.b_quitt := TRUE;
			axis_bestueckachse.st_ctrl.in.b_quitt := TRUE;
			axis_y_achse.st_ctrl.in.b_quitt := TRUE;
			axis_z_achse.st_ctrl.in.b_quitt := TRUE;
			ST_TouchProbe.st_ctrl_in.b_quitt := TRUE;
			axis_bandeinzug_achse.st_ctrl.in.b_quitt := TRUE;
			bandspruehoeler.st_ctrl.in.b_quitt := TRUE;
			haspel_kontroller.st_ctrl.in.b_quitt := TRUE;
			hublift_links.st_ctrl.in.b_quitt := TRUE;
			hublift_rechts.st_ctrl.in.b_quitt := TRUE;
			wt_transport_kontroller.st_ctrl.in.b_quitt := TRUE;
			wkz_absicherung.st_ctrl.in.b_quitt := TRUE;
			stueckzahlen.st_ctrl.in.b_quitt := TRUE;
			balluff_tag_reader.st_ctrl.in.b_quitt := TRUE;
			bbgen.st_ctrl.in.b_quitt := TRUE;
			wartung.st_ctrl.in.b_quitt := TRUE;
			einpresskraft_kontroller.st_ctrl.in.b_quitt := TRUE;
			safety.st_ctrl.in.b_quitt := TRUE;
			edit_mfps.st_ctrl.in.b_quitt := TRUE;
			routing_backpanel.st_ctrl.in.b_quitt := TRUE;
			routing_nachbarpc.st_ctrl.in.b_quitt := TRUE;
			Lesen_Schreiben_Tag.st_ctrl.in.b_quitt := TRUE;
			Service.st_ctrl.in.b_quitt := TRUE;
			axis_transport_wt_achse.st_ctrl.in.b_quitt := TRUE;
			(* STOP *)
			bandeinzug_kontroller.st_ctrl.in.b_stop := FALSE;
			bandwechsel_kontroller.st_ctrl.in.b_stop := FALSE;
			axis_virt_master.st_ctrl.in.b_stop := FALSE;
			axis_bestueckachse.st_ctrl.in.b_stop := FALSE;
			axis_y_achse.st_ctrl.in.b_stop := FALSE;
			axis_z_achse.st_ctrl.in.b_stop := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_stop := FALSE;
			bandspruehoeler.st_ctrl.in.b_stop := FALSE;
			haspel_kontroller.st_ctrl.in.b_stop := FALSE;
			hublift_links.st_ctrl.in.b_stop := FALSE;
			hublift_rechts.st_ctrl.in.b_stop := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_stop := FALSE;
			wkz_absicherung.st_ctrl.in.b_stop := FALSE;
			stueckzahlen.st_ctrl.in.b_stop := FALSE;
			balluff_tag_reader.st_ctrl.in.b_stop := FALSE;
			edit_mfps.st_ctrl.in.b_stop := FALSE;
			axis_transport_wt_achse.st_ctrl.in.b_stop := FALSE;
			(* HALT - nur Achsen *)
			axis_virt_master.st_ctrl.in.b_halt := FALSE;
			axis_bestueckachse.st_ctrl.in.b_halt := FALSE;
			axis_y_achse.st_ctrl.in.b_halt := FALSE;
			axis_z_achse.st_ctrl.in.b_halt := FALSE;
			axis_bandeinzug_achse.st_ctrl.in.b_halt := FALSE;
			axis_transport_wt_achse.st_ctrl.in.b_halt := FALSE;
		END_IF

		IF fb_ton_quitt.Q THEN
			IF (gi16_betriebsart = AUTO OR gi16_betriebsart = TIPPEN) THEN
				fb_state_entry.i16_next_step := INIT;
			END_IF
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );


(*Beim Einfädel Meldung zurücksetzen*)
IF	ST_TippTasten.b_einfaedeln_aktiv THEN
	bm_Maschine_in_Gst := FALSE;
END_IF

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_disable_auto_reset;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_Maschine_in_Gst;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := bm_Check;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1720\/WT Transport' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_WT_Transport_Beladen_1720
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu								: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
	t_WT_WechselZeit					: TIME := t#0ms;
	t_traegerwechselzeit					: TIME := t#0ms;
	t_Zentrierer_ausfahren					: TIME := t#0ms;
	t_Zentrierer_einfahren					: TIME := t#0ms;
	t_komplett_zyklus						: TIME := t#0ms;
END_VAR
VAR
	fb_ton_uez							: TON;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_wt_auf_beladepos				: TON;
	fb_tof_wt_auf_beladepos				: TOF;
	fb_r_trig_start							: R_TRIG;
	fb_r_trig_beladepos					: R_TRIG;
	fb_r_trig_beladepos_verlassen			: R_TRIG;
	fb_state_entry							: ST_StateEntry;
	fb_traegerwechselzeit					: ST_Taktzeit;
	fb_WT_WechselZeit					: ST_Taktzeit;
	fb_Zentrierer_ausfahren				: ST_Taktzeit;
	fb_Zentrierer_einfahren					: ST_Taktzeit;
	t_bestueckzeit						: TIME := t#0ms;
	sm_wt_hat_beladepos_nicht_verlassen	: BOOL := FALSE;
	sm_tagnummer_ungueltig				: BOOL := FALSE;
	sm_wt_hat_kein_tag					: BOOL := FALSE;
	sm_tagreader_nicht_fertig				: BOOL := FALSE;
	sm_keine_bandfreigabe				: BOOL := FALSE;
	bm_abfrage_wt_auf_beladepos			: BOOL := FALSE;
	bm_warte_auf_wt_an_stopper			: BOOL := FALSE;
	bMerkerSchrittketteKommtVonInit		: BOOL := FALSE;
	fb_ton_abfrage_wt_auf_beladepos		: TON;
	fb_ton_warte_auf_wt_an_stopper			: TON;
	i									: INT := 0;

	(* zum Testen der Achsen nach Tausch, Bestückbild "Becherspucken", WKZ ausgebaut, Vorschubkontrolle abeschaltet,
	Bit muss von Programmierer geforct werden, zum Beenden Schlüsselschalter auf HAND und Zelle neu starten *)
	b_Dauertest_Achsen					: BOOL := FALSE;

	e_wt_auf_beladepos					AT %I* : BOOL;
	e_wt_im_aktionsfeld					AT %I* : BOOL;
	e_wt_beladepos_verlassen				AT %I* : BOOL;
	e_wt_auf_pufferstrecke					AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

fb_ton_wt_auf_beladepos(IN:= e_wt_auf_beladepos, PT:= t#200ms, Q=> , ET=> );
fb_tof_wt_auf_beladepos(IN:= e_wt_auf_beladepos, PT:= t#200ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_beladepos(CLK:= e_wt_auf_beladepos, Q=> );
fb_r_trig_beladepos_verlassen(CLK:= e_wt_beladepos_verlassen, Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );

(*Trägerwechselzeiten*)
fb_WT_WechselZeit(b_start:= , t_zeit=> );
fb_Zentrierer_ausfahren(b_start:= , t_zeit=> );
fb_Zentrierer_einfahren(b_start:= , t_zeit=> );


(* ==================================Toplevel=================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* Allgemeine Fehler *)
	IF st_ctrl_in.b_stop THEN
		fb_state_entry.i16_next_step := STOP;
	ELSIF zyl_wt_zentrierer_tisch.st_ctrl.out.b_fehler OR zyl_wt_stopper_tisch.st_ctrl.out.b_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;
	(* Zylinder im Handbetrieb *)
	ELSIF gi16_betriebsart = HAND AND
		(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_wt_zentrierer_tisch.fb.st_config.i16_identnummer OR
		st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_wt_stopper_tisch.fb.st_config.i16_identnummer)
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ============================Haupt-Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_luftlos := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := FALSE;
			axis_z_achse.st_ctrl.in.b_start := FALSE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := FALSE;
			sm_wt_hat_beladepos_nicht_verlassen := FALSE;
			sm_tagnummer_ungueltig := FALSE;
			sm_wt_hat_kein_tag := FALSE;
			sm_tagreader_nicht_fertig := FALSE;
			sm_keine_bandfreigabe := FALSE;
			bm_abfrage_wt_auf_beladepos := FALSE;
			bm_warte_auf_wt_an_stopper := FALSE;
			balluff_tag_reader.st_ctrl.in.b_start_lesen := FALSE;
			balluff_tag_reader.st_ctrl.in.b_start_schreiben := FALSE;

			bMerkerSchrittketteKommtVonInit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: (* Initialisierung: Stopper an Bestücktisch ausfahren und Zentrierer einfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := TRUE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_tisch.st_ctrl.out.b_ausgefahren AND zyl_wt_zentrierer_tisch.st_ctrl.out.b_eingefahren THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:	(* Warte auf Start von Kontroller *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := FALSE;
		END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_config.b_station_aktiv OR st_config.b_station_in_simulation THEN
			(* WT Transport aktiv oder in Simulation *)
			IF st_ctrl_in.b_start THEN
			(* WT Transport gestartet *)
				st_ctrl_out.b_fertig := FALSE;
				fb_ton_wz.IN := FALSE;
				st_ctrl_out.b_kontroller_start := TRUE;
				(* Abfrage, ob Schrittkette von Init kommt und ob WT auf Beladepos ist *)
				IF bMerkerSchrittketteKommtVonInit AND
					e_wt_auf_beladepos THEN
					fb_state_entry.i16_next_step := 170;	(* WT auslesen und prüfen, ob dieser schon bestückt wurde *)
				ELSE
					fb_state_entry.i16_next_step := 110;
				END_IF
			END_IF
		ELSE
			IF fb_r_trig_start.Q THEN
			(* Nur Z-Achse gestartet *)
				st_ctrl_out.b_fertig := FALSE;
				fb_ton_wz.IN := FALSE;
				fb_state_entry.i16_next_step := 500;
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			bMerkerSchrittketteKommtVonInit := FALSE;
		END_IF

(*=======================================================*)
	110: (* WT-Abfrage auf Beladeposition *)
		IF fb_state_entry.E THEN
			bm_abfrage_wt_auf_beladepos := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wt_auf_beladepos THEN
			(* Ein WT ist anwesend zum rausschicken *)
			IF NOT ST_WT_Transport_Abgabe.e_wt_auf_abgabepos THEN
				(* Erst wenn kein Stau vorhanden ist, dann wird der WT weiter gelassen *)
				st_ctrl_out.b_kontroller_start := FALSE;
				bm_abfrage_wt_auf_beladepos := FALSE;
				fb_state_entry.i16_next_step := 120;
			END_IF
		ELSE	(* Kein WT da, deshalb einen holen *)
			st_ctrl_out.b_kontroller_start := FALSE;
			bm_abfrage_wt_auf_beladepos := FALSE;
			fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	120: (* WT-Zentrierer und Stopper einfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := TRUE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := TRUE;
			fb_Zentrierer_einfahren(b_start:= TRUE, t_zeit=> );
		END_IF
		IF 	zyl_wt_zentrierer_tisch.st_ctrl.out.b_eingefahren THEN
			fb_Zentrierer_einfahren(b_start:= FALSE, t_zeit=>t_Zentrierer_einfahren );
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_tisch.st_ctrl.out.b_eingefahren AND zyl_wt_zentrierer_tisch.st_ctrl.out.b_eingefahren THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_einfahren := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 130;
		END_IF

(*=======================================================*)
	130: (* Und auf Pufferstrecke angekommen ist *)
		IF fb_state_entry.E THEN
			fb_ton_uez.PT := t#5s;
 			fb_ton_uez.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_beladepos_verlassen.Q THEN
			fb_ton_uez.IN := FALSE;
			fb_state_entry.i16_next_step := 140;
		ELSIF fb_ton_uez.Q THEN
			sm_wt_hat_beladepos_nicht_verlassen := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	140: (* Stopper ausfahren und  WT-Zentrierer einfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := TRUE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	zyl_wt_stopper_tisch.st_ctrl.out.b_ausgefahren AND
			zyl_wt_zentrierer_tisch.st_ctrl.out.b_eingefahren
			THEN
				zyl_wt_stopper_tisch.st_ctrl.in.b_ausfahren := FALSE;
				zyl_wt_zentrierer_tisch.st_ctrl.in.b_einfahren := FALSE;
				st_ctrl_out.b_kontroller_start := TRUE;
				fb_state_entry.i16_next_step := 150;
		END_IF

(*=======================================================*)
	150: (* Warte auf Flanke "angekommen an Tisch-Stopper" *)
		IF fb_state_entry.E THEN
			bm_warte_auf_wt_an_stopper := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_r_trig_beladepos.Q THEN
			st_ctrl_out.b_kontroller_start := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160: (* WT sicher angekommen an Tisch-Stopper *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  fb_ton_wt_auf_beladepos.Q THEN
			bm_warte_auf_wt_an_stopper := FALSE;
			fb_state_entry.i16_next_step := 170;
		END_IF

(*=======================================================*)
	170: (* WT-Zentrierer ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
			fb_Zentrierer_ausfahren(b_start:= TRUE, t_zeit=> );
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_ausgefahren AND
			NOT ST_TippTasten.b_einfaedeln_aktiv AND
			NOT ST_Virtuelle_Masterachse.b_merker_bandende_links  AND
 			NOT ST_Virtuelle_Masterachse.b_merker_bandende_rechts THEN
			fb_Zentrierer_ausfahren(b_start:= FALSE, t_zeit=> t_Zentrierer_ausfahren);
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			IF st_config.b_station_in_simulation THEN
				(* WT-Transport ist in Simulation und deshalb wird der WT ohne zu Bestücken weiter gefahren *)
				fb_state_entry.i16_next_step := BEREIT;
			ELSE
				fb_state_entry.i16_next_step := 180;
			END_IF
		END_IF

(*=======================================================*)
	180: (* WT-Tag mit RFID-Lesegerät abfragen *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#100ms;
			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			IF e_wt_im_aktionsfeld THEN
				(* Tag auslesen *)
				fb_ton_wz.IN := FALSE;
				fb_state_entry.i16_next_step := 230;
			ELSE
				(* Kein Tag auf WT *)
				sm_wt_hat_kein_tag := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

(*=======================================================*)
	230: (* Z-Achse und anschliessend Bestückachse wird gestartet *)
		IF fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_start := TRUE;
			(*Zeitmessung Trägerwechsel stoppen und ausgeben*)
			fb_WT_WechselZeit(b_start:=FALSE , t_zeit=>t_WT_WechselZeit );
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(*IF axis_bestueckachse.st_ctrl.in.b_start THEN*)
		IF	axis_virt_master.st_ctrl.in.b_start THEN
			fb_state_entry.i16_next_step := 240;
		END_IF

		(*WT abgeben bei NIO*)
		IF axis_z_achse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_start := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF


(*=======================================================*)
	240: (* WT-Zentrierzylinder luftlos machen *)
		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_luftlos := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_ohne_luft THEN
			(* Luftlos-Kommando bleibt TRUE, und für die Überwachung brauchen wir noch das Ausfahr-Kommando *)
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
			fb_state_entry.i16_next_step := 250;
		END_IF

(*=======================================================*)
	250: (* Bestückachse ist fertig *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_fertig = TRUE THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_luftlos := FALSE;
			fb_state_entry.i16_next_step := 260;
		END_IF

(*=======================================================*)
	260: (* WT-Zentrierer ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_ausgefahren THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 270;
		END_IF

(*=======================================================*)
	270: (* Z-Achse ist fertig *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			(*Zeitmessung Trägerwechsel starten*)
			fb_WT_WechselZeit(b_start:=TRUE , t_zeit=> );
			(*Zeitmessung zusammenfassen*)
			t_bestueckzeit:=ST_Z_Achse.t_Bestueckung;
			t_traegerwechselzeit:=t_WT_WechselZeit + ST_Z_Achse.t_Z_Achse_einfahren + ST_Z_Achse.t_Z_Achse_ausfahren;
			t_komplett_zyklus:= t_traegerwechselzeit + t_bestueckzeit;

			axis_z_achse.st_ctrl.in.b_start := FALSE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := TRUE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

		IF fb_state_entry.X THEN
			gst_datensatz.st_md.produzierte_Stecker := gst_datensatz.st_md.produzierte_Stecker + 1;
		END_IF

(*=======================================================*)
	500: (* Warte bis angekommen an Stopper *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wt_auf_beladepos.Q THEN
			fb_state_entry.i16_next_step := 510;
		END_IF

(*=======================================================*)
	510: (* WT-Zentrierer auf Bestücktisch ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_ausgefahren  THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			axis_z_achse.st_ctrl.in.b_start := TRUE;
			fb_state_entry.i16_next_step := 520;
		END_IF

(*=======================================================*)
	520: (* Bestückachse wird gestartet *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.in.b_start THEN
			fb_state_entry.i16_next_step := 530;
		END_IF

(*=======================================================*)
	530: (* WT-Zentrierzylinder luftlos machen *)
		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_luftlos := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_ohne_luft THEN
			(* Luftlos-Kommando bleibt TRUE, und für die Überwachung brauchen wir noch das Ausfahr-Kommando *)
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
			fb_state_entry.i16_next_step := 540;
		END_IF

(*=======================================================*)
	540: (* Bestückablauf ist fertig *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_fertig THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_luftlos := FALSE;
			fb_state_entry.i16_next_step := 550;
		END_IF

(*=======================================================*)
	550: (* WT-Zentrierer ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_zentrierer_tisch.st_ctrl.out.b_ausgefahren THEN
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 560;
		END_IF

(*=======================================================*)
	560:	(* Warte auf Z-Achse komplett fertig *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_fertig AND NOT fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_start := FALSE;
			stueckzahlen.st_ctrl.in.b_gutteil_produziert := TRUE;
			IF NOT b_Dauertest_Achsen THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSE
				(* zum Testen der Achsen nach Tausch, Bestückbild "Becherspucken", WKZ ausgebaut, Vorschubkontrolle abeschaltet,
				Bit muss von Programmierer geforct werden, zum Beenden Schlüsselschalter auf HAND und Zelle neu starten *)
				fb_state_entry.i16_next_step := 500;	(* Dauertest *)
			END_IF
		END_IF

		IF fb_state_entry.X AND NOT b_Dauertest_Achsen THEN
			gst_datensatz.st_md.produzierte_Stecker := gst_datensatz.st_md.produzierte_Stecker + 1;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := FALSE;

			(*ST_Markiere_WT_NIO();*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := TRUE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := FALSE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := FALSE;
			(*ST_Markiere_WT_NIO();*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_wt_zentrierer_tisch.st_ctrl.in.b_quittieren := TRUE;
			zyl_wt_stopper_tisch.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

fb_ton_abfrage_wt_auf_beladepos (IN:=bm_abfrage_wt_auf_beladepos,PT:=t#30s);
fb_ton_warte_auf_wt_an_stopper (IN:=bm_warte_auf_wt_an_stopper,PT:=t#30s);

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_wt_hat_beladepos_nicht_verlassen;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_tagnummer_ungueltig;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_wt_hat_kein_tag;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := sm_tagreader_nicht_fertig;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := sm_keine_bandfreigabe;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := fb_ton_abfrage_wt_auf_beladepos.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := fb_ton_warte_auf_wt_an_stopper.Q;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1720\/WT Transport' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_WT_Transport_Warteposition_1720
VAR_INPUT
	st_config								: struct_config;
	st_ctrl_in								: struct_ctrl_in;
	e_station_vorher_in_anforderung			: BOOL := FALSE;
	e_station_vorher_in_abgegeben			: BOOL := FALSE;
END_VAR
VAR_IN_OUT
	st_visu								: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out							: struct_ctrl_out;
	a_station_vorher_out_erlaubnis			: BOOL := FALSE;
	a_station_vorher_out_angekommen		: BOOL := FALSE;
END_VAR
VAR
	fb_ton_uez							: TON;
	fb_ton_wz							: TON;
	fb_ton_quitt							: TON;
	fb_ton_wt_auf_wartepos				: TON;
	fb_tof_wt_auf_wartepos					: TOF;
	fb_r_trig_start							: R_TRIG;
	fb_r_trig_wartepos						: R_TRIG;
	fb_r_trig_wartepos_verlassen			: R_TRIG;
	fb_state_entry							: ST_StateEntry;
	sm_wt_hat_wartepos_nicht_verlassen	: BOOL := FALSE;
	sm_wt_hat_wartepos_ueberfahren		: BOOL := FALSE;
	bm_warte_anforderung					: BOOL := FALSE;
	bm_warte_wt_an_stopper				: BOOL := FALSE;
	bm_warte_beladepos_frei				: BOOL := FALSE;

	e_wt_auf_wartepos					AT %I* : BOOL;
	e_wt_wartepos_verlassen				AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_wz(IN:= , PT:= , Q=> , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

fb_ton_wt_auf_wartepos(IN:= e_wt_auf_wartepos, PT:= t#200ms, Q=> , ET=> );
fb_tof_wt_auf_wartepos(IN:= e_wt_auf_wartepos, PT:= t#200ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_wartepos(CLK:= e_wt_auf_wartepos, Q=> );
fb_r_trig_wartepos_verlassen(CLK:= e_wt_wartepos_verlassen, Q=> );
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );

(* ==================================Toplevel=================================== *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	(* Allgemeine Fehler *)
	IF st_ctrl_in.b_stop THEN
		fb_state_entry.i16_next_step := STOP;
	ELSIF zyl_wt_stopper_einlauf.st_ctrl.out.b_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;
	(* Zylinder im Handbetrieb *)
	ELSIF gi16_betriebsart = HAND AND
		st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_wt_stopper_einlauf.fb.st_config.i16_identnummer
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ============================Haupt-Schrittkette================================ *)
fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_stopper_einlauf.st_ctrl.in.b_einfahren := FALSE;
			zyl_wt_stopper_einlauf.st_ctrl.in.b_ausfahren := FALSE;
			sm_wt_hat_wartepos_nicht_verlassen := FALSE;
			sm_wt_hat_wartepos_ueberfahren := FALSE;
			bm_warte_anforderung := FALSE;
			bm_warte_wt_an_stopper := FALSE;
			bm_warte_beladepos_frei := FALSE;
			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_wt_stopper_einlauf.st_ctrl.in.b_quittieren := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20: (* Initialisierung: Einlaufstopper ausfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_einlauf.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_einlauf.st_ctrl.out.b_ausgefahren THEN
			zyl_wt_stopper_einlauf.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step :=  BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:	(* Warte auf Start von Kontroller *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
		END_IF

	(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_config.b_station_aktiv OR st_config.b_station_in_simulation THEN
			(* WT Transport aktiv oder in Simulation *)
			IF st_ctrl_in.b_start THEN
			(* WT Transport gestartet *)
				st_ctrl_out.b_fertig := FALSE;
				fb_state_entry.i16_next_step := 110;
			END_IF
		ELSE
			fb_state_entry.i16_next_step := 500;
		END_IF

(*=======================================================*)
	110: (* Statische WT-Abfrage auf Warteposition nach der Initialisierung *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_kontroller_start := TRUE;
		END_IF

		IF NOT e_station_vorher_in_abgegeben THEN
			a_station_vorher_out_angekommen := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wt_auf_wartepos THEN
			st_ctrl_out.b_kontroller_start := FALSE;
			fb_state_entry.i16_next_step := 140;
		ELSE	(* Kein WT da, deshalb einen holen *)
			st_ctrl_out.b_kontroller_start := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120: (* Kein WT da -> warte auf Anforderung von vorheriger Station *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_kontroller_start := TRUE;
			bm_warte_anforderung := TRUE;
		END_IF

		IF NOT e_station_vorher_in_abgegeben THEN
			a_station_vorher_out_angekommen := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_station_vorher_in_anforderung THEN
			a_station_vorher_out_angekommen := FALSE;
			a_station_vorher_out_erlaubnis := TRUE;
			st_ctrl_out.b_kontroller_start := FALSE;
			bm_warte_anforderung := FALSE;
			fb_state_entry.i16_next_step := 130;
		END_IF

(*=======================================================*)
	130: (* Warte bis WT an Stopper angekommen ist *)
		IF fb_state_entry.E THEN
			st_ctrl_out.b_kontroller_start := TRUE;
			bm_warte_wt_an_stopper := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_wartepos.Q THEN
			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := TRUE;
			st_ctrl_out.b_kontroller_start := FALSE;
			fb_ton_uez.IN := FALSE;
			bm_warte_wt_an_stopper := FALSE;
			fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	140: (* WT ist da - Warten bis Beladeposition auf Bestücktisch frei ist *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_einlauf.st_ctrl.in.b_ausfahren := FALSE;
			zyl_wt_stopper_einlauf.st_ctrl.in.b_einfahren := FALSE;
			bm_warte_beladepos_frei := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT ST_WT_Transport_Beladen_1720.e_wt_auf_beladepos AND NOT axis_z_achse.st_ctrl.in.b_start THEN
			bm_warte_beladepos_frei := FALSE;
			fb_state_entry.i16_next_step := 150;
		ELSIF e_wt_wartepos_verlassen THEN
			(* Warteposition wurde unerlaubterweise überfahren *)
			sm_wt_hat_wartepos_ueberfahren := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	150: (* Bestücktisch ist frei -> Einlaufstopper einfahren *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_einlauf.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_einlauf.st_ctrl.out.b_eingefahren THEN
			zyl_wt_stopper_einlauf.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160: (* WT fährt weiter - Überwachung starten *)
		IF fb_state_entry.E THEN
			fb_ton_uez.PT := t#5s;
 			fb_ton_uez.IN := TRUE;
			st_ctrl_out.b_kontroller_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_wartepos_verlassen.Q THEN
			fb_ton_uez.IN := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			fb_state_entry.i16_next_step := 170;
		ELSIF fb_ton_uez.Q THEN
			sm_wt_hat_wartepos_nicht_verlassen := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	170: (* Einlaufstopper ausfahren *)
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := TRUE;
			fb_ton_wz.PT := t#1s;
			zyl_wt_stopper_einlauf.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_einlauf.st_ctrl.out.b_ausgefahren AND fb_ton_wz.Q THEN
			zyl_wt_stopper_einlauf.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
			fb_ton_wz.IN := FALSE;
		END_IF

(*=======================================================*)
	500: (* Einlaufstopper einfahren, damit WTs auf Bestücktisch geschoben werden können. *)
		IF fb_state_entry.E THEN
			zyl_wt_stopper_einlauf.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_wt_stopper_einlauf.st_ctrl.out.b_eingefahren THEN
			zyl_wt_stopper_einlauf.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step :=  510;
		END_IF

(*=======================================================*)
	510:	(* Warte auf Konfigurationsänderung *)

	(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_config.b_station_aktiv OR st_config.b_station_in_simulation THEN
			(* WT Transport aktiv oder in Simulation *)
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_wt_stopper_einlauf.st_ctrl.in.b_quittieren := FALSE;

			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_wt_stopper_einlauf.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_kontroller_start := FALSE;
			zyl_wt_stopper_einlauf.st_ctrl.in.b_quittieren := FALSE;
			a_station_vorher_out_erlaubnis := FALSE;
			a_station_vorher_out_angekommen := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_wt_stopper_einlauf.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen ab dem Startindex in das globale Störmeldungsarray schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_wt_hat_wartepos_nicht_verlassen;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_wt_hat_wartepos_ueberfahren;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_warte_anforderung;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := bm_warte_wt_an_stopper;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := bm_warte_beladepos_frei;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1720' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_AbfallBlasluft
VAR_INPUT
	b_wkz_blasluft_aktiv	: BOOL;
END_VAR
VAR
	a_AbfallBlasluft		AT %Q* : BOOL;
	fb_rtrig_nocke		: R_TRIG;
	fb_tof_blaszeit		: TOF;
	b_blasluft_aktiv		: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
fb_rtrig_nocke (CLK:= (bestueckachse.NcToPlc.ModuloActPos > 170 AND bestueckachse.NcToPlc.ModuloActPos < 190), Q=> );

IF b_wkz_blasluft_aktiv THEN
	fb_tof_blaszeit (IN:=fb_rtrig_nocke.Q , PT:= t#200ms, Q=> a_AbfallBlasluft, ET=> );
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1720' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Bandeinzug_Kontroller_1720
VAR_INPUT
	st_config							: struct_config;
	st_ctrl_in							: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu							: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out						: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz						: TON;
	fb_ton_uez						: TON;
	fb_ton_quitt						: TON;
	fb_state_entry						: ST_StateEntry;
	e_ls_bandende_re				AT %I* : BOOL;
	e_ls_bandende_li					AT %I* : BOOL;

	fb_r_trig_vorschubkontrolle_li		: R_TRIG;
	fb_f_trig_vorschubkontrolle_li		: F_TRIG;
	fb_r_trig_nocke_einzug				: R_TRIG;
	fb_f_trig_nocke_einzug				: F_TRIG;
	b_hm_pos_flanke_vorschub_li		: BOOL := FALSE;
	b_hm_neg_flanke_vorschub_li		: BOOL := FALSE;
	sm_fehler_bandvorschub_li			: BOOL := FALSE;
	fb_r_trig_vorschubkontrolle_re		: R_TRIG;
	fb_f_trig_vorschubkontrolle_re		: F_TRIG;
	b_hm_pos_flanke_vorschub_re		: BOOL := FALSE;
	b_hm_neg_flanke_vorschub_re		: BOOL := FALSE;
	sm_fehler_bandvorschub_re			: BOOL := FALSE;
	sm_keine_busverbindung			: BOOL := FALSE;

	e_wc_state							AT %I* : BOOL;	(* 0=Data valid, 1=Data invalid *)
	e_gls_bandvorschubkontrolle_li		AT %I* : BOOL;
	e_gls_bandvorschubkontrolle_re		AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= , Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Flanken *)
fb_f_trig_vorschubkontrolle_li(CLK:= e_gls_bandvorschubkontrolle_li, Q=> );
fb_r_trig_vorschubkontrolle_li(CLK:= e_gls_bandvorschubkontrolle_li, Q=> );
fb_f_trig_nocke_einzug(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_PNEUMATIKBANDEINZUG_GLS], Q=> );
fb_r_trig_nocke_einzug(CLK:= nockenschaltwerk_bestueckachse.fb.arr_spur[SP_PNEUMATIKBANDEINZUG_GLS], Q=> );
fb_f_trig_vorschubkontrolle_re(CLK:= e_gls_bandvorschubkontrolle_re, Q=> );
fb_r_trig_vorschubkontrolle_re(CLK:= e_gls_bandvorschubkontrolle_re, Q=> );

(*neue Haltezylinder für Bandklemmeinzug*)
(*bei Steuerung Ein oben bei Steuerung Aus wird selbständig über Federkraft geklemmt*)
IF ST_Safetyprogramm.se_steuerung_ein THEN
	zyl_bawe_halter_li.st_ctrl.in.b_einfahren := TRUE;
	zyl_bawe_halter_re.st_ctrl.in.b_einfahren := TRUE;
END_IF

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
	(* Allgemeine Fehler *)
	IF	NOT gst_datensatz.st_md.b_wt_transport_simulation AND
		(zyl_bandfaenger_li.st_ctrl.out.b_fehler OR
		zyl_bandklemmen_li.st_ctrl.out.b_fehler OR
		zyl_bandfaenger_re.st_ctrl.out.b_fehler OR
		zyl_bandklemmen_re.st_ctrl.out.b_fehler OR
		zyl_bawe_halter_li.st_ctrl.out.b_fehler OR
		zyl_bawe_halter_re.st_ctrl.out.b_fehler)
		THEN
			fb_state_entry.i16_next_step := FEHLER;
	(* Zylinder im Handbetrieb *)
	ELSIF	 gi16_betriebsart = HAND AND (
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bandfaenger_li.fb.st_config.i16_identnummer OR
			st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bandfaenger_li.fb.st_config.i16_identnummer OR
			st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bandfaenger_re.fb.st_config.i16_identnummer OR
			st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bandklemmen_re.fb.st_config.i16_identnummer OR
			st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bawe_halter_li.fb.st_config.i16_identnummer OR
			st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_bawe_halter_re.fb.st_config.i16_identnummer))
			THEN
				fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			zyl_bandfaenger_li.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bandfaenger_li.st_ctrl.in.b_einfahren := FALSE;
			 zyl_bandklemmen_li.st_ctrl.in.b_ausfahren := FALSE;
			 zyl_bandklemmen_li.st_ctrl.in.b_einfahren := FALSE;
			zyl_bandfaenger_re.st_ctrl.in.b_ausfahren := FALSE;
			zyl_bandfaenger_re.st_ctrl.in.b_einfahren := FALSE;
			 zyl_bandklemmen_re.st_ctrl.in.b_ausfahren := FALSE;
			 zyl_bandklemmen_re.st_ctrl.in.b_einfahren := FALSE;
			sm_fehler_bandvorschub_li := FALSE;
			sm_fehler_bandvorschub_re := FALSE;
			sm_keine_busverbindung := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_bandfaenger_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandklemmen_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandfaenger_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandklemmen_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_re.st_ctrl.in.b_quittieren := FALSE;
			IF gst_datensatz.st_md.b_wt_transport_simulation THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSE
				(*fb_state_entry.i16_next_step := 20; Bei nächster TSM-Änderung bitte aktivieren*)
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	20: (* Prüfe, ob Busverbindung vorhanden ist *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_wc_state THEN	(* Prüfe Busverbindung ( 0=Data valid, 1=Data invalid )*)
			sm_keine_busverbindung := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		ELSE
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		CASE gst_datensatz.st_wkz.i16_typ_bandeinzug OF

			STANDARD_2FACH_V2:
				fb_state_entry.i16_next_step := 200;


			BANDWECHSLER_V2:
				(* Den Bandwechsler gibt es nur bei BSH1700 *)
				;
		END_CASE;

(*===========================Bandvorschub mit GLS-Kontrolle============================*)
	200:	(* Warte auf Vorschubnocke  und Freigabe von der Bestückachse *)
		(* Die Freigabe erfolgt nur im normalen Produktionsablauf; nicht bei Bandwechsel, Einfädeln, ... da hier keine Überwachung erfolgen soll. *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_nocke_einzug.Q AND gi16_betriebsart <> HAND AND st_ctrl_in.b_freigabe THEN
			b_hm_pos_flanke_vorschub_li := FALSE;
			b_hm_neg_flanke_vorschub_li := FALSE;
			b_hm_pos_flanke_vorschub_re := FALSE;
			b_hm_neg_flanke_vorschub_re := FALSE;
			fb_state_entry.i16_next_step := 210;
		END_IF

(*=======================================================*)
	210:	(* Band links bzw. rechts wird vorgeschoben *)
		(* Vorschubkontrolle durch positive Flanke *)
		IF fb_r_trig_vorschubkontrolle_li.Q THEN
			b_hm_pos_flanke_vorschub_li := TRUE;
		END_IF
		IF fb_r_trig_vorschubkontrolle_re.Q THEN
			b_hm_pos_flanke_vorschub_re := TRUE;
		END_IF
		(* Vorschubkontrolle durch negative Flanke *)
		IF fb_f_trig_vorschubkontrolle_li.Q THEN
			b_hm_neg_flanke_vorschub_li := TRUE;
		END_IF
		IF fb_f_trig_vorschubkontrolle_re.Q THEN
			b_hm_neg_flanke_vorschub_re := TRUE;
		END_IF


		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_f_trig_nocke_einzug.Q THEN
			IF 	b_hm_pos_flanke_vorschub_li AND b_hm_neg_flanke_vorschub_li AND
				b_hm_pos_flanke_vorschub_re AND b_hm_neg_flanke_vorschub_re
				THEN
					fb_state_entry.i16_next_step := 200;
			ELSE
				IF NOT b_hm_pos_flanke_vorschub_li OR NOT b_hm_neg_flanke_vorschub_li THEN
					sm_fehler_bandvorschub_li := TRUE;
				END_IF
				IF NOT b_hm_pos_flanke_vorschub_re OR NOT b_hm_neg_flanke_vorschub_re THEN
					sm_fehler_bandvorschub_re := TRUE;
				END_IF
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		ELSIF gi16_betriebsart = HAND THEN
			fb_state_entry.i16_next_step := 200;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_bandfaenger_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandklemmen_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandfaenger_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandklemmen_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_re.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_bandfaenger_li.st_ctrl.in.b_quittieren := TRUE;
			zyl_bandklemmen_li.st_ctrl.in.b_quittieren := TRUE;
			zyl_bandfaenger_re.st_ctrl.in.b_quittieren := TRUE;
			zyl_bandklemmen_re.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_halter_li.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_halter_re.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			zyl_bandfaenger_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandklemmen_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandfaenger_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_bandklemmen_re.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_li.st_ctrl.in.b_quittieren := FALSE;
			zyl_bawe_halter_re.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_bandfaenger_li.st_ctrl.in.b_quittieren := TRUE;
			zyl_bandklemmen_li.st_ctrl.in.b_quittieren := TRUE;
			zyl_bandfaenger_re.st_ctrl.in.b_quittieren := TRUE;
			zyl_bandklemmen_re.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_halter_li.st_ctrl.in.b_quittieren := TRUE;
			zyl_bawe_halter_re.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := FALSE;(* belegt  durch Bandeinzugskontroller 1700 *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_fehler_bandvorschub_li;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := sm_fehler_bandvorschub_re;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := sm_keine_busverbindung;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1720' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Stoerungen_Quitt_1720
VAR_INPUT
	st_config					: struct_config;
	st_ctrl_in					: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu					: struct_visu;
	st_visu_hinten				: struct_visu_hinten;
END_VAR
VAR_OUTPUT
	st_ctrl_out				: struct_ctrl_out;
	b_lampe_stoerung		: BOOL;
	b_lampe_produktion		: BOOL;
END_VAR
VAR
	fb_ton_quitt				: TON;
	fb_r_trig_quittieren			: R_TRIG;
	b_Merker_quitt			: BOOL:=FALSE;
	fb_ton_wz				: TON;

	fb_state_entry				: ST_StateEntry;

	fb_blinker				: ST_Blinker;

	bm_Maschine_in_Gst		: BOOL := FALSE;
	bm_Check		: BOOL := FALSE;
	sm_disable_auto_reset	: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_quitt(IN:= , PT:= t#300ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_quittieren(CLK:= (st_visu.b_quittieren OR st_visu_hinten.out.b_quittieren) AND gi16_betriebsart <> HAND, Q=> );

(* Blinker *)
fb_blinker(
	b_start:= TRUE,
	t_taktzeit_on:=t#500ms,
	t_taktzeit_off:=t#500ms,
	b_blinker_out=> );

(* Lampen *)
b_lampe_stoerung := gi16_maschinenstatusinfo = KEIN_STATUS OR gi16_maschinenstatusinfo = STATUS_FEHLER;

b_lampe_produktion := (fb_blinker.b_blinker_out AND
					(gi16_maschinenstatusinfo = STATUS_FEHLER_QUITTIERT OR
					gi16_maschinenstatusinfo = STATUS_BETRIEBSBEREIT)) OR
					gi16_maschinenstatusinfo = STATUS_MASCHINE_ARBEITET;

bm_Check:=(
	CheckBounds_ErrCnt+
	CheckByteZeroDiv_ErrCnt+
	CheckDWordZeroDiv_ErrCnt+
	CheckRealZeroDiv_ErrCnt+
	CheckWordZeroDiv_ErrCnt+
	CheckRangeSigned_ErrCnt+
	CheckRangeUnsigned_ErrCnt) > 0 ;

(* Toplevel *)
(* Hier nur Abschaltungen welche zu sofortigem Stop führen müssen *)
IF fb_state_entry.i16_step < FEHLER AND
	(axis_virt_master.st_ctrl.out.b_fehler OR
	axis_bestueckachse.st_ctrl.out.b_fehler OR
	axis_z_achse.st_ctrl.out.b_fehler OR
	bandeinzug_kontroller.st_ctrl.out.b_fehler OR
	bandspruehoeler.st_ctrl.out.b_fehler OR
	wkz_absicherung.st_ctrl.out.b_fehler OR
	wt_transport_kontroller.st_ctrl.out.b_fehler OR
(*	hublift_links.st_ctrl.out.b_fehler OR
	hublift_rechts.st_ctrl.out.b_fehler OR*)
	balluff_tag_reader.st_ctrl.out.b_fehler OR
	haspel_kontroller.st_ctrl.out.b_fehler OR
	bbgen.st_ctrl.out.b_fehler OR
	wartung.st_ctrl.out.b_fehler OR
	betriebsfreigaben.st_ctrl.out.b_fehler OR
	safety.st_ctrl.out.b_fehler OR
	edit_mfps.st_ctrl.out.b_fehler OR
	Lesen_Schreiben_Tag.st_ctrl.out.b_fehler OR
	Service.st_ctrl.out.b_fehler)
	THEN
		fb_state_entry.i16_next_step := FEHLER;
END_IF

(* Prüfe ob BA = Hand -> Stoppe Abläufe *)
IF  fb_state_entry.i16_step > INIT  AND fb_state_entry.i16_step < FEHLER  AND gi16_betriebsart = HAND THEN
	fb_state_entry.i16_next_step := FEHLER;
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			gi16_maschinenstatusinfo := STATUS_FEHLER_QUITTIERT;

			fb_ton_quitt.IN := FALSE;
			UPS.st_ctrl.in.b_quitt := FALSE;
			betriebsfreigaben.st_ctrl.in.b_quitt := FALSE;
			bandeinzug_kontroller.st_ctrl.in.b_quitt := FALSE;
			axis_virt_master.st_ctrl.in.b_quitt := FALSE;
			axis_bestueckachse.st_ctrl.in.b_quitt := FALSE;
			axis_z_achse.st_ctrl.in.b_quitt := FALSE;
			bandspruehoeler.st_ctrl.in.b_quitt := FALSE;
			haspel_kontroller.st_ctrl.in.b_quitt := FALSE;
			hublift_links.st_ctrl.in.b_quitt := FALSE;
			hublift_rechts.st_ctrl.in.b_quitt := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_quitt := FALSE;
			wkz_absicherung.st_ctrl.in.b_quitt := FALSE;
			stueckzahlen.st_ctrl.in.b_quitt := FALSE;
			balluff_tag_reader.st_ctrl.in.b_quitt := FALSE;
			bbgen.st_ctrl.in.b_quitt := FALSE;
			wartung.st_ctrl.in.b_quitt := FALSE;
			safety.st_ctrl.in.b_quitt := FALSE;
			edit_mfps.st_ctrl.in.b_quitt := FALSE;
			routing_backpanel.st_ctrl.in.b_quitt := FALSE;
			routing_nachbarpc.st_ctrl.in.b_quitt := FALSE;
			bm_Maschine_in_Gst := FALSE;
			Lesen_Schreiben_Tag.st_ctrl.in.b_quitt :=FALSE;
			Service.st_ctrl.in.b_quitt :=FALSE;
			ST_TippTasten.b_initialisierungsphase := TRUE;
			sm_disable_auto_reset := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF safety.st_ctrl.out.b_bereit THEN
			fb_state_entry.i16_next_step := 11;
		END_IF

(*=======================================================*)
	11:
		IF fb_state_entry.E THEN
			axis_virt_master.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_prebereit  THEN
			axis_virt_master.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 12;
		END_IF

(*=======================================================*)
	12:
		IF fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_prebereit  THEN
			axis_z_achse.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 14;
		END_IF

(*=======================================================*)
	14:
		IF fb_state_entry.E THEN
			axis_bestueckachse.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bestueckachse.st_ctrl.out.b_prebereit THEN
			axis_bestueckachse.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 16;
		END_IF

(*=======================================================*)
	16:
		(*Wenn die Bestückachse nicht in einem bestimmten Bereich steht, dann muss sie von Hand
		    freigefahren werden. Außer es ist die Nocke auf 0,0 gestellt*)
		IF	gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_begin = 0 AND
			gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_end = 0 THEN
				fb_state_entry.i16_next_step := 20;
		ELSE
			IF gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_begin > gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_end THEN
				IF bestueckachse.NcToPlc.ModuloActPos > gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_begin OR
					bestueckachse.NcToPlc.ModuloActPos < gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_end THEN
					sm_disable_auto_reset := TRUE;
					fb_state_entry.i16_next_step := FEHLER;
				ELSE
					fb_state_entry.i16_next_step := 20;
				END_IF
			ELSE
				IF bestueckachse.NcToPlc.ModuloActPos > gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_begin AND
					bestueckachse.NcToPlc.ModuloActPos < gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[SP_DISABLE_AUTO_RESET].r_cam_end THEN
					sm_disable_auto_reset := TRUE;
					fb_state_entry.i16_next_step := FEHLER;
				ELSE
					fb_state_entry.i16_next_step := 20;
				END_IF
			END_IF
		END_IF

(*=======================================================*)
	20:
		IF fb_state_entry.E THEN
			haspel_kontroller.st_ctrl.in.b_init := TRUE;
			bandspruehoeler.st_ctrl.in.b_init := TRUE;
			wkz_absicherung.st_ctrl.in.b_init := TRUE;
			stueckzahlen.st_ctrl.in.b_init := TRUE;
			(*balluff_tag_reader.st_ctrl.in.b_init := TRUE;*)
			edit_mfps.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	haspel_kontroller.st_ctrl.out.b_bereit  AND
			bandspruehoeler.st_ctrl.out.b_bereit  AND
			wkz_absicherung.st_ctrl.out.b_bereit AND
			balluff_tag_reader.st_ctrl.out.b_bereit AND
			edit_mfps.st_ctrl.out.b_bereit
			THEN
				haspel_kontroller.st_ctrl.in.b_init := FALSE;
				bandspruehoeler.st_ctrl.in.b_init := FALSE;
				wkz_absicherung.st_ctrl.in.b_init := FALSE;
				stueckzahlen.st_ctrl.in.b_init := FALSE;
				(*balluff_tag_reader.st_ctrl.in.b_init := FALSE;*)
				edit_mfps.st_ctrl.in.b_init := FALSE;
				fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:
		IF fb_state_entry.E THEN
			bandeinzug_kontroller.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF bandeinzug_kontroller.st_ctrl.out.b_bereit THEN
			bandeinzug_kontroller.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:
		IF fb_state_entry.E THEN
			axis_bestueckachse.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bestueckachse.st_ctrl.out.b_bereit  THEN
			axis_bestueckachse.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:
		IF fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_bereit THEN
			axis_z_achse.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60:
		IF fb_state_entry.E THEN
			axis_virt_master.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_bereit  THEN
			axis_virt_master.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 70;
		END_IF

(*=======================================================*)
	70:
		IF fb_state_entry.E THEN
			hublift_links.st_ctrl.in.b_init := TRUE;
			hublift_rechts.st_ctrl.in.b_init := TRUE;
			wt_transport_kontroller.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF hublift_links.st_ctrl.out.b_bereit AND hublift_rechts.st_ctrl.out.b_bereit AND wt_transport_kontroller.st_ctrl.out.b_bereit THEN
			hublift_links.st_ctrl.in.b_init := FALSE;
			hublift_rechts.st_ctrl.in.b_init := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			ST_TippTasten.b_initialisierungsphase  := FALSE;

			(* Setze Maschinenstatus *)
			bm_Maschine_in_Gst := TRUE;
		END_IF

		(*Beim Einfädeln muss der Status geändert werden, damit nicht
		ständig neue Maschinendaten erzeugt werden*)
		IF ST_TippTasten.b_einfaedeln_aktiv THEN
			gi16_maschinenstatusinfo := STATUS_MASCHINE_ARBEITET;
		ELSE
			gi16_maschinenstatusinfo := STATUS_BETRIEBSBEREIT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT wt_transport_kontroller.st_ctrl.out.b_fertig THEN
			bm_Maschine_in_Gst := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110: (* Produktion *)
		IF fb_state_entry.E THEN
			gi16_maschinenstatusinfo := STATUS_MASCHINE_ARBEITET;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF wt_transport_kontroller.st_ctrl.out.b_fertig THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			gi16_maschinenstatusinfo := STATUS_FEHLER;
			bm_Maschine_in_Gst := FALSE;
			ST_TippTasten.b_initialisierungsphase  := FALSE;
			fb_ton_quitt.IN := FALSE;
			fb_ton_wz.IN:=FALSE;
			s_alte_artikelnummer := '';

			(* Schlecht Stueckzahl erhöhen *)
			IF fb_state_entry.i16_last_step = 110 THEN
				stueckzahlen.st_ctrl.in.b_schlechtteil_produziert := TRUE;
			END_IF

			UPS.st_ctrl.in.b_quitt := FALSE;
			betriebsfreigaben.st_ctrl.in.b_quitt := FALSE;
			bandeinzug_kontroller.st_ctrl.in.b_quitt := FALSE;
			axis_virt_master.st_ctrl.in.b_quitt := FALSE;
			axis_bestueckachse.st_ctrl.in.b_quitt := FALSE;
			axis_z_achse.st_ctrl.in.b_quitt := FALSE;
			bandspruehoeler.st_ctrl.in.b_quitt := FALSE;
			haspel_kontroller.st_ctrl.in.b_quitt := FALSE;
			hublift_links.st_ctrl.in.b_quitt := FALSE;
			hublift_rechts.st_ctrl.in.b_quitt := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_quitt := FALSE;
			wkz_absicherung.st_ctrl.in.b_quitt := FALSE;
			stueckzahlen.st_ctrl.in.b_quitt := FALSE;
			balluff_tag_reader.st_ctrl.in.b_quitt := FALSE;
			bbgen.st_ctrl.in.b_quitt := FALSE;
			wartung.st_ctrl.in.b_quitt := FALSE;
			safety.st_ctrl.in.b_quitt := FALSE;
			edit_mfps.st_ctrl.in.b_quitt := FALSE;
			routing_backpanel.st_ctrl.in.b_quitt := FALSE;
			routing_nachbarpc.st_ctrl.in.b_quitt := FALSE;
			Lesen_Schreiben_Tag.st_ctrl.in.b_quitt := FALSE;
			Service.st_ctrl.in.b_quitt := FALSE;

			axis_virt_master.st_ctrl.in.b_preinit := FALSE;
			axis_bestueckachse.st_ctrl.in.b_preinit := FALSE;
			axis_z_achse.st_ctrl.in.b_preinit := FALSE;

			bandeinzug_kontroller.st_ctrl.in.b_init := FALSE;
			axis_virt_master.st_ctrl.in.b_init := FALSE;
			axis_bestueckachse.st_ctrl.in.b_init := FALSE;
			axis_z_achse.st_ctrl.in.b_init := FALSE;
			bandspruehoeler.st_ctrl.in.b_init := FALSE;
			haspel_kontroller.st_ctrl.in.b_init := FALSE;
			hublift_links.st_ctrl.in.b_init := FALSE;
			hublift_rechts.st_ctrl.in.b_init := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_init := FALSE;
			wkz_absicherung.st_ctrl.in.b_init := FALSE;
			stueckzahlen.st_ctrl.in.b_init := FALSE;
			balluff_tag_reader.st_ctrl.in.b_init := FALSE;
			edit_mfps.st_ctrl.in.b_init := FALSE;
		END_IF

		(* Fehlerhandling: was soll bei welchem Fehler passieren? *)
		IF 	NOT fb_ton_quitt.IN THEN
			(* Stoppe/Halte Komponenten an *)
			bandeinzug_kontroller.st_ctrl.in.b_stop := TRUE;
			bandspruehoeler.st_ctrl.in.b_stop := TRUE;
			(*haspel_kontroller.st_ctrl.in.b_stop := TRUE;*)
			hublift_links.st_ctrl.in.b_stop := TRUE;
			hublift_rechts.st_ctrl.in.b_stop := TRUE;
			wt_transport_kontroller.st_ctrl.in.b_stop := TRUE;
			stueckzahlen.st_ctrl.in.b_stop := TRUE;
			balluff_tag_reader.st_ctrl.in.b_stop := TRUE;
			edit_mfps.st_ctrl.in.b_stop := TRUE;

			(* Diese Fehler führt zum "Stop" in der Maschine *)
			IF safety.st_ctrl.out.b_fehler THEN
				axis_virt_master.st_ctrl.in.b_stop := TRUE;
				axis_bestueckachse.st_ctrl.in.b_stop := TRUE;
				axis_z_achse.st_ctrl.in.b_stop := TRUE;
				axis_virt_master.st_ctrl.in.b_halt := FALSE;
				axis_bestueckachse.st_ctrl.in.b_halt := FALSE;
				axis_z_achse.st_ctrl.in.b_halt := FALSE;
			ELSE
				axis_virt_master.st_ctrl.in.b_halt := TRUE;
				axis_bestueckachse.st_ctrl.in.b_halt := TRUE;
				axis_z_achse.st_ctrl.in.b_halt := TRUE;
				axis_virt_master.st_ctrl.in.b_stop := FALSE;
				axis_bestueckachse.st_ctrl.in.b_stop := FALSE;
				axis_z_achse.st_ctrl.in.b_stop := FALSE;
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	fb_r_trig_quittieren.Q THEN
			fb_ton_wz.IN:=TRUE;
			b_Merker_quitt:=TRUE;
		END_IF
		IF 	(b_Merker_quitt AND ST_Betriebsfreigaben.e_druckwaechter) OR
			fb_ton_wz.Q THEN
			fb_ton_wz.IN:=FALSE;
			b_Merker_quitt:=FALSE;
			fb_ton_quitt.IN := TRUE;
			(* QUITT *)
			UPS.st_ctrl.in.b_quitt := TRUE;
			betriebsfreigaben.st_ctrl.in.b_quitt := TRUE;
			bandeinzug_kontroller.st_ctrl.in.b_quitt := TRUE;
			axis_virt_master.st_ctrl.in.b_quitt := TRUE;
			axis_bestueckachse.st_ctrl.in.b_quitt := TRUE;
			axis_z_achse.st_ctrl.in.b_quitt := TRUE;
			bandspruehoeler.st_ctrl.in.b_quitt := TRUE;
			haspel_kontroller.st_ctrl.in.b_quitt := TRUE;
			hublift_links.st_ctrl.in.b_quitt := TRUE;
			hublift_rechts.st_ctrl.in.b_quitt := TRUE;
			wt_transport_kontroller.st_ctrl.in.b_quitt := TRUE;
			wkz_absicherung.st_ctrl.in.b_quitt := TRUE;
			stueckzahlen.st_ctrl.in.b_quitt := TRUE;
			balluff_tag_reader.st_ctrl.in.b_quitt := TRUE;
			bbgen.st_ctrl.in.b_quitt := TRUE;
			wartung.st_ctrl.in.b_quitt := TRUE;
			safety.st_ctrl.in.b_quitt := TRUE;
			edit_mfps.st_ctrl.in.b_quitt := TRUE;
			routing_backpanel.st_ctrl.in.b_quitt := TRUE;
			routing_nachbarpc.st_ctrl.in.b_quitt := TRUE;
			Lesen_Schreiben_Tag.st_ctrl.in.b_quitt := TRUE;
			Service.st_ctrl.in.b_quitt := TRUE;
			(* STOP *)
			bandeinzug_kontroller.st_ctrl.in.b_stop := FALSE;
			axis_virt_master.st_ctrl.in.b_stop := FALSE;
			axis_bestueckachse.st_ctrl.in.b_stop := FALSE;
			axis_z_achse.st_ctrl.in.b_stop := FALSE;
			bandspruehoeler.st_ctrl.in.b_stop := FALSE;
			haspel_kontroller.st_ctrl.in.b_stop := FALSE;
			hublift_links.st_ctrl.in.b_stop := FALSE;
			hublift_rechts.st_ctrl.in.b_stop := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_stop := FALSE;
			wkz_absicherung.st_ctrl.in.b_stop := FALSE;
			stueckzahlen.st_ctrl.in.b_stop := FALSE;
			balluff_tag_reader.st_ctrl.in.b_stop := FALSE;
			edit_mfps.st_ctrl.in.b_stop := FALSE;
			(* HALT - nur Achsen *)
			axis_virt_master.st_ctrl.in.b_halt := FALSE;
			axis_bestueckachse.st_ctrl.in.b_halt := FALSE;
			axis_z_achse.st_ctrl.in.b_halt := FALSE;
		END_IF

		IF fb_ton_quitt.Q THEN
			IF (gi16_betriebsart = AUTO OR gi16_betriebsart = TIPPEN) THEN
				fb_state_entry.i16_next_step := INIT;
			END_IF
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_disable_auto_reset;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_Maschine_in_Gst;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := bm_Check;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Rasterfolie' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Rafl_Stoerungen_Quitt
VAR_INPUT
	st_config						: struct_config;
	st_ctrl_in						: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu						: struct_visu;
	st_visu_hinten					: struct_visu_hinten;
END_VAR
VAR_OUTPUT
	st_ctrl_out					: struct_ctrl_out;
	b_lampe_stoerung			: BOOL;
	b_lampe_produktion			: BOOL;
END_VAR
VAR
	fb_ton_quitt					: TON;
	fb_ton_wz				: TON;
	fb_r_trig_quittieren				: R_TRIG;
	fb_state_entry					: ST_StateEntry;

	fb_blinker					: ST_Blinker;
	b_Merker_quitt			: BOOL:=FALSE;
	bm_Maschine_in_Gst			: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_quitt(IN:= , PT:= t#150ms, Q=> , ET=> );
fb_ton_wz(IN:= , PT:= t#3000ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_quittieren(CLK:= (st_visu.b_quittieren OR st_visu_hinten.out.b_quittieren) AND gi16_betriebsart <> HAND, Q=> );

(* Blinker *)
fb_blinker(
	b_start:= TRUE,
	t_taktzeit_on:=t#500ms,
	t_taktzeit_off:=t#500ms,
	b_blinker_out=> );

(* Lampen *)
b_lampe_stoerung := gi16_maschinenstatusinfo = KEIN_STATUS OR gi16_maschinenstatusinfo = STATUS_FEHLER;

b_lampe_produktion := (fb_blinker.b_blinker_out AND
					(gi16_maschinenstatusinfo = STATUS_FEHLER_QUITTIERT OR
					gi16_maschinenstatusinfo = STATUS_BETRIEBSBEREIT)) OR
					gi16_maschinenstatusinfo = STATUS_MASCHINE_ARBEITET;

(* Toplevel *)
(* Hier nur Abschaltungen welche zu sofortigem Stop führen müssen *)
IF fb_state_entry.i16_step < FEHLER AND
	(axis_virt_master.st_ctrl.out.b_fehler OR
	axis_bestueckachse.st_ctrl.out.b_fehler OR
	axis_z_achse.st_ctrl.out.b_fehler OR
	axis_y_achse.st_ctrl.out.b_fehler OR
	ST_TouchProbe.st_ctrl_out.b_fehler OR
	haspel_kontroller.st_ctrl.out.b_fehler OR
	rasterfolieneinzug.st_ctrl.out.b_fehler OR
	rasterfolienmontage.st_ctrl.out.b_fehler OR
	wt_transport_kontroller.st_ctrl.out.b_fehler OR
	balluff_tag_reader.st_ctrl.out.b_fehler OR
	bbgen.st_ctrl.out.b_fehler OR
	betriebsfreigaben.st_ctrl.out.b_fehler OR
	safety.st_ctrl.out.b_fehler OR
	edit_mfps.st_ctrl.out.b_fehler OR
	Lesen_Schreiben_Tag.st_ctrl.out.b_fehler OR
	Service.st_ctrl.out.b_fehler)
	THEN
		fb_state_entry.i16_next_step := FEHLER;
END_IF

(* Prüfe ob BA = Hand -> Stoppe Abläufe *)
IF  fb_state_entry.i16_step > INIT  AND fb_state_entry.i16_step < FEHLER  AND gi16_betriebsart = HAND THEN
	fb_state_entry.i16_next_step := FEHLER;
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			gi16_maschinenstatusinfo := STATUS_FEHLER_QUITTIERT;
			fb_ton_quitt.IN := FALSE;
			betriebsfreigaben.st_ctrl.in.b_quitt := FALSE;
			safety.st_ctrl.in.b_quitt := FALSE;
			rasterfolienmontage.st_ctrl.in.b_quitt := FALSE;
			rasterfolieneinzug.st_ctrl.in.b_quitt := FALSE;
			axis_virt_master.st_ctrl.in.b_quitt := FALSE;
			axis_bestueckachse.st_ctrl.in.b_quitt := FALSE;
			axis_y_achse.st_ctrl.in.b_quitt := FALSE;
			axis_z_achse.st_ctrl.in.b_quitt := FALSE;
			ST_TouchProbe.st_ctrl_in.b_quitt := FALSE;
			hublift_links.st_ctrl.in.b_quitt := FALSE;
			hublift_rechts.st_ctrl.in.b_quitt := FALSE;
			stueckzahlen.st_ctrl.in.b_quitt := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_quitt := FALSE;
			balluff_tag_reader.st_ctrl.in.b_quitt := FALSE;
			bbgen.st_ctrl.in.b_quitt := FALSE;
			edit_mfps.st_ctrl.in.b_quitt := FALSE;
			routing_backpanel.st_ctrl.in.b_quitt := FALSE;
			routing_nachbarpc.st_ctrl.in.b_quitt := FALSE;
			bm_Maschine_in_Gst := FALSE;
			Lesen_Schreiben_Tag.st_ctrl.in.b_quitt := FALSE;
			Service.st_ctrl.in.b_quitt := FALSE;
			ST_TippTasten.b_initialisierungsphase  := TRUE;
			haspel_kontroller.st_ctrl.in.b_quitt := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF safety.st_ctrl.out.b_bereit THEN
			fb_state_entry.i16_next_step := 11;
		END_IF

(*=======================================================*)
	11:
		IF fb_state_entry.E THEN
			axis_virt_master.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_prebereit  THEN
			axis_virt_master.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 12;
		END_IF

(*=======================================================*)
	12:
		IF fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_prebereit  THEN
			axis_z_achse.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 14;
		END_IF

(*=======================================================*)
	14:
		IF fb_state_entry.E THEN
			axis_y_achse.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_y_achse.st_ctrl.out.b_prebereit  THEN
			axis_y_achse.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 16;
		END_IF

(*=======================================================*)
	16:
		IF fb_state_entry.E THEN
			axis_bestueckachse.st_ctrl.in.b_preinit := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bestueckachse.st_ctrl.out.b_prebereit THEN
			axis_bestueckachse.st_ctrl.in.b_preinit := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:
		IF fb_state_entry.E THEN
			haspel_kontroller.st_ctrl.in.b_init := TRUE;
			stueckzahlen.st_ctrl.in.b_init := TRUE;
			balluff_tag_reader.st_ctrl.in.b_init := TRUE;
			rasterfolienmontage.st_ctrl.in.b_init := TRUE;
			edit_mfps.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF	haspel_kontroller.st_ctrl.out.b_bereit AND
			rasterfolienmontage.st_ctrl.out.b_bereit AND
			balluff_tag_reader.st_ctrl.out.b_bereit AND
			edit_mfps.st_ctrl.out.b_bereit
			THEN
				haspel_kontroller.st_ctrl.in.b_init := FALSE;
				stueckzahlen.st_ctrl.in.b_init := FALSE;
				balluff_tag_reader.st_ctrl.in.b_init := FALSE;
				rasterfolienmontage.st_ctrl.in.b_init := FALSE;
				edit_mfps.st_ctrl.in.b_init := FALSE;
				fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:
		IF fb_state_entry.E THEN
			rasterfolieneinzug.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF rasterfolieneinzug.st_ctrl.out.b_bereit THEN
			rasterfolieneinzug.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:
		IF fb_state_entry.E THEN
			axis_bestueckachse.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_bestueckachse.st_ctrl.out.b_bereit  THEN
			axis_bestueckachse.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:
		IF fb_state_entry.E THEN
			axis_z_achse.st_ctrl.in.b_init := TRUE;
			axis_y_achse.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_z_achse.st_ctrl.out.b_bereit AND axis_y_achse.st_ctrl.out.b_bereit THEN
			axis_z_achse.st_ctrl.in.b_init := FALSE;
			axis_y_achse.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60:
		IF fb_state_entry.E THEN
			axis_virt_master.st_ctrl.in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF axis_virt_master.st_ctrl.out.b_bereit  THEN
			axis_virt_master.st_ctrl.in.b_init := FALSE;
			fb_state_entry.i16_next_step := 70;
		END_IF

(*=======================================================*)
	70:
		IF fb_state_entry.E THEN
			hublift_links.st_ctrl.in.b_init := TRUE;
			hublift_rechts.st_ctrl.in.b_init := TRUE;
			wt_transport_kontroller.st_ctrl.in.b_init := TRUE;
			ST_TouchProbe.st_ctrl_in.b_init := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	hublift_links.st_ctrl.out.b_bereit AND
			hublift_rechts.st_ctrl.out.b_bereit AND
			wt_transport_kontroller.st_ctrl.out.b_bereit AND
			ST_TouchProbe.st_ctrl_out.b_bereit
			THEN
				hublift_links.st_ctrl.in.b_init := FALSE;
				hublift_rechts.st_ctrl.in.b_init := FALSE;
				wt_transport_kontroller.st_ctrl.in.b_init := FALSE;
				ST_TouchProbe.st_ctrl_in.b_init := FALSE;
				fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			ST_TippTasten.b_initialisierungsphase  := FALSE;

			(* Setze Maschinenstatus *)
			bm_Maschine_in_Gst := TRUE;
		END_IF

		(*Beim Einfädeln muss der Status geändert werden, damit nicht
		ständig neue Maschinendaten erzeugt werden*)
		IF ST_TippTasten.b_einfaedeln_aktiv THEN
			gi16_maschinenstatusinfo := STATUS_MASCHINE_ARBEITET;
		ELSE
			gi16_maschinenstatusinfo := STATUS_BETRIEBSBEREIT;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF NOT wt_transport_kontroller.st_ctrl.out.b_fertig THEN
			bm_Maschine_in_Gst := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110: (* Produktion *)
		IF fb_state_entry.E THEN
			gi16_maschinenstatusinfo := STATUS_MASCHINE_ARBEITET;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF wt_transport_kontroller.st_ctrl.out.b_fertig THEN
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			gi16_maschinenstatusinfo := STATUS_FEHLER;
			bm_Maschine_in_Gst := FALSE;
			ST_TippTasten.b_initialisierungsphase  := FALSE;
			fb_ton_quitt.IN := FALSE;
			s_alte_artikelnummer := '';

			(* Schlecht Stueckzahl erhöhen *)
			IF fb_state_entry.i16_last_step = 110 THEN
				stueckzahlen.st_ctrl.in.b_schlechtteil_produziert := TRUE;
			END_IF

			betriebsfreigaben.st_ctrl.in.b_quitt := FALSE;
			safety.st_ctrl.in.b_quitt := FALSE;
			rasterfolienmontage.st_ctrl.in.b_quitt := FALSE;
			rasterfolieneinzug.st_ctrl.in.b_quitt := FALSE;
			axis_virt_master.st_ctrl.in.b_quitt := FALSE;
			axis_bestueckachse.st_ctrl.in.b_quitt := FALSE;
			axis_y_achse.st_ctrl.in.b_quitt := FALSE;
			axis_z_achse.st_ctrl.in.b_quitt := FALSE;
			ST_TouchProbe.st_ctrl_in.b_quitt := FALSE;
			haspel_kontroller.st_ctrl.in.b_quitt := FALSE;
			hublift_links.st_ctrl.in.b_quitt := FALSE;
			hublift_rechts.st_ctrl.in.b_quitt := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_quitt := FALSE;
			stueckzahlen.st_ctrl.in.b_quitt := FALSE;
			balluff_tag_reader.st_ctrl.in.b_quitt := FALSE;
			bbgen.st_ctrl.in.b_quitt := FALSE;
			edit_mfps.st_ctrl.in.b_quitt := FALSE;
			routing_backpanel.st_ctrl.in.b_quitt := FALSE;
			routing_nachbarpc.st_ctrl.in.b_quitt := FALSE;
			Lesen_Schreiben_Tag.st_ctrl.in.b_quitt := FALSE;
			Service.st_ctrl.in.b_quitt := FALSE;

			axis_virt_master.st_ctrl.in.b_preinit := FALSE;
			axis_bestueckachse.st_ctrl.in.b_preinit := FALSE;
			axis_y_achse.st_ctrl.in.b_preinit := FALSE;
			axis_z_achse.st_ctrl.in.b_preinit := FALSE;

			rasterfolienmontage.st_ctrl.in.b_init := FALSE;
			rasterfolieneinzug.st_ctrl.in.b_init := FALSE;
			axis_virt_master.st_ctrl.in.b_init := FALSE;
			axis_bestueckachse.st_ctrl.in.b_init := FALSE;
			axis_y_achse.st_ctrl.in.b_init := FALSE;
			axis_z_achse.st_ctrl.in.b_init := FALSE;
			ST_TouchProbe.st_ctrl_in.b_init := FALSE;
			haspel_kontroller.st_ctrl.in.b_init := FALSE;
			hublift_links.st_ctrl.in.b_init := FALSE;
			hublift_rechts.st_ctrl.in.b_init := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_init := FALSE;
			stueckzahlen.st_ctrl.in.b_init := FALSE;
			balluff_tag_reader.st_ctrl.in.b_init := FALSE;
			edit_mfps.st_ctrl.in.b_init := FALSE;
		END_IF

		(* Fehlerhandling: was soll bei welchem Fehler passieren? *)
		IF 	NOT fb_ton_quitt.IN THEN
			(* Stoppe/Halte Komponenten an *)
			rasterfolienmontage.st_ctrl.in.b_stop := TRUE;
			rasterfolieneinzug.st_ctrl.in.b_stop := TRUE;
			hublift_links.st_ctrl.in.b_stop := TRUE;
			hublift_rechts.st_ctrl.in.b_stop := TRUE;
			wt_transport_kontroller.st_ctrl.in.b_stop := TRUE;
			stueckzahlen.st_ctrl.in.b_stop := TRUE;
			balluff_tag_reader.st_ctrl.in.b_stop := TRUE;
			edit_mfps.st_ctrl.in.b_stop := TRUE;

			(* Diese Fehler führt zum "Stop" in der Maschine *)
			IF safety.st_ctrl.out.b_fehler THEN
				axis_virt_master.st_ctrl.in.b_stop := TRUE;
				axis_bestueckachse.st_ctrl.in.b_stop := TRUE;
				axis_z_achse.st_ctrl.in.b_stop := TRUE;
				axis_y_achse.st_ctrl.in.b_stop := TRUE;
				axis_virt_master.st_ctrl.in.b_halt := FALSE;
				axis_bestueckachse.st_ctrl.in.b_halt := FALSE;
				axis_z_achse.st_ctrl.in.b_halt := FALSE;
				axis_y_achse.st_ctrl.in.b_halt := FALSE;
			ELSE
				axis_virt_master.st_ctrl.in.b_halt := TRUE;
				axis_bestueckachse.st_ctrl.in.b_halt := TRUE;
				axis_z_achse.st_ctrl.in.b_halt := TRUE;
				axis_y_achse.st_ctrl.in.b_halt := TRUE;
				axis_virt_master.st_ctrl.in.b_stop := FALSE;
				axis_bestueckachse.st_ctrl.in.b_stop := FALSE;
				axis_z_achse.st_ctrl.in.b_stop := FALSE;
				axis_y_achse.st_ctrl.in.b_stop := FALSE;
			END_IF
		END_IF


		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_r_trig_quittieren.Q THEN
			fb_ton_wz.IN:=TRUE;
			b_Merker_quitt:=TRUE;
		END_IF
		IF 	(b_Merker_quitt AND ST_Betriebsfreigaben.e_druckwaechter) OR
			fb_ton_wz.Q THEN
			fb_ton_wz.IN:=FALSE;
			b_Merker_quitt:=FALSE;
			fb_ton_quitt.IN := TRUE;
			(* QUITT *)
			betriebsfreigaben.st_ctrl.in.b_quitt := TRUE;
			safety.st_ctrl.in.b_quitt := TRUE;
			rasterfolienmontage.st_ctrl.in.b_quitt := TRUE;
			rasterfolieneinzug.st_ctrl.in.b_quitt := TRUE;
			axis_virt_master.st_ctrl.in.b_quitt := TRUE;
			axis_bestueckachse.st_ctrl.in.b_quitt := TRUE;
			axis_y_achse.st_ctrl.in.b_quitt := TRUE;
			axis_z_achse.st_ctrl.in.b_quitt := TRUE;
			ST_TouchProbe.st_ctrl_in.b_quitt := TRUE;
			haspel_kontroller.st_ctrl.in.b_quitt := TRUE;
			hublift_links.st_ctrl.in.b_quitt := TRUE;
			hublift_rechts.st_ctrl.in.b_quitt := TRUE;
			wt_transport_kontroller.st_ctrl.in.b_quitt := TRUE;
			stueckzahlen.st_ctrl.in.b_quitt := TRUE;
			balluff_tag_reader.st_ctrl.in.b_quitt := TRUE;
			bbgen.st_ctrl.in.b_quitt := TRUE;
			edit_mfps.st_ctrl.in.b_quitt := TRUE;
			routing_backpanel.st_ctrl.in.b_quitt := TRUE;
			routing_nachbarpc.st_ctrl.in.b_quitt := TRUE;
			Lesen_Schreiben_Tag.st_ctrl.in.b_quitt := TRUE;
			Service.st_ctrl.in.b_quitt := TRUE;
			(* STOP *)
			rasterfolienmontage.st_ctrl.in.b_stop := FALSE;
			rasterfolieneinzug.st_ctrl.in.b_stop := FALSE;
			axis_virt_master.st_ctrl.in.b_stop := FALSE;
			axis_bestueckachse.st_ctrl.in.b_stop := FALSE;
			axis_y_achse.st_ctrl.in.b_stop := FALSE;
			axis_z_achse.st_ctrl.in.b_stop := FALSE;
			haspel_kontroller.st_ctrl.in.b_stop := FALSE;
			hublift_links.st_ctrl.in.b_stop := FALSE;
			hublift_rechts.st_ctrl.in.b_stop := FALSE;
			wt_transport_kontroller.st_ctrl.in.b_stop := FALSE;
			stueckzahlen.st_ctrl.in.b_stop := FALSE;
			balluff_tag_reader.st_ctrl.in.b_stop := FALSE;
			edit_mfps.st_ctrl.in.b_stop := FALSE;
			(* HALT - nur Achsen *)
			axis_virt_master.st_ctrl.in.b_halt := FALSE;
			axis_bestueckachse.st_ctrl.in.b_halt := FALSE;
			axis_y_achse.st_ctrl.in.b_halt := FALSE;
			axis_z_achse.st_ctrl.in.b_halt := FALSE;
		END_IF

		IF fb_ton_quitt.Q THEN
			IF (gi16_betriebsart = AUTO OR gi16_betriebsart = TIPPEN) THEN
				fb_state_entry.i16_next_step := INIT;
			END_IF
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 2,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := bm_Maschine_in_Gst;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Rasterfolie' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Rasterfolieneinzug
VAR_INPUT
	st_config							: struct_config;
	st_ctrl_in							: struct_ctrl_in;
END_VAR
VAR_IN_OUT
	st_visu							: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out						: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz						: TON;
	fb_ton_uez						: TON;
	fb_ton_quitt						: TON;
	fb_ton_gls_rafo_vorhanden		: TON;
	fb_tof_gls_rafo_ende			: TOF;
	fb_tof_AbschaltungIonisierung		: TOF;
	fb_r_trig_start						: R_TRIG;
	fb_r_trig_vorschubkontrolle			: R_TRIG;
	fb_f_trig_vorschubkontrolle			: F_TRIG;
	fb_state_entry						: ST_StateEntry;
	i								: INT := 0;
	sm_fehler_rafo_vorschub			: BOOL := FALSE;
	sm_keine_rafo_im_einzug		: BOOL := FALSE;

	e_rasfo_ende						AT %I* : BOOL;
	e_rasfo_vorschubkontrolle			AT %I* : BOOL;
	e_rasfo_rueckzugueberwachung		AT %I* : BOOL;

	(* Ausgang Ionisierung Rasterfolie einschalten *)
	aIonisierungEin				AT %Q* : BOOL;

END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= t#1000ms, Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );
fb_ton_gls_rafo_vorhanden(IN:= e_rasfo_ende, PT:= T#300ms, Q=> , ET=> );
fb_tof_gls_rafo_ende(IN:= fb_ton_gls_rafo_vorhanden.Q, PT:= T#300ms, Q=> , ET=> );
fb_tof_AbschaltungIonisierung(IN:= fb_state_entry.i16_step = 200, PT:= T#2m, Q=> , ET=> );

(* Flanken *)
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );
fb_r_trig_vorschubkontrolle(CLK:= e_rasfo_vorschubkontrolle, Q=> );
fb_f_trig_vorschubkontrolle(CLK:= e_rasfo_vorschubkontrolle, Q=> );


(* Steuerung Ionisierung *)
IF gi16_maschinenstatusinfo = STATUS_MASCHINE_ARBEITET THEN
	aIonisierungEin := fb_tof_AbschaltungIonisierung.Q;
ELSE
	aIonisierungEin := FALSE;
END_IF


(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
	(* Allgemeine Fehler *)
	IF	zyl_rafo_faenger.st_ctrl.out.b_fehler OR
		zyl_rafo_klemmen.st_ctrl.out.b_fehler OR
		zyl_rafo_vorschub.st_ctrl.out.b_fehler
		THEN
			fb_state_entry.i16_next_step := FEHLER;

	(* Zylinder im Handbetrieb *)
	ELSIF	gi16_betriebsart = HAND AND (
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_rafo_faenger.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_rafo_klemmen.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_rafo_vorschub.fb.st_config.i16_identnummer) )
			THEN
				fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

sm_keine_rafo_im_einzug:=ST_Z_Achse.sm_keine_rafo_im_einzug;

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> , 
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			zyl_rafo_faenger.st_ctrl.in.b_ausfahren := FALSE;
			zyl_rafo_faenger.st_ctrl.in.b_einfahren := FALSE;
			zyl_rafo_klemmen.st_ctrl.in.b_ausfahren := FALSE;
			zyl_rafo_klemmen.st_ctrl.in.b_einfahren := FALSE;
			zyl_rafo_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			zyl_rafo_vorschub.st_ctrl.in.b_einfahren := FALSE;
			sm_fehler_rafo_vorschub := FALSE;
			sm_keine_rafo_im_einzug := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_rafo_faenger.st_ctrl.in.b_quittieren := FALSE;
			zyl_rafo_klemmen.st_ctrl.in.b_quittieren := FALSE;
			zyl_rafo_vorschub.st_ctrl.in.b_quittieren := FALSE;
			IF gst_datensatz.st_md.b_wt_transport_simulation THEN
				fb_state_entry.i16_next_step := BEREIT;
			ELSE
				fb_state_entry.i16_next_step := 20;
			END_IF
		END_IF

(*=======================================================*)
	20:	(* Klemmung ausfahren und Folie halten *)
		IF fb_state_entry.E THEN
			zyl_rafo_klemmen.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_klemmen.st_ctrl.out.b_ausgefahren THEN
			zyl_rafo_klemmen.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 30;
		END_IF

(*=======================================================*)
	30:	(* Fänger einfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_faenger.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_faenger.st_ctrl.out.b_eingefahren THEN
			zyl_rafo_faenger.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 40;
		END_IF

(*=======================================================*)
	40:	(* Vorschub zurück fahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_vorschub.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_vorschub.st_ctrl.out.b_eingefahren THEN
			zyl_rafo_vorschub.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 50;
		END_IF

(*=======================================================*)
	50:	(* Fänger ausfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_faenger.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_faenger.st_ctrl.out.b_ausgefahren THEN
			zyl_rafo_faenger.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 60;
		END_IF

(*=======================================================*)
	60:	(* Klemmung einfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_klemmen.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_klemmen.st_ctrl.out.b_eingefahren THEN
			zyl_rafo_klemmen.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_start THEN
			st_ctrl_out.b_fertig := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110:	(* Prüfe Rasterfolie im Einzug *)		(*wird im BEREIT der Z-Achse geprütf*)

		fb_state_entry.i16_next_step := 200;

(*===========================Vorschub Folie============================*)
	200:	(* Vorschub ausfahren und Vorschub prüfen *)
		IF fb_state_entry.E THEN
			zyl_rafo_vorschub.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Vorschubkontrolle durch positive Flanke *)
		IF fb_r_trig_vorschubkontrolle.Q THEN
			fb_state_entry.i16_next_step := 210;
		ELSIF zyl_rafo_vorschub.st_ctrl.out.b_ausgefahren THEN
			sm_fehler_rafo_vorschub := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	210:	(* Verhindere Signalüberschneidungen *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#1000ms;
 			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		(* Vorschubkontrolle durch negative Flanke *)
		IF fb_f_trig_vorschubkontrolle.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 220;
		ELSIF zyl_rafo_vorschub.st_ctrl.out.b_ausgefahren AND fb_ton_wz.Q THEN
			sm_fehler_rafo_vorschub := TRUE;
			fb_state_entry.i16_next_step := FEHLER;
		END_IF

(*=======================================================*)
	220:	(* Vorschub ist fertig ausgefahren *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_vorschub.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 230;
		END_IF

(*=======================================================*)
	230:	(* Klemmung ausfahren und Folie halten *)
		IF fb_state_entry.E THEN
			zyl_rafo_klemmen.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_klemmen.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_klemmen.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 240;
		END_IF

(*=======================================================*)
	240:	(* Fänger einfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_faenger.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_faenger.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_faenger.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 250;
		END_IF

(*=======================================================*)
	250:	(* Vorschub zurück fahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_vorschub.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_vorschub.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_vorschub.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 260;
		END_IF

(*=======================================================*)
	260: (* Warte *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#300ms;
 			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			(* Rasterfolieneinzug lüften
			Dies wird nur gemacht, wenn die Nocken ungleich 0 sind und Anfangs- und Endnocke aunterschiedlich sind
			Zwischen den Nocken wird die Rasterfolie vom Werkzeug gehalten *)
			IF gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_RASTERFOLIE_LUEFTEN].r_cam_begin <> 0 AND
				gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_RASTERFOLIE_LUEFTEN].r_cam_begin <> gst_datensatz.st_wkz.nockenschaltwerk_bestueckachse.arr_nocken[NO_RASTERFOLIE_LUEFTEN].r_cam_end THEN
				fb_state_entry.i16_next_step := 290;(* Ablauf mit Lüften *)
			ELSE
				fb_state_entry.i16_next_step := 270;(* Ablauf ohne Lüften *)
			END_IF
		END_IF

(*=======================================================*)
	270:	(* Fänger ausfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_faenger.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_faenger.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_faenger.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 280;
		END_IF

(*=======================================================*)
	280:	(* Klemmung einfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_klemmen.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_klemmen.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_klemmen.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 290;
		END_IF

(*=======================================================*)
	290:	(* Bandüberstand nach WKZ prüfen und eventuell zurückziehen *)

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF e_rasfo_rueckzugueberwachung THEN
			fb_state_entry.i16_next_step := 300;
		ELSE
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*===========================Rückzug Folie============================*)
	300:	(* Klemmung ausfahren und Folie halten *)
		IF fb_state_entry.E THEN
			zyl_rafo_klemmen.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_klemmen.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_klemmen.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 310;
		END_IF

(*=======================================================*)
	310:	(* Fänger einfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_faenger.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_faenger.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_faenger.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 320;
		END_IF

(*=======================================================*)
	320:	(* Vorschub ausfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_vorschub.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_vorschub.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_vorschub.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 330;
		END_IF

(*=======================================================*)
	330:	(* Fänger ausfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_faenger.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_faenger.st_ctrl.out.b_ausgefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_faenger.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := 340;
		END_IF

(*=======================================================*)
	340:	(* Klemmung einfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_klemmen.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_klemmen.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_klemmen.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 350;
		END_IF

(*=======================================================*)
	350:	(* Vorschub zurück fahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_vorschub.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_vorschub.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_vorschub.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 290;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_rafo_faenger.st_ctrl.in.b_quittieren := FALSE;
			zyl_rafo_klemmen.st_ctrl.in.b_quittieren := FALSE;
			zyl_rafo_vorschub.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_rafo_faenger.st_ctrl.in.b_quittieren := TRUE;
			zyl_rafo_klemmen.st_ctrl.in.b_quittieren := TRUE;
			zyl_rafo_vorschub.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_fehler_rafo_vorschub;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := sm_keine_rafo_im_einzug;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Rasterfolie' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ST_Rasterfolienmontage
VAR_INPUT
	st_config							: struct_config;
	st_ctrl_in							: struct_ctrl_in;
	b_start_y_Achse					: BOOL;
END_VAR
VAR_IN_OUT
	st_visu							: struct_visu;
END_VAR
VAR_OUTPUT
	st_ctrl_out						: struct_ctrl_out;
END_VAR
VAR
	fb_ton_wz						: TON;
	fb_ton_uez						: TON;
	fb_ton_quitt						: TON;
	fb_r_trig_start						: R_TRIG;
	fb_state_entry						: ST_StateEntry;
	i								: INT := 0;
	arr_rafo_schieberegister			: ARRAY [0..7] OF BOOL;
	sm_keine_rafo_aufgepresst			: BOOL := FALSE;

	e_rasterfolie_aufgepresst			AT %I* : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Zeiten *)
fb_ton_wz(IN:= , PT:= , Q=>  , ET=> );
fb_ton_uez(IN:= , PT:= t#10s, Q=>  , ET=> );
fb_ton_quitt(IN:= , PT:= t#100ms, Q=> , ET=> );

(* Flanken *)
fb_r_trig_start(CLK:= st_ctrl_in.b_start, Q=> );

(* Toplevel *)
IF fb_state_entry.i16_next_step > INIT AND fb_state_entry.i16_next_step < FEHLER THEN
	IF fb_state_entry.i16_next_step < STOP THEN
		IF st_ctrl_in.b_stop THEN
			fb_state_entry.i16_next_step := STOP;
		END_IF
	END_IF
	(* Allgemeine Fehler *)
	IF zyl_rafo_kamm.st_ctrl.out.b_fehler OR zyl_rafo_vorzentrierer.st_ctrl.out.b_fehler THEN
		fb_state_entry.i16_next_step := FEHLER;

	(* Zylinder im Handbetrieb *)
	ELSIF	gi16_betriebsart = HAND AND
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_rafo_kamm.fb.st_config.i16_identnummer) OR
			(st_visu.st_zyl.i16_nr_zyl_im_handbetrieb = zyl_rafo_vorzentrierer.fb.st_config.i16_identnummer)
			THEN
				fb_state_entry.i16_next_step := FEHLER;
	END_IF
END_IF

(* ======================================Schrittkette======================================== *)
fb_state_entry(
	i16_next_step:= ,
	i16_pos:= 1,
	s_debugtext:= ,
	E=> ,
	X=> ,
	i16_step=> ,
	i16_last_step=> );

CASE fb_state_entry.i16_step OF
(*=======================================================*)
	INIT_OBJ:
		IF st_config.b_config_fertig THEN
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	INIT:
		IF fb_state_entry.E THEN
			fb_ton_wz.IN := FALSE;
			fb_ton_uez.IN := FALSE;
			fb_ton_quitt.IN := FALSE;
			st_ctrl_out.b_fehler := FALSE;
			st_ctrl_out.b_bereit := FALSE;
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_fertig_2 := FALSE;
			zyl_rafo_kamm.st_ctrl.in.b_ausfahren := FALSE;
			zyl_rafo_kamm.st_ctrl.in.b_einfahren := FALSE;
			zyl_rafo_vorzentrierer.st_ctrl.in.b_ausfahren := FALSE;
			zyl_rafo_vorzentrierer.st_ctrl.in.b_einfahren := FALSE;
			rasterfolieneinzug.st_ctrl.in.b_start := FALSE;
			sm_keine_rafo_aufgepresst := FALSE;

			FOR i := 0 TO 7 BY 1 DO
				arr_rafo_schieberegister[i] := FALSE;
			END_FOR
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_init THEN
			zyl_rafo_kamm.st_ctrl.in.b_quittieren := FALSE;
			fb_state_entry.i16_next_step := 20;
		END_IF

(*=======================================================*)
	20:	(* Kamm einfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_kamm.st_ctrl.in.b_ausfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_kamm.st_ctrl.out.b_ausgefahren  THEN
			zyl_rafo_kamm.st_ctrl.in.b_ausfahren := FALSE;
			IF gst_datensatz.st_wkz.b_rafo_vorzentrierer_aktiv THEN
				fb_state_entry.i16_next_step := 30;
			ELSE
				fb_state_entry.i16_next_step := BEREIT;
			END_IF
		END_IF

(*=======================================================*)
	30:	(* Vorzentrierer einfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_vorzentrierer.st_ctrl.in.b_ausfahren := TRUE;	(*Federrückstellung*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  zyl_rafo_vorzentrierer.st_ctrl.out.b_ausgefahren THEN
			zyl_rafo_vorzentrierer.st_ctrl.in.b_ausfahren := FALSE;
			fb_state_entry.i16_next_step := BEREIT;
		END_IF

(*=======================================================*)
	BEREIT:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_bereit := TRUE;
			st_ctrl_out.b_fertig := TRUE;
			st_ctrl_out.b_fertig_2 := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_start THEN
			st_ctrl_out.b_fertig := FALSE;
			st_ctrl_out.b_fertig_2 := FALSE;
			b_start_y_Achse := FALSE;
			fb_state_entry.i16_next_step := 110;
		END_IF

(*=======================================================*)
	110: (* Positioniere Achse wieder zurück auf  0-Koordinate  des ISK *)
		IF fb_state_entry.E THEN
			ST_Y_Achse.lr_tmp_Achspos:=
							gst_datensatz.st_isk.lr_pos_y_0 +
							gst_datensatz.st_wkz.lr_offset_y_pos_0 +
							gst_datensatz.st_wt.lr_offset_y_pos_0 +
							gst_datensatz.st_md.lr_offset_y_pos_0 +
							gst_datensatz.st_bestueckprogramm.lr_y[0];
			b_start_y_Achse := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF 	ST_Y_Achse.st_drive_cmd.enu_cmd = NO_COMMAND AND
			NOT b_start_y_Achse THEN
			fb_state_entry.i16_next_step := 117;
		END_IF

(*=======================================================*)
	117:	(* Vorzentrierung vorhanden *)

	IF gst_datensatz.st_wkz.b_rafo_vorzentrierer_aktiv THEN
		fb_state_entry.i16_next_step := 118;
	ELSE
		fb_state_entry.i16_next_step :=120;
	END_IF

(*=======================================================*)
	118:	(* Vorzentrierung ausfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_vorzentrierer.st_ctrl.in.b_einfahren := TRUE;		(*Nicht Federrückstellend*)
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_vorzentrierer.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_vorzentrierer.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 120;
		END_IF

(*=======================================================*)
	120:	(* Kamm zum Gegenhalten ausfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_kamm.st_ctrl.in.b_einfahren := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF zyl_rafo_kamm.st_ctrl.out.b_eingefahren AND gb_ba_auto_kontroller THEN
			zyl_rafo_kamm.st_ctrl.in.b_einfahren := FALSE;
			fb_state_entry.i16_next_step := 130;
		END_IF

(*=======================================================*)
	130: (* Warte *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#100ms;
 			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 140;
		END_IF

(*=======================================================*)
	140:	(* Y-Achse muss runter fahren auf Absenkposition *)

		IF fb_state_entry.E THEN
			ST_Y_Achse.lr_tmp_Achspos:=	gst_datensatz.st_wkz.st_rasterfolie.lr_pos_absenken
											+ gst_datensatz.st_md.lr_offset_y_pos_0;
			b_start_y_Achse := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_Y_Achse.st_drive_cmd.enu_cmd = NO_COMMAND AND
			NOT b_start_y_Achse THEN
			fb_state_entry.i16_next_step := 150;
		END_IF

(*=======================================================*)
	150:	(* Eine Rasterfolie mit der Bestückachse setzen *)
		IF fb_state_entry.E THEN
			axis_virt_master.st_ctrl.in.b_start := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF  axis_virt_master.st_ctrl.out.b_fertig AND NOT fb_state_entry.E AND gb_ba_auto_kontroller THEN
			axis_virt_master.st_ctrl.in.b_start := FALSE;
			fb_state_entry.i16_next_step := 160;
		END_IF

(*=======================================================*)
	160: (* Warte bis Y-Achse wieder hoch gefahren ist auf  0-Koordinate  des ISK *)

		IF fb_state_entry.E THEN
			ST_Y_Achse.lr_tmp_Achspos:=
							gst_datensatz.st_isk.lr_pos_y_0 +
							gst_datensatz.st_wkz.lr_offset_y_pos_0 +
							gst_datensatz.st_wt.lr_offset_y_pos_0 +
							gst_datensatz.st_md.lr_offset_y_pos_0 +
							gst_datensatz.st_bestueckprogramm.lr_y[0];
			b_start_y_Achse := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_Y_Achse.st_drive_cmd.enu_cmd = NO_COMMAND AND
			NOT b_start_y_Achse THEN
			fb_state_entry.i16_next_step := 170;
		END_IF

(*=======================================================*)
	170: (* Warte *)
		IF fb_state_entry.E THEN
			fb_ton_wz.PT := t#100ms;
 			fb_ton_wz.IN := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF fb_ton_wz.Q THEN
			fb_ton_wz.IN := FALSE;
			fb_state_entry.i16_next_step := 180;
		END_IF

(*=======================================================*)
	180:	(* Kamm einfahren *)
		IF fb_state_entry.E THEN
			zyl_rafo_kamm.st_ctrl.in.b_ausfahren := TRUE;
			IF gst_datensatz.st_wkz.b_rafo_vorzentrierer_aktiv THEN
				zyl_rafo_vorzentrierer.st_ctrl.in.b_ausfahren := TRUE;	(*Federrückstellung*)
			END_IF
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF gst_datensatz.st_wkz.b_rafo_vorzentrierer_aktiv
			AND zyl_rafo_kamm.st_ctrl.out.b_ausgefahren AND zyl_rafo_vorzentrierer.st_ctrl.out.b_ausgefahren
				AND gb_ba_auto_kontroller THEN
					zyl_rafo_kamm.st_ctrl.in.b_ausfahren := FALSE;
					zyl_rafo_vorzentrierer.st_ctrl.in.b_ausfahren := FALSE;
				fb_state_entry.i16_next_step := 185;
		ELSIF NOT gst_datensatz.st_wkz.b_rafo_vorzentrierer_aktiv AND  zyl_rafo_kamm.st_ctrl.out.b_ausgefahren
				AND gb_ba_auto_kontroller THEN
					zyl_rafo_kamm.st_ctrl.in.b_ausfahren := FALSE;
				fb_state_entry.i16_next_step := 185;
		END_IF

(*=======================================================*)
	185: (* Warte bis Y-Achse wieder runter gefahren ist (auf Einfahrhöhe) *)
		IF fb_state_entry.E THEN
			ST_Y_Achse.lr_tmp_Achspos:= gst_datensatz.st_wkz.st_yz_tisch.r_wkz_einfahrpos_y;
			b_start_y_Achse := TRUE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF ST_Y_Achse.st_drive_cmd.enu_cmd = NO_COMMAND AND
			NOT b_start_y_Achse THEN
			st_ctrl_out.b_fertig := TRUE;
			fb_state_entry.i16_next_step := 190;
		END_IF
(*=======================================================*)
	190:
		IF	ST_Z_Achse.st_drive_cmd.enu_cmd = MOVE_ABSOLUTE THEN
			fb_state_entry.i16_next_step := 200;
		END_IF

(*=======================================================*)
	200: (* Warte bis Z-Achse zwischen die GLS fährt zur Überprüfung der Rasterfolie auf dem STV *)
		IF fb_state_entry.E THEN
			arr_rafo_schieberegister[ST_Z_Achse.i32_anzahl_rasterfolie] := FALSE;
			fb_ton_uez.IN:=FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
			(* Überprüfung GLS-Signal *)
		IF	ST_Z_Achse.st_drive_cmd.enu_cmd = NO_COMMAND THEN
			fb_ton_uez(IN:=TRUE,PT:=t#4s);
			IF e_rasterfolie_aufgepresst  THEN
				(* Rasterfolie vorhanden *)
				arr_rafo_schieberegister[ST_Z_Achse.i32_anzahl_rasterfolie] := TRUE;
				fb_state_entry.i16_next_step := BEREIT;
			ELSIF fb_ton_uez.Q THEN
				(* Keine Rasterfolie auf dem STV *)
				sm_keine_rafo_aufgepresst := TRUE;
				fb_state_entry.i16_next_step := FEHLER;
			END_IF
		END_IF

		IF fb_state_entry.X THEN
			fb_ton_uez.IN:=FALSE;
		END_IF

(*=======================================================*)
	FEHLER:
		IF fb_state_entry.E THEN
			st_ctrl_out.b_fehler := TRUE;
			fb_ton_quitt.IN := FALSE;
			zyl_rafo_kamm.st_ctrl.in.b_quittieren := FALSE;
			zyl_rafo_vorzentrierer.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			st_ctrl_out.b_fehler := FALSE;
			zyl_rafo_kamm.st_ctrl.in.b_quittieren := TRUE;
			zyl_rafo_vorzentrierer.st_ctrl.in.b_quittieren := TRUE;
			fb_ton_quitt.IN := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF

(*=======================================================*)
	STOP:
		IF fb_state_entry.E THEN
			fb_ton_quitt.IN := FALSE;
			zyl_rafo_kamm.st_ctrl.in.b_quittieren := FALSE;
			zyl_rafo_vorzentrierer.st_ctrl.in.b_quittieren := FALSE;
		END_IF

		(*-----------------------Weiterschaltbedingungen----------------------------*)
		IF st_ctrl_in.b_quitt AND NOT fb_state_entry.E THEN
			fb_ton_quitt.IN := TRUE;
			zyl_rafo_kamm.st_ctrl.in.b_quittieren := TRUE;
			zyl_rafo_vorzentrierer.st_ctrl.in.b_quittieren := TRUE;
		END_IF

		IF fb_ton_quitt.Q THEN
			fb_ton_quitt.IN := FALSE;
			fb_state_entry.i16_next_step := INIT;
		END_IF
END_CASE

fb_state_entry(
	i16_next_step:= , 
	i16_pos:= 2,
	s_debugtext:= ,
	E=> , 
	X=> , 
	i16_step=> ,
	i16_last_step=> );

IF st_config.b_config_fertig THEN
	(* Fehlermeldungen und Betriebsmeldungen ab dem Startindex in die globalen Meldungsarrays schreiben *)
	garr_stoermeldungen[st_config.i16_meld_startindex + 0] := sm_keine_rafo_aufgepresst;
	garr_stoermeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_stoermeldungen[st_config.i16_meld_startindex + 19] := FALSE;
	
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 0] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 1] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 2] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 3] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 4] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 5] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 6] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 7] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 8] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 9] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 10] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 11] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 12] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 13] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 14] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 15] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 16] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 17] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 18] := FALSE;
	garr_betriebsmeldungen[st_config.i16_meld_startindex + 19] := FALSE;
END_IF

END_PROGRAM

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_ecd_cmd :
	(
	NO_COMMAND := 0,
	ABORT,
	POWER_DISABLE,
	POWER_ENABLE,
	RESET,
	HOME,
	SET_POSITION,
	JOG_VORWAERTS,
	JOG_RUECKWAERTS,
	JOG_STOP,
	MOVE_ABSOLUTE,
	MOVE_ABSOLUTE_NEXT,
	MOVE_RELATIVE,
	MOVE_VELOCITY,
	MOVE_MODULO,
	MOVE_TOUCH_PROBE,
	STOP_AXIS,
	HALT_AXIS,
	GEAR_IN_SLAVE,
	GEAR_OUT_SLAVE,
	CAM_IN_SLAVE,
	CAM_OUT_SLAVE,
	CAM_SCALEING_SLAVE,
	SOE_WRITE_PARAM,
	SOE_READ_PARAM,
	ECCOESDO_WRITE_PARAM,
	ECCOESDO_READ_PARAM,
	WRITE_NC_PARAMETER,
	READ_NC_PARAMETER,
	WRITE_ADS_PARAMETER,
	READ_ADS_PARAMETER,
	WRITE_MOTION_POINT,
	READ_MOTION_POINT,
	READ_SLAVE_DYNAMICS,
	READ_CAMTABLE_CHAR

	);
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_ecd_typ :
	(
	LINEAR := 1,
	RUND,
	LINEAR_VIRTUELL,
	RUND_VIRTUELL,
	SERVOKLEMME7201
	);
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE st_camscaleingoptions :
STRUCT
	st_scaleing_activation_mode			: MC_CamActivationMode;
	r_scaleing_activation_position			: LREAL;
	st_master_scaling_mode				: MC_CamScalingMode;
	st_slave_scaling_mode				: MC_CamScalingMode;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_achse :
STRUCT
	st_ctrl		: struct_ctrl;
	st_config		: struct_ecd_config;
	st_visu		: struct_ecd_visu;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ads_info :
STRUCT
	s_net_id 								: T_AmsNetId := '';
	st_symbol_info						: SYMINFOSTRUCT;
	dw_zieladresse_ads_read				: DWORD := 16#0000;
	dw_quelladresse_ads_write				: DWORD := 16#0000;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_eccoe_sdo :
STRUCT
	s_ec_slave_net_id 		: T_AmsNetId := '';
	ui16_slave_addr 			: UINT := 0; (* Address of the slave device.*)
	i8_sub_index 				: BYTE := 0; (* CANopen Sdo subindex.*)
	w_index 					: WORD := 16#00; (* CANopen Sdo index.*)
	dw_p_source_buffer 		: DWORD := 16#0000; (* Contains the address of the buffer containing the data to be send. *)
	dw_p_destination_buffer	: DWORD := 16#0000; (* Contains the address of the buffer for the received data. *)
	ui32_buffer_length 			: UDINT := 0; (* Contains the max. number of bytes to be received. *)
	ui32_value 				: UDINT := 0; (* variable to be written to the CoE Object *)
	ui16_value 				: UINT := 0; (* variable to be written to the CoE Object *)
	byte_value 				: BYTE := 16#00; (* variable to be written to the CoE Object *)
	bool_value 				: BOOL := FALSE; (* variable to be written to the CoE Object *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ecd_cmd :
STRUCT
	b_job_fehler 		: BOOL := FALSE;
	enu_cmd			: enum_ecd_cmd;
	meldungen		: struct_ecd_cmd_meldungen;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ecd_cmd_meldungen :
STRUCT
	sm_power_enable					: BOOL := FALSE;
	sm_power_disable				: BOOL := FALSE;
	sm_reset							: BOOL := FALSE;
	sm_home						: BOOL := FALSE;
	sm_setposition					: BOOL := FALSE;
	sm_jog_vorwaerts					: BOOL := FALSE;
	sm_jog_rueckwaerts				: BOOL := FALSE;
	sm_move_absolute				: BOOL := FALSE;
	sm_move_relative					: BOOL := FALSE;
	sm_move_velocity				: BOOL := FALSE;
	sm_move_modulo					: BOOL := FALSE;
	sm_stop_axis						: BOOL := FALSE;
	sm_halt_axis						: BOOL := FALSE;
	sm_gear_in_slave					: BOOL := FALSE;
	sm_gear_out_slave				: BOOL := FALSE;
	sm_cam_in_slave					: BOOL := FALSE;
	sm_cam_out_slave				: BOOL := FALSE;
	sm_cam_scaleing_slave			: BOOL := FALSE;
	sm_motion_command_timeout		: BOOL := FALSE;
	sm_camgear_command_timeout	: BOOL := FALSE;
	sm_achse_nicht_referenziert		: BOOL := FALSE;
	sm_limit_positiv_erreicht			: BOOL := FALSE;
	sm_limit_negativ_erreicht			: BOOL := FALSE;
	sm_write_soe_parameter			: BOOL := FALSE;
	sm_read_soe_parameter			: BOOL := FALSE;
	sm_write_nc_parameter			: BOOL := FALSE;
	sm_read_nc_parameter			: BOOL := FALSE;
	sm_write_motion_funktion_point		: BOOL := FALSE;
	sm_read_motion_funktion_point		: BOOL := FALSE;
	sm_read_camtable_slave_dynamics	: BOOL := FALSE;
	sm_read_camtable_charakteristik	: BOOL := FALSE;
	sm_write_ads_parameter			: BOOL := FALSE;
	sm_read_ads_parameter			: BOOL := FALSE;
	sm_ec_coe_sdo_write_ex			: BOOL := FALSE;
	sm_ec_coe_sdo_read_ex			: BOOL := FALSE;
	sm_touch_probe_defect			: BOOL := FALSE;
	sm_touch_probe_err				: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ecd_config :
STRUCT
	s_instanz_name					: STRING(48) := '';
	s_beschreibung					: STRING(32) := '';
	i16_meld_startindex				: INT;
	ui16_ethercat_adr					: UINT := 0;
	ui16_ethercat_slave_id				: UINT := 0;

	i16_achs_nr						: INT := 0;
	i16_modul_nr						: INT := 0;

	b_refsensor_vorhanden			: BOOL := FALSE;
	b_limitsensor_positiv_vorhanden	: BOOL := FALSE;
	b_limitsensor_negativ_vorhanden	: BOOL := FALSE;

	r_getriebefaktor					: LREAL := 0.0;
	ui16_bipolar_torque_limit			: UINT := 1000;
	i16_achstyp						: enum_ecd_typ;

	b_config_fertig					: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ecd_fehler :
STRUCT
	b_sammel				: BOOL := FALSE;
	b_job_fehler 				: BOOL := FALSE;
	b_achsfehler 				: BOOL := FALSE;
	b_devicefehler 			: BOOL := FALSE;
	b_limit_positiv_erreicht 		: BOOL := FALSE;
	b_limit_negativ_erreicht	: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ecd_geschwindigkeiten :
STRUCT
	lr_maximalgeschwindigkeit	: LREAL := 0.0;
	lr_beschleunigung 		: LREAL := 0.0;
	lr_verzoegerung	 		: LREAL := 0.0;
	lr_ruck			 		: LREAL := 0.0;

	lr_auto_max				: LREAL := 0.0;
	lr_auto_min				: LREAL := 0.0;
	lr_jog					: LREAL := 0.0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ecd_meldungen :
STRUCT
	b_achsfehler					: BOOL := FALSE;
	b_devicefehler				: BOOL := FALSE;
	b_achse_nicht_bb				: BOOL := FALSE;
	b_achse_nicht_referenziert		: BOOL := FALSE;
	b_keine_verfahrfreigabe		: BOOL := FALSE;
	b_achse_nicht_auf_startpos		: BOOL := FALSE;
	b_ende_skalierungs_nocke		: BOOL := FALSE;
	b_ende_camming_nocke		: BOOL := FALSE;
	b_skalierung_noch_aktiv		: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ecd_positionen :
STRUCT
	r_soll		 			: LREAL := 0.0;
	r_referenz				: LREAL := 0.0;
	lr_ibn_pos_start			: LREAL := 0.0;
	lr_ibn_pos_ziel			: LREAL := 0.0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ecd_visu :
STRUCT
	b_nullpunkt_setzen				: BOOL := FALSE;
	b_tippen_vorwaerts				: BOOL := FALSE;
	b_tippen_rueckwaerts				: BOOL := FALSE;
	b_achse_lueften					: BOOL := FALSE;
	b_achse_regeln					: BOOL := FALSE;
	b_bandeinzug_referenzieren		: BOOL := FALSE;
	i32_geschwindigkeit_soll			: DINT := 0;
	i32_geschwindigkeit_ist			: DINT := 0;
	i32_position_ist					: DINT := 0;
	lr_geschwindigkeit_soll				: LREAL := 0.0;
	lr_geschwindigkeit_ist				: LREAL := 0.0;
	lr_position_ist						: LREAL := 0.0;
	b_winkel_vor_ot_uebernehmen		: BOOL := FALSE;
	b_winkel_nach_ot_uebernehmen	: BOOL := FALSE;
	b_winkeloffset_uebernehmen		: BOOL := FALSE;
	b_einschalten						: BOOL := FALSE;
	b_ausschalten					: BOOL := FALSE;
	b_motor_dreht					: BOOL := FALSE;
	b_taste_vorgabegeschwindigkeit	: BOOL := FALSE;
	b_taste_plus						: BOOL := FALSE;
	b_taste_plusplus					: BOOL := FALSE;
	b_taste_minus					: BOOL := FALSE;
	b_taste_minusminus				: BOOL := FALSE;
	st_zyl							: struct_zylinder_visu;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Achsen\/BECKHOFF' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_nc_scaling_parameter :
STRUCT
	lr_ref_velo					: LREAL := 0.0;
	lr_max_velo					: LREAL := 0.0;
	lr_manual_velo_fast			: LREAL := 0.0;
	lr_manual_velo_slow			: LREAL := 0.0;
	lr_calibration_velo_forward		: LREAL := 0.0;
	lr_calibration_velo_backward	: LREAL := 0.0;
	lr_acceleration				: LREAL := 0.0;
	lr_deceleration				: LREAL := 0.0;
	lr_jerk						: LREAL := 0.0;
	lr_scaling_factor				: LREAL := 0.0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Allgemeine Kontrollstrukturen Objekte' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_step_nr :
	(
	INIT_OBJ := 0,
	INIT := 10,
	BEREIT := 100,
	FEHLER := 1000,
	STOP := 1100,
	STILLSTAND := 1200,
	HALT := 1300,
	HANDRAD := 2000,
	MOTORBREMSE_AUF :=2100,
	MOTORBREMSE_ZU := 2200,
	LUEFTEN := 2300,
	REGELN := 2400,
	NULLPUNKT_SETZEN := 2500,
	INBETRIEBNAHME := 5000,
	(* Zylinder *)
	ZYL_INIT := 3000,
	GESTOPPT := 3010,
	EINGEFAHREN := 3020,
	BEWEGUNG_AUSFAHREN := 3030,
	AUSGEFAHREN := 3040,
	BEWEGUNG_EINFAHREN := 3050,
	MITTEGEFAHREN := 3060,
	BEWEGUNG_MITTE := 3070,
	LUFTLOS := 3080,
	ZYL_FEHLER := 3090,
	DIREKT_EINFAHREN := 3100,
	DIREKT_AUSFAHREN := 3110
	);
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Allgemeine Kontrollstrukturen Objekte' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_config :
STRUCT
	str_instanz_name					: STRING(48) := '';
	str_beschreibung					: STRING(32) := '';
	b_station_aktiv					: BOOL := FALSE;
	b_station_in_simulation				: BOOL := FALSE;
	i16_meld_startindex				: INT := 0;
	b_config_fertig					: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Allgemeine Kontrollstrukturen Objekte' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ctrl :
STRUCT
	in		: struct_ctrl_in;
	out		: struct_ctrl_out;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Allgemeine Kontrollstrukturen Objekte' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ctrl_in :
STRUCT
	b_quitt						: BOOL := FALSE;
	b_stop 						: BOOL := FALSE;
         b_halt		  	 			: BOOL := FALSE;
         b_definierter_halt  	 			: BOOL := FALSE;
	b_init 						: BOOL := FALSE;
	b_init_2 						: BOOL := FALSE;
         b_preinit                				: BOOL := FALSE;
	b_start						: BOOL := FALSE;
	b_start_2						: BOOL := FALSE;
	b_gutteil_produziert 			: BOOL := FALSE;
	b_schlechtteil_produziert 		: BOOL := FALSE;
	b_start_lesen					: BOOL := FALSE;
	b_start_schreiben				: BOOL := FALSE;
	b_schutzhaube_ab			: BOOL := FALSE;
	b_schutzhaube_auf			: BOOL := FALSE;
	b_nachtabschaltung			: BOOL := FALSE;
	b_gehe_step_ibn				: BOOL := FALSE;
	b_ibn_start					: BOOL := FALSE;
	b_freigabe					: BOOL := FALSE;
	b_bremse_auf				: BOOL := FALSE;
	b_bremse_zu					: BOOL := FALSE;
	b_home						: BOOL := FALSE;
	b_ausfaedeln_servo			: BOOL := FALSE;
	b_einfaedeln_servo			: BOOL := FALSE;
	b_startpos					: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Allgemeine Kontrollstrukturen Objekte' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ctrl_out :
STRUCT
	b_bereit 						: BOOL := FALSE;
	b_bereit_2					: BOOL := FALSE;
         b_prebereit               			: BOOL := FALSE;
	b_fehler 						: BOOL := FALSE;
	b_fertig						: BOOL := FALSE;
	b_fertig_2					: BOOL := FALSE;
	b_bandende					: BOOL := FALSE;
	b_kontroller_start				: BOOL := FALSE;
	b_gestoppt					: BOOL := FALSE;
	b_angehalten					: BOOL := FALSE;
	b_haube_oeffnen				: BOOL := FALSE;
	b_nachtabschaltung			: BOOL := FALSE;
	b_einzelfertigung				: BOOL := FALSE;
	b_busy						: BOOL := FALSE;
	b_bremse_geschlossen		: BOOL := FALSE;
	b_bremse_geoeffnet			: BOOL := FALSE;
	b_ausgefaedelt_servo			: BOOL := FALSE;
	b_servo_auf_einfaedelpos		: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Allgemeine Kontrollstrukturen Objekte' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_objekt :
STRUCT
	st_config		: struct_config;
	st_ctrl		: struct_ctrl;
	st_visu		: struct_visu;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Analogkarte' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_analog_in :
STRUCT
	e_b_status_underrange		: BOOL := FALSE;
	e_b_status_overrange			: BOOL := FALSE;
	e_by_status_limit1				: BYTE := 2#0;
	e_by_status_limit2				: BYTE := 2#0;
	e_b_status_error				: BOOL := FALSE;
	e_i16_value					: INT := 0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Analogkarte' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_analogin :
STRUCT
	fb			: ST_AnalogIn;
	st_ctrl		: struct_ctrl;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Analogkarte' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_analogout :
STRUCT
	fb			: ST_AnalogOut;
	st_ctrl		: struct_ctrl;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Betriebsarten' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_betriebsarten :
	(KEINE := 0,
	AUTO,
	TIPPEN,
	DUMMY,
	PSEUDO,
	HAND);
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Betriebsarten' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_betriebsarten :
STRUCT
	st_config					: struct_config;
	st_ctrl					: struct_ctrl;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_auftrag_cameditor :
	(
	MFP_KEIN_AUFTRAG := 0,
	MFP_LESEN,
	MFP_SCHREIBEN
	);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_cam_editor :
STRUCT
	fb					: ST_Kurvenscheibeneditor;
	st_config				: struct_config;
	st_ctrl				: struct_ctrl;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_cameditor_meldungen :
STRUCT
	schreibe_mfp 							: BOOL := FALSE;
	lese_mfp									: BOOL := FALSE;
	schreibe_camtable						: BOOL := FALSE;
	lese_camtable							: BOOL := FALSE;
	berechne_konstantfahrphase				: BOOL := FALSE;
	berechne_max_master_geschwindigkeit		: BOOL := FALSE;
	lesen_werte_mf_tab						: BOOL := FALSE;
	fehler_cam_in								: BOOL := FALSE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_camtable_maker :
STRUCT
	fb					: ST_Camtable_Maker;
	st_config			: struct_config;
	st_ctrl				: struct_ctrl;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_db_motionfunctionpoint :
STRUCT
	    PointIndex        		: MC_MotionFunctionPoint_ID;
	    FunctionType    		: MC_MotionFunctionType;
	    PointType        		: MC_MotionPointType;
	    MasterPos        		: LREAL; (* X *)
	    SlavePos          		: LREAL; (* Y *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/CamEditor' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_mf_editor :
STRUCT
	fb					: ST_MFCalcConstPhase;
	st_config				: struct_config;
	st_ctrl				: struct_ctrl;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Diagnose' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ecat_klemmen_diagnose :
STRUCT
	WcState			: BOOL := 2#0;		(* 1 = Data invalid *)
	ECatState		: UINT := 0;		(* 0x08 = OP-State *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Nockenschaltwerk\/NSW_INT' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_nocken_int :
STRUCT
	i16_track_no 				: INT := 0;
	b_camvalid 				: BOOL := FALSE;
	b_eff_direction_pos 		: BOOL := FALSE;
	b_eff_direction_neg 		: BOOL := FALSE;
	b_nockenzustand 			: BOOL := FALSE;
	i16_cam_begin 			: INT := 0;
	i16_cam_end 				: INT := 0;
	t_vorsteuerzeit			: TIME := t#0ms;
	i16_vorsteuerpos			: INT := 0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Nockenschaltwerk\/NSW_INT' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_nockenschaltwerk_int :
STRUCT
	fb					: ST_Nockenschaltwerk_int;
	st_config				: struct_config;
	arr_nocken			: ARRAY [0..MAX_NOCKENGERUEST] OF struct_nocken_int;
	arr_spur				: ARRAY [0..MAX_NOCKENGERUEST] OF BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Nockenschaltwerk\/NSW_LREAL' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_nocken_lreal :
STRUCT
	i16_track_no 				: INT := 0;
	b_camvalid 				: BOOL := FALSE;
	b_eff_direction_pos 		: BOOL := FALSE;
	b_eff_direction_neg 		: BOOL := FALSE;
	b_nockenzustand 			: BOOL := FALSE;
	r_cam_begin 				: LREAL := 0.0;
	r_cam_end 				: LREAL := 0.0;
	t_vorsteuerzeit			: TIME := t#0ms;
	r_vorsteuerpos			: LREAL := 0.0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Nockenschaltwerk\/NSW_LREAL' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_nocken_visu :
STRUCT
	b_daten_backup					: BOOL := FALSE;
	b_daten_recover					: BOOL := FALSE;
	b_setze_drehgeber_nullpunkt		: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Nockenschaltwerk\/NSW_LREAL' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_nockeneinstellungen :
STRUCT
	arr_nocken			: ARRAY [0..MAX_NOCKENGERUEST] OF struct_nocken_lreal;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Nockenschaltwerk\/NSW_LREAL' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_nockenschaltwerk_lreal :
STRUCT
	fb					: ST_Nockenschaltwerk_lreal;
	st_config				: struct_config;
	arr_nocken			: ARRAY [0..MAX_NOCKENGERUEST] OF struct_nocken_lreal;
	arr_spur				: ARRAY [0..MAX_NOCKENGERUEST] OF BOOL;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Nockenschaltwerk\/NZW' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_nockenzaehlwerk :
STRUCT
	fb					: ST_Nockenzaehlwerk;
	st_config				: struct_config;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Routing' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ads_kommunikation :
STRUCT
	fb			: ST_ADS_Kommunikation;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Routing' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_nachbar_pc :
STRUCT
	st_station_vorher		: struct_station_vorher;
	st_station_nachher		: struct_station_nachher;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Routing' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_station_nachher :
STRUCT
	s_ams_netid		: T_AmsNetId := '0.0.0.0.0.0';
	in				: struct_station_nachher_in;
	out				: struct_station_nachher_out;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Routing' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_station_nachher_in :
STRUCT
	b_erlaubnis			: BOOL;
	b_angekommen		: BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Routing' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_station_nachher_out :
STRUCT
	b_start_fb			: BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Routing' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_station_vorher :
STRUCT
	s_ams_netid		: T_AmsNetId := '0.0.0.0.0.0';
	in				: struct_station_vorher_in;
	out				: struct_station_vorher_out;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Routing' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_station_vorher_in :
STRUCT
	b_start_fb			: BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Routing' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_station_vorher_out :
STRUCT
	b_erlaubnis			: BOOL;
	b_angekommen		: BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Serielle Kommunikation' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_balluff_tag_reader :
STRUCT
	fb			: ST_BalluffTagReader;
	st_ctrl		: struct_ctrl;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Serielle Kommunikation' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_barcode_reader :
STRUCT
	fb			: ST_BarcodeReader;
	st_ctrl		: struct_ctrl;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Serielle Kommunikation' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_serial_data :
STRUCT
	arr_buffer			: ARRAY[0..79] OF BYTE;
	i32_size				: UDINT := 0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Sprache' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_sprache :
	(
	KEINE_SPRACHE := 0,
	DEUTSCH := 1,
	ENGLISCH := 2,
	TSCHECHISCH := 3,
	RESERVESPRACHE1 := 4,
	RESERVESPRACHE2 := 5);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Sprache' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_sprachumschaltung :
STRUCT
	i16_akt_sprache		: enum_sprache := DEUTSCH;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_st_zylinder :
STRUCT
	fb			: ST_Zylinder12V012346E;
	st_ctrl		: struct_zylinder_ctrl;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_totzeitkompensation :
STRUCT
	t_einfahrzeit					: TIME := t#0ms;
	t_ausfahrzeit					: TIME := t#0ms;
	t_einfahrzeit_kompensiert		: TIME := t#0ms;
	t_ausfahrzeit_kompensiert		: TIME := t#0ms;
	t_kompensationszeit			: TIME := t#0ms;
	fb_ton_tzk					: TON;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_zylinder_config :
STRUCT
	i16_identnummer					: INT := 0;
	i16_gruppe						: INT := 0;
	str_instanz_name					: STRING(48) := '';
	str_beschreibung					: STRING(32) := '';
	str_zylinder_typ					: STRING := '2V2E_EIN_AUS';
	b_aktiv							: BOOL := TRUE;
	b_endlage1_aktiv					: BOOL := TRUE;
	b_sensor1_aktiv					: BOOL := TRUE;
	b_endlage2_aktiv	 				: BOOL := FALSE;
	b_sensor2_aktiv					: BOOL := FALSE;
	b_endlage3_aktiv	 				: BOOL := FALSE;
	b_sensor3_aktiv					: BOOL := FALSE;
	t_ueberwachungszeit				: TIME := t#2000ms;
	t_ein_aus_fahrzeit					: TIME := t#100ms;
	i16_meld_startindex				: INT := 0;
	i16_tzk_faktor_ausfahren			: INT := 100;
	i16_tzk_faktor_einfahren			: INT := 100;
	b_config_fertig					: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_zylinder_ctrl :
STRUCT
	in		: struct_zylinder_ctrl_in;
	out		: struct_zylinder_ctrl_out;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_zylinder_ctrl_in :
STRUCT
	b_quittieren			: BOOL := FALSE;
	b_stop				: BOOL := FALSE;
	b_einfahren			: BOOL := FALSE;
	b_ausfahren			: BOOL := FALSE;
	b_luftlos				: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_zylinder_ctrl_out :
STRUCT
	b_fehler				: BOOL := FALSE;
	b_eingefahren		: BOOL := FALSE;
	b_ausgefahren		: BOOL := FALSE;
	b_gestoppt			: BOOL := FALSE;
	b_ohne_luft			: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_zylinder_meldungen :
STRUCT
	b_zeit_ausfahren1			: BOOL := FALSE;
	b_zeit_einfahren1			: BOOL := FALSE;
	b_endlage1				: BOOL := FALSE;
	b_sensor1				: BOOL := FALSE;
	b_zeit_ausfahren2			: BOOL := FALSE;
	b_zeit_einfahren2			: BOOL := FALSE;
	b_endlage2				: BOOL := FALSE;
	b_sensor2				: BOOL := FALSE;
	b_zeit_ausfahren3			: BOOL := FALSE;
	b_zeit_einfahren3			: BOOL := FALSE;
	b_endlage3				: BOOL := FALSE;
	b_sensor3				: BOOL := FALSE;
	b_winkel_ausfahren1		: BOOL := FALSE;
	b_winkel_einfahren1		: BOOL := FALSE;
	b_winkel_ausfahren2		: BOOL := FALSE;
	b_winkel_einfahren2		: BOOL := FALSE;
	b_winkel_ausfahren3		: BOOL := FALSE;
	b_winkel_einfahren3		: BOOL := FALSE;
	b_zyltyp_nicht_definiert		: BOOL := FALSE;
	b_reserve1				: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/EPT Lib\/Zylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_zylinder_visu :
STRUCT
	b_taste_ausfahren			: BOOL := FALSE;
	b_taste_mittefahren		: BOOL := FALSE;
	b_taste_einfahren			: BOOL := FALSE;
	b_sensor_eingefahren		: BOOL := FALSE;
	b_sensor_ausgefahren		: BOOL := FALSE;
	b_sensor_mittegefahren	: BOOL := FALSE;
	enu_zustand				: enum_step_nr;
	i16_nr_zyl_im_handbetrieb	: INT := 0;
	i16_zyl_id 				: INT := 0;
	i16_zyl_fehlergruppe		: INT := 0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Allgemein' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_achsen :
	(
	KEINE_ACHSE := 0,
	BESTUECK__ACHSE := 1,
	Z__ACHSE := 2,
	Y__ACHSE := 3,
	B__ACHSE := 4);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Allgemein' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_maschinenstatus :
	(
	KEIN_STATUS := 0,
	STATUS_FEHLER := 1,
	STATUS_FEHLER_QUITTIERT := 2,
	STATUS_BETRIEBSBEREIT := 3,
	STATUS_MASCHINE_ARBEITET := 4);
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Allgemein' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_raster :
	(
	KEIN_RASTER := 0,
	RASTER_DEFAULT,
	RASTER_22,
	RASTER_34);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Allgemein' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_typ_Bestueckprog :
	(
	BESTUECKUNG_AUTO := 0,
	BESTUECKUNG_HALBAUTO:=1,
	BESTUECKUNG_MANUAL:=5
	);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Allgemein' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_typ_zelle :
	(
	KEINE_ZELLE := 0,
	BESTUECKZELLE_1700,
	BESTUECKZELLE_1720,
	RASTERFOLIE
	);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Barcode' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_barcode :
STRUCT
	fb			: ST_Barcode;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Barcode' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_barcode_daten :
STRUCT
	(* Angewählte Bänder und Wkz *)
	s_wkz_anwahl				: STRING;
	s_band_anwahl				: STRING;
	s_band_ID_links				: STRING:='';
	s_band_ID_rechts			: STRING:='';

	(* Dürfen diese Bander verarbeitet werden ?*)
	b_band_links_ok				: BOOL;
	b_band_rechts_ok				: BOOL;
	b_band_ok					: BOOL;
	b_band_ID_links_ok				: BOOL;
	b_band_ID_rechts_ok				: BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen\/PersDaten' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_LTS :
STRUCT
	s_tmpNewbatch				: ARRAY [0..1] OF STRING(20);
	i_tmpVPE					: DINT;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen\/PersDaten' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_LTS_xml :
STRUCT
	timestamp					: STRING(20);	(*Zeitstempel*)
	order						: STRING(20);	(*(Fertigungsaftrag) wird nur an der UML beschrieben muss aber in der xml Struktur vorhanden sein *)
	newbatch					: ARRAY [0..1] OF STRING(20);	(*Chargennummer (ID)  ARRAY 1 wid nur bei 1720 benutzt*)
	VPE						: DINT;			(*Verpackungseinheit*)
	UmlNo						: DINT;			(*Anlagennummer UML kommt mit der Plle mit*)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen\/PersDaten' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_PD :
STRUCT
	st_LTS						: struct_LTS;

	b_Zelle_nicht_in_Betrieb		: BOOL;
	i_DayOfYearAutoCheckIn	: DINT;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_bandtyp :
(
	ZINN := 0,
	GOLD,
	SILBER
);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_bbgen_auftrag :
(
	KEIN_BB_AUFTRAG := 0,
	LESE_WKZ,
	LESE_MD,
	LESE_ISK,
	LESE_BAND,
	LESE_WT,
	LESE_BESTUECKBILD,
	LESE_KOMPLETT,
	SCHREIBE_ISK,
	SCHREIBE_WKZ,
	SCHREIBE_BAND,
	SCHREIBE_WT,
	SCHREIBE_MD,
	SCHREIBE_BESTUECKBILD
);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_bestueckrichtung :
(
	YMinus_nach_YPlus_ZMinus_nach_ZPlus := 0,
	YMinus_nach_YPlus_ZPlus_nach_ZMinus,
	YPlus_nach_YMinus_ZMinus_nach_ZPlus,
	YPlus_nach_YMinus_ZPlus_nach_ZMinus
);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_typ_bandeinzug :
(
	KEIN_EINZUG := 0,
	STANDARD_2FACH_V2:=2,
	BANDWECHSLER_V2:=4,
	SERVO:=5
);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_typ_bandeinzug_visu :
(
	KEIN_BANDEINZUG := 0,
	BANDEINZUG_1,
	BANDEINZUG_2,
	BANDEINZUG_3
);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_typ_wkz :
(
	NORMAL := 0,
	BESTUECKSCHIEBER_GESTEUERT:=1
);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_banddaten :
STRUCT
	typ					: enum_bandtyp;
	st_einpressen		: struct_einpresskraftueberwachung;
	r_raster				: LREAL := 0.0;
	i16_igelrad_zaehne	: INT := 0;
	i16_startpos_einfaedeln : INT := 0;
	lr_offset_erster_hub_wkz_mm	: LREAL := 0.0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_bestueckbild :
	(* Struktur beschreibt einen kompletten Stecker mit allen Daten *)
STRUCT
	(* Artikel *)
	s_artikelnummer			: STRING(50);
	(* Beschreibung des Projekts *)
	s_beschreibung			: STRING(50);

	(* Werkzeug Wechselteil(WT) *)
	s_wkzgruppe				: ARRAY [0..4] OF struct_wkzgruppe;

	(* Der zu verarbeitende ISK *)
	s_isknummer				: STRING(50);
	(* Projektnummer *)
	s_projektnummer			: ARRAY  [0..4] OF STRING(4);

	(* Bestückrichtung *)
	enu_richtung			 	: enum_bestueckrichtung;

	(* Alle Pins innerhalb dieses Steckers *)
	i32_anzahl_pins			: DINT := 0;
	s_Bestueckbild_vollbestueckt	: ARRAY  [0..14] OF STRING(255);
	st_pins					: ARRAY  [0..1023] OF struct_PinDaten;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_bestueckbild_halbauto :
	(* Struktur beschreibt einen kompletten Stecker mit allen Daten *)
STRUCT
	(* bei TRUE liest der UML Desinger das Bestückbild nicht ein *)
	b_uml_designer_ignore	: BOOL := FALSE;
	(* Artikel *)
	s_artikelnummer			: STRING(50);
	(* Beschreibung des Projekts *)
	s_beschreibung			: STRING(50);

	(* Werkzeug Wechselteil(WT) *)
	s_wkzgruppe				: ARRAY [0..4] OF struct_wkzgruppe;

	(* Der zu verarbeitende ISK *)
	s_isknummer				: STRING(50);
	(* Projektnummer *)
	s_projektnummer			: ARRAY  [0..4] OF STRING(4);

	st_uml_designer_isk			: ARRAY [0..7] OF struct_uml_designer_isk;

	s_Bestueckbild_vollbestueckt	: ARRAY  [0..14] OF STRING(255);

	Wkz							:ARRAY  [0..14] OF struct_bestueckprogramm;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_bestueckprogramm :
STRUCT

	i32_anzahl						: DINT := 0;
	s_band							: STRING(20);
	lr_y_offset						: LREAL;
	lr_z_offset						: LREAL;
	st_isk							: struct_isk_daten;
	lr_y								: ARRAY [0..511] OF LREAL;
	lr_z								: ARRAY [0..511] OF LREAL;
	i16_b							: ARRAY [0..511] OF INT;
	b_podest_verschieben			: ARRAY [0..511] OF BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_datensatz :
STRUCT
	st_bestueckprogramm					: struct_bestueckprogramm;
	st_isk								: struct_isk_daten;
	st_band								: struct_banddaten;
	st_wkz								: struct_wkz;
	st_wt								: struct_wt;
	st_md								: struct_maschinendaten;
	st_stueckzahlen						: struct_stueckzahlen;
	st_wartungsprotokoll					: struct_Wartungsprotokoll;


	i16_counter_pruef_pos1				: DINT;
	i16_counter_pruef_pos2				: DINT;

END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_isk_daten :
STRUCT
	lr_breite		: LREAL;
	lr_hoehe		: LREAL;
	lr_pos_y_0	: LREAL;
	lr_pos_z_0	: LREAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_maschinendaten :
STRUCT
	i16_typ_zelle						: enum_typ_zelle := KEINE_ZELLE;
	i16_typ_y_achse					: INT;
	i32_bestueckhubzaehler				: UDINT := 0;
	T_Betriebstundenzaehler_alt			:TIME;
	T_Betriebstundenzaehler_neu		:TIME;

	(* Bestückbildgenerierung: speichern der aktuellen Daten, welche für den Neustart der Maschine notwendig sind. *)
	s_aktuelles_wkz						: STRING(50);
	s_aktuelles_wkz_wartung			: STRING(50);
	s_aktuelles_band					: STRING(50);
	s_aktuelle_artikelnummer				: STRING(50);
	s_aktueller_isk						: STRING(50);
	s_aktueller_wt						: STRING(50);

	b_wt_transport_aktiv					: BOOL := FALSE;
	b_hublift_links_aktiv					: BOOL := FALSE;
	b_hublift_rechts_aktiv				: BOOL := FALSE;
	b_wt_transport_simulation			: BOOL := FALSE;
	b_hublift_links_simulation				: BOOL := FALSE;
	b_hublift_rechts_simulation			: BOOL := FALSE;
	b_auto_Bandwechsel				: BOOL := FALSE;

	st_md_bestueckachse				: struct_md_achse;
	st_md_z_achse						: struct_md_achse;
	st_md_y_achse						: struct_md_achse;
	st_md_b_achse						: struct_md_achse;
	st_md_transport_wt_achse			: struct_md_achse;

	st_rasterplatte						: struct_daten_rasterplatte;

	b_bestueckprogramm_manuell		: BOOL := FALSE;	(* Haken wird in Visu gesetzt *)
	i16_typ_bestueckmodus				: enum_typ_Bestueckprog := BESTUECKUNG_AUTO;
	b_tagreader_fahrend					: BOOL := FALSE;

	i32_betriebssekundenzaehler			: UDINT := 0;
	i16_tag_data_structur_version		: INT := 0; (* 0 =Version mit StateParts[0]/[1], 1 = Version mit StateParts[0..7] *)
	i32_werkzeughubzaehler				: UDINT := 0;
	b_band_ID_Puffer_aus				: BOOL := FALSE;
	b_haspel_mit_auflegeblech			: BOOL := FALSE;	(*Wird im Programm nicht mehr verwendet, weil alle Zellen nachgerüstet wurden*)
	lr_offset_z_pos_0					: LREAL := 0.0;
	lr_offset_y_pos_0					: LREAL := 0.0;
	st_wkz_gruppe						: ARRAY[0..4] OF  struct_md_wkz; (*nur bei Halbautomatisch: Werkzeuge die mann zusammenfassen kann*)
	lr_ToleranzTouchProbe				: LREAL := 0.1;
	i16_WdhTouchProbe				: INT := 0;
	t_max_Traegerwechselzeit			:TIME:=t#1200ms;
	t_max_Tischwechselzeit			:TIME:=t#500ms;
	produzierte_Stecker				: UDINT;
	b_auswahlSpruehoeler				: BOOL:=TRUE;
	b_wkzBereinigen					:BOOL:=FALSE;		(*wenn true dann wird die Werkzeugdatei vorher gelöscht und dann neu erstellt*)
	r_geschwindigkeit_achse_transport		: LREAL := 0.0;
	b_anwahl_transport_achse			: BOOL := FALSE;	(* wenn TRUE, dann ist Transport-Achse für schnellen WT-Wechsel vorhanden *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_md_achse :
STRUCT
	lr_startposition						: LREAL;
	lr_nullpunktverschiebung				: LREAL;
	lr_wt_uebergabepos					: LREAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_md_wkz :
STRUCT
	s_wkz						: STRING(50);
	i16_wkz_gruppe_kompatibel	: INT;
	s_Band						: STRING(50);
	i32_Anzahl					: DINT;
	i32_Wkz_nr					: DINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_pindaten :
STRUCT
	lr_y	:	LREAL;
	lr_z	:	LREAL;
	typ	:	STRING(50);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_uml_designer_isk :
STRUCT
	s_isknummer		: STRING(20);
	lr_y_offeset			: LREAL := 0.0;
	lr_z_offeset			: LREAL := 0.0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_virtmaster_bestueckachse :
STRUCT
	arr_motion_function_points	: ARRAY[1..100] OF struct_db_motionfunctionpoint;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_wkz :
STRUCT
	i16_anzahl_einfaedel_pins				: INT := 1;
	i16_anzahl_einfaedel_auto_pins			: INT := 1;
	b_laufrichtung_haspel_links				: BOOL := FALSE;
	b_wkz_blasluft_aktiv					: BOOL := FALSE;
	nockenschaltwerk_bestueckachse		: struct_nockeneinstellungen;

	b_wkz_zweifachfallend					: BOOL := FALSE;
	r_auto								: LREAL := 0.0;
	r_auto_y								: LREAL := 0.0;
	r_auto_z								: LREAL := 0.0;
	r_auto_bandeinzug					: LREAL := 0.0;
	st_yz_tisch							: struct_yz_tisch;
	lr_offset_z_pos_0						: LREAL := 0.0;
	lr_offset_y_pos_0						: LREAL := 0.0;

	st_rasterfolie							: struct_daten_rasterfolie;

	i16_typ_bandeinzug					: enum_typ_bandeinzug := KEIN_EINZUG;

	st_oeler								: struct_oeler;

	lr_einfaedelposition					: LREAL := 180.0;
	i16_typ_wkz							: enum_typ_wkz := NORMAL;
	i16_anzahl_bestueckschieber			: INT := 1;
	i16_wkz_gruppe_kompatibel			: INT; 		(*Werkzeuge die die Gleiche Arbeit machen können sollten die gleiche Nummer haben*)

	b_rafo_vorzentrierer_aktiv				: BOOL := FALSE;
	i16_einfaedelhub_lueften				: INT := 1;
	b_variable_einfahrposition				: BOOL := FALSE;
	i16_anzahl_Teile_autostop_bandwechsel	: INT := 0;
	lr_ausbauposition						: LREAL := 17.0;
	i16_vorgabe_einfaedeln					: INT := 3;
	b_rafo_auto_einf_aktiv					: BOOL := FALSE;
	bFahreSofortAufUebergabePosition		: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_wkzgruppe :
STRUCT
	s_wkznummer			: ARRAY [0..MaxNoOfWkz] OF STRING(50);
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_wt :
STRUCT
	lr_offset_z_pos_0						: LREAL := 0.0;
	lr_offset_y_pos_0						: LREAL := 0.0;
	i_anzahl_teile							: INT := 1;
	i16_typ_bestueckmodus				: enum_typ_Bestueckprog := BESTUECKUNG_AUTO;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_yz_tisch :
STRUCT
	r_wkz_einfahrpos_z		: LREAL := 0.0;
	r_wkz_einfahrpos_y		: LREAL := 0.0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Betriebsfreigaben' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_betriebsfreigaben :
STRUCT
	st_config		: struct_config;
	st_ctrl		: struct_ctrl;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Betriebsstundenzaehler' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_betriebsstundenzaehler :
STRUCT
	fb			: ST_Betriebsstundenzaehler;
	st_ctrl		: struct_ctrl;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Haspel' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_einfach_haspelkontroller :
STRUCT
	fb			: ST_Einfachhaspelkontroller;
	st_ctrl		: struct_ctrl;
	st_visu		: struct_visu;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Haspel' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_haspel_st_zylinder :
STRUCT
	fb			: ST_Haspel_st_zylinder;
	st_ctrl		: struct_ctrl;
	st_visu		: struct_visu;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Haspel' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_haspel_V2 :
STRUCT
	fb			: ST_Haspel_V2;
	st_ctrl		: struct_ctrl;
	st_visu		: struct_visu;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Haspel' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_haspelkontroller :
STRUCT
	t_abschaltzeit_motor			: TIME := t#0s;
	b_drehrichtung_antrieb_links	: BOOL := FALSE;
	st_config						: struct_config;
	haspel1_ctrl_in				: struct_ctrl_out;
	haspel2_ctrl_in				: struct_ctrl_out;
	st_ctrl						: struct_ctrl;
	st_visu						: struct_visu;
	haspel1_ctrl_out				: struct_ctrl_in;
	haspel2_ctrl_out				: struct_ctrl_in;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Nockenschaltwerk' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_nocken_namen :
	( NO_OT := 0,
	NO_START_SKALIERUNG,
	NO_VERFAHRFREIGABE_Z_ACHSE,
	NO_BW_BANDFAENGER_EINFAHREN,
	NO_BW_BANDFAENGER_AUSFAHREN,
	NO_BW_BANDKLEMMEN_EINFAHREN,
	NO_BW_BANDKLEMMEN_AUSFAHREN,
	NO_UW_BANDFAENGER_EINFAHREN,
	NO_UW_BANDFAENGER_AUSFAHREN,
	NO_UW_BANDKLEMMEN_EINFAHREN,	(* 9 *)
	NO_UW_BANDKLEMMEN_AUSFAHREN,
	NO_PRUEFE_BANDENDE_AM_EINZUG,
	NO_BESTUECKSCHIEBERHUB,
	NO_UW_BESTUECKSCHIEBER_ON,
	NO_UW_BESTUECKSCHIEBER_OFF,
	NO_AUFNAHMEHUB,
	NO_EINPRESSHUB,
	NO_BW_BANDFAENGER_LI_EINFAHREN,
	NO_BW_BANDFAENGER_LI_AUSFAHREN,
	NO_BW_BANDKLEMMEN_LI_EINFAHREN,	(* 19 *)
	NO_BW_BANDKLEMMEN_LI_AUSFAHREN,
	NO_UW_BANDFAENGER_LI_EINFAHREN,
	NO_UW_BANDFAENGER_LI_AUSFAHREN,
	NO_UW_BANDKLEMMEN_LI_EINFAHREN,
	NO_UW_BANDKLEMMEN_LI_AUSFAHREN,
	NO_BW_BANDFAENGER_RE_EINFAHREN,
	NO_BW_BANDFAENGER_RE_AUSFAHREN,
	NO_BW_BANDKLEMMEN_RE_EINFAHREN,
	NO_BW_BANDKLEMMEN_RE_AUSFAHREN,
	NO_UW_BANDFAENGER_RE_EINFAHREN,	(* 29 *)
	NO_UW_BANDFAENGER_RE_AUSFAHREN,
	NO_UW_BANDKLEMMEN_RE_EINFAHREN,
	NO_UW_BANDKLEMMEN_RE_AUSFAHREN,
	NO_UW_WKZ_NIEDERHALTER_LI,
	NO_UW_WKZ_NIEDERHALTER_RE,
	NO_PNEUMATIKBANDEINZUG_GLS,
	NO_BW_BANDFAENGER_BAWEV2_EINFAHREN,
	NO_BW_BANDFAENGER_BAWEV2_AUSFAHREN,
	NO_BW_BANDKLEMMEN_BAWEV2_EINFAHREN,
	NO_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN,	(* 39 *)
	NO_BW_BANDFAENGER_LI_BAEZV2_EINFAHREN,
	NO_BW_BANDFAENGER_LI_BAEZV2_AUSFAHREN,
	NO_BW_BANDKLEMMEN_LI_BAEZV2_EINFAHREN,
	NO_BW_BANDKLEMMEN_LI_BAEZV2_AUSFAHREN,
	NO_BW_BANDFAENGER_RE_BAEZV2_EINFAHREN,
	NO_BW_BANDFAENGER_RE_BAEZV2_AUSFAHREN,
	NO_BW_BANDKLEMMEN_RE_BAEZV2_EINFAHREN,
	NO_BW_BANDKLEMMEN_RE_BAEZV2_AUSFAHREN,
	NO_SERVOBANDEINZUG_LUEFTEN,
	NO_SERVOBANDEINZUG_GLS,
	NO_MIN_KRAFT_EINPRESSEN := 50,
	NO_BW_BESTUECKSCHIEBER_EINSTEUERN,
	NO_UW_BESTUECKSCHIEBER_EINSTEUERN,
	NO_DISABLE_AUTO_RESET,
	NO_RASTERFOLIE_LUEFTEN);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Nockenschaltwerk' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_spur_namen :
	( SP_OT := 0,
	SP_START_SKALIERUNG,
	SP_VERFAHRFREIGABE_Z_ACHSE,
	SP_BW_BANDFAENGER_EINFAHREN,
	SP_BW_BANDFAENGER_AUSFAHREN,
	SP_BW_BANDKLEMMEN_EINFAHREN,
	SP_BW_BANDKLEMMEN_AUSFAHREN,
	SP_UW_BANDFAENGER_EINFAHREN,
	SP_UW_BANDFAENGER_AUSFAHREN,
	SP_UW_BANDKLEMMEN_EINFAHREN,
	SP_UW_BANDKLEMMEN_AUSFAHREN,
	SP_PRUEFE_BANDENDE_AM_EINZUG,
	SP_BESTUECKSCHIEBERHUB,
	SP_UW_BESTUECKSCHIEBER_ON,
	SP_UW_BESTUECKSCHIEBER_OFF,
	SP_AUFNAHMEHUB,
	SP_EINPRESSHUB,
	SP_BW_BANDFAENGER_LI_EINFAHREN,
	SP_BW_BANDFAENGER_LI_AUSFAHREN,
	SP_BW_BANDKLEMMEN_LI_EINFAHREN,
	SP_BW_BANDKLEMMEN_LI_AUSFAHREN,
	SP_UW_BANDFAENGER_LI_EINFAHREN,
	SP_UW_BANDFAENGER_LI_AUSFAHREN,
	SP_UW_BANDKLEMMEN_LI_EINFAHREN,
	SP_UW_BANDKLEMMEN_LI_AUSFAHREN,
	SP_BW_BANDFAENGER_RE_EINFAHREN,
	SP_BW_BANDFAENGER_RE_AUSFAHREN,
	SP_BW_BANDKLEMMEN_RE_EINFAHREN,
	SP_BW_BANDKLEMMEN_RE_AUSFAHREN,
	SP_UW_BANDFAENGER_RE_EINFAHREN,
	SP_UW_BANDFAENGER_RE_AUSFAHREN,
	SP_UW_BANDKLEMMEN_RE_EINFAHREN,
	SP_UW_BANDKLEMMEN_RE_AUSFAHREN,
	SP_UW_WKZ_NIEDERHALTER_LI,
	SP_UW_WKZ_NIEDERHALTER_RE,
	SP_PNEUMATIKBANDEINZUG_GLS,
	SP_BW_BANDFAENGER_BAWEV2_EINFAHREN,
	SP_BW_BANDFAENGER_BAWEV2_AUSFAHREN,
	SP_BW_BANDKLEMMEN_BAWEV2_EINFAHREN,
	SP_BW_BANDKLEMMEN_BAWEV2_AUSFAHREN,
	SP_BW_BANDFAENGER_LI_BAEZV2_EINFAHREN,
	SP_BW_BANDFAENGER_LI_BAEZV2_AUSFAHREN,
	SP_BW_BANDKLEMMEN_LI_BAEZV2_EINFAHREN,
	SP_BW_BANDKLEMMEN_LI_BAEZV2_AUSFAHREN,
	SP_BW_BANDFAENGER_RE_BAEZV2_EINFAHREN,
	SP_BW_BANDFAENGER_RE_BAEZV2_AUSFAHREN,
	SP_BW_BANDKLEMMEN_RE_BAEZV2_EINFAHREN,
	SP_BW_BANDKLEMMEN_RE_BAEZV2_AUSFAHREN,
	SP_SERVOBANDEINZUG_LUEFTEN,
	SP_SERVOBANDEINZUG_GLS,
	SP_MIN_KRAFT_EINPRESSEN := 50,
	SP_BW_BESTUECKSCHIEBER_EINSTEUERN,
	SP_UW_BESTUECKSCHIEBER_EINSTEUERN,
	SP_DISABLE_AUTO_RESET,
	SP_RASTERFOLIE_LUEFTEN);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_bandoeler :
STRUCT
	fb			: ST_Bandoeler;
	st_ctrl		: struct_ctrl;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_oeler :
STRUCT
	i16_intervall_bandoelen				: INT := 1;
	t_ventiloeffnungszeit					: DINT := 500;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_oeler_daten :
STRUCT
	i32_neue_intervallvorgabe		: DINT := 500;
	t_ventiloeffnungszeit			: TIME := t#10ms;
	t_oelzeit_nach_stillstand		: TIME := t#20ms;
	i32_aktueller_stand			: DINT := 0;
	i32_alte_intervallvorgabe		: DINT := 0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_oeler_retain :
STRUCT
	i32_neue_intervallvorgabe		: DINT := 500;
	t_ventiloeffnungszeit			: TIME := t#10ms;
	t_oelzeit_nach_stillstand		: TIME := t#20ms;
	i32_aktueller_stand			: DINT := 0;
	i32_alte_intervallvorgabe		: DINT := 0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_oeler_visu :
STRUCT
	b_handoelen							: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Oeler' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_schmier_daten :
STRUCT
	i32_neue_intervallvorgabe		: DINT := 500;
	t_ventiloeffnungszeit			: TIME := t#10ms;
	i32_aktueller_stand			: DINT := 0;
	i32_alte_intervallvorgabe		: DINT := 0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Stueckzahlen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_zaehlerart :
	(
	JAHR := 0,
	AUFTRAG,
	VPE
	);
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Stueckzahlen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_gut_schlecht_teile :
STRUCT
	i32_aktuelle_gutteile		: DINT := 0;
	i32_aktuelle_schlechtteile	: DINT := 0;
	i32_vorgabe_gutteile		: DINT := 0;
	b_reset_gutteile			: BOOL := FALSE;
	b_reset_schlechtteile		: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Stueckzahlen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_stueckzahl :
STRUCT
	fb			: ST_Stueckzahl;
	st_ctrl		: struct_ctrl;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Stueckzahlen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_stueckzahlen :
STRUCT
	st_teilezaehler		: ARRAY[0..2] OF struct_gut_schlecht_teile;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Tag_Reader' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_part_state :
(
(*	PART_UNDEFINDED		:= -1, (*State not defined*)*)
	PART_NO				:= 0, (*no Part available*)
	PART_OK				:= 1, (*Part processed with OK-Result*)
	PART_NOK				:= 2, (*Part processed with NOK-Result*)
	PART_NEW			:= 4,  (*new Part (picked up from Feeder, and not yet processed) *)
	PART_DUMMY			:= 99, (*dummy Part on Wpc *)
	XXXX					:= 100 (*Tag lesen*)
);
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Tag_Reader' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_tag_data :
STRUCT
	WpcNumber			: BYTE;
	StateParts				: ARRAY[0..7] OF enum_part_state;
	AmountPartsOnWpc		: BYTE;
	LastUsedTool			: BYTE;
	Articelnumber			: STRING(50);
	UmlNo_VPE				: DINT:=100;  	(*erste Zahl immer 1 + UMl-Nummer max 99   danach max 6 Stellen für VPE =>  z.B. 1 78 100123  wird für die automatisch LTS buchung benutzt*)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_servobandeinzug :
STRUCT
	b_taste_bremse				: BOOL := FALSE;
	b_taste_tippen				: BOOL := FALSE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_taste_ein_aus :
STRUCT
	b_einfahren				: BOOL := FALSE;
	b_ausfahren				: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_texte :
STRUCT
	txt_zylindernamen	: ARRAY [0..16] OF struct_zyltexte_ein_aus;
	txt_statisch			: ARRAY [0..35] OF STRING(255) := '';
	txt_variabel			: ARRAY [0..15] OF STRING(255) := '';
	txt_bm_einfaedeln	: ARRAY [0..15] OF STRING(255) := '';
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_visu :
STRUCT
	b_quittieren								: BOOL := FALSE;
	b_start									: BOOL := FALSE;
	b_stop									: BOOL := FALSE;
	b_einzelfertigung							: BOOL := FALSE;
	b_tippen_start							: BOOL := FALSE;
	b_start_foerderband						: BOOL := FALSE;
	b_inbetriebnahme							: BOOL := FALSE;
	b_geschwindigkeit_vorgabe				: BOOL := FALSE;
	b_vollbestuecken							: BOOL := FALSE;
	b_merker_vollbestuecken					: BOOL := FALSE;
	b_Reset_Band_ID							: BOOL := FALSE;
	b_handoelen								: BOOL := FALSE;
	b_reset_wartung_wkz						: BOOL := FALSE;
	b_reset_wartung_maschine					: BOOL := FALSE;
	s_akt_sprache							: STRING(255) := 'de';
	st_nocken								: struct_nocken_visu;
	st_zyl									: struct_zylinder_visu;
	st_achsen								: ARRAY [0..3] OF struct_ecd_visu;
	st_xml_server								: struct_xml_visu;
	st_tagreader								: struct_visu_tagreader;
	st_service								: struct_visu_service;
	st_bandwechsler							: struct_bandwechsler_visu;
	MeldungProduktion	 					: struct_MeldungProduktion;
	b_logon									: BOOL;
	b_start_remove_pos						: BOOL;
	b_save									: BOOL := FALSE;
	b_load									: BOOL := FALSE;
	b_fbwf_info								: BOOL := FALSE;
	b_fbwf_disable							: BOOL := FALSE;
	b_fbwf_enable							: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_visu_hinten :
STRUCT
	in	:	struct_visu_hinten_in;
	out	:	struct_visu_hinten_out;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_visu_hinten_in :
STRUCT
	betriebsart				: STRING(255) := '';
	s_maschinenstatusinfo 		: STRING(255) := '';
	i16_maschinenstatusinfo	: INT := 0;
	s_betriebsmeldung		: STRING(255) := '';
	i16_position_ist			: INT := 0;
	zylinder_sensoren			: ARRAY [0..16] OF struct_zylinder_sensoren;
	texte					: struct_texte;
	bandfreigabe				: ARRAY [0..1] OF BOOL;
	band_ID					: ARRAY [0..1] OF BOOL;
	scannen_moeglich		: ARRAY [0..1] OF BOOL;
	i16_typ_zelle				: enum_typ_zelle := KEINE_ZELLE;
	i16_typ_bandeinzug		: enum_typ_bandeinzug := KEIN_EINZUG;
	s_aktuelles_wkz			: STRING(50);
	s_Barcode				: STRING(50);
	s_aktuelles_band			: STRING(50);
	b_zustand_bremse		: BOOL := FALSE;
	current_visu_folie			: STRING(50);
	b_bandwechsel_aktiv		: BOOL := FALSE;
	sm_Meldung				: ARRAY [0..14] OF STRING(255);
	bm_Meldung				: ARRAY [0..14] OF STRING(255);
	band_ID_Puffer_aus		: BOOL := FALSE;
	Lampe_auto_Bandwechsel	: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_visu_hinten_out :
STRUCT
	zylinder_direkttasten			: ARRAY [0..16] OF struct_taste_ein_aus;		(* Direkttasten für Haspelzylinder u.s.w. *)
	b_quittieren					: BOOL := FALSE;
	b_start						: BOOL := FALSE;
	b_stop						: BOOL := FALSE;
	b_einzelfertigung				: BOOL := FALSE;
	b_tippen						: BOOL := FALSE;
	b_Bandwechsel				: BOOL;
	b_Trennstelle					: BOOL;
	auto_Bandwechsel_aus		: BOOL;
	st_servobandeinzug			: struct_servobandeinzug;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_visu_service :
STRUCT
	t_WT_wechsel					:TIME;
	t_Zentrierer_ausfahren			:TIME;
	t_Z_Achse_einfahren			:TIME;
	t_Bestueckung					:TIME;
	t_Z_Achse_ausfahren			:TIME;
	t_Zentrierer_einfahren			:TIME;

	t_Traegerwechselzeit			:TIME;
	t_komplett_zyklus				:TIME;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_visu_tagreader :
STRUCT
	b_start_lesen								: BOOL := FALSE;
	b_start_schreiben							: BOOL := FALSE;
	b_tag_im_Aktionsfeld						: BOOL;
	b_WT_ruecksetzen						: BOOL := FALSE;

	Farbwechsel								:ARRAY [1..12] OF BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_zylinder_sensoren :
STRUCT
	b_eingefahren		: BOOL := FALSE;
	b_ausgefahren		: BOOL := FALSE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_zyltexte_ein_aus :
STRUCT
	s_einfahren	: STRING(255) := '';
	s_ausfahren	: STRING(255) := '';
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Wartung' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_Wartungsprotokoll :
STRUCT
	st_wartung_md	: struct_Wartungsprotokoll_md;
	st_wartung_wkz	: struct_Wartungsprotokoll_wkz;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Wartung' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_Wartungsprotokoll_md :
STRUCT
	hubzaehler			: UDINT;
	produzierte_stecker	: UDINT;
	betriebsstunden		: LREAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/Wartung' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_Wartungsprotokoll_wkz :
STRUCT
	hubzaehler			: UDINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/XML_Server' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_xml_auftrag :
	(
	KEIN := 0,
	WKZ_WECHSELN,
	WKZ_SPEICHERN,
	WKZ_LADEN,
	WKZ_KOPIEREN,
	WKZ_EINLESEN,
	MD_SPEICHERN,
	MD_LADEN
	);
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Gemeinsamkeiten17xx\/XML_Server' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_xml_visu :
STRUCT
	b_taste_daten_speichern			: BOOL := FALSE;
	b_taste_daten_laden				: BOOL := FALSE;
	b_taste_daten_kopieren			: BOOL := FALSE;
	b_taste_daten_einlesen			: BOOL := FALSE;
	i16_quelldatensatz					: INT := 0;
	i16_zieldatensatz					: INT := 0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Band' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_bandwechsler :
STRUCT
	st_config		: struct_config;
	st_ctrl		: struct_ctrl;
	st_visu		: struct_visu;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Band' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_bandwechsler_visu :
STRUCT
	b_taste_io			: BOOL := FALSE;
	b_taste_nio			: BOOL := FALSE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Einpresskraftueberwachung' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_einpressmodus :
	(
	KEIN_MODUS := 0,
	F_MAXWERT,
	F_MITTELWERT
	);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Einpresskraftueberwachung' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_einpressausgabe :
STRUCT
	st_ergebnisse					: struct_weg_kraft_ergebnisse;
	st_kurve							: ARRAY[0..99] OF struct_kurven;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Einpresskraftueberwachung' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_einpresskraftueberwachung :
STRUCT
	st_einstellungen			: struct_weg_kraft_einstellungen;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Einpresskraftueberwachung' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_kurven :
STRUCT
	arr_weg_stuetz			: ARRAY[0..360] OF LREAL;
	arr_kraft_stuetz			: ARRAY[0..360] OF LREAL;
	arr_weg_ist				: ARRAY[0..360] OF LREAL;
	arr_kraft_ist				: ARRAY[0..360] OF LREAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Einpresskraftueberwachung' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_weg_kraft_einstellungen :
STRUCT
	enu_modus				: enum_einpressmodus := F_MAXWERT;
	lr_maxkraft_aufnahme		: LREAL := 0;
	lr_maxkraft_einpressen		: LREAL := 100;
	lr_minkraft_einpressen		: LREAL := 0;
	lr_delta_kraft				: LREAL := 20;
	lr_delta_weg				: LREAL := 0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Maschine1700\/Einpresskraftueberwachung' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_weg_kraft_ergebnisse :
STRUCT
	lr_reserve				: LREAL := 0;
	lr_maxkraft_einpressen		: LREAL := 0;
	lr_maxkraft_einpres_proHub: LREAL := 0;
	lr_ueberlaufkraft			: LREAL := 0;
	lr_minkraft_einpressen		: LREAL := 0;
	lr_maxkraft_aufnahme		: LREAL := 0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Rasterfolie\/Rafo_BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_daten_rasterfolie :
STRUCT
	lr_pruefpos_rafo					: LREAL := 0.0;	(*Abstand zwischen Bestückposition und Prüfposition*)
	lr_pos_absenken				: LREAL := 0.0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Rasterplatte\/Rapl_BBGen' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_daten_rasterplatte :
STRUCT
	lr_anfang_pruefpos_rapl		: LREAL := 20.0;
	lr_ende_pruefpos_rapl			: LREAL := 30.0;
	lr_pos_absenken				: LREAL := 0.0;
	lr_pruefpos_rastnase_z			: ARRAY  [0..2] OF LREAL := 0.0;
	lr_pruefpos_rastnase_y		: ARRAY  [0..2] OF LREAL := 0.0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Visu\/ButtonVisu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_ButtonVisu :
STRUCT
		sichtbar						: BOOL;
		tasten						: BOOL;
		Text							: STRING(30);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Visu\/EtherCatDiagnose' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_EthercatDiagnose :
STRUCT
	st_Master			: struct_EthercatMaster;
	st_Slave			: ARRAY[1..MaxNoOfSlaves] OF struct_EthercatSlave;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Visu\/EtherCatDiagnose' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_EthercatMaster :
STRUCT
	s_Name				: STRING := 'Master undefined';	(*Name des Ethercat Masters*)
	s_AmsNetId			: STRING := '0.0.0.0.0.0';			(*AmsNetId des Ethercat Masters*)
	i_Slaves				: INT := 0;							(*Anzahl konfigurierter Slaves*)
	f_FramesPerSeconed	: LREAL := 0;
	i_LostFrames			: UDINT := 0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Visu\/EtherCatDiagnose' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_EthercatSlave :
STRUCT
	i_Number			: INT;		(*Nummer in Ethercat Strang*)
	s_DeviceState		: STRING;	(*z.B. INIT, OP*)
	s_Name			: STRING;	(*Konfigurierter Name z.B. CO1_EL6910*)
	s_Type				: STRING;	(*z.B. EL6910*)
	s_Adress			: STRING;	(*Ethercat Adresse z.B. 1003*)
	b_Err				: BOOL;		(*nicht OP*)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE sMessageLine :
STRUCT
	MsgString		: STRING(40);
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Visu' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE struct_MeldungProduktion :
STRUCT
	ShowMessage				: BOOL;
	Name						: STRING(250);
	Text						: ARRAY [0..9] OF STRING(250);
	Color_R						: INT;
	Color_G						: INT;
	Color_B						: INT;

	Button1						: struct_ButtonVisu;
	Button2						: struct_ButtonVisu;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_typ_achse :
	(
	BECKHOFF := 0,
	FESTO
	);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE enum_wartung_auftrag :
(
	KEIN_WARTUNG_AUFTRAG := 0,
	LESE_WARTUNGSPROTOKOLL_WKZ,
	LESE_WARTUNGSPROTOKOLL_MD,
	LESE_WARTUNGSPROTOKOLL_KOMPLETT,
	SCHREIBE_WARTUNGSPROTOKOLL_WKZ,
	SCHREIBE_WARTUNGSPROTOKOLL_WKZ_RESET,
	SCHREIBE_WARTUNGSPROTOKOLL_MD,
	SCHREIBE_WARTUNGSPROTOKOLL_KOMPLETT,
	SPEICHERN_WARTUNGSPROTOKOLL
);
END_TYPE
(* @END_DECLARATION := '0' *)
